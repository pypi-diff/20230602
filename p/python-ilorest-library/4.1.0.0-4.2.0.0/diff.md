# Comparing `tmp/python-ilorest-library-4.1.0.0.zip` & `tmp/python-ilorest-library-4.2.0.0.zip`

## zipinfo {}

```diff
@@ -1,40 +1,40 @@
-Zip file size: 92271 bytes, number of entries: 38
-drwxrwxrwx  2.0 fat        0 b- stor 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/
--rw-rw-rw-  2.0 fat    11539 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/LICENSE
--rw-rw-rw-  2.0 fat       37 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/MANIFEST.in
--rw-rw-rw-  2.0 fat      869 b- defN 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/PKG-INFO
--rw-rw-rw-  2.0 fat      333 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/pyproject.toml
--rw-rw-rw-  2.0 fat     5711 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/README.rst
--rw-rw-rw-  2.0 fat      217 b- defN 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/setup.cfg
--rw-rw-rw-  2.0 fat     1194 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/setup.py
-drwxrwxrwx  2.0 fat        0 b- stor 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/redfish/
--rw-rw-rw-  2.0 fat        1 b- defN 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/dependency_links.txt
--rw-rw-rw-  2.0 fat      869 b- defN 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/PKG-INFO
--rw-rw-rw-  2.0 fat       46 b- defN 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/requires.txt
--rw-rw-rw-  2.0 fat      858 b- defN 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/SOURCES.txt
--rw-rw-rw-  2.0 fat        8 b- defN 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/top_level.txt
-drwxrwxrwx  2.0 fat        0 b- stor 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/redfish/hpilo/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/redfish/rest/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Feb-06 14:00 python-ilorest-library-4.1.0.0/src/redfish/ris/
--rw-rw-rw-  2.0 fat      532 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/__init__.py
--rw-rw-rw-  2.0 fat    33256 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/hpilo/risblobstore2.py
--rw-rw-rw-  2.0 fat     6931 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/hpilo/rishpilo.py
--rw-rw-rw-  2.0 fat       64 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/hpilo/__init__.py
--rw-rw-rw-  2.0 fat    23469 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/rest/connections.py
--rw-rw-rw-  2.0 fat    11145 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/rest/containers.py
--rw-rw-rw-  2.0 fat    23391 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/rest/v1.py
--rw-rw-rw-  2.0 fat      107 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/rest/__init__.py
--rw-rw-rw-  2.0 fat    17749 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/gen_compat.py
--rw-rw-rw-  2.0 fat    14943 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/resp_handler.py
--rw-rw-rw-  2.0 fat    47336 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/ris.py
--rw-rw-rw-  2.0 fat    10278 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/ris_threaded.py
--rw-rw-rw-  2.0 fat    73810 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/rmc.py
--rw-rw-rw-  2.0 fat      353 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/rmc_api.py
--rw-rw-rw-  2.0 fat    16036 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/rmc_helper.py
--rw-rw-rw-  2.0 fat     1742 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/sharedtypes.py
--rw-rw-rw-  2.0 fat    21000 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/utils.py
--rw-rw-rw-  2.0 fat    51825 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/validation.py
--rw-rw-rw-  2.0 fat      833 b- defN 23-Feb-06 13:56 python-ilorest-library-4.1.0.0/src/redfish/ris/__init__.py
-38 files, 376482 bytes uncompressed, 85125 bytes compressed:  77.4%
+Zip file size: 92054 bytes, number of entries: 38
+drwxrwxrwx  2.0 fat        0 b- stor 23-May-18 06:51 python-ilorest-library-4.2.0.0/
+drwxrwxrwx  2.0 fat        0 b- stor 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/
+-rw-rw-rw-  2.0 fat    11539 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/LICENSE
+-rw-rw-rw-  2.0 fat       37 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/MANIFEST.in
+-rw-rw-rw-  2.0 fat      869 b- defN 23-May-18 06:51 python-ilorest-library-4.2.0.0/PKG-INFO
+-rw-rw-rw-  2.0 fat      311 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/pyproject.toml
+-rw-rw-rw-  2.0 fat     5568 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/README.rst
+-rw-rw-rw-  2.0 fat      217 b- defN 23-May-18 06:51 python-ilorest-library-4.2.0.0/setup.cfg
+-rw-rw-rw-  2.0 fat     1194 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/setup.py
+drwxrwxrwx  2.0 fat        0 b- stor 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/
+drwxrwxrwx  2.0 fat        0 b- stor 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/redfish/
+-rw-rw-rw-  2.0 fat        1 b- defN 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/dependency_links.txt
+-rw-rw-rw-  2.0 fat      869 b- defN 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/PKG-INFO
+-rw-rw-rw-  2.0 fat       46 b- defN 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/requires.txt
+-rw-rw-rw-  2.0 fat      858 b- defN 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/SOURCES.txt
+-rw-rw-rw-  2.0 fat        8 b- defN 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/top_level.txt
+drwxrwxrwx  2.0 fat        0 b- stor 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/redfish/hpilo/
+drwxrwxrwx  2.0 fat        0 b- stor 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/redfish/rest/
+drwxrwxrwx  2.0 fat        0 b- stor 23-May-18 06:51 python-ilorest-library-4.2.0.0/src/redfish/ris/
+-rw-rw-rw-  2.0 fat      532 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/__init__.py
+-rw-rw-rw-  2.0 fat    31969 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/hpilo/risblobstore2.py
+-rw-rw-rw-  2.0 fat     6629 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/hpilo/rishpilo.py
+-rw-rw-rw-  2.0 fat       64 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/hpilo/__init__.py
+-rw-rw-rw-  2.0 fat    23041 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/rest/connections.py
+-rw-rw-rw-  2.0 fat    10779 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/rest/containers.py
+-rw-rw-rw-  2.0 fat    22836 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/rest/v1.py
+-rw-rw-rw-  2.0 fat      105 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/rest/__init__.py
+-rw-rw-rw-  2.0 fat    17320 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/gen_compat.py
+-rw-rw-rw-  2.0 fat    14663 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/resp_handler.py
+-rw-rw-rw-  2.0 fat    47336 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/ris.py
+-rw-rw-rw-  2.0 fat    10007 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/ris_threaded.py
+-rw-rw-rw-  2.0 fat    73540 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/rmc.py
+-rw-rw-rw-  2.0 fat      338 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/rmc_api.py
+-rw-rw-rw-  2.0 fat    16036 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/rmc_helper.py
+-rw-rw-rw-  2.0 fat     1742 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/sharedtypes.py
+-rw-rw-rw-  2.0 fat    20435 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/utils.py
+-rw-rw-rw-  2.0 fat    50428 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/validation.py
+-rw-rw-rw-  2.0 fat      833 b- defN 23-May-18 06:48 python-ilorest-library-4.2.0.0/src/redfish/ris/__init__.py
+38 files, 370150 bytes uncompressed, 84908 bytes compressed:  77.1%
```

## zipnote {}

```diff
@@ -1,115 +1,115 @@
-Filename: python-ilorest-library-4.1.0.0/
+Filename: python-ilorest-library-4.2.0.0/
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/
+Filename: python-ilorest-library-4.2.0.0/src/
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/LICENSE
+Filename: python-ilorest-library-4.2.0.0/LICENSE
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/MANIFEST.in
+Filename: python-ilorest-library-4.2.0.0/MANIFEST.in
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/PKG-INFO
+Filename: python-ilorest-library-4.2.0.0/PKG-INFO
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/pyproject.toml
+Filename: python-ilorest-library-4.2.0.0/pyproject.toml
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/README.rst
+Filename: python-ilorest-library-4.2.0.0/README.rst
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/setup.cfg
+Filename: python-ilorest-library-4.2.0.0/setup.cfg
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/setup.py
+Filename: python-ilorest-library-4.2.0.0/setup.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/
+Filename: python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/
+Filename: python-ilorest-library-4.2.0.0/src/redfish/
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/dependency_links.txt
+Filename: python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/dependency_links.txt
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/PKG-INFO
+Filename: python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/PKG-INFO
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/requires.txt
+Filename: python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/requires.txt
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/SOURCES.txt
+Filename: python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/SOURCES.txt
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/top_level.txt
+Filename: python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/top_level.txt
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/hpilo/
+Filename: python-ilorest-library-4.2.0.0/src/redfish/hpilo/
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/rest/
+Filename: python-ilorest-library-4.2.0.0/src/redfish/rest/
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/__init__.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/__init__.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/hpilo/risblobstore2.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/hpilo/risblobstore2.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/hpilo/rishpilo.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/hpilo/rishpilo.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/hpilo/__init__.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/hpilo/__init__.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/rest/connections.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/rest/connections.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/rest/containers.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/rest/containers.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/rest/v1.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/rest/v1.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/rest/__init__.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/rest/__init__.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/gen_compat.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/gen_compat.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/resp_handler.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/resp_handler.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/ris.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/ris.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/ris_threaded.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/ris_threaded.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/rmc.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/rmc.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/rmc_api.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/rmc_api.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/rmc_helper.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/rmc_helper.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/sharedtypes.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/sharedtypes.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/utils.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/utils.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/validation.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/validation.py
 Comment: 
 
-Filename: python-ilorest-library-4.1.0.0/src/redfish/ris/__init__.py
+Filename: python-ilorest-library-4.2.0.0/src/redfish/ris/__init__.py
 Comment: 
 
 Zip file comment:
```

## Comparing `python-ilorest-library-4.1.0.0/LICENSE` & `python-ilorest-library-4.2.0.0/LICENSE`

 * *Files identical despite different names*

## Comparing `python-ilorest-library-4.1.0.0/PKG-INFO` & `python-ilorest-library-4.2.0.0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.1
 Name: python-ilorest-library
-Version: 4.1.0.0
+Version: 4.2.0.0
 Summary: iLO Rest Python Library
 Home-page: https://github.com/HewlettPackard/python-ilorest-library
 Author: Hewlett Packard Enterprise
 Author-email: rajeevalochana.kallur@hpe.com
 License: UNKNOWN
 Description: UNKNOWN
 Keywords: Hewlett Packard Enterprise
```

## Comparing `python-ilorest-library-4.1.0.0/README.rst` & `python-ilorest-library-4.2.0.0/README.rst`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,143 +1,143 @@
-python-ilorest-library
-======================
-.. image:: https://travis-ci.org/HewlettPackard/python-ilorest-library.svg?branch=master
-    :target: https://travis-ci.org/HewlettPackard/python-ilorest-library
-.. image:: https://img.shields.io/pypi/v/python-ilorest-library.svg?maxAge=2592000
-	:target: https://pypi.python.org/pypi/python-ilorest-library
-.. image:: https://img.shields.io/github/release/HewlettPackard/python-ilorest-library.svg?maxAge=2592000
-	:target:
-.. image:: https://img.shields.io/badge/license-Apache%202-blue.svg
-	:target: https://raw.githubusercontent.com/HewlettPackard/python-ilorest-library/master/LICENSE
-.. image:: https://img.shields.io/pypi/pyversions/python-ilorest-library.svg?maxAge=2592000
-	:target: https://pypi.python.org/pypi/python-ilorest-library
-.. image:: https://api.codacy.com/project/badge/Grade/1283adc3972d42b4a3ddb9b96660bc07
-	:target: https://www.codacy.com/app/rexysmydog/python-ilorest-library?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=HewlettPackard/python-ilorest-library&amp;utm_campaign=Badge_Grade
-
-
-.. contents:: :depth: 1
-
-Description
-----------
-The python-ilorest-library is a python library built for interacting with the Redfish API remotely to any BMC that 
-implements a Redfish API or any HPE system locally. The library also supports HPE's legacy REST API. Go to the library
-`documentation <https://pages.github.hpe.com/intelligent-provisioning/python-redfish-library/>`_ for more details.
-
-HPE RESTful API for iLO is a RESTful application programming interface for the
-management of iLO and iLO Chassis Manager based HPE servers. REST
-(Representational State Transfer) is a web based software architectural style
-consisting of a set of constraints that focuses on a system's resources. iLO
-REST library performs the basic HTTP operations GET, POST, PUT, PATCH and
-DELETE on resources using the HATEOAS (Hypermedia as the Engine of Application
-State) REST architecture. The API allows the clients to manage and interact
-with iLO through a fixed URL and several URIs. Go to the API 
-`documentation <https://hewlettpackard.github.io/ilo-rest-api-docs/>`_
-for more details.
-
-Installing
-----------
-
-.. code-block:: console
-
-	pip install python-ilorest-library
-
-Building from zip file source
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. code-block:: console
-
-	python setup.py sdist --formats=zip (this will produce a .zip file)
-	cd dist
-	pip install python-ilorest-library-x.x.x.zip
-	
-Including socks support (Version 2.5 or greater)
-~~~~~~~~~~~~~~~~~~~~~~~~~
-.. code-block:: console
-
-	pip install python-ilorest-library[socks]
-
-.. code-block:: console
-
-	python setup.py sdist --formats=zip (this will produce a .zip file)
-	cd dist
-	pip install python-ilorest-library-x.x.x.zip[socks]
-
-Requirements
-------------
-
-Remote communication
-~~~~~~~~~~~~~~~~~~~~
-No special requirements.
-
-Inband communication
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
- To enable support for inband communications, you must download the DLL/SO for your system. By downloading, you agree to the terms and conditions of the `Hewlett Packard Enterprise Software License Agreement`_. 
-It must be placed in your working environment path.
- 
- Windows Download: ilorest_chif.dll_
- 
- Linux Download: ilorest_chif.so_
- 
- .. _`Hewlett Packard Enterprise Software License Agreement` : https://www.hpe.com/us/en/software/licensing.html
- .. _ilorest_chif.dll: https://downloads.hpe.com/pub/softlib2/software1/pubsw-windows/p1463761240/v167985/ilorest_chif.dll
- .. _ilorest_chif.so: https://downloads.hpe.com/pub/softlib2/software1/pubsw-linux/p1093353304/v168967/ilorest_chif.so
-
-Usage
-----------
-For 3.x and greater versions of the library see the documentation for usage: https://pages.github.hpe.com/intelligent-provisioning/python-redfish-library/
-
-For 2.x versions of the library documentation is located at the `Wiki <https://github.hpe.com/intelligent-provisioning/python-redfish-library/wiki>`_.
-
-Contributing
-----------
-
- 1. Fork it!
- 2. Create your feature branch: `git checkout -b my-new-feature`
- 3. Commit your changes: `git commit -am 'Add some feature'`
- 4. Push to the branch: `git push origin my-new-feature`
- 5. Submit a pull request :D
-
-History
--------
-
-  * 04/01/2016: Initial Commit
-  * 06/23/2016: Release of v1.1.0
-  * 07/25/2016: Release of v1.2.0
-  * 08/02/2016: Release of v1.3.0
-  * 09/06/2016: Release of v1.4.0
-  * 11/04/2016: Release of v1.5.0
-  * 12/06/2016: Release of v1.6.0
-  * 01/17/2017: Release of v1.7.0
-  * 02/01/2017: Release of v1.8.0
-  * 03/22/2017: Release of v1.9.0
-  * 04/12/2017: Release of v1.9.1
-  * 07/17/2017: Release of v2.0.0
-  * 10/30/2017: Release of v2.1.0
-  * 02/20/2018: Release of v2.2.0
-  * 06/11/2018: Release of v2.3.0
-  * 07/02/2018: Release of v2.3.1
-  * 03/25/2019: Release of v2.4.1
-  * 05/09/2019: Release of v2.4.2
-  * 07/05/2019: Release of v2.5.0
-  * 07/11/2019: Release of v2.5.1
-  * 08/13/2019: Release of v2.5.2
-  * 11/13/2019: Release of v3.0.0
-
-Copyright and License
----------------------
-
-::
-
- Copyright 2016 Hewlett Packard Enterprise Development LP
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-  http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
+python-ilorest-library
+======================
+.. image:: https://travis-ci.org/HewlettPackard/python-ilorest-library.svg?branch=master
+    :target: https://travis-ci.org/HewlettPackard/python-ilorest-library
+.. image:: https://img.shields.io/pypi/v/python-ilorest-library.svg?maxAge=2592000
+	:target: https://pypi.python.org/pypi/python-ilorest-library
+.. image:: https://img.shields.io/github/release/HewlettPackard/python-ilorest-library.svg?maxAge=2592000
+	:target:
+.. image:: https://img.shields.io/badge/license-Apache%202-blue.svg
+	:target: https://raw.githubusercontent.com/HewlettPackard/python-ilorest-library/master/LICENSE
+.. image:: https://img.shields.io/pypi/pyversions/python-ilorest-library.svg?maxAge=2592000
+	:target: https://pypi.python.org/pypi/python-ilorest-library
+.. image:: https://api.codacy.com/project/badge/Grade/1283adc3972d42b4a3ddb9b96660bc07
+	:target: https://www.codacy.com/app/rexysmydog/python-ilorest-library?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=HewlettPackard/python-ilorest-library&amp;utm_campaign=Badge_Grade
+
+
+.. contents:: :depth: 1
+
+Description
+----------
+The python-ilorest-library is a python library built for interacting with the Redfish API remotely to any BMC that 
+implements a Redfish API or any HPE system locally. The library also supports HPE's legacy REST API. Go to the library
+`documentation <https://pages.github.hpe.com/intelligent-provisioning/python-redfish-library/>`_ for more details.
+
+HPE RESTful API for iLO is a RESTful application programming interface for the
+management of iLO and iLO Chassis Manager based HPE servers. REST
+(Representational State Transfer) is a web based software architectural style
+consisting of a set of constraints that focuses on a system's resources. iLO
+REST library performs the basic HTTP operations GET, POST, PUT, PATCH and
+DELETE on resources using the HATEOAS (Hypermedia as the Engine of Application
+State) REST architecture. The API allows the clients to manage and interact
+with iLO through a fixed URL and several URIs. Go to the API 
+`documentation <https://hewlettpackard.github.io/ilo-rest-api-docs/>`_
+for more details.
+
+Installing
+----------
+
+.. code-block:: console
+
+	pip install python-ilorest-library
+
+Building from zip file source
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. code-block:: console
+
+	python setup.py sdist --formats=zip (this will produce a .zip file)
+	cd dist
+	pip install python-ilorest-library-x.x.x.zip
+	
+Including socks support (Version 2.5 or greater)
+~~~~~~~~~~~~~~~~~~~~~~~~~
+.. code-block:: console
+
+	pip install python-ilorest-library[socks]
+
+.. code-block:: console
+
+	python setup.py sdist --formats=zip (this will produce a .zip file)
+	cd dist
+	pip install python-ilorest-library-x.x.x.zip[socks]
+
+Requirements
+------------
+
+Remote communication
+~~~~~~~~~~~~~~~~~~~~
+No special requirements.
+
+Inband communication
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+ To enable support for inband communications, you must download the DLL/SO for your system. By downloading, you agree to the terms and conditions of the `Hewlett Packard Enterprise Software License Agreement`_. 
+It must be placed in your working environment path.
+ 
+ Windows Download: ilorest_chif.dll_
+ 
+ Linux Download: ilorest_chif.so_
+ 
+ .. _`Hewlett Packard Enterprise Software License Agreement` : https://www.hpe.com/us/en/software/licensing.html
+ .. _ilorest_chif.dll: https://downloads.hpe.com/pub/softlib2/software1/pubsw-windows/p1463761240/v167985/ilorest_chif.dll
+ .. _ilorest_chif.so: https://downloads.hpe.com/pub/softlib2/software1/pubsw-linux/p1093353304/v168967/ilorest_chif.so
+
+Usage
+----------
+For 3.x and greater versions of the library see the documentation for usage: https://pages.github.hpe.com/intelligent-provisioning/python-redfish-library/
+
+For 2.x versions of the library documentation is located at the `Wiki <https://github.hpe.com/intelligent-provisioning/python-redfish-library/wiki>`_.
+
+Contributing
+----------
+
+ 1. Fork it!
+ 2. Create your feature branch: `git checkout -b my-new-feature`
+ 3. Commit your changes: `git commit -am 'Add some feature'`
+ 4. Push to the branch: `git push origin my-new-feature`
+ 5. Submit a pull request :D
+
+History
+-------
+
+  * 04/01/2016: Initial Commit
+  * 06/23/2016: Release of v1.1.0
+  * 07/25/2016: Release of v1.2.0
+  * 08/02/2016: Release of v1.3.0
+  * 09/06/2016: Release of v1.4.0
+  * 11/04/2016: Release of v1.5.0
+  * 12/06/2016: Release of v1.6.0
+  * 01/17/2017: Release of v1.7.0
+  * 02/01/2017: Release of v1.8.0
+  * 03/22/2017: Release of v1.9.0
+  * 04/12/2017: Release of v1.9.1
+  * 07/17/2017: Release of v2.0.0
+  * 10/30/2017: Release of v2.1.0
+  * 02/20/2018: Release of v2.2.0
+  * 06/11/2018: Release of v2.3.0
+  * 07/02/2018: Release of v2.3.1
+  * 03/25/2019: Release of v2.4.1
+  * 05/09/2019: Release of v2.4.2
+  * 07/05/2019: Release of v2.5.0
+  * 07/11/2019: Release of v2.5.1
+  * 08/13/2019: Release of v2.5.2
+  * 11/13/2019: Release of v3.0.0
+
+Copyright and License
+---------------------
+
+::
+
+ Copyright 2016 Hewlett Packard Enterprise Development LP
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
```

## Comparing `python-ilorest-library-4.1.0.0/setup.py` & `python-ilorest-library-4.2.0.0/setup.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from setuptools import setup, find_packages
 
 extras = {}
 
 setup(name='python-ilorest-library',
-      version='4.1.0.0',
+      version='4.2.0.0',
       description='iLO Rest Python Library',
 	  author = 'Hewlett Packard Enterprise',
 	  author_email = 'rajeevalochana.kallur@hpe.com',
       extras_require = extras,
       classifiers=[
           'Development Status :: 5 - Production/Stable',
           'License :: OSI Approved :: Apache Software License',
```

## Comparing `python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/PKG-INFO` & `python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.1
 Name: python-ilorest-library
-Version: 4.1.0.0
+Version: 4.2.0.0
 Summary: iLO Rest Python Library
 Home-page: https://github.com/HewlettPackard/python-ilorest-library
 Author: Hewlett Packard Enterprise
 Author-email: rajeevalochana.kallur@hpe.com
 License: UNKNOWN
 Description: UNKNOWN
 Keywords: Hewlett Packard Enterprise
```

## Comparing `python-ilorest-library-4.1.0.0/src/python_ilorest_library.egg-info/SOURCES.txt` & `python-ilorest-library-4.2.0.0/src/python_ilorest_library.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/__init__.py` & `python-ilorest-library-4.2.0.0/src/redfish/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 """ Redfish restful library """
 
 __all__ = ["rest", "ris", "hpilo"]
-__version__ = "4.1.0.0"
+__version__ = "4.2.0.0"
 
 import logging
 from redfish.rest.v1 import AuthMethod, LegacyRestClient, RedfishClient
 
 
 def redfish_logger(file_name, log_format, log_level=logging.ERROR):
     """redfish logger"""
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/hpilo/risblobstore2.py` & `python-ilorest-library-4.2.0.0/src/redfish/hpilo/risblobstore2.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,1046 +1,1043 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-
-# -*- coding: utf-8 -*-
-"""Base implementation for interaction with blob store interface"""
-
-# ---------Imports---------
-
-import os
-import sys
-import struct
-import random
-import string
-import logging
-
-from ctypes import (
-    c_char_p,
-    c_ubyte,
-    c_uint,
-    cdll,
-    POINTER,
-    create_string_buffer,
-    c_ushort,
-    c_void_p,
-)
-
-from redfish.hpilo.rishpilo import HpIlo, HpIloInitialError, HpIloChifPacketExchangeError
-from redfish.hpilo.rishpilo import BlobReturnCodes as hpiloreturncodes
-
-if os.name == "nt":
-    from ctypes import windll
-else:
-    from _ctypes import dlclose
-
-# ---------End of imports---------
-# ---------Debug logger---------
-
-LOGGER = logging.getLogger(__name__)
-
-
-# ---------End of debug logger---------
-# -----------------------Error Returns----------------------
-
-
-class UnexpectedResponseError(Exception):
-    """Raise when we get data that we don't expect from iLO"""
-
-    pass
-
-
-class HpIloError(Exception):
-    """Raised when iLO returns non-zero error code"""
-
-    pass
-
-
-class Blob2CreateError(Exception):
-    """Raised when create operation fails"""
-
-    pass
-
-
-class Blob2InfoError(Exception):
-    """Raised when create operation fails"""
-
-    pass
-
-
-class Blob2ReadError(Exception):
-    """Raised when read operation fails"""
-
-    pass
-
-
-class Blob2WriteError(Exception):
-    """Raised when write operation fails"""
-
-    pass
-
-
-class Blob2DeleteError(Exception):
-    """Raised when delete operation fails"""
-
-    pass
-
-
-class Blob2OverrideError(Exception):
-    """Raised when delete operation fails because of it been overwritten"""
-
-    pass
-
-
-class BlobRetriesExhaustedError(Exception):
-    """Raised when max retries have been attempted for same operation"""
-
-    pass
-
-
-class Blob2FinalizeError(Exception):
-    """Raised when finalize operation fails"""
-
-    pass
-
-
-class Blob2ListError(Exception):
-    """Raised when list operation fails"""
-
-    pass
-
-
-class Blob2SecurityError(Exception):
-    """Raised when there is an issue with security"""
-
-    pass
-
-
-class BlobNotFoundError(Exception):
-    """Raised when blob not found in key/namespace"""
-
-    pass
-
-
-class ChifDllMissingError(Exception):
-    """Raised when unable to obtain ilorest_chif dll handle"""
-
-    pass
-
-
-class EncryptionEnabledError(Exception):
-    """Raised when high security encryption is enabled"""
-
-    pass
-
-
-# ----------------------------------------------------------
-
-# -------------------Helper functions-------------------------
-
-
-class BlobReturnCodes(object):
-    """Blob store return codes.
-
-    SUCCESS           success
-    BADPARAMETER      bad parameter supplied
-    NOTFOUND          blob name not found
-    NOTMODIFIED       call did not perform the operation
-
-    """
-
-    SUCCESS = 0
-    BADPARAMETER = 2
-    NOTFOUND = 12
-    NOTMODIFIED = 20
-
-
-class BlobStore2(object):
-    """Blob store 2 class"""
-
-    def __init__(self):
-        lib = self.gethprestchifhandle()
-        self.channel = HpIlo(dll=lib)
-        self.max_retries = 3
-
-    def __del__(self):
-        """Blob store 2 close channel function"""
-        if hasattr(self, "channel"):
-            self.channel.close()
-
-    def create(self, key, namespace):
-        """Create the blob
-
-        :param key: The blob key to create.
-        :type key: str.
-        :param namespace: The blob namespace to create the key in.
-        :type namespace: str.
-
-        """
-        lib = self.gethprestchifhandle()
-        lib.create_not_blobentry.argtypes = [c_char_p, c_char_p]
-        lib.create_not_blobentry.restype = POINTER(c_ubyte)
-
-        name = create_string_buffer(key.encode("utf-8"))
-        namespace = create_string_buffer(namespace.encode("utf-8"))
-
-        ptr = lib.create_not_blobentry(name, namespace)
-        data = ptr[: lib.size_of_createRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def get_info(self, key, namespace, retries=0):
-        """Get information for a particular blob
-
-        :param key: The blob key to retrieve.
-        :type key: str.
-        :param namespace: The blob namespace to retrieve the key from.
-        :type namespace: str.
-
-        """
-        lib = self.gethprestchifhandle()
-        lib.get_info.argtypes = [c_char_p, c_char_p]
-        lib.get_info.restype = POINTER(c_ubyte)
-
-        name = create_string_buffer(key.encode("utf-8"))
-        namspace = create_string_buffer(namespace.encode("utf-8"))
-
-        ptr = lib.get_info(name, namspace)
-        data = ptr[: lib.size_of_infoRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if errorcode == BlobReturnCodes.BADPARAMETER:
-            if retries < self.max_retries:
-                self.get_info(key=key, namespace=namespace, retries=retries + 1)
-            else:
-                raise Blob2OverrideError(errorcode)
-        elif errorcode == BlobReturnCodes.NOTFOUND:
-            raise BlobNotFoundError(key, namespace)
-
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        response = resp[lib.size_of_responseHeaderBlob() :]
-
-        self.unloadchifhandle(lib)
-
-        return response
-
-    def read(self, key, namespace, retries=0):
-        """Read a particular blob
-
-        :param key: The blob key to be read.
-        :type key: str.
-        :param namespace: The blob namespace to read the key from.
-        :type namespace: str.
-
-        """
-        lib = self.gethprestchifhandle()
-        maxread = lib.max_read_size()
-        readsize = lib.size_of_readRequest()
-        readhead = lib.size_of_responseHeaderBlob()
-
-        self.unloadchifhandle(lib)
-
-        blob_info = self.get_info(key, namespace)
-        blobsize = struct.unpack("<I", bytes(blob_info[0:4]))[0]
-
-        bytes_read = 0
-        data = bytearray()
-
-        while bytes_read < blobsize:
-            if (maxread - readsize) < (blobsize - bytes_read):
-                count = maxread - readsize
-            else:
-                count = blobsize - bytes_read
-
-            read_block_size = bytes_read
-            recvpkt = self.read_fragment(key, namespace, read_block_size, count)
-
-            newreadsize = readhead + 4
-            bytesread = struct.unpack("<I", bytes(recvpkt[readhead:(newreadsize)]))[0]
-
-            if bytesread == 0:
-                if retries < self.max_retries:
-                    data = self.read(key=key, namespace=namespace, retries=retries + 1)
-                    return data
-                else:
-                    raise BlobRetriesExhaustedError()
-
-            data.extend(recvpkt[newreadsize : newreadsize + bytesread])
-            bytes_read += bytesread
-
-        return data
-
-    def read_fragment(self, key, namespace, offset=0, count=1):
-        """Fragmented version of read function for large blobs
-
-        :param key: The blob key to be read.
-        :type key: str.
-        :param namespace: The blob namespace to read the key from.
-        :type namespace: str.
-        :param offset: The data offset for the current fragmented read.
-        :type key: int.
-        :param count: The data count for the current fragmented read.
-        :type namespace: int.
-
-        """
-        lib = self.gethprestchifhandle()
-        lib.read_fragment.argtypes = [c_uint, c_uint, c_char_p, c_char_p]
-        lib.read_fragment.restype = POINTER(c_ubyte)
-
-        name = create_string_buffer(key.encode("utf-8"))
-        namespace = create_string_buffer(namespace.encode("utf-8"))
-
-        ptr = lib.read_fragment(offset, count, name, namespace)
-        data = ptr[: lib.size_of_readRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        resp = resp + b"\0" * (lib.size_of_readResponse() - len(resp))
-
-        return resp
-
-    def write(self, key, namespace, data=None):
-        """Write a particular blob
-
-        :param key: The blob key to be written.
-        :type key: str.
-        :param namespace: The blob namespace to write the key in.
-        :type namespace: str.
-        :param data: The blob data to be written.
-        :type data: str.
-
-        """
-        lib = self.gethprestchifhandle()
-        maxwrite = lib.max_write_size()
-        writesize = lib.size_of_writeRequest()
-
-        self.unloadchifhandle(lib)
-
-        if data:
-            data_length = len(data)
-            bytes_written = 0
-
-            while bytes_written < data_length:
-                if (maxwrite - writesize) < (data_length - bytes_written):
-                    count = maxwrite - writesize
-                else:
-                    count = data_length - bytes_written
-
-                write_blob_size = bytes_written
-
-                self.write_fragment(
-                    key,
-                    namespace=namespace,
-                    data=data[write_blob_size : write_blob_size + count],
-                    offset=write_blob_size,
-                    count=count,
-                )
-
-                bytes_written += count
-
-        return self.finalize(key, namespace=namespace)
-
-    def write_fragment(self, key, namespace, data=None, offset=0, count=1):
-        """Fragmented version of write function for large blobs
-
-        :param key: The blob key to be written.
-        :type key: str.
-        :param namespace: The blob namespace to write the key in.
-        :type namespace: str.
-        :param data: The blob data to be written to blob.
-        :type data: str.
-        :param offset: The data offset for the current fragmented write.
-        :type key: int.
-        :param count: The data count for the current fragmented write.
-        :type count: int.
-
-        """
-        lib = self.gethprestchifhandle()
-        lib.write_fragment.argtypes = [c_uint, c_uint, c_char_p, c_char_p]
-        lib.write_fragment.restype = POINTER(c_ubyte)
-
-        name = create_string_buffer(key.encode("utf-8"))
-        namespace = create_string_buffer(namespace.encode("utf-8"))
-
-        ptr = lib.write_fragment(offset, count, name, namespace)
-        sendpacket = ptr[: lib.size_of_writeRequest()]
-
-        if isinstance(data, str):
-            data = data.encode("utf-8")
-
-        dataarr = bytearray(sendpacket)
-        dataarr.extend(memoryview(data))
-
-        resp = self._send_receive_raw(dataarr)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def delete(self, key, namespace, retries=0):
-        """Delete the blob
-
-        :param key: The blob key to be deleted.
-        :type key: str.
-        :param namespace: The blob namespace to delete the key from.
-        :type namespace: str.
-
-        """
-        lib = self.gethprestchifhandle()
-        lib.delete_blob.argtypes = [c_char_p, c_char_p]
-        lib.delete_blob.restype = POINTER(c_ubyte)
-
-        name = create_string_buffer(key.encode("utf-8"))
-        namspace = create_string_buffer(namespace.encode("utf-8"))
-
-        ptr = lib.delete_blob(name, namspace)
-        data = ptr[: lib.size_of_deleteRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if errorcode == BlobReturnCodes.BADPARAMETER:
-            if retries < self.max_retries:
-                self.delete(key=key, namespace=namespace, retries=retries + 1)
-            else:
-                raise Blob2OverrideError(errorcode)
-        elif not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return errorcode
-
-    def list(self, namespace):
-        """List operation to retrieve all blobs in a given namespace
-
-        :param namespace: The blob namespace to retrieve the keys from.
-        :type namespace: str.
-
-        """
-        lib = self.gethprestchifhandle()
-        lib.list_blob.argtypes = [c_char_p]
-        lib.list_blob.restype = POINTER(c_ubyte)
-
-        namespace = create_string_buffer(namespace.encode("utf-8"))
-
-        ptr = lib.list_blob(namespace)
-        data = ptr[: lib.size_of_listRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        resp = resp + b"\0" * (lib.size_of_listResponse() - len(resp))
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def finalize(self, key, namespace):
-        """Finalize the blob
-
-        :param key: The blob key to be finalized.
-        :type key: str.
-        :param namespace: The blob namespace to finalize the key in.
-        :type namespace: str.
-
-        """
-        lib = self.gethprestchifhandle()
-        lib.finalize_blob.argtypes = [c_char_p, c_char_p]
-        lib.finalize_blob.restype = POINTER(c_ubyte)
-
-        name = create_string_buffer(key.encode("utf-8"))
-        namespace = create_string_buffer(namespace.encode("utf-8"))
-
-        ptr = lib.finalize_blob(name, namespace)
-        data = ptr[: lib.size_of_finalizeRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return errorcode
-
-    def rest_immediate(
-        self,
-        req_data,
-        rqt_key="RisRequest",
-        rsp_key="RisResponse",
-        rsp_namespace="volatile",
-    ):
-        """Read/write blob via immediate operation
-
-        :param req_data: The blob data to be read/written.
-        :type req_data: str.
-        :param rqt_key: The blob key to be used for the request data.
-        :type rqt_key: str.
-        :param rsp_key: The blob key to be used for the response data.
-        :type rsp_key: str.
-        :param rsp_namespace: The blob namespace to retrieve the response from.
-        :type rsp_namespace: str.
-
-        """
-        rqt_key = "".join(
-            random.choice(string.ascii_letters + string.digits) for _ in range(10)
-        )
-        rsp_key = "".join(
-            random.choice(string.ascii_letters + string.digits) for _ in range(10)
-        )
-
-        lib = self.gethprestchifhandle()
-
-        if len(req_data) < (lib.size_of_restImmediateRequest() + lib.max_write_size()):
-            lib.rest_immediate.argtypes = [c_uint, c_char_p, c_char_p]
-            lib.rest_immediate.restype = POINTER(c_ubyte)
-
-            name = create_string_buffer(rsp_key.encode("utf-8"))
-            namespace = create_string_buffer(rsp_namespace.encode("utf-8"))
-
-            ptr = lib.rest_immediate(len(req_data), name, namespace)
-            sendpacket = ptr[: lib.size_of_restImmediateRequest()]
-            mode = False
-        else:
-            self.create(rqt_key, rsp_namespace)
-            self.write(rqt_key, rsp_namespace, req_data)
-
-            lib.rest_immediate_blobdesc.argtypes = [c_char_p, c_char_p, c_char_p]
-            lib.rest_immediate_blobdesc.restype = POINTER(c_ubyte)
-
-            name = create_string_buffer(rqt_key.encode("utf-8"))
-            namespace = create_string_buffer(rsp_namespace.encode("utf-8"))
-            rspname = create_string_buffer(rsp_key.encode("utf-8"))
-
-            ptr = lib.rest_immediate_blobdesc(name, rspname, namespace)
-            sendpacket = ptr[: lib.size_of_restBlobRequest()]
-            mode = True
-
-        data = bytearray(sendpacket)
-
-        if not mode:
-            data.extend(req_data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if errorcode == BlobReturnCodes.NOTFOUND:
-            raise BlobNotFoundError(rsp_key, rsp_namespace)
-
-        recvmode = struct.unpack("<I", bytes(resp[12:16]))[0]
-
-        fixdlen = lib.size_of_restResponseFixed()
-        response = resp[fixdlen : struct.unpack("<I", bytes(resp[16:20]))[0] + fixdlen]
-
-        tmpresponse = None
-        if errorcode == BlobReturnCodes.SUCCESS and not mode:
-            if recvmode == 0:
-                tmpresponse = "".join(map(chr, response))
-        elif errorcode == BlobReturnCodes.NOTMODIFIED and not mode:
-            if recvmode == 0:
-                tmpresponse = "".join(map(chr, response))
-        elif errorcode == BlobReturnCodes.SUCCESS:
-            if recvmode == 0:
-                tmpresponse = "".join(map(chr, response))
-        elif recvmode == 0:
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        if not tmpresponse and recvmode == 1:
-            tmpresponse = self.read(rsp_key, rsp_namespace)
-
-            try:
-                self.delete(rsp_key, rsp_namespace)
-            except Exception as excp:
-                raise excp
-        else:
-            try:
-                self.delete(rsp_key, rsp_namespace)
-            except Blob2OverrideError as excp:
-                pass
-            except HpIloChifPacketExchangeError as excp:
-                pass
-            except Exception as excp:
-                raise excp
-
-        return tmpresponse
-
-    def get_security_state(self):
-        """Get information for the current security state"""
-        lib = self.gethprestchifhandle()
-        lib.get_security_state.argtypes = []
-        lib.get_security_state.restype = POINTER(c_ubyte)
-
-        ptr = lib.get_security_state()
-        data = ptr[: lib.size_of_securityStateRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        try:
-            securitystate = struct.unpack("<c", bytes(resp[72]))[0]
-        except:
-            securitystate = int(resp[72])
-
-        self.unloadchifhandle(lib)
-
-        return securitystate
-
-    def mount_blackbox(self):
-        """Operation to mount the blackbox partition"""
-        lib = self.gethprestchifhandle()
-        lib.blackbox_media_mount.argtypes = []
-        lib.blackbox_media_mount.restype = POINTER(c_ubyte)
-
-        ptr = lib.blackbox_media_mount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def absaroka_media_mount(self):
-        """Operation to mount the absaroka repo partition"""
-        lib = self.gethprestchifhandle()
-        lib.absaroka_media_mount.argtypes = []
-        lib.absaroka_media_mount.restype = POINTER(c_ubyte)
-
-        ptr = lib.absaroka_media_mount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def gaius_media_mount(self):
-        """Operation to mount the gaius media partition"""
-        lib = self.gethprestchifhandle()
-        lib.gaius_media_mount.argtypes = []
-        lib.gaius_media_mount.restype = POINTER(c_ubyte)
-
-        ptr = lib.gaius_media_mount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def vid_media_mount(self):
-        """Operation to mount the gaius media partition"""
-        lib = self.gethprestchifhandle()
-        lib.vid_media_mount.argtypes = []
-        lib.vid_media_mount.restype = POINTER(c_ubyte)
-
-        ptr = lib.vid_media_mount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def mountflat(self):
-        """Operation to mount the gaius media partition"""
-        lib = self.gethprestchifhandle()
-        lib.flat_media_mount.argtypes = []
-        lib.flat_media_mount.restype = POINTER(c_ubyte)
-
-        ptr = lib.flat_media_mount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def media_unmount(self):
-        """Operation to unmount the media partition"""
-        lib = self.gethprestchifhandle()
-        lib.media_unmount.argtypes = []
-        lib.media_unmount.restype = POINTER(c_ubyte)
-
-        ptr = lib.media_unmount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def bb_media_unmount(self):
-        """Operation to unmount the media partition"""
-        lib = self.gethprestchifhandle()
-        lib.bb_media_unmount.argtypes = []
-        lib.bb_media_unmount.restype = POINTER(c_ubyte)
-
-        ptr = lib.bb_media_unmount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def vid_media_unmount(self):
-        """Operation to unmount the media partition"""
-        lib = self.gethprestchifhandle()
-        lib.vid_media_unmount.argtypes = []
-        lib.vid_media_unmount.restype = POINTER(c_ubyte)
-
-        ptr = lib.vid_media_unmount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def gaius_media_unmount(self):
-        """Operation to unmount the media partition"""
-        lib = self.gethprestchifhandle()
-        lib.gaius_media_unmount.argtypes = []
-        lib.gaius_media_unmount.restype = POINTER(c_ubyte)
-
-        ptr = lib.gaius_media_unmount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def absr_media_unmount(self):
-        """Operation to unmount the media partition"""
-        lib = self.gethprestchifhandle()
-        lib.absaroka_media_unmount.argtypes = []
-        lib.absaroka_media_unmount.restype = POINTER(c_ubyte)
-
-        ptr = lib.absaroka_media_unmount()
-        data = ptr[: lib.size_of_embeddedMediaRequest()]
-        data = bytearray(data)
-
-        resp = self._send_receive_raw(data)
-
-        errorcode = resp[12]
-        if not (
-            errorcode == BlobReturnCodes.SUCCESS
-            or errorcode == BlobReturnCodes.NOTMODIFIED
-        ):
-            raise HpIloError(errorcode)
-
-        self.unloadchifhandle(lib)
-
-        return resp
-
-    def _send_receive_raw(self, indata):
-        """Send and receive raw function for blob operations
-
-        :param indata: The data to be sent to blob operation.
-        :type indata: str.
-
-        """
-        excp = None
-        for _ in range(0, 3):  # channel loop for iLO
-            try:
-                resp = self.channel.send_receive_raw(indata, 10)
-                return resp
-            except Exception as exp:
-                self.channel.close()
-                lib = self.gethprestchifhandle()
-                self.channel = HpIlo(dll=lib)
-                excp = exp
-        if excp:
-            raise excp
-
-    def cert_login(self, cert_file, priv_key, key_pass):
-        lib = self.gethprestchifhandle()
-        lib.login_cert.argtypes = [c_void_p, c_char_p, c_char_p, c_char_p]
-        lib.login_cert.restype = c_char_p
-
-        token = lib.login_cert(self.channel.fhandle, cert_file, priv_key, key_pass)
-        return token
-
-    @staticmethod
-    def gethprestchifhandle():
-        """Multi platform handle for chif hprest library"""
-        excp = None
-        libhandle = None
-        if os.name != "nt":
-            libpath = '/opt/ilorest/lib64/libilorestchif.so'
-            if os.path.isfile(libpath):
-                libhandle = cdll.LoadLibrary(libpath)
-        if not libhandle:
-            libnames = (
-                ["ilorest_chif.dll", "hprest_chif.dll"]
-                if os.name == "nt"
-                else [
-                    "ilorest_chif_dev.so",
-                    "hprest_chif_dev.so",
-                    "ilorest_chif.so",
-                    "hprest_chif.so",
-                ]
-            )
-            for libname in libnames:
-                try:
-                    libpath = BlobStore2.checkincurrdirectory(libname)
-                    LOGGER.info("Loading Library %s for libhpsrv", libpath)
-                    libhandle = cdll.LoadLibrary(libpath)
-                    if libhandle:
-                        LOGGER.info("Got Libhandle %s for libhpsrv", libhandle)
-                        break
-                except Exception as exp:
-                    excp = exp
-
-        if libhandle:
-            BlobStore2.setglobalhprestchifrandnumber(libhandle)
-            return libhandle
-        raise ChifDllMissingError(excp)
-
-    @staticmethod
-    def setglobalhprestchifrandnumber(libbhndl):
-        """Set the random number for the chif handle
-        :param libbhndl: The library handle provided by loading the chif library.
-        :type libbhndl: library handle.
-        """
-        rndval = random.randint(1, 65535)
-        libbhndl.updaterandval.argtypes = [c_ushort]
-        libbhndl.updaterandval(rndval)
-
-    @staticmethod
-    def initializecreds(username=None, password=None):
-        """Get chif ready to use high security
-        :param username: The username to login.
-        :type username: str.
-        :param password: The password to login.
-        :type password: str.
-        """
-        LOGGER.info("Inside initializecreds")
-        dll = BlobStore2.gethprestchifhandle()
-        if LOGGER.isEnabledFor(logging.DEBUG):
-            LOGGER.info("Enabling DEBUG from libhpsrv")
-            dll.enabledebugoutput()
-        LOGGER.info("Calling ChifInitialize from libhpsrv")
-        dll.ChifInitialize(None)
-        if username:
-            if not password:
-                return False
-            if dll.ChifIsSecurityRequired() > 0:
-                dll.initiate_credentials.argtypes = [c_char_p, c_char_p]
-                dll.initiate_credentials.restype = POINTER(c_ubyte)
-
-                usernew = create_string_buffer(username.encode("utf-8"))
-                passnew = create_string_buffer(password.encode("utf-8"))
-
-                LOGGER.info("Calling initiate_credentials from libhpsrv")
-                dll.initiate_credentials(usernew, passnew)
-                LOGGER.info("Calling ChifVerifyCredentials from libhpsrv")
-                credreturn = dll.ChifVerifyCredentials()
-                if not credreturn == BlobReturnCodes.SUCCESS:
-                    if credreturn == hpiloreturncodes.CHIFERR_AccessDenied:
-                        raise Blob2SecurityError()
-                    else:
-                        raise HpIloInitialError(
-                            "Error %s occurred while trying "
-                            "to open a channel to iLO" % credreturn
-                        )
-            else:
-                dll.ChifDisableSecurity()
-        else:
-            # if high security return False
-            LOGGER.info("Calling ChifIsSecurityRequired from libhpsrv")
-            if dll.ChifIsSecurityRequired() > 0:
-                return False
-            else:
-                LOGGER.info("Calling ChifDisableSecurity from libhpsrv")
-                dll.ChifDisableSecurity()
-
-        BlobStore2.unloadchifhandle(dll)
-
-        return True
-
-    @staticmethod
-    def checkincurrdirectory(libname):
-        """Check if the library is present in current directory.
-        :param libname: The name of the library to search for.
-        :type libname: str."""
-        libpath = libname
-
-        if os.path.isfile(os.path.join(os.path.split(sys.executable)[0], libpath)):
-            libpath = os.path.join(os.path.split(sys.executable)[0], libpath)
-        elif os.path.isfile(os.path.join(os.getcwd(), libpath)):
-            libpath = os.path.join(os.getcwd(), libpath)
-        elif os.environ.get("LD_LIBRARY_PATH"):
-            paths = os.getenv("LD_LIBRARY_PATH", libpath).split(";")
-            libpath = [
-                os.path.join(pat, libname)
-                for pat in paths
-                if os.path.isfile(os.path.join(pat, libname))
-            ]
-            libpath = libpath[0] if libpath else libname
-
-        return libpath
-
-    @staticmethod
-    def unloadchifhandle(lib):
-        """Release a handle on the chif iLOrest library
-
-        :param lib: The library handle provided by loading the chif library.
-        :type lib: library handle.
-
-        """
-        try:
-            libhandle = lib._handle
-            if os.name == "nt":
-                windll.kernel32.FreeLibrary(None, handle=libhandle)
-            else:
-                dlclose(libhandle)
-        except Exception:
-            pass
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+
+# -*- coding: utf-8 -*-
+"""Base implementation for interaction with blob store interface"""
+
+# ---------Imports---------
+
+import os
+import sys
+import struct
+import random
+import string
+import logging
+
+from ctypes import (
+    c_char_p,
+    c_ubyte,
+    c_uint,
+    cdll,
+    POINTER,
+    create_string_buffer,
+    c_ushort,
+    c_void_p,
+)
+
+from redfish.hpilo.rishpilo import HpIlo, HpIloInitialError, HpIloChifPacketExchangeError
+from redfish.hpilo.rishpilo import BlobReturnCodes as hpiloreturncodes
+
+if os.name == "nt":
+    from ctypes import windll
+else:
+    from _ctypes import dlclose
+
+# ---------End of imports---------
+# ---------Debug logger---------
+
+LOGGER = logging.getLogger(__name__)
+
+
+# ---------End of debug logger---------
+# -----------------------Error Returns----------------------
+
+
+class UnexpectedResponseError(Exception):
+    """Raise when we get data that we don't expect from iLO"""
+
+    pass
+
+
+class HpIloError(Exception):
+    """Raised when iLO returns non-zero error code"""
+
+    pass
+
+
+class Blob2CreateError(Exception):
+    """Raised when create operation fails"""
+
+    pass
+
+
+class Blob2InfoError(Exception):
+    """Raised when create operation fails"""
+
+    pass
+
+
+class Blob2ReadError(Exception):
+    """Raised when read operation fails"""
+
+    pass
+
+
+class Blob2WriteError(Exception):
+    """Raised when write operation fails"""
+
+    pass
+
+
+class Blob2DeleteError(Exception):
+    """Raised when delete operation fails"""
+
+    pass
+
+
+class Blob2OverrideError(Exception):
+    """Raised when delete operation fails because of it been overwritten"""
+
+    pass
+
+
+class BlobRetriesExhaustedError(Exception):
+    """Raised when max retries have been attempted for same operation"""
+
+    pass
+
+
+class Blob2FinalizeError(Exception):
+    """Raised when finalize operation fails"""
+
+    pass
+
+
+class Blob2ListError(Exception):
+    """Raised when list operation fails"""
+
+    pass
+
+
+class Blob2SecurityError(Exception):
+    """Raised when there is an issue with security"""
+
+    pass
+
+
+class BlobNotFoundError(Exception):
+    """Raised when blob not found in key/namespace"""
+
+    pass
+
+
+class ChifDllMissingError(Exception):
+    """Raised when unable to obtain ilorest_chif dll handle"""
+
+    pass
+
+
+class EncryptionEnabledError(Exception):
+    """Raised when high security encryption is enabled"""
+
+    pass
+
+
+# ----------------------------------------------------------
+
+# -------------------Helper functions-------------------------
+
+
+class BlobReturnCodes(object):
+    """Blob store return codes.
+
+    SUCCESS           success
+    BADPARAMETER      bad parameter supplied
+    NOTFOUND          blob name not found
+    NOTMODIFIED       call did not perform the operation
+
+    """
+
+    SUCCESS = 0
+    BADPARAMETER = 2
+    NOTFOUND = 12
+    NOTMODIFIED = 20
+
+
+class BlobStore2(object):
+    """Blob store 2 class"""
+
+    def __init__(self):
+        lib = self.gethprestchifhandle()
+        self.channel = HpIlo(dll=lib)
+        self.max_retries = 3
+
+    def __del__(self):
+        """Blob store 2 close channel function"""
+        if hasattr(self, "channel"):
+            self.channel.close()
+
+    def create(self, key, namespace):
+        """Create the blob
+
+        :param key: The blob key to create.
+        :type key: str.
+        :param namespace: The blob namespace to create the key in.
+        :type namespace: str.
+
+        """
+        lib = self.gethprestchifhandle()
+        lib.create_not_blobentry.argtypes = [c_char_p, c_char_p]
+        lib.create_not_blobentry.restype = POINTER(c_ubyte)
+
+        name = create_string_buffer(key.encode("utf-8"))
+        namespace = create_string_buffer(namespace.encode("utf-8"))
+
+        ptr = lib.create_not_blobentry(name, namespace)
+        data = ptr[: lib.size_of_createRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def get_info(self, key, namespace, retries=0):
+        """Get information for a particular blob
+
+        :param key: The blob key to retrieve.
+        :type key: str.
+        :param namespace: The blob namespace to retrieve the key from.
+        :type namespace: str.
+
+        """
+        lib = self.gethprestchifhandle()
+        lib.get_info.argtypes = [c_char_p, c_char_p]
+        lib.get_info.restype = POINTER(c_ubyte)
+
+        name = create_string_buffer(key.encode("utf-8"))
+        namspace = create_string_buffer(namespace.encode("utf-8"))
+
+        ptr = lib.get_info(name, namspace)
+        data = ptr[: lib.size_of_infoRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if errorcode == BlobReturnCodes.BADPARAMETER:
+            if retries < self.max_retries:
+                self.get_info(key=key, namespace=namespace, retries=retries + 1)
+            else:
+                raise Blob2OverrideError(errorcode)
+        elif errorcode == BlobReturnCodes.NOTFOUND:
+            raise BlobNotFoundError(key, namespace)
+
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        response = resp[lib.size_of_responseHeaderBlob() :]
+
+        self.unloadchifhandle(lib)
+
+        return response
+
+    def read(self, key, namespace, retries=0):
+        """Read a particular blob
+
+        :param key: The blob key to be read.
+        :type key: str.
+        :param namespace: The blob namespace to read the key from.
+        :type namespace: str.
+
+        """
+        lib = self.gethprestchifhandle()
+        maxread = lib.max_read_size()
+        readsize = lib.size_of_readRequest()
+        readhead = lib.size_of_responseHeaderBlob()
+
+        self.unloadchifhandle(lib)
+
+        blob_info = self.get_info(key, namespace)
+        blobsize = struct.unpack("<I", bytes(blob_info[0:4]))[0]
+
+        bytes_read = 0
+        data = bytearray()
+
+        while bytes_read < blobsize:
+            if (maxread - readsize) < (blobsize - bytes_read):
+                count = maxread - readsize
+            else:
+                count = blobsize - bytes_read
+
+            read_block_size = bytes_read
+            recvpkt = self.read_fragment(key, namespace, read_block_size, count)
+
+            newreadsize = readhead + 4
+            bytesread = struct.unpack("<I", bytes(recvpkt[readhead:(newreadsize)]))[0]
+
+            if bytesread == 0:
+                if retries < self.max_retries:
+                    data = self.read(key=key, namespace=namespace, retries=retries + 1)
+                    return data
+                else:
+                    raise BlobRetriesExhaustedError()
+
+            data.extend(recvpkt[newreadsize : newreadsize + bytesread])
+            bytes_read += bytesread
+
+        return data
+
+    def read_fragment(self, key, namespace, offset=0, count=1):
+        """Fragmented version of read function for large blobs
+
+        :param key: The blob key to be read.
+        :type key: str.
+        :param namespace: The blob namespace to read the key from.
+        :type namespace: str.
+        :param offset: The data offset for the current fragmented read.
+        :type key: int.
+        :param count: The data count for the current fragmented read.
+        :type namespace: int.
+
+        """
+        lib = self.gethprestchifhandle()
+        lib.read_fragment.argtypes = [c_uint, c_uint, c_char_p, c_char_p]
+        lib.read_fragment.restype = POINTER(c_ubyte)
+
+        name = create_string_buffer(key.encode("utf-8"))
+        namespace = create_string_buffer(namespace.encode("utf-8"))
+
+        ptr = lib.read_fragment(offset, count, name, namespace)
+        data = ptr[: lib.size_of_readRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        resp = resp + b"\0" * (lib.size_of_readResponse() - len(resp))
+
+        return resp
+
+    def write(self, key, namespace, data=None):
+        """Write a particular blob
+
+        :param key: The blob key to be written.
+        :type key: str.
+        :param namespace: The blob namespace to write the key in.
+        :type namespace: str.
+        :param data: The blob data to be written.
+        :type data: str.
+
+        """
+        lib = self.gethprestchifhandle()
+        maxwrite = lib.max_write_size()
+        writesize = lib.size_of_writeRequest()
+
+        self.unloadchifhandle(lib)
+
+        if data:
+            data_length = len(data)
+            bytes_written = 0
+
+            while bytes_written < data_length:
+                if (maxwrite - writesize) < (data_length - bytes_written):
+                    count = maxwrite - writesize
+                else:
+                    count = data_length - bytes_written
+
+                write_blob_size = bytes_written
+
+                self.write_fragment(
+                    key,
+                    namespace=namespace,
+                    data=data[write_blob_size : write_blob_size + count],
+                    offset=write_blob_size,
+                    count=count,
+                )
+
+                bytes_written += count
+
+        return self.finalize(key, namespace=namespace)
+
+    def write_fragment(self, key, namespace, data=None, offset=0, count=1):
+        """Fragmented version of write function for large blobs
+
+        :param key: The blob key to be written.
+        :type key: str.
+        :param namespace: The blob namespace to write the key in.
+        :type namespace: str.
+        :param data: The blob data to be written to blob.
+        :type data: str.
+        :param offset: The data offset for the current fragmented write.
+        :type key: int.
+        :param count: The data count for the current fragmented write.
+        :type count: int.
+
+        """
+        lib = self.gethprestchifhandle()
+        lib.write_fragment.argtypes = [c_uint, c_uint, c_char_p, c_char_p]
+        lib.write_fragment.restype = POINTER(c_ubyte)
+
+        name = create_string_buffer(key.encode("utf-8"))
+        namespace = create_string_buffer(namespace.encode("utf-8"))
+
+        ptr = lib.write_fragment(offset, count, name, namespace)
+        sendpacket = ptr[: lib.size_of_writeRequest()]
+
+        if isinstance(data, str):
+            data = data.encode("utf-8")
+
+        dataarr = bytearray(sendpacket)
+        dataarr.extend(memoryview(data))
+
+        resp = self._send_receive_raw(dataarr)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def delete(self, key, namespace, retries=0):
+        """Delete the blob
+
+        :param key: The blob key to be deleted.
+        :type key: str.
+        :param namespace: The blob namespace to delete the key from.
+        :type namespace: str.
+
+        """
+        lib = self.gethprestchifhandle()
+        lib.delete_blob.argtypes = [c_char_p, c_char_p]
+        lib.delete_blob.restype = POINTER(c_ubyte)
+
+        name = create_string_buffer(key.encode("utf-8"))
+        namspace = create_string_buffer(namespace.encode("utf-8"))
+
+        ptr = lib.delete_blob(name, namspace)
+        data = ptr[: lib.size_of_deleteRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if errorcode == BlobReturnCodes.BADPARAMETER:
+            if retries < self.max_retries:
+                self.delete(key=key, namespace=namespace, retries=retries + 1)
+            else:
+                raise Blob2OverrideError(errorcode)
+        elif not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return errorcode
+
+    def list(self, namespace):
+        """List operation to retrieve all blobs in a given namespace
+
+        :param namespace: The blob namespace to retrieve the keys from.
+        :type namespace: str.
+
+        """
+        lib = self.gethprestchifhandle()
+        lib.list_blob.argtypes = [c_char_p]
+        lib.list_blob.restype = POINTER(c_ubyte)
+
+        namespace = create_string_buffer(namespace.encode("utf-8"))
+
+        ptr = lib.list_blob(namespace)
+        data = ptr[: lib.size_of_listRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        resp = resp + b"\0" * (lib.size_of_listResponse() - len(resp))
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def finalize(self, key, namespace):
+        """Finalize the blob
+
+        :param key: The blob key to be finalized.
+        :type key: str.
+        :param namespace: The blob namespace to finalize the key in.
+        :type namespace: str.
+
+        """
+        lib = self.gethprestchifhandle()
+        lib.finalize_blob.argtypes = [c_char_p, c_char_p]
+        lib.finalize_blob.restype = POINTER(c_ubyte)
+
+        name = create_string_buffer(key.encode("utf-8"))
+        namespace = create_string_buffer(namespace.encode("utf-8"))
+
+        ptr = lib.finalize_blob(name, namespace)
+        data = ptr[: lib.size_of_finalizeRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return errorcode
+
+    def rest_immediate(
+        self,
+        req_data,
+        rqt_key="RisRequest",
+        rsp_key="RisResponse",
+        rsp_namespace="volatile",
+    ):
+        """Read/write blob via immediate operation
+
+        :param req_data: The blob data to be read/written.
+        :type req_data: str.
+        :param rqt_key: The blob key to be used for the request data.
+        :type rqt_key: str.
+        :param rsp_key: The blob key to be used for the response data.
+        :type rsp_key: str.
+        :param rsp_namespace: The blob namespace to retrieve the response from.
+        :type rsp_namespace: str.
+
+        """
+        rqt_key = "".join(
+            random.choice(string.ascii_letters + string.digits) for _ in range(10)
+        )
+        rsp_key = "".join(
+            random.choice(string.ascii_letters + string.digits) for _ in range(10)
+        )
+
+        lib = self.gethprestchifhandle()
+
+        if len(req_data) < (lib.size_of_restImmediateRequest() + lib.max_write_size()):
+            lib.rest_immediate.argtypes = [c_uint, c_char_p, c_char_p]
+            lib.rest_immediate.restype = POINTER(c_ubyte)
+
+            name = create_string_buffer(rsp_key.encode("utf-8"))
+            namespace = create_string_buffer(rsp_namespace.encode("utf-8"))
+
+            ptr = lib.rest_immediate(len(req_data), name, namespace)
+            sendpacket = ptr[: lib.size_of_restImmediateRequest()]
+            mode = False
+        else:
+            self.create(rqt_key, rsp_namespace)
+            self.write(rqt_key, rsp_namespace, req_data)
+
+            lib.rest_immediate_blobdesc.argtypes = [c_char_p, c_char_p, c_char_p]
+            lib.rest_immediate_blobdesc.restype = POINTER(c_ubyte)
+
+            name = create_string_buffer(rqt_key.encode("utf-8"))
+            namespace = create_string_buffer(rsp_namespace.encode("utf-8"))
+            rspname = create_string_buffer(rsp_key.encode("utf-8"))
+
+            ptr = lib.rest_immediate_blobdesc(name, rspname, namespace)
+            sendpacket = ptr[: lib.size_of_restBlobRequest()]
+            mode = True
+
+        data = bytearray(sendpacket)
+
+        if not mode:
+            data.extend(req_data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if errorcode == BlobReturnCodes.NOTFOUND:
+            raise BlobNotFoundError(rsp_key, rsp_namespace)
+
+        recvmode = struct.unpack("<I", bytes(resp[12:16]))[0]
+
+        fixdlen = lib.size_of_restResponseFixed()
+        response = resp[fixdlen : struct.unpack("<I", bytes(resp[16:20]))[0] + fixdlen]
+
+        tmpresponse = None
+        if errorcode == BlobReturnCodes.SUCCESS and not mode:
+            if recvmode == 0:
+                tmpresponse = "".join(map(chr, response))
+        elif errorcode == BlobReturnCodes.NOTMODIFIED and not mode:
+            if recvmode == 0:
+                tmpresponse = "".join(map(chr, response))
+        elif errorcode == BlobReturnCodes.SUCCESS:
+            if recvmode == 0:
+                tmpresponse = "".join(map(chr, response))
+        elif recvmode == 0:
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        if not tmpresponse and recvmode == 1:
+            tmpresponse = self.read(rsp_key, rsp_namespace)
+
+            try:
+                self.delete(rsp_key, rsp_namespace)
+            except Exception as excp:
+                raise excp
+        else:
+            try:
+                self.delete(rsp_key, rsp_namespace)
+            except Blob2OverrideError as excp:
+                pass
+            except HpIloChifPacketExchangeError as excp:
+                pass
+            except Exception as excp:
+                raise excp
+
+        return tmpresponse
+
+    def get_security_state(self):
+        """Get information for the current security state"""
+        lib = self.gethprestchifhandle()
+        lib.get_security_state.argtypes = []
+        lib.get_security_state.restype = POINTER(c_ubyte)
+
+        ptr = lib.get_security_state()
+        data = ptr[: lib.size_of_securityStateRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = struct.unpack("<I", bytes(resp[8:12]))[0]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        try:
+            securitystate = struct.unpack("<c", bytes(resp[72]))[0]
+        except:
+            securitystate = int(resp[72])
+
+        self.unloadchifhandle(lib)
+
+        return securitystate
+
+    def mount_blackbox(self):
+        """Operation to mount the blackbox partition"""
+        lib = self.gethprestchifhandle()
+        lib.blackbox_media_mount.argtypes = []
+        lib.blackbox_media_mount.restype = POINTER(c_ubyte)
+
+        ptr = lib.blackbox_media_mount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def absaroka_media_mount(self):
+        """Operation to mount the absaroka repo partition"""
+        lib = self.gethprestchifhandle()
+        lib.absaroka_media_mount.argtypes = []
+        lib.absaroka_media_mount.restype = POINTER(c_ubyte)
+
+        ptr = lib.absaroka_media_mount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def gaius_media_mount(self):
+        """Operation to mount the gaius media partition"""
+        lib = self.gethprestchifhandle()
+        lib.gaius_media_mount.argtypes = []
+        lib.gaius_media_mount.restype = POINTER(c_ubyte)
+
+        ptr = lib.gaius_media_mount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def vid_media_mount(self):
+        """Operation to mount the gaius media partition"""
+        lib = self.gethprestchifhandle()
+        lib.vid_media_mount.argtypes = []
+        lib.vid_media_mount.restype = POINTER(c_ubyte)
+
+        ptr = lib.vid_media_mount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def mountflat(self):
+        """Operation to mount the gaius media partition"""
+        lib = self.gethprestchifhandle()
+        lib.flat_media_mount.argtypes = []
+        lib.flat_media_mount.restype = POINTER(c_ubyte)
+
+        ptr = lib.flat_media_mount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def media_unmount(self):
+        """Operation to unmount the media partition"""
+        lib = self.gethprestchifhandle()
+        lib.media_unmount.argtypes = []
+        lib.media_unmount.restype = POINTER(c_ubyte)
+
+        ptr = lib.media_unmount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def bb_media_unmount(self):
+        """Operation to unmount the media partition"""
+        lib = self.gethprestchifhandle()
+        lib.bb_media_unmount.argtypes = []
+        lib.bb_media_unmount.restype = POINTER(c_ubyte)
+
+        ptr = lib.bb_media_unmount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def vid_media_unmount(self):
+        """Operation to unmount the media partition"""
+        lib = self.gethprestchifhandle()
+        lib.vid_media_unmount.argtypes = []
+        lib.vid_media_unmount.restype = POINTER(c_ubyte)
+
+        ptr = lib.vid_media_unmount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def gaius_media_unmount(self):
+        """Operation to unmount the media partition"""
+        lib = self.gethprestchifhandle()
+        lib.gaius_media_unmount.argtypes = []
+        lib.gaius_media_unmount.restype = POINTER(c_ubyte)
+
+        ptr = lib.gaius_media_unmount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def absr_media_unmount(self):
+        """Operation to unmount the media partition"""
+        lib = self.gethprestchifhandle()
+        lib.absaroka_media_unmount.argtypes = []
+        lib.absaroka_media_unmount.restype = POINTER(c_ubyte)
+
+        ptr = lib.absaroka_media_unmount()
+        data = ptr[: lib.size_of_embeddedMediaRequest()]
+        data = bytearray(data)
+
+        resp = self._send_receive_raw(data)
+
+        errorcode = resp[12]
+        if not (
+            errorcode == BlobReturnCodes.SUCCESS
+            or errorcode == BlobReturnCodes.NOTMODIFIED
+        ):
+            raise HpIloError(errorcode)
+
+        self.unloadchifhandle(lib)
+
+        return resp
+
+    def _send_receive_raw(self, indata):
+        """Send and receive raw function for blob operations
+
+        :param indata: The data to be sent to blob operation.
+        :type indata: str.
+
+        """
+        excp = None
+        for _ in range(0, 3):  # channel loop for iLO
+            try:
+                resp = self.channel.send_receive_raw(indata, 10)
+                return resp
+            except Exception as exp:
+                self.channel.close()
+                lib = self.gethprestchifhandle()
+                self.channel = HpIlo(dll=lib)
+                excp = exp
+        if excp:
+            raise excp
+
+    def cert_login(self, cert_file, priv_key, key_pass):
+        lib = self.gethprestchifhandle()
+        lib.login_cert.argtypes = [c_void_p, c_char_p, c_char_p, c_char_p]
+        lib.login_cert.restype = c_char_p
+
+        token = lib.login_cert(self.channel.fhandle, cert_file, priv_key, key_pass)
+        return token
+
+    @staticmethod
+    def gethprestchifhandle():
+        """Multi platform handle for chif hprest library"""
+        excp = None
+        libhandle = None
+        if os.name != "nt":
+            libpath = '/opt/ilorest/lib64/libilorestchif.so'
+            if os.path.isfile(libpath):
+                libhandle = cdll.LoadLibrary(libpath)
+        if not libhandle:
+            libnames = (
+                ["ilorest_chif.dll"]
+                if os.name == "nt"
+                else [
+                    "ilorest_chif_dev.so",
+                    "ilorest_chif.so",
+                ]
+            )
+            for libname in libnames:
+                try:
+                    libpath = BlobStore2.checkincurrdirectory(libname)
+                    #LOGGER.debug("Loading Library %s for libhpsrv", libpath)
+                    libhandle = cdll.LoadLibrary(libpath)
+                    if libhandle:
+                        #LOGGER.debug("Got Libhandle %s for libhpsrv", libhandle)
+                        break
+                except Exception as exp:
+                    excp = exp
+
+        if libhandle:
+            BlobStore2.setglobalhprestchifrandnumber(libhandle)
+            return libhandle
+        raise ChifDllMissingError(excp)
+
+    @staticmethod
+    def setglobalhprestchifrandnumber(libbhndl):
+        """Set the random number for the chif handle
+        :param libbhndl: The library handle provided by loading the chif library.
+        :type libbhndl: library handle.
+        """
+        rndval = random.randint(1, 65535)
+        libbhndl.updaterandval.argtypes = [c_ushort]
+        libbhndl.updaterandval(rndval)
+
+    @staticmethod
+    def initializecreds(username=None, password=None):
+        """Get chif ready to use high security
+        :param username: The username to login.
+        :type username: str.
+        :param password: The password to login.
+        :type password: str.
+        """
+
+        dll = BlobStore2.gethprestchifhandle()
+        if LOGGER.isEnabledFor(logging.DEBUG):
+            dll.enabledebugoutput()
+        #LOGGER.debug("Calling ChifInitialize...")
+        dll.ChifInitialize(None)
+        if username:
+            if not password:
+                return False
+            if dll.ChifIsSecurityRequired() > 0:
+                dll.initiate_credentials.argtypes = [c_char_p, c_char_p]
+                dll.initiate_credentials.restype = POINTER(c_ubyte)
+
+                usernew = create_string_buffer(username.encode("utf-8"))
+                passnew = create_string_buffer(password.encode("utf-8"))
+
+                #LOGGER.debug("Calling initiate_credentials...")
+                dll.initiate_credentials(usernew, passnew)
+                #LOGGER.debug("Calling ChifVerifyCredentials...")
+                credreturn = dll.ChifVerifyCredentials()
+                if not credreturn == BlobReturnCodes.SUCCESS:
+                    if credreturn == hpiloreturncodes.CHIFERR_AccessDenied:
+                        raise Blob2SecurityError()
+                    else:
+                        raise HpIloInitialError(
+                            "Error %s occurred while trying "
+                            "to open a channel to iLO" % credreturn
+                        )
+            else:
+                dll.ChifDisableSecurity()
+        else:
+            # if high security return False
+            #LOGGER.debug("Calling ChifIsSecurityRequired...")
+            if dll.ChifIsSecurityRequired() > 0:
+                return False
+            else:
+                #LOGGER.debug("Calling ChifDisableSecurity...")
+                dll.ChifDisableSecurity()
+
+        BlobStore2.unloadchifhandle(dll)
+
+        return True
+
+    @staticmethod
+    def checkincurrdirectory(libname):
+        """Check if the library is present in current directory.
+        :param libname: The name of the library to search for.
+        :type libname: str."""
+        libpath = libname
+
+        if os.path.isfile(os.path.join(os.path.split(sys.executable)[0], libpath)):
+            libpath = os.path.join(os.path.split(sys.executable)[0], libpath)
+        elif os.path.isfile(os.path.join(os.getcwd(), libpath)):
+            libpath = os.path.join(os.getcwd(), libpath)
+        elif os.environ.get("LD_LIBRARY_PATH"):
+            paths = os.getenv("LD_LIBRARY_PATH", libpath).split(";")
+            libpath = [
+                os.path.join(pat, libname)
+                for pat in paths
+                if os.path.isfile(os.path.join(pat, libname))
+            ]
+            libpath = libpath[0] if libpath else libname
+
+        return libpath
+
+    @staticmethod
+    def unloadchifhandle(lib):
+        """Release a handle on the chif iLOrest library
+
+        :param lib: The library handle provided by loading the chif library.
+        :type lib: library handle.
+
+        """
+        try:
+            libhandle = lib._handle
+            if os.name == "nt":
+                windll.kernel32.FreeLibrary(None, handle=libhandle)
+            else:
+                dlclose(libhandle)
+        except Exception:
+            pass
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/hpilo/rishpilo.py` & `python-ilorest-library-4.2.0.0/src/redfish/hpilo/rishpilo.py`

 * *Files 8% similar despite different names*

```diff
@@ -108,46 +108,44 @@
 class HpIlo(object):
     """Base class of interaction with iLO"""
 
     def __init__(self, dll=None):
         fhandle = c_void_p()
         self.dll = dll
         if LOGGER.isEnabledFor(logging.DEBUG):
-            LOGGER.info("Enabling DEBUG from libhpsrv")
             self.dll.enabledebugoutput()
-        LOGGER.info("Calling ChifInitialize from libhpsrv")
+        #LOGGER.debug("Calling ChifInitialize...")
         self.dll.ChifInitialize(None)
 
         self.dll.ChifCreate.argtypes = [c_void_p]
         self.dll.ChifCreate.restype = c_uint32
 
         try:
-            LOGGER.info("Calling ChifCreate from libhpsrv - handle = %s", fhandle)
+            LOGGER.debug("Calling ChifCreate...")
             status = self.dll.ChifCreate(byref(fhandle))
             if status != BlobReturnCodes.SUCCESS:
                 raise HpIloInitialError(
                     "Error %s occurred while trying " "to create a channel." % status
                 )
 
             self.fhandle = fhandle
 
             if not "skip_ping" in os.environ:
-                LOGGER.info("Calling ChifPing from libhpsrv - handle = %s", self.fhandle)
                 status = self.dll.ChifPing(self.fhandle)
                 if status != BlobReturnCodes.SUCCESS:
                     errmsg = (
                         "Error {0} occurred while trying to open a "
                         "channel to iLO".format(status)
                     )
                     if status == BlobReturnCodes.CHIFERR_NoDriver:
                         errmsg = "chif"
                     elif status == BlobReturnCodes.CHIFERR_AccessDenied:
                         errmsg = "You must be root/Administrator to use this program."
                     raise HpIloInitialError(errmsg)
-                LOGGER.info("Calling ChifSetRecvTimeout from libhpsrv - handle = %s", self.fhandle)
+                #LOGGER.debug("Calling ChifSetRecvTimeout...")
                 self.dll.ChifSetRecvTimeout(self.fhandle, 60000)
         except:
             raise
 
     def chif_packet_exchange(self, data):
         """Function for handling chif packet exchange
 
@@ -155,15 +153,15 @@
         :type data: str
 
         """
         datarecv = self.dll.get_max_buffer_size()
         buff = create_string_buffer(bytes(data))
 
         recbuff = create_string_buffer(datarecv)
-        LOGGER.info("Calling ChifPacketExchange from libhpsrv - handle = %s", self.fhandle)
+        #LOGGER.debug("Calling ChifPacketExchange...")
         error = self.dll.ChifPacketExchange(
             self.fhandle, byref(buff), byref(recbuff), datarecv
         )
         if error != BlobReturnCodes.SUCCESS:
             raise HpIloChifPacketExchangeError(
                 "Error %s occurred while " "exchange chif packet" % error
             )
@@ -213,15 +211,15 @@
 
         raise HpIloSendReceiveError("iLO not responding")
 
     def close(self):
         """Chif close function"""
         try:
             if self.fhandle is not None:
-                LOGGER.info("Calling ChifClose from libhpsrv - handle = %s", self.fhandle)
+                LOGGER.debug("Calling ChifClose...")
                 self.dll.ChifClose(self.fhandle)
                 self.fhandle = None
         except Exception:
             pass
 
     def __del__(self):
         """Chif delete function"""
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/rest/containers.py` & `python-ilorest-library-4.2.0.0/src/redfish/rest/containers.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,366 +1,366 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-
-# -*- coding: utf-8 -*-
-"""Containers used for REST requests and responses."""
-import sys
-import json
-import six
-
-try:
-    from collections import OrderedDict
-except ImportError:
-    from collections.abc import OrderedDict
-
-from six import text_type, string_types, StringIO, BytesIO
-from six.moves import http_client
-
-
-class JSONEncoder(json.JSONEncoder):
-    """JSON Encoder class"""
-
-    def default(self, obj):
-        """Set defaults in JSON encoder class
-
-        :param obj: object to be encoded into JSON.
-        :type obj: RestResponse
-        :returns: A JSON :class:`OrderedDict`
-        """
-        if isinstance(obj, RestResponse):
-            jsondict = OrderedDict()
-            jsondict["Status"] = obj.status
-            jsondict["Headers"] = obj.getheaders()
-
-            if obj.read:
-                jsondict["Content"] = obj.dict
-
-            return jsondict
-        if isinstance(obj, bytes):
-            obj = obj.decode("utf-8")
-        return json.JSONEncoder.default(self, obj)
-
-
-class JSONDecoder(json.JSONDecoder):
-    """Custom JSONDecoder that understands our types"""
-
-    def decode(self, json_string):
-        """Decode JSON string
-
-        :param json_string: The JSON string to be decoded into usable data.
-        :type json_string: str
-        :returns: returns a parsed dict
-        """
-        parsed_dict = super(JSONDecoder, self).decode(json_string)
-        return parsed_dict
-
-
-class _FakeSocket(BytesIO):
-    """slick way to parse a http response.
-    http://pythonwise.blogspot.com/2010/02/parse-http-response.html"""
-
-    def makefile(self, *args, **kwargs):
-        """Return self object"""
-        return self
-
-
-class RisObject(dict):
-    """Converts a JSON/Rest dict into a object so you can use .property notation
-
-    :param d: dictionary to be converted
-    :type d: dict
-    """
-
-    __getattr__ = dict.__getitem__
-
-    def __init__(self, d):
-        """Initialize RisObject"""
-        super(RisObject, self).__init__()
-        self.update(**dict((k, self.parse(value)) for k, value in list(d.items())))
-
-    @classmethod
-    def parse(cls, value):
-        """Parse for RIS value
-
-        :param cls: class referenced from class method
-        :type cls: RisObject
-        :param value: value to be parsed
-        :type value: data type
-        :returns: returns parsed value
-        """
-        if isinstance(value, dict):
-            return cls(value)
-        elif isinstance(value, list):
-            return [cls.parse(i) for i in value]
-
-        return value
-
-
-class RestRequest(object):
-    """Holder for Request information
-
-    :param path: The URI path.
-    :type path: str
-    :param method: method to be implemented
-    :type method: str
-    :param data: body payload for the rest call
-    :type data: dict
-    """
-
-    def __init__(self, path, method="GET", data="", url=None):
-        self._path = path
-        self._body = data
-        self._method = method
-        self.url = url
-
-    @property
-    def path(self):
-        """The path the request is made against."""
-        return self._path
-
-    @property
-    def method(self):
-        """The method to implement."""
-        return self._method
-
-    @property
-    def body(self):
-        """The body to pass along with the request, if any."""
-        return self._body
-
-    def __str__(self):
-        """Format string"""
-        body = "" if not self._body else self._body
-        try:
-            return "{} {}\n\n{}".format(self.method, self.path, body)
-        except:
-            return "{} {}\n\n{}".format(self.method, self.path, "")
-
-
-class RestResponse(object):
-    """Returned by Rest requests
-
-    :param rest_request: Holder for request information
-    :type rest_request: :class:`RestRequest` object
-    :param http_response: Response from HTTP
-    :type http_response: :class:`HTTPResponse` object
-    """
-
-    def __init__(self, rest_request, http_response):
-        self._read = None
-        self._status = None
-        self._headers = None
-        self._session_key = None
-        self._session_location = None
-        self._rest_request = rest_request
-        self._http_response = http_response
-        self._read = self._http_response.data if http_response is not None else None
-        self._ori = self._read
-
-    @property
-    def read(self):
-        """The response body, attempted to be translated into json, else is a string."""
-        if self._read and not isinstance(self._read, text_type):
-            self._read = self._read.decode("utf-8", "ignore")
-        return self._read
-
-    @read.setter
-    def read(self, read):
-        """Property for setting _read
-
-        :param read: The data to set to read.
-        :type read: str
-        """
-        if read is not None:
-            if isinstance(read, dict):
-                read = json.dumps(read, indent=4)
-            self._read = read
-
-    def getheaders(self):
-        """Get all headers included in the response."""
-        return (
-            dict(self._http_response.headers)
-            if self._http_response is not None
-            else self._headers
-        )
-
-    def getheader(self, name):
-        """Case-insensitive search for an individual header
-
-        :param name: The header name to retrieve.
-        :type name: str
-        :returns: returns a header from HTTP response or None if not found.
-        """
-
-        def search_dict(search_key, dct):
-            for key, val in dct.items():
-                if key.lower() == search_key.lower():
-                    return val
-            return None
-
-        if self._http_response:
-            return search_dict(name, self._http_response.headers)
-        return search_dict(name, self._headers)
-
-    def loaddict(self, newdict):
-        """Property for setting JSON data. Used during initialization.
-
-        :param newdict: The string data to set as JSON data.
-        :type newdict: str
-        """
-        self._read = json.dumps(newdict, indent=4)
-
-    @property
-    def dict(self):
-        """The response body data as an dict"""
-        try:
-            return json.loads(self.read)
-        except ValueError as exp:
-            if self.path != "/smbios":
-                sys.stderr.write("An invalid response body was returned: %s" % exp)
-            return None
-
-    @property
-    def obj(self):
-        """The response body data as an object"""
-        return RisObject.parse(self.dict)
-
-    @property
-    def ori(self):
-        """The original response body data"""
-        return self._ori
-
-    @property
-    def status(self):
-        """The status code of the request."""
-        if self._status:
-            return self._status
-
-        return (
-            self._http_response.status
-            if self._http_response is not None
-            else self._status
-        )
-
-    @property
-    def session_key(self):
-        """The saved session key for the connection."""
-        if self._session_key:
-            return self._session_key
-
-        self._session_key = self.getheader("x-auth-token")
-        return self._session_key
-
-    @property
-    def session_location(self):
-        """The saved session location, used for logging out."""
-        if self._session_location:
-            return self._session_location
-
-        self._session_location = self.getheader("location")
-        return self._session_location
-
-    @property
-    def request(self):
-        """The saved http request the response was generated by."""
-        return self._rest_request
-
-    @property
-    def path(self):
-        """The path the request was made against."""
-        return self.request.path
-
-    def __str__(self):
-        """Class string formatter"""
-        headerstr = ""
-        for kiy, val in self.getheaders().items():
-            headerstr += "%s %s\n" % (kiy, val)
-
-        return "%(status)s\n%(headerstr)s\n\n%(body)s" % {
-            "status": self.status,
-            "headerstr": headerstr,
-            "body": self.read,
-        }
-
-
-class RisRestResponse(RestResponse):
-    """Returned by Rest requests from CHIF
-
-    :param rest_request: Holder for request information
-    :type rest_request: :class:`RestRequest` object
-    :param resp_text: text from response to be buffered and read
-    :type resp_text: str
-    """
-
-    def __init__(self, rest_request, resp_txt):
-        """Initialization of RisRestResponse"""
-        if not isinstance(resp_txt, string_types):
-            resp_txt = "".join(map(chr, resp_txt))
-        self._respfh = StringIO(resp_txt)
-        self._socket = _FakeSocket(bytearray(list(map(ord, self._respfh.read()))))
-
-        response = http_client.HTTPResponse(self._socket)
-        response.begin()
-        response.data = response.read()
-        response.headers = {ki[0]: ki[1] for ki in response.getheaders()}
-        super(RisRestResponse, self).__init__(rest_request, response)
-
-
-class StaticRestResponse(RestResponse):
-    """A RestResponse object used when data is being cached."""
-
-    def __init__(self, **kwargs):
-        restreq = None
-
-        if "restreq" in kwargs:
-            restreq = kwargs["restreq"]
-
-        super(StaticRestResponse, self).__init__(restreq, None)
-
-        if "Status" in kwargs:
-            self._status = kwargs["Status"]
-
-        if "Headers" in kwargs:
-            self._headers = kwargs["Headers"]
-
-        if "session_key" in kwargs:
-            self._session_key = kwargs["session_key"]
-
-        if "session_location" in kwargs:
-            self._session_location = kwargs["session_location"]
-
-        if "Content" in kwargs:
-            content = kwargs["Content"]
-
-            if isinstance(content, string_types):
-                self._read = content
-            else:
-                self._read = json.dumps(content)
-        else:
-            self._read = ""
-
-    def getheaders(self):
-        """Function for accessing the headers"""
-        returnlist = {}
-
-        if isinstance(self._headers, dict):
-            returnlist = self._headers
-        elif isinstance(self._headers, (list, tuple)):
-            returnlist = {ki[0]: ki[1] for ki in self._headers}
-        else:
-            for item in self._headers:
-                returnlist.update(item.items()[0])
-
-        return returnlist
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+
+# -*- coding: utf-8 -*-
+"""Containers used for REST requests and responses."""
+import sys
+import json
+import six
+
+try:
+    from collections import OrderedDict
+except ImportError:
+    from collections.abc import OrderedDict
+
+from six import text_type, string_types, StringIO, BytesIO
+from six.moves import http_client
+
+
+class JSONEncoder(json.JSONEncoder):
+    """JSON Encoder class"""
+
+    def default(self, obj):
+        """Set defaults in JSON encoder class
+
+        :param obj: object to be encoded into JSON.
+        :type obj: RestResponse
+        :returns: A JSON :class:`OrderedDict`
+        """
+        if isinstance(obj, RestResponse):
+            jsondict = OrderedDict()
+            jsondict["Status"] = obj.status
+            jsondict["Headers"] = obj.getheaders()
+
+            if obj.read:
+                jsondict["Content"] = obj.dict
+
+            return jsondict
+        if isinstance(obj, bytes):
+            obj = obj.decode("utf-8")
+        return json.JSONEncoder.default(self, obj)
+
+
+class JSONDecoder(json.JSONDecoder):
+    """Custom JSONDecoder that understands our types"""
+
+    def decode(self, json_string):
+        """Decode JSON string
+
+        :param json_string: The JSON string to be decoded into usable data.
+        :type json_string: str
+        :returns: returns a parsed dict
+        """
+        parsed_dict = super(JSONDecoder, self).decode(json_string)
+        return parsed_dict
+
+
+class _FakeSocket(BytesIO):
+    """slick way to parse a http response.
+    http://pythonwise.blogspot.com/2010/02/parse-http-response.html"""
+
+    def makefile(self, *args, **kwargs):
+        """Return self object"""
+        return self
+
+
+class RisObject(dict):
+    """Converts a JSON/Rest dict into a object so you can use .property notation
+
+    :param d: dictionary to be converted
+    :type d: dict
+    """
+
+    __getattr__ = dict.__getitem__
+
+    def __init__(self, d):
+        """Initialize RisObject"""
+        super(RisObject, self).__init__()
+        self.update(**dict((k, self.parse(value)) for k, value in list(d.items())))
+
+    @classmethod
+    def parse(cls, value):
+        """Parse for RIS value
+
+        :param cls: class referenced from class method
+        :type cls: RisObject
+        :param value: value to be parsed
+        :type value: data type
+        :returns: returns parsed value
+        """
+        if isinstance(value, dict):
+            return cls(value)
+        elif isinstance(value, list):
+            return [cls.parse(i) for i in value]
+
+        return value
+
+
+class RestRequest(object):
+    """Holder for Request information
+
+    :param path: The URI path.
+    :type path: str
+    :param method: method to be implemented
+    :type method: str
+    :param data: body payload for the rest call
+    :type data: dict
+    """
+
+    def __init__(self, path, method="GET", data="", url=None):
+        self._path = path
+        self._body = data
+        self._method = method
+        self.url = url
+
+    @property
+    def path(self):
+        """The path the request is made against."""
+        return self._path
+
+    @property
+    def method(self):
+        """The method to implement."""
+        return self._method
+
+    @property
+    def body(self):
+        """The body to pass along with the request, if any."""
+        return self._body
+
+    def __str__(self):
+        """Format string"""
+        body = "" if not self._body else self._body
+        try:
+            return "{} {}\n\n{}".format(self.method, self.path, body)
+        except:
+            return "{} {}\n\n{}".format(self.method, self.path, "")
+
+
+class RestResponse(object):
+    """Returned by Rest requests
+
+    :param rest_request: Holder for request information
+    :type rest_request: :class:`RestRequest` object
+    :param http_response: Response from HTTP
+    :type http_response: :class:`HTTPResponse` object
+    """
+
+    def __init__(self, rest_request, http_response):
+        self._read = None
+        self._status = None
+        self._headers = None
+        self._session_key = None
+        self._session_location = None
+        self._rest_request = rest_request
+        self._http_response = http_response
+        self._read = self._http_response.data if http_response is not None else None
+        self._ori = self._read
+
+    @property
+    def read(self):
+        """The response body, attempted to be translated into json, else is a string."""
+        if self._read and not isinstance(self._read, text_type):
+            self._read = self._read.decode("utf-8", "ignore")
+        return self._read
+
+    @read.setter
+    def read(self, read):
+        """Property for setting _read
+
+        :param read: The data to set to read.
+        :type read: str
+        """
+        if read is not None:
+            if isinstance(read, dict):
+                read = json.dumps(read, indent=4)
+            self._read = read
+
+    def getheaders(self):
+        """Get all headers included in the response."""
+        return (
+            dict(self._http_response.headers)
+            if self._http_response is not None
+            else self._headers
+        )
+
+    def getheader(self, name):
+        """Case-insensitive search for an individual header
+
+        :param name: The header name to retrieve.
+        :type name: str
+        :returns: returns a header from HTTP response or None if not found.
+        """
+
+        def search_dict(search_key, dct):
+            for key, val in dct.items():
+                if key.lower() == search_key.lower():
+                    return val
+            return None
+
+        if self._http_response:
+            return search_dict(name, self._http_response.headers)
+        return search_dict(name, self._headers)
+
+    def loaddict(self, newdict):
+        """Property for setting JSON data. Used during initialization.
+
+        :param newdict: The string data to set as JSON data.
+        :type newdict: str
+        """
+        self._read = json.dumps(newdict, indent=4)
+
+    @property
+    def dict(self):
+        """The response body data as an dict"""
+        try:
+            return json.loads(self.read)
+        except ValueError as exp:
+            if self.path != "/smbios":
+                sys.stderr.write("An invalid response body was returned: %s" % exp)
+            return None
+
+    @property
+    def obj(self):
+        """The response body data as an object"""
+        return RisObject.parse(self.dict)
+
+    @property
+    def ori(self):
+        """The original response body data"""
+        return self._ori
+
+    @property
+    def status(self):
+        """The status code of the request."""
+        if self._status:
+            return self._status
+
+        return (
+            self._http_response.status
+            if self._http_response is not None
+            else self._status
+        )
+
+    @property
+    def session_key(self):
+        """The saved session key for the connection."""
+        if self._session_key:
+            return self._session_key
+
+        self._session_key = self.getheader("x-auth-token")
+        return self._session_key
+
+    @property
+    def session_location(self):
+        """The saved session location, used for logging out."""
+        if self._session_location:
+            return self._session_location
+
+        self._session_location = self.getheader("location")
+        return self._session_location
+
+    @property
+    def request(self):
+        """The saved http request the response was generated by."""
+        return self._rest_request
+
+    @property
+    def path(self):
+        """The path the request was made against."""
+        return self.request.path
+
+    def __str__(self):
+        """Class string formatter"""
+        headerstr = ""
+        for kiy, val in self.getheaders().items():
+            headerstr += "%s %s\n" % (kiy, val)
+
+        return "%(status)s\n%(headerstr)s\n\n%(body)s" % {
+            "status": self.status,
+            "headerstr": headerstr,
+            "body": self.read,
+        }
+
+
+class RisRestResponse(RestResponse):
+    """Returned by Rest requests from CHIF
+
+    :param rest_request: Holder for request information
+    :type rest_request: :class:`RestRequest` object
+    :param resp_text: text from response to be buffered and read
+    :type resp_text: str
+    """
+
+    def __init__(self, rest_request, resp_txt):
+        """Initialization of RisRestResponse"""
+        if not isinstance(resp_txt, string_types):
+            resp_txt = "".join(map(chr, resp_txt))
+        self._respfh = StringIO(resp_txt)
+        self._socket = _FakeSocket(bytearray(list(map(ord, self._respfh.read()))))
+
+        response = http_client.HTTPResponse(self._socket)
+        response.begin()
+        response.data = response.read()
+        response.headers = {ki[0]: ki[1] for ki in response.getheaders()}
+        super(RisRestResponse, self).__init__(rest_request, response)
+
+
+class StaticRestResponse(RestResponse):
+    """A RestResponse object used when data is being cached."""
+
+    def __init__(self, **kwargs):
+        restreq = None
+
+        if "restreq" in kwargs:
+            restreq = kwargs["restreq"]
+
+        super(StaticRestResponse, self).__init__(restreq, None)
+
+        if "Status" in kwargs:
+            self._status = kwargs["Status"]
+
+        if "Headers" in kwargs:
+            self._headers = kwargs["Headers"]
+
+        if "session_key" in kwargs:
+            self._session_key = kwargs["session_key"]
+
+        if "session_location" in kwargs:
+            self._session_location = kwargs["session_location"]
+
+        if "Content" in kwargs:
+            content = kwargs["Content"]
+
+            if isinstance(content, string_types):
+                self._read = content
+            else:
+                self._read = json.dumps(content)
+        else:
+            self._read = ""
+
+    def getheaders(self):
+        """Function for accessing the headers"""
+        returnlist = {}
+
+        if isinstance(self._headers, dict):
+            returnlist = self._headers
+        elif isinstance(self._headers, (list, tuple)):
+            returnlist = {ki[0]: ki[1] for ki in self._headers}
+        else:
+            for item in self._headers:
+                returnlist.update(item.items()[0])
+
+        return returnlist
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/gen_compat.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/gen_compat.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,429 +1,429 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-
-# -*- coding: utf-8 -*-
-"""Compatibility functionality in between iLO versions and generic Redfish/LegacyRest servers.
-Used to provide convenient string variables that are usable on any iLO irrespective of version or
-API type."""
-# ---------Imports---------
-import logging
-
-from redfish import RedfishClient, LegacyRestClient
-from redfish.rest.v1 import ServerDownOrUnreachableError
-from redfish.ris.rmc_helper import (
-    UnableToObtainIloVersionError,
-    NothingSelectedError,
-    UserNotAdminError,
-)
-
-# ---------End of imports---------
-
-LOGGER = logging.getLogger(__name__)
-
-
-# TODO: This will be a part of the compatability class
-class Typesandpathdefines(object):
-    """The global types and path definitions class. Holds information on a system and automatically
-    creates the correct type strings along with some generic paths. Paths are meant to be used with
-    iLO systems. Paths may be different on generic Redfish systems. Self variables are created when
-    the `getgen` function is called.
-
-    Useful self variables that are created include:
-
-    * **url**: The url of the system that the defines were created for.
-    * **defs**: The string defines for the system that was passed to `getgen`. Includes key
-      property keys, paths, types, and flags to check what the system type is.
-    * **ilogen**: The iLO generation of the system that the defines were created for. For non-iLO
-      Redfish systems this is set to **5**.
-    * **iloversion**: The iLO version of the system that the defines were created for.
-    * **flagiften**: Flag is set to true if the system is Gen 10 or a non-iLO Redfish system.
-    """
-
-    def __init__(self):
-        self.url = None
-        self.defs = None
-        self.ilogen = None
-        self.iloversion = None
-        self.flagiften = False
-        self.adminpriv = True
-
-    def getgen(
-        self,
-        gen=None,
-        url=None,
-        username=None,
-        password=None,
-        sessionid=None,
-        logger=None,
-        proxy=None,
-        ca_cert_data={},
-        isredfish=True,
-    ):
-        """Function designed to verify the servers platform. Will generate the `Typeandpathdefines`
-        variables based on the system type that is detected.
-
-        :param url: The URL to perform the request on.
-        :type url: str
-        :param username: The username to login with.
-        :type username: str
-        :param password: The password to login with.
-        :type password: str
-        :param proxy: The proxy to connect to the system with.
-        :type proxy: str
-        :param ca_certs: Dictionary including the TLS certificate information of user based
-          authentication
-        :type ca_certs: dict
-        :param isredfish: The flag to force redfish conformance on iLO 4 systems. You will still
-          need to call `updatedefinesflag` to update the defines to Redfish.
-        :type isredfish: bool
-        :param logger: The logger handler to log data too uses the default if none is provided.
-        :type logger: str
-        """
-
-        if self.adminpriv is False and url.startswith("blob"):
-            raise UserNotAdminError("")
-
-        self.url = url
-        self.is_redfish = isredfish
-        self.gencompany = self.rootresp = False
-        self.ilogen = 5  # If no iLO or Anonymous data , default to iLO 5 types
-        logger = logger if not logger else LOGGER
-        client = None
-        self.noschemas = False
-        self.schemapath = self.regpath = ""
-
-        if not gen:
-            try_count = 0
-            try:
-                client = RedfishClient(
-                    base_url=self.url,
-                    username=username,
-                    password=password,
-                    sessionid=sessionid,
-                    proxy=proxy,
-                    ca_cert_data=ca_cert_data,
-                )
-                client._get_root()
-            except ServerDownOrUnreachableError as excp:
-                if self.is_redfish:
-                    raise excp
-                try_count += 1
-            if not self.is_redfish:
-                try:
-                    restclient = LegacyRestClient(
-                        base_url=self.url,
-                        username=username,
-                        password=password,
-                        sessionid=sessionid,
-                        proxy=proxy,
-                        ca_cert_data=ca_cert_data,
-                    )
-                    restclient._get_root()
-                    # Check that the response is actually legacy rest and not a redirect
-                    _ = restclient.root.obj.Type
-                    self.is_redfish = False
-                    client = restclient
-                except Exception as excp:
-                    try_count += 1
-                    if not client:
-                        logger.info("Gen get rest error:" + str(excp) + "\n")
-                        raise excp
-                    else:
-                        self.is_redfish = True
-
-            if try_count > 1:
-                raise ServerDownOrUnreachableError(
-                    "Server not reachable or does not support "
-                    "HPRest or Redfish: %s\n" % str(excp)
-                )
-
-            rootresp = client.root.obj
-            self.rootresp = rootresp
-            client.logout()
-
-            self.gencompany = next(iter(self.rootresp.get("Oem", {}).keys()), None) in (
-                "Hpe",
-                "Hp",
-            )
-            comp = "Hp" if self.gencompany else None
-            comp = "Hpe" if rootresp.get("Oem", {}).get("Hpe", None) else comp
-            if comp and next(
-                iter(rootresp.get("Oem", {}).get(comp, {}).get("Manager", {}))
-            ).get("ManagerType", None):
-                self.ilogen = next(
-                    iter(rootresp.get("Oem", {}).get(comp, {}).get("Manager", {}))
-                ).get("ManagerType")
-                self.ilover = next(
-                    iter(rootresp.get("Oem", {}).get(comp, {}).get("Manager", {}))
-                ).get("ManagerFirmwareVersion")
-                if self.ilogen.split(" ")[-1] == "CM":
-                    # Assume iLO 4 types in Moonshot
-                    self.ilogen = 4
-                    self.iloversion = None
-                else:
-                    self.iloversion = float(
-                        self.ilogen.split(" ")[-1] + "." + "".join(self.ilover.split("."))
-                    )
-        else:
-            self.ilogen = int(gen)
-
-        try:
-            if not isinstance(self.ilogen, int):
-                self.ilogen = int(self.ilogen.split(" ")[-1])
-            self.flagiften = True if int(self.ilogen) >= 5 else False
-        except:
-            raise UnableToObtainIloVersionError("Unable to find the iLO generation.")
-
-        self.noschemas = (
-            True
-            if self.rootresp
-            and "JsonSchemas" in self.rootresp
-            and not self.rootresp.get("JsonSchemas", None)
-            else False
-        )
-        if self.noschemas:
-            self.ilogen = self.ilover = self.iloversion = None
-        if self.rootresp and not self.noschemas:
-            self.defineregschemapath(self.rootresp)
-
-        if self.flagiften:
-            self.defs = Definevalstenplus()
-        else:
-            self.defs = DefinevalsNine()
-
-    def defineregschemapath(self, rootobj):
-        """Defines the schema and registry paths using data in root path.
-
-        :param rootobj: The root path data.
-        :type rootobj: dict.
-        """
-        self.gencompany = next(iter(rootobj.get("Oem", {}).keys()), None) in ("Hpe", "Hp")
-        self.schemapath = (
-            rootobj["JsonSchemas"]["@odata.id"]
-            if rootobj.get("JsonSchemas", None)
-            else rootobj["links"]["Schemas"]["href"]
-        )
-        self.schemapath = (
-            self.schemapath.rstrip("/") + "/?$expand=."
-            if self.is_redfish and self.flagiften and self.gencompany
-            else self.schemapath
-        )
-        self.regpath = (
-            rootobj["Registries"]["@odata.id"]
-            if rootobj.get("Registries", None)
-            else rootobj["links"]["Registries"]["href"]
-        )
-        self.regpath = (
-            self.regpath.rstrip("/") + "/?$expand=."
-            if self.is_redfish and self.flagiften and self.gencompany
-            else self.regpath
-        )
-
-    # TODO: Move these to a compatability class
-    def updatedefinesflag(self, redfishflag=None):
-        """Updates the redfish and rest flag depending on system and redfishflag input. On an iLO 5
-        system or another Redfish system, this will do nothing. On an iLO 4 system with both Redfish
-        and LegacyRest this will update the defines to redfish if the *redfishflag* is set to True
-        and stay with the LegacyRest defines otherwise.
-
-        :param redfishflag: User input for redfish
-        :type redfishflag: bool
-        :returns: True if the system should use Redfish, False for legacy Rest.
-        :rtype: bool
-        """
-        if self.defs:
-            is_redfish = redfishflag or self.defs.isgen10
-            self.defs.flagforrest = not is_redfish
-            if is_redfish:
-                self.defs.redfishchange()
-
-            return is_redfish
-        else:
-            return redfishflag
-
-    def modifyselectorforgen(self, sel):
-        """Changes the select to match the Generation's HP string based to the correct type for
-        specific iLO versions.
-
-        :param sel: query to be changed to match Generation's HP string
-        :type sel: str
-        :returns: A modified selector matching the Generation's HP string.
-        :rtype: string
-        """
-        if not sel:
-            raise NothingSelectedError()
-        sel = sel.lower()
-        returnval = sel
-
-        if sel.startswith(("hpeeskm", "#hpeeskm", "hpeskm", "#hpeskm")):
-            returnval = self.defs.hpeskmtype
-        elif "bios." in sel[:9].lower():
-            returnval = self.defs.biostype
-        elif sel.startswith(("hpe", "#hpe")) and self.defs and self.defs.isgen9:
-            returnval = sel[:4].replace("hpe", "hp") + sel[4:]
-        elif not sel.startswith(("hpe", "#hpe")) and self.defs and self.defs.isgen10:
-            returnval = sel[:3].replace("hp", "hpe") + sel[3:]
-
-        return returnval
-
-
-class Definevals(object):
-    """Base class for setting platform dependent variables."""
-
-    def __init__(self):
-        pass
-
-
-class Definevalstenplus(Definevals):
-    """Platform dependent variables for iLO 5+ (Gen 10)."""
-
-    # pylint: disable=too-many-instance-attributes
-    # As a defines class this will need all the attributes
-    def __init__(self):
-        self.oemhp = "Hpe"
-
-        self.oempath = "/Oem/Hpe"
-        self.startpath = "/redfish/v1/"
-        self.systempath = "/redfish/v1/Systems/1/"
-        self.managerpath = "/redfish/v1/Managers/1/"
-        self.biospath = "/redfish/v1/systems/1/bios/"
-        self.addlicensepath = "/redfish/v1/Managers/1/LicenseService/"
-        self.accountspath = "/redfish/v1/AccountService/Accounts/"
-        self.federationpath = "/redfish/v1/Managers/1/FederationGroups/"
-        self.resourcedirpath = "/redfish/v1/ResourceDirectory/"
-
-        self.biostype = "Bios."
-        self.hpeskmtype = "HpeESKM."
-        self.hpcommontype = "HpeCommon"
-        self.hpilossotype = "HpeiLOSSO."
-        self.hpsecureboot = "SecureBoot."
-        self.logservicetype = "#LogService."
-        self.iscsisource = "iSCSISources"
-        self.iscsiattemptinstance = "iSCSIAttemptInstance"
-        self.iscsiattemptname = "iSCSIAttemptName"
-        self.hphttpscerttype = "HpeHttpsCert."
-        self.snmpservice = "HpeiLOSnmpService."
-        self.attributenametype = "AttributeName"
-        self.hpilodatetimetype = "HpeiLODateTime."
-        self.attributeregtype = "#AttributeRegistry."
-        self.hpilofirmwareupdatetype = "UpdateService."
-        self.resourcedirectorytype = "HpeiLOResourceDirectory."
-        self.hpilofederationgrouptype = "HpeiLOFederationGroup."
-        self.managernetworkservicetype = "ManagerNetworkProtocol."
-        self.schemafilecollectiontype = "#JsonSchemaFileCollection."
-        self.regfilecollectiontype = "#MessageRegistryFileCollection."
-        self.hpilolicensecollectiontype = "HpeiLOLicenseCollection."
-        self.hpiloactivehealthsystemtype = "#HpeiLOActiveHealthSystem."
-        self.securityservice = "HpeSecurityService."
-        self.hpiscsisoftwareinitiatortype = "HpeiSCSISoftwareInitiator."
-        self.hpilofederationgrouptypecoll = "HpeiLOFederationGroupCollection."
-        self.bootoverridetargettype = "BootSourceOverrideTarget@Redfish.AllowableValues"
-        self.messageregistrytype = "#MessageRegistry."
-
-        self.typestring = "@odata.type"
-        self.hrefstring = "@odata.id"
-        self.collectionstring = "Members"
-        self.biossettingsstring = "@Redfish.Settings"
-        self.attname = "AttributeName"
-        self.iscsistring = "iSCSISources"
-
-        self.isgen9 = False
-        self.isgen10 = True
-        self.flagforrest = False
-        super(Definevalstenplus, self).__init__()
-
-    def redfishchange(self):
-        """Empty function to update redfish variables (unneeded when the system is already redfish)."""
-        pass
-
-
-class DefinevalsNine(Definevals):
-    """Platform dependent variables for iLO 4 LegacyRest (Gen 9)."""
-
-    # pylint: disable=too-many-instance-attributes
-    # As a defines class this will need all the attributes
-    def __init__(self):
-        self.oemhp = "Hp"
-
-        self.oempath = "/Oem/Hp"
-        self.startpath = "/rest/v1"
-        self.systempath = "/rest/v1/Systems/1"
-        self.managerpath = "/rest/v1/Managers/1"
-        self.biospath = "/rest/v1/systems/1/bios"
-        self.addlicensepath = "/rest/v1/Managers/1/LicenseService"
-        self.accountspath = "/rest/v1/AccountService/Accounts"
-        self.federationpath = "/rest/v1/Managers/1/FederationGroups"
-        self.resourcedirpath = "/rest/v1/ResourceDirectory"
-
-        self.biostype = "HpBios."
-        self.hpeskmtype = "HpESKM."
-        self.hpcommontype = "HpCommon"
-        self.hpilossotype = "HpiLOSSO."
-        self.snmpservice = "SnmpService."
-        self.attributenametype = "Name"
-        self.logservicetype = "LogService."
-        self.iscsisource = "iSCSIBootSources"
-        self.iscsiattemptinstance = "iSCSIBootAttemptInstance"
-        self.iscsiattemptname = "iSCSIBootAttemptName"
-        self.hpsecureboot = "HpSecureBoot."
-        self.hphttpscerttype = "HpHttpsCert."
-        self.hpilodatetimetype = "HpiLODateTime."
-        self.hpilofirmwareupdatetype = "HpiLOFirmwareUpdate."
-        self.resourcedirectorytype = "HpiLOResourceDirectory."
-        self.hpilofederationgrouptype = "HpiLOFederationGroup."
-        self.attributeregtype = "HpBiosAttributeRegistrySchema."
-        self.schemafilecollectiontype = "#SchemaFileCollection."
-        self.regfilecollectiontype = "#SchemaFileCollection."
-        self.managernetworkservicetype = "ManagerNetworkService."
-        self.hpiloactivehealthsystemtype = "HpiLOActiveHealthSystem."
-        self.messageregistrytype = "MessageRegistry."
-        self.hpilolicensecollectiontype = None
-        self.hpilofederationgrouptypecoll = None
-        self.bootoverridetargettype = "BootSourceOverrideSupported"
-        self.hpiscsisoftwareinitiatortype = "HpiSCSISoftwareInitiator"
-
-        self.typestring = "Type"
-        self.hrefstring = "href"
-        self.collectionstring = "Items"
-        self.biossettingsstring = "SettingsResult"
-        self.attname = "Name"
-        self.iscsistring = "iSCSIBootSources"
-
-        self.isgen9 = True
-        self.isgen10 = False
-        self.flagforrest = True
-        super(DefinevalsNine, self).__init__()
-
-    def redfishchange(self):
-        """Function to update redfish variables from LegacyRest to iLO 4 Redfish (Gen 9)."""
-        self.startpath = "/redfish/v1/"
-        self.systempath = "/redfish/v1/Systems/1/"
-        self.managerpath = "/redfish/v1/Managers/1/"
-        self.biospath = "/redfish/v1/systems/1/bios/"
-        self.addlicensepath = "/redfish/v1/Managers/1/LicenseService/"
-        self.resourcedirpath = "/redfish/v1/ResourceDirectory/"
-
-        self.typestring = "@odata.type"
-        self.hrefstring = "@odata.id"
-        self.collectionstring = "Members"
-
-        self.logservicetype = "#LogService."
-        self.hpiloactivehealthsystemtype = "#HpiLOActiveHealthSystem."
-        self.hpilolicensecollectiontype = "HpiLOLicenseCollection."
-        self.hpilofederationgrouptypecoll = "HpiLOFederationGroupCollection."
-        self.managernetworkservicetype = "ManagerNetworkProtocol."
-
-        self.flagforrest = False
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+
+# -*- coding: utf-8 -*-
+"""Compatibility functionality in between iLO versions and generic Redfish/LegacyRest servers.
+Used to provide convenient string variables that are usable on any iLO irrespective of version or
+API type."""
+# ---------Imports---------
+import logging
+
+from redfish import RedfishClient, LegacyRestClient
+from redfish.rest.v1 import ServerDownOrUnreachableError
+from redfish.ris.rmc_helper import (
+    UnableToObtainIloVersionError,
+    NothingSelectedError,
+    UserNotAdminError,
+)
+
+# ---------End of imports---------
+
+LOGGER = logging.getLogger(__name__)
+
+
+# TODO: This will be a part of the compatability class
+class Typesandpathdefines(object):
+    """The global types and path definitions class. Holds information on a system and automatically
+    creates the correct type strings along with some generic paths. Paths are meant to be used with
+    iLO systems. Paths may be different on generic Redfish systems. Self variables are created when
+    the `getgen` function is called.
+
+    Useful self variables that are created include:
+
+    * **url**: The url of the system that the defines were created for.
+    * **defs**: The string defines for the system that was passed to `getgen`. Includes key
+      property keys, paths, types, and flags to check what the system type is.
+    * **ilogen**: The iLO generation of the system that the defines were created for. For non-iLO
+      Redfish systems this is set to **5**.
+    * **iloversion**: The iLO version of the system that the defines were created for.
+    * **flagiften**: Flag is set to true if the system is Gen 10 or a non-iLO Redfish system.
+    """
+
+    def __init__(self):
+        self.url = None
+        self.defs = None
+        self.ilogen = None
+        self.iloversion = None
+        self.flagiften = False
+        self.adminpriv = True
+
+    def getgen(
+        self,
+        gen=None,
+        url=None,
+        username=None,
+        password=None,
+        sessionid=None,
+        logger=None,
+        proxy=None,
+        ca_cert_data={},
+        isredfish=True,
+    ):
+        """Function designed to verify the servers platform. Will generate the `Typeandpathdefines`
+        variables based on the system type that is detected.
+
+        :param url: The URL to perform the request on.
+        :type url: str
+        :param username: The username to login with.
+        :type username: str
+        :param password: The password to login with.
+        :type password: str
+        :param proxy: The proxy to connect to the system with.
+        :type proxy: str
+        :param ca_certs: Dictionary including the TLS certificate information of user based
+          authentication
+        :type ca_certs: dict
+        :param isredfish: The flag to force redfish conformance on iLO 4 systems. You will still
+          need to call `updatedefinesflag` to update the defines to Redfish.
+        :type isredfish: bool
+        :param logger: The logger handler to log data too uses the default if none is provided.
+        :type logger: str
+        """
+
+        if self.adminpriv is False and url.startswith("blob"):
+            raise UserNotAdminError("")
+
+        self.url = url
+        self.is_redfish = isredfish
+        self.gencompany = self.rootresp = False
+        self.ilogen = 5  # If no iLO or Anonymous data , default to iLO 5 types
+        logger = logger if not logger else LOGGER
+        client = None
+        self.noschemas = False
+        self.schemapath = self.regpath = ""
+
+        if not gen:
+            try_count = 0
+            try:
+                client = RedfishClient(
+                    base_url=self.url,
+                    username=username,
+                    password=password,
+                    sessionid=sessionid,
+                    proxy=proxy,
+                    ca_cert_data=ca_cert_data,
+                )
+                client._get_root()
+            except ServerDownOrUnreachableError as excp:
+                if self.is_redfish:
+                    raise excp
+                try_count += 1
+            if not self.is_redfish:
+                try:
+                    restclient = LegacyRestClient(
+                        base_url=self.url,
+                        username=username,
+                        password=password,
+                        sessionid=sessionid,
+                        proxy=proxy,
+                        ca_cert_data=ca_cert_data,
+                    )
+                    restclient._get_root()
+                    # Check that the response is actually legacy rest and not a redirect
+                    _ = restclient.root.obj.Type
+                    self.is_redfish = False
+                    client = restclient
+                except Exception as excp:
+                    try_count += 1
+                    if not client:
+                        logger.info("Gen get rest error:" + str(excp) + "\n")
+                        raise excp
+                    else:
+                        self.is_redfish = True
+
+            if try_count > 1:
+                raise ServerDownOrUnreachableError(
+                    "Server not reachable or does not support "
+                    "HPRest or Redfish: %s\n" % str(excp)
+                )
+
+            rootresp = client.root.obj
+            self.rootresp = rootresp
+            client.logout()
+
+            self.gencompany = next(iter(self.rootresp.get("Oem", {}).keys()), None) in (
+                "Hpe",
+                "Hp",
+            )
+            comp = "Hp" if self.gencompany else None
+            comp = "Hpe" if rootresp.get("Oem", {}).get("Hpe", None) else comp
+            if comp and next(
+                iter(rootresp.get("Oem", {}).get(comp, {}).get("Manager", {}))
+            ).get("ManagerType", None):
+                self.ilogen = next(
+                    iter(rootresp.get("Oem", {}).get(comp, {}).get("Manager", {}))
+                ).get("ManagerType")
+                self.ilover = next(
+                    iter(rootresp.get("Oem", {}).get(comp, {}).get("Manager", {}))
+                ).get("ManagerFirmwareVersion")
+                if self.ilogen.split(" ")[-1] == "CM":
+                    # Assume iLO 4 types in Moonshot
+                    self.ilogen = 4
+                    self.iloversion = None
+                else:
+                    self.iloversion = float(
+                        self.ilogen.split(" ")[-1] + "." + "".join(self.ilover.split("."))
+                    )
+        else:
+            self.ilogen = int(gen)
+
+        try:
+            if not isinstance(self.ilogen, int):
+                self.ilogen = int(self.ilogen.split(" ")[-1])
+            self.flagiften = True if int(self.ilogen) >= 5 else False
+        except:
+            raise UnableToObtainIloVersionError("Unable to find the iLO generation.")
+
+        self.noschemas = (
+            True
+            if self.rootresp
+            and "JsonSchemas" in self.rootresp
+            and not self.rootresp.get("JsonSchemas", None)
+            else False
+        )
+        if self.noschemas:
+            self.ilogen = self.ilover = self.iloversion = None
+        if self.rootresp and not self.noschemas:
+            self.defineregschemapath(self.rootresp)
+
+        if self.flagiften:
+            self.defs = Definevalstenplus()
+        else:
+            self.defs = DefinevalsNine()
+
+    def defineregschemapath(self, rootobj):
+        """Defines the schema and registry paths using data in root path.
+
+        :param rootobj: The root path data.
+        :type rootobj: dict.
+        """
+        self.gencompany = next(iter(rootobj.get("Oem", {}).keys()), None) in ("Hpe", "Hp")
+        self.schemapath = (
+            rootobj["JsonSchemas"]["@odata.id"]
+            if rootobj.get("JsonSchemas", None)
+            else rootobj["links"]["Schemas"]["href"]
+        )
+        self.schemapath = (
+            self.schemapath.rstrip("/") + "/?$expand=."
+            if self.is_redfish and self.flagiften and self.gencompany
+            else self.schemapath
+        )
+        self.regpath = (
+            rootobj["Registries"]["@odata.id"]
+            if rootobj.get("Registries", None)
+            else rootobj["links"]["Registries"]["href"]
+        )
+        self.regpath = (
+            self.regpath.rstrip("/") + "/?$expand=."
+            if self.is_redfish and self.flagiften and self.gencompany
+            else self.regpath
+        )
+
+    # TODO: Move these to a compatability class
+    def updatedefinesflag(self, redfishflag=None):
+        """Updates the redfish and rest flag depending on system and redfishflag input. On an iLO 5
+        system or another Redfish system, this will do nothing. On an iLO 4 system with both Redfish
+        and LegacyRest this will update the defines to redfish if the *redfishflag* is set to True
+        and stay with the LegacyRest defines otherwise.
+
+        :param redfishflag: User input for redfish
+        :type redfishflag: bool
+        :returns: True if the system should use Redfish, False for legacy Rest.
+        :rtype: bool
+        """
+        if self.defs:
+            is_redfish = redfishflag or self.defs.isgen10
+            self.defs.flagforrest = not is_redfish
+            if is_redfish:
+                self.defs.redfishchange()
+
+            return is_redfish
+        else:
+            return redfishflag
+
+    def modifyselectorforgen(self, sel):
+        """Changes the select to match the Generation's HP string based to the correct type for
+        specific iLO versions.
+
+        :param sel: query to be changed to match Generation's HP string
+        :type sel: str
+        :returns: A modified selector matching the Generation's HP string.
+        :rtype: string
+        """
+        if not sel:
+            raise NothingSelectedError()
+        sel = sel.lower()
+        returnval = sel
+
+        if sel.startswith(("hpeeskm", "#hpeeskm", "hpeskm", "#hpeskm")):
+            returnval = self.defs.hpeskmtype
+        elif "bios." in sel[:9].lower():
+            returnval = self.defs.biostype
+        elif sel.startswith(("hpe", "#hpe")) and self.defs and self.defs.isgen9:
+            returnval = sel[:4].replace("hpe", "hp") + sel[4:]
+        elif not sel.startswith(("hpe", "#hpe")) and self.defs and self.defs.isgen10:
+            returnval = sel[:3].replace("hp", "hpe") + sel[3:]
+
+        return returnval
+
+
+class Definevals(object):
+    """Base class for setting platform dependent variables."""
+
+    def __init__(self):
+        pass
+
+
+class Definevalstenplus(Definevals):
+    """Platform dependent variables for iLO 5+ (Gen 10)."""
+
+    # pylint: disable=too-many-instance-attributes
+    # As a defines class this will need all the attributes
+    def __init__(self):
+        self.oemhp = "Hpe"
+
+        self.oempath = "/Oem/Hpe"
+        self.startpath = "/redfish/v1/"
+        self.systempath = "/redfish/v1/Systems/1/"
+        self.managerpath = "/redfish/v1/Managers/1/"
+        self.biospath = "/redfish/v1/systems/1/bios/"
+        self.addlicensepath = "/redfish/v1/Managers/1/LicenseService/"
+        self.accountspath = "/redfish/v1/AccountService/Accounts/"
+        self.federationpath = "/redfish/v1/Managers/1/FederationGroups/"
+        self.resourcedirpath = "/redfish/v1/ResourceDirectory/"
+
+        self.biostype = "Bios."
+        self.hpeskmtype = "HpeESKM."
+        self.hpcommontype = "HpeCommon"
+        self.hpilossotype = "HpeiLOSSO."
+        self.hpsecureboot = "SecureBoot."
+        self.logservicetype = "#LogService."
+        self.iscsisource = "iSCSISources"
+        self.iscsiattemptinstance = "iSCSIAttemptInstance"
+        self.iscsiattemptname = "iSCSIAttemptName"
+        self.hphttpscerttype = "HpeHttpsCert."
+        self.snmpservice = "HpeiLOSnmpService."
+        self.attributenametype = "AttributeName"
+        self.hpilodatetimetype = "HpeiLODateTime."
+        self.attributeregtype = "#AttributeRegistry."
+        self.hpilofirmwareupdatetype = "UpdateService."
+        self.resourcedirectorytype = "HpeiLOResourceDirectory."
+        self.hpilofederationgrouptype = "HpeiLOFederationGroup."
+        self.managernetworkservicetype = "ManagerNetworkProtocol."
+        self.schemafilecollectiontype = "#JsonSchemaFileCollection."
+        self.regfilecollectiontype = "#MessageRegistryFileCollection."
+        self.hpilolicensecollectiontype = "HpeiLOLicenseCollection."
+        self.hpiloactivehealthsystemtype = "#HpeiLOActiveHealthSystem."
+        self.securityservice = "HpeSecurityService."
+        self.hpiscsisoftwareinitiatortype = "HpeiSCSISoftwareInitiator."
+        self.hpilofederationgrouptypecoll = "HpeiLOFederationGroupCollection."
+        self.bootoverridetargettype = "BootSourceOverrideTarget@Redfish.AllowableValues"
+        self.messageregistrytype = "#MessageRegistry."
+
+        self.typestring = "@odata.type"
+        self.hrefstring = "@odata.id"
+        self.collectionstring = "Members"
+        self.biossettingsstring = "@Redfish.Settings"
+        self.attname = "AttributeName"
+        self.iscsistring = "iSCSISources"
+
+        self.isgen9 = False
+        self.isgen10 = True
+        self.flagforrest = False
+        super(Definevalstenplus, self).__init__()
+
+    def redfishchange(self):
+        """Empty function to update redfish variables (unneeded when the system is already redfish)."""
+        pass
+
+
+class DefinevalsNine(Definevals):
+    """Platform dependent variables for iLO 4 LegacyRest (Gen 9)."""
+
+    # pylint: disable=too-many-instance-attributes
+    # As a defines class this will need all the attributes
+    def __init__(self):
+        self.oemhp = "Hp"
+
+        self.oempath = "/Oem/Hp"
+        self.startpath = "/rest/v1"
+        self.systempath = "/rest/v1/Systems/1"
+        self.managerpath = "/rest/v1/Managers/1"
+        self.biospath = "/rest/v1/systems/1/bios"
+        self.addlicensepath = "/rest/v1/Managers/1/LicenseService"
+        self.accountspath = "/rest/v1/AccountService/Accounts"
+        self.federationpath = "/rest/v1/Managers/1/FederationGroups"
+        self.resourcedirpath = "/rest/v1/ResourceDirectory"
+
+        self.biostype = "HpBios."
+        self.hpeskmtype = "HpESKM."
+        self.hpcommontype = "HpCommon"
+        self.hpilossotype = "HpiLOSSO."
+        self.snmpservice = "SnmpService."
+        self.attributenametype = "Name"
+        self.logservicetype = "LogService."
+        self.iscsisource = "iSCSIBootSources"
+        self.iscsiattemptinstance = "iSCSIBootAttemptInstance"
+        self.iscsiattemptname = "iSCSIBootAttemptName"
+        self.hpsecureboot = "HpSecureBoot."
+        self.hphttpscerttype = "HpHttpsCert."
+        self.hpilodatetimetype = "HpiLODateTime."
+        self.hpilofirmwareupdatetype = "HpiLOFirmwareUpdate."
+        self.resourcedirectorytype = "HpiLOResourceDirectory."
+        self.hpilofederationgrouptype = "HpiLOFederationGroup."
+        self.attributeregtype = "HpBiosAttributeRegistrySchema."
+        self.schemafilecollectiontype = "#SchemaFileCollection."
+        self.regfilecollectiontype = "#SchemaFileCollection."
+        self.managernetworkservicetype = "ManagerNetworkService."
+        self.hpiloactivehealthsystemtype = "HpiLOActiveHealthSystem."
+        self.messageregistrytype = "MessageRegistry."
+        self.hpilolicensecollectiontype = None
+        self.hpilofederationgrouptypecoll = None
+        self.bootoverridetargettype = "BootSourceOverrideSupported"
+        self.hpiscsisoftwareinitiatortype = "HpiSCSISoftwareInitiator"
+
+        self.typestring = "Type"
+        self.hrefstring = "href"
+        self.collectionstring = "Items"
+        self.biossettingsstring = "SettingsResult"
+        self.attname = "Name"
+        self.iscsistring = "iSCSIBootSources"
+
+        self.isgen9 = True
+        self.isgen10 = False
+        self.flagforrest = True
+        super(DefinevalsNine, self).__init__()
+
+    def redfishchange(self):
+        """Function to update redfish variables from LegacyRest to iLO 4 Redfish (Gen 9)."""
+        self.startpath = "/redfish/v1/"
+        self.systempath = "/redfish/v1/Systems/1/"
+        self.managerpath = "/redfish/v1/Managers/1/"
+        self.biospath = "/redfish/v1/systems/1/bios/"
+        self.addlicensepath = "/redfish/v1/Managers/1/LicenseService/"
+        self.resourcedirpath = "/redfish/v1/ResourceDirectory/"
+
+        self.typestring = "@odata.type"
+        self.hrefstring = "@odata.id"
+        self.collectionstring = "Members"
+
+        self.logservicetype = "#LogService."
+        self.hpiloactivehealthsystemtype = "#HpiLOActiveHealthSystem."
+        self.hpilolicensecollectiontype = "HpiLOLicenseCollection."
+        self.hpilofederationgrouptypecoll = "HpiLOFederationGroupCollection."
+        self.managernetworkservicetype = "ManagerNetworkProtocol."
+
+        self.flagforrest = False
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/resp_handler.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/resp_handler.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,366 +1,369 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-# -*- coding: utf-8 -*-
-
-"""Error response handler for Redfish or LegacryRest responses. Extended information only available
-with registries available on system, otherwise will return generic error responses."""
-import logging
-
-from redfish.ris.rmc_helper import IloLicenseError, ScepenabledError
-from redfish.ris.ris import SessionExpired
-from redfish.ris.utils import warning_handler, print_handler, get_errmsg_type, json_traversal
-from redfish.ris.rmc_helper import (
-    IloResponseError,
-    IdTokenError,
-    ValueChangedError,
-    EmptyRaiseForEAFP,
-)
-
-# ---------Debug logger---------
-
-LOGGER = logging.getLogger()
-
-
-# ---------End of debug logger---------
-
-
-class ResponseHandler(object):
-    """Class to handle error responses from the server.
-
-    :param validation_mgr: ValidationManager instance to gather registries if needed. Available
-                           in an RmcApp class as an attribute.
-    :type validation_mgr: ValidationManager
-    :param msg_reg_type: Redfish (#MessageRegistry.) or LegacyRest (MessageRegistry.)
-                         message registry string. Available in Typesandpathdefines class.
-    :type msg_reg_type: str
-    """
-
-    def __init__(self, validaition_mgr, msg_type):
-        self.validation_mgr = validaition_mgr
-        self.msg_reg_type = msg_type
-
-    def output_resp(self, response, dl_reg=False, verbosity=1):
-        """Prints or logs parsed MessageId response. Will raise an IloResponseError or return
-        a list of message response data which includes the information returned from
-        message_handler.
-
-        :param response: message response of a call.
-        :type response: :class:`redfish.rest.containers.RestResponse`
-        :param dl_reg: Flag to download registry. If this is set to True a generic message response
-                       will be returned instead of gathered from registries.
-        :type dl_reg: bool
-        :param verbosity: Optional verbosity level. Only modifies what is output to log or screen.
-        :type verbosity: int
-        :returns: List of error response dictionaries.
-        """
-        retdata = None
-
-        if response.status > 299:
-            message_text = "No error message returned or unable to parse error response."
-        else:
-            message_text = "The operation completed successfully."
-
-        if response.status < 300 and (
-            response._rest_request.method == "GET" or not response.read
-        ):
-            print_handler(
-                self.verbosity_levels(
-                    message=message_text,
-                    response_status=response.status,
-                    verbosity=verbosity,
-                    dl_reg=dl_reg))
-        elif response.status == 401:
-            raise SessionExpired()
-        elif response.status == 403:
-            results = response.dict["error"]["@Message.ExtendedInfo"]
-            for result in results:
-                if (
-                    "License" in list(result.values())[0]
-                    or "license" in list(result.values())[0]
-                ):
-                    raise IloLicenseError("")
-            raise IdTokenError()
-        elif response.status == 412:
-            warning_handler(
-                "The property you are trying to change has been updated. "
-                "Please check entry again before manipulating it.\n",
-                override=True,
-            )
-            raise ValueChangedError()
-        else:
-            retdata = self.message_handler(
-                response_data=response,
-                verbosity=verbosity,
-                message_text=message_text,
-                dl_reg=dl_reg,
-            )
-        if response.status == 400:
-            results = response.dict["error"]["@Message.ExtendedInfo"]
-            for result in results:
-                if (
-                    "License" in list(result.values())[0]
-                    or "license" in list(result.values())[0]
-                ):
-                    raise IloLicenseError("")
-                if "UnsupportedOperationACEEnabled" in list(result.values())[0]:
-                    raise ScepenabledError("")
-        if response.status > 299:
-            raise IloResponseError("")
-        else:
-            return retdata
-
-    def message_handler(
-        self, response_data, verbosity=0, message_text="No Response", dl_reg=False
-    ):
-        """Prints or logs parsed MessageId response based on verbosity level and returns the
-        following message information in a list:
-
-        * MessageArgs
-        * MessageId
-        * RestResponse status
-        * Resolution
-        * Full error message text
-
-        :param response_data: message response of a call.
-        :type response_data: :class:`redfish.rest.containers.RestResponse`
-        :param verbosity: Optional verbosity level. Only modifies what is output to log or screen.
-        :type verbosity: int
-        :param message_text: Response message text. If not provided, message_handler will attempt to
-                             parse it from the RestResponse and registries.
-        :type message_text: str
-        :param dl_reg: Flag to download registry. If this is set to True a generic message response
-                       will be returned instead of gathered from registries.
-        :type dl_reg: bool
-        :returns: List of error response dictionaries.
-        """
-        _tmp_message_id = _tmp_description = _tmp_resolution = message_text
-        retlist = list()
-        response_error_str = ""
-        try:
-            response_status = response_data.status
-        except (AttributeError, ValueError):
-            response_status = "???"
-        try:
-            response_data = response_data.dict
-        except (AttributeError, ValueError):
-            pass
-        try:
-            for inst in self.get_message_data(response_data, dl_reg):
-                try:
-                    for _key in inst.keys():
-                        if "messageid" in str(_key.lower()):
-                            _tmp_message_id = inst[_key]
-                        if "description" in str(_key.lower()):
-                            _tmp_description = inst[_key]
-                    if inst.get("Message") and inst.get("MessageArgs"):
-                        for i in range(inst["Message"].count("%")):
-                            inst["Message"] = inst["Message"].replace(
-                                "%" + str(i + 1), '"' + inst["MessageArgs"][i] + '"'
-                            )
-                        message_text = inst.get("Message", " ")
-                    elif inst.get("Message"):
-                        message_text = inst.get("Message", " ")
-                    elif response_status not in [200, 201]:
-                        message_text = _tmp_message_id
-                    _tmp_resolution = inst.get("Resolution", " ")
-                except (KeyError, ValueError, TypeError):
-                    pass
-                finally:
-                    response_error_str += "[%s] %s\n" % (response_status, message_text)
-                    print_handler(
-                        self.verbosity_levels(
-                            message_text,
-                            _tmp_message_id,
-                            _tmp_description,
-                            _tmp_resolution,
-                            response_status,
-                            verbosity,
-                            dl_reg,
-                        )
-                    )
-                    retlist.append(inst)
-        except Exception:
-            if not message_text:
-                message_text = _tmp_message_id
-            response_error_str += "[%s] %s\n" % (response_status, message_text)
-            print_handler(
-                self.verbosity_levels(
-                    message_text,
-                    _tmp_message_id,
-                    _tmp_description,
-                    _tmp_resolution,
-                    response_status,
-                    verbosity,
-                    dl_reg,
-                )
-            )
-            retlist.append(inst)
-        finally:
-            return retlist
-
-    def get_message_data(self, resp_data, dl_reg=False):
-        """Obtain relevant keys from rest response.
-
-        :param resp: response
-        :type resp: :class:`redfish.rest.containers.RestResponse`
-        :returns: list of error response dictionaries
-        """
-        err_response_keys = ["MessageId", "Message", "MessageArgs", "Resolution"]
-        try:
-            if "messageid" in [_key.lower() for _key in resp_data.keys()]:
-                data_extract = [resp_data]
-            else:
-                raise TypeError
-        except (TypeError, KeyError):
-            data_extract = json_traversal(resp_data, "messageid", ret_dict=True)
-        if data_extract:
-            try:
-                if not dl_reg:
-                    for inst in data_extract:
-                        if [key.lower() for key in inst.keys()] not in [
-                            erk.lower() for erk in err_response_keys
-                        ]:
-                            if "messageid" in [str(_key.lower()) for _key in inst.keys()]:
-                                inst.update(self.get_error_messages(inst[_key]))
-                                continue
-            finally:
-                return data_extract
-        else:
-            return None
-
-    def verbosity_levels(
-        self,
-        message,
-        messageid=" ",
-        description=" ",
-        resolution=" ",
-        response_status=None,
-        verbosity=0,
-        dl_reg=False,
-    ):
-        """Formatting based on verbosity level.
-
-        :param message: Message from BMC response combined with the registry model/schema.
-        :type message: str
-        :param messageid: Error code as classified by the BMC's error code registry.
-        :type messageid: str
-        :param resolution: Message from BMC registry model/schema with the suggested
-                           resolution for the given error.
-        :type resolution: str
-        :param response_status: HTTP response status code.
-        :type response_status: int
-        :param verbosity: Option to set/control output message (stderr) verbosity.
-        :type verbosity: int
-        :returns: Message to be returned to caller.
-        """
-        resp_str = ""
-        if response_status:
-            resp_str = "[" + str(response_status) + "] "
-
-        if (verbosity == 1 or dl_reg) and message:
-            return resp_str + message + "\n"
-        elif verbosity > 1 and messageid and message and resolution:
-            if not resp_str:
-                resp_str = "None "
-            return (
-                "\nHTTP Response Code: "
-                + resp_str[:-1]
-                + "\nMessageId: "
-                + messageid
-                + "\nDescription: "
-                + description
-                + "\nMessage: "
-                + message
-                + "\nResolution: "
-                + resolution
-                + "\n"
-            )
-        else:
-            return "" + message + "\n"
-
-    # unused? (removal pending)
-    @staticmethod
-    def _get_errmsg_type(results):
-        """Return the registry type of a response.
-
-        :param resuts: rest response.
-        :type results: RestResponse.
-        :returns: returns a Registry Id type string, None if not match is found, or no_id if the
-                  response is not an error message.
-        """
-        return get_errmsg_type(results)
-
-    def get_error_messages(self, regtype=None):
-        """Returns registry error messages. Can specify a specific registry to return by Id.
-
-        :param regtype: Id of registry type to add to list.
-        :type regtype: str
-        :returns: A list of error messages.
-        """
-        LOGGER.info("Entering validation...")
-        messages = None
-        errmessages = {}
-        reglist = []
-
-        # An error occurred during the shortcut method so let's go through each registry,
-        # obtain the schema and narrow down the selected schema for the registry type provided
-        try:
-            _regtype = regtype.split(".")[0]
-            for reg in self.validation_mgr.iterregmems():
-                # gen 10 / gen 9 rest
-                if _regtype:
-                    if reg and "Id" in reg and reg["Id"] == _regtype:
-                        try:
-                            reglist.append(reg["Registry"])
-                        except KeyError:
-                            reglist.append(reg["Schema"])
-                        break
-                    else:
-                        continue
-
-            if not reglist:
-                # gen 9 redfish
-                regval = [reg.get(arg, None) for arg in ["Registry", "Schema", "Id"]]
-                regval = next(
-                    (val for val in regval if val and "biosattributeregistry" not in val),
-                    None,
-                )
-                if not regval and reg:
-                    reg = reg["@odata.id"].split("/")
-                    reg = reg[len(reg) - 2]
-                    if not "biosattributeregistry" in reg.lower():
-                        reglist.append(reg)
-                elif regval:
-                    reglist.append(regval)
-
-            for reg in reglist:
-                reg = reg.replace("%23", "#")
-                messages = self.validation_mgr.get_registry_model(
-                    getmsg=True, currtype=reg, searchtype=self.msg_reg_type
-                )
-                if messages:
-                    errmessages.update(
-                        messages.get(next(iter(messages)))[regtype.split(".")[-1]]
-                    )
-            if not reglist or not errmessages:
-                raise Exception
-        except Exception:
-            raise EmptyRaiseForEAFP(
-                "Unable to find registry schema with provided registry "
-                "type: %s" % regtype
-            )
-        else:
-            return errmessages
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+# -*- coding: utf-8 -*-
+
+"""Error response handler for Redfish or LegacryRest responses. Extended information only available
+with registries available on system, otherwise will return generic error responses."""
+import logging
+
+from redfish.ris.rmc_helper import IloLicenseError, ScepenabledError
+from redfish.ris.ris import SessionExpired
+from redfish.ris.utils import warning_handler, print_handler, get_errmsg_type, json_traversal
+from redfish.ris.rmc_helper import (
+    IloResponseError,
+    IdTokenError,
+    ValueChangedError,
+    EmptyRaiseForEAFP,
+)
+
+# ---------Debug logger---------
+
+LOGGER = logging.getLogger()
+
+
+# ---------End of debug logger---------
+
+
+class ResponseHandler(object):
+    """Class to handle error responses from the server.
+
+    :param validation_mgr: ValidationManager instance to gather registries if needed. Available
+                           in an RmcApp class as an attribute.
+    :type validation_mgr: ValidationManager
+    :param msg_reg_type: Redfish (#MessageRegistry.) or LegacyRest (MessageRegistry.)
+                         message registry string. Available in Typesandpathdefines class.
+    :type msg_reg_type: str
+    """
+
+    def __init__(self, validaition_mgr, msg_type):
+        self.validation_mgr = validaition_mgr
+        self.msg_reg_type = msg_type
+
+    def output_resp(self, response, dl_reg=False, verbosity=1):
+        """Prints or logs parsed MessageId response. Will raise an IloResponseError or return
+        a list of message response data which includes the information returned from
+        message_handler.
+
+        :param response: message response of a call.
+        :type response: :class:`redfish.rest.containers.RestResponse`
+        :param dl_reg: Flag to download registry. If this is set to True a generic message response
+                       will be returned instead of gathered from registries.
+        :type dl_reg: bool
+        :param verbosity: Optional verbosity level. Only modifies what is output to log or screen.
+        :type verbosity: int
+        :returns: List of error response dictionaries.
+        """
+        retdata = None
+
+        if response.status > 299:
+            message_text = "No error message returned or unable to parse error response."
+        else:
+            message_text = "The operation completed successfully."
+
+        if response.status < 300 and (
+            response._rest_request.method == "GET" or not response.read
+        ):
+            # for rawget
+            if verbosity == 0:
+                verbosity = 1
+            print_handler(
+                self.verbosity_levels(
+                    message=message_text,
+                    response_status=response.status,
+                    verbosity=verbosity,
+                    dl_reg=dl_reg))
+        elif response.status == 401:
+            raise SessionExpired()
+        elif response.status == 403:
+            results = response.dict["error"]["@Message.ExtendedInfo"]
+            for result in results:
+                if (
+                    "License" in list(result.values())[0]
+                    or "license" in list(result.values())[0]
+                ):
+                    raise IloLicenseError("")
+            raise IdTokenError()
+        elif response.status == 412:
+            warning_handler(
+                "The property you are trying to change has been updated. "
+                "Please check entry again before manipulating it.\n",
+                override=True,
+            )
+            raise ValueChangedError()
+        else:
+            retdata = self.message_handler(
+                response_data=response,
+                verbosity=verbosity,
+                message_text=message_text,
+                dl_reg=dl_reg,
+            )
+        if response.status == 400:
+            results = response.dict["error"]["@Message.ExtendedInfo"]
+            for result in results:
+                if (
+                    "License" in list(result.values())[0]
+                    or "license" in list(result.values())[0]
+                ):
+                    raise IloLicenseError("")
+                if "UnsupportedOperationACEEnabled" in list(result.values())[0]:
+                    raise ScepenabledError("")
+        if response.status > 299:
+            raise IloResponseError("")
+        else:
+            return retdata
+
+    def message_handler(
+        self, response_data, verbosity=0, message_text="No Response", dl_reg=False
+    ):
+        """Prints or logs parsed MessageId response based on verbosity level and returns the
+        following message information in a list:
+
+        * MessageArgs
+        * MessageId
+        * RestResponse status
+        * Resolution
+        * Full error message text
+
+        :param response_data: message response of a call.
+        :type response_data: :class:`redfish.rest.containers.RestResponse`
+        :param verbosity: Optional verbosity level. Only modifies what is output to log or screen.
+        :type verbosity: int
+        :param message_text: Response message text. If not provided, message_handler will attempt to
+                             parse it from the RestResponse and registries.
+        :type message_text: str
+        :param dl_reg: Flag to download registry. If this is set to True a generic message response
+                       will be returned instead of gathered from registries.
+        :type dl_reg: bool
+        :returns: List of error response dictionaries.
+        """
+        _tmp_message_id = _tmp_description = _tmp_resolution = message_text
+        retlist = list()
+        response_error_str = ""
+        try:
+            response_status = response_data.status
+        except (AttributeError, ValueError):
+            response_status = "???"
+        try:
+            response_data = response_data.dict
+        except (AttributeError, ValueError):
+            pass
+        try:
+            for inst in self.get_message_data(response_data, dl_reg):
+                try:
+                    for _key in inst.keys():
+                        if "messageid" in str(_key.lower()):
+                            _tmp_message_id = inst[_key]
+                        if "description" in str(_key.lower()):
+                            _tmp_description = inst[_key]
+                    if inst.get("Message") and inst.get("MessageArgs"):
+                        for i in range(inst["Message"].count("%")):
+                            inst["Message"] = inst["Message"].replace(
+                                "%" + str(i + 1), '"' + inst["MessageArgs"][i] + '"'
+                            )
+                        message_text = inst.get("Message", " ")
+                    elif inst.get("Message"):
+                        message_text = inst.get("Message", " ")
+                    elif response_status not in [200, 201]:
+                        message_text = _tmp_message_id
+                    _tmp_resolution = inst.get("Resolution", " ")
+                except (KeyError, ValueError, TypeError):
+                    pass
+                finally:
+                    response_error_str += "[%s] %s\n" % (response_status, message_text)
+                    print_handler(
+                        self.verbosity_levels(
+                            message_text,
+                            _tmp_message_id,
+                            _tmp_description,
+                            _tmp_resolution,
+                            response_status,
+                            verbosity,
+                            dl_reg,
+                        )
+                    )
+                    retlist.append(inst)
+        except Exception:
+            if not message_text:
+                message_text = _tmp_message_id
+            response_error_str += "[%s] %s\n" % (response_status, message_text)
+            print_handler(
+                self.verbosity_levels(
+                    message_text,
+                    _tmp_message_id,
+                    _tmp_description,
+                    _tmp_resolution,
+                    response_status,
+                    verbosity,
+                    dl_reg,
+                )
+            )
+            retlist.append(inst)
+        finally:
+            return retlist
+
+    def get_message_data(self, resp_data, dl_reg=False):
+        """Obtain relevant keys from rest response.
+
+        :param resp: response
+        :type resp: :class:`redfish.rest.containers.RestResponse`
+        :returns: list of error response dictionaries
+        """
+        err_response_keys = ["MessageId", "Message", "MessageArgs", "Resolution"]
+        try:
+            if "messageid" in [_key.lower() for _key in resp_data.keys()]:
+                data_extract = [resp_data]
+            else:
+                raise TypeError
+        except (TypeError, KeyError):
+            data_extract = json_traversal(resp_data, "messageid", ret_dict=True)
+        if data_extract:
+            try:
+                if not dl_reg:
+                    for inst in data_extract:
+                        if [key.lower() for key in inst.keys()] not in [
+                            erk.lower() for erk in err_response_keys
+                        ]:
+                            if "messageid" in [str(_key.lower()) for _key in inst.keys()]:
+                                inst.update(self.get_error_messages(inst[_key]))
+                                continue
+            finally:
+                return data_extract
+        else:
+            return None
+
+    def verbosity_levels(
+        self,
+        message,
+        messageid=" ",
+        description=" ",
+        resolution=" ",
+        response_status=None,
+        verbosity=0,
+        dl_reg=False,
+    ):
+        """Formatting based on verbosity level.
+
+        :param message: Message from BMC response combined with the registry model/schema.
+        :type message: str
+        :param messageid: Error code as classified by the BMC's error code registry.
+        :type messageid: str
+        :param resolution: Message from BMC registry model/schema with the suggested
+                           resolution for the given error.
+        :type resolution: str
+        :param response_status: HTTP response status code.
+        :type response_status: int
+        :param verbosity: Option to set/control output message (stderr) verbosity.
+        :type verbosity: int
+        :returns: Message to be returned to caller.
+        """
+        resp_str = ""
+        if response_status:
+            resp_str = "[" + str(response_status) + "] "
+
+        if (verbosity == 1 or dl_reg) and message:
+            return resp_str + message + "\n"
+        elif verbosity > 1 and messageid and message and resolution:
+            if not resp_str:
+                resp_str = "None "
+            return (
+                "\nHTTP Response Code: "
+                + resp_str[:-1]
+                + "\nMessageId: "
+                + messageid
+                + "\nDescription: "
+                + description
+                + "\nMessage: "
+                + message
+                + "\nResolution: "
+                + resolution
+                + "\n"
+            )
+        else:
+            return "" + message + "\n"
+
+    # unused? (removal pending)
+    @staticmethod
+    def _get_errmsg_type(results):
+        """Return the registry type of a response.
+
+        :param resuts: rest response.
+        :type results: RestResponse.
+        :returns: returns a Registry Id type string, None if not match is found, or no_id if the
+                  response is not an error message.
+        """
+        return get_errmsg_type(results)
+
+    def get_error_messages(self, regtype=None):
+        """Returns registry error messages. Can specify a specific registry to return by Id.
+
+        :param regtype: Id of registry type to add to list.
+        :type regtype: str
+        :returns: A list of error messages.
+        """
+        LOGGER.info("Entering validation...")
+        messages = None
+        errmessages = {}
+        reglist = []
+
+        # An error occurred during the shortcut method so let's go through each registry,
+        # obtain the schema and narrow down the selected schema for the registry type provided
+        try:
+            _regtype = regtype.split(".")[0]
+            for reg in self.validation_mgr.iterregmems():
+                # gen 10 / gen 9 rest
+                if _regtype:
+                    if reg and "Id" in reg and reg["Id"] == _regtype:
+                        try:
+                            reglist.append(reg["Registry"])
+                        except KeyError:
+                            reglist.append(reg["Schema"])
+                        break
+                    else:
+                        continue
+
+            if not reglist:
+                # gen 9 redfish
+                regval = [reg.get(arg, None) for arg in ["Registry", "Schema", "Id"]]
+                regval = next(
+                    (val for val in regval if val and "biosattributeregistry" not in val),
+                    None,
+                )
+                if not regval and reg:
+                    reg = reg["@odata.id"].split("/")
+                    reg = reg[len(reg) - 2]
+                    if not "biosattributeregistry" in reg.lower():
+                        reglist.append(reg)
+                elif regval:
+                    reglist.append(regval)
+
+            for reg in reglist:
+                reg = reg.replace("%23", "#")
+                messages = self.validation_mgr.get_registry_model(
+                    getmsg=True, currtype=reg, searchtype=self.msg_reg_type
+                )
+                if messages:
+                    errmessages.update(
+                        messages.get(next(iter(messages)))[regtype.split(".")[-1]]
+                    )
+            if not reglist or not errmessages:
+                raise Exception
+        except Exception:
+            raise EmptyRaiseForEAFP(
+                "Unable to find registry schema with provided registry "
+                "type: %s" % regtype
+            )
+        else:
+            return errmessages
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/ris.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/ris.py`

 * *Files identical despite different names*

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/ris_threaded.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/ris_threaded.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,271 +1,271 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-# -*- coding: utf-8 -*-
-"""A threaded version of RIS _load for quicker searching"""
-# ---------Imports---------
-
-import logging
-import threading
-
-# Added for py3 compatibility
-import six
-
-from queue import Empty
-from six.moves.urllib.parse import urlparse, urlunparse
-
-import jsonpath_rw
-
-import redfish.ris
-
-# ---------End of imports---------
-
-# ---------Debug logger---------
-
-LOGGER = logging.getLogger(__name__)
-
-# ---------End of debug logger---------
-
-
-class LoadWorker(threading.Thread):
-    """A threaded implementation of _load for quicker crawling"""
-
-    def __init__(self, queue):
-        threading.Thread.__init__(self)
-        self.queue = queue
-        self.exception = None
-
-    def run(self):
-        """Main worker function"""
-        try:
-            while True:
-                (
-                    path,
-                    includelogs,
-                    loadcomplete,
-                    crawl,
-                    rel,
-                    init,
-                    prevpath,
-                    originaluri,
-                    theobj,
-                ) = self.queue.get()
-                if (
-                    path
-                    == includelogs
-                    == loadcomplete
-                    == crawl
-                    == rel
-                    == init
-                    == prevpath
-                    == originaluri
-                    == theobj
-                    == "KILL"
-                ):
-                    break
-
-                if path.endswith("?page=1") and not loadcomplete:
-                    # Don't download schemas in crawl unless we are loading absolutely everything
-                    self.queue.task_done()
-                    continue
-                elif not includelogs and crawl:
-                    # Only include logs when asked as there can be an extreme amount of entries
-                    if "/log" in path.lower():
-                        self.queue.task_done()
-                        continue
-
-                # TODO: need to find a better way to support non ascii characters
-                path = path.replace("|", "%7C")
-                # remove fragments
-                newpath = urlparse(path)
-                newpath = list(newpath[:])
-                newpath[-1] = ""
-                path = urlunparse(tuple(newpath))
-
-                if prevpath and prevpath != path:
-                    theobj.ctree[prevpath].update([path])
-                if not rel:
-                    if path.lower() in theobj.visited_urls:
-                        self.queue.task_done()
-                        continue
-                LOGGER.debug("_loading %s", path)
-
-                resp = theobj._client.get(path)
-
-                if resp.status != 200 and path.lower() == theobj.typepath.defs.biospath:
-                    self.queue.task_done()
-                    raise redfish.ris.ris.BiosUnregisteredError()
-                elif resp.status == 401:
-                    self.queue.task_done()
-                    raise redfish.ris.ris.SessionExpired(
-                        "Invalid session. Please logout and "
-                        "log back in or include credentials."
-                    )
-                elif resp.status not in (201, 200):
-                    theobj.removepath(path)
-                    self.queue.task_done()
-                    continue
-
-                theobj.update_member(resp=resp, path=path, init=init)
-
-                fpath = (
-                    lambda pa, path: path
-                    if pa.endswith(theobj.typepath.defs.hrefstring)
-                    and pa.startswith((theobj.collstr, "Entries"))
-                    else None
-                )
-
-                # follow all the href attributes
-                if theobj.is_redfish:
-                    jsonpath_expr = jsonpath_rw.parse("$..'@odata.id'")
-                else:
-                    jsonpath_expr = jsonpath_rw.parse("$..href")
-                matches = jsonpath_expr.find(resp.dict)
-
-                if "links" in resp.dict and "NextPage" in resp.dict["links"]:
-                    if originaluri:
-                        next_link_uri = (
-                            originaluri
-                            + "?page="
-                            + str(resp.dict["links"]["NextPage"]["page"])
-                        )
-                        href = "%s" % next_link_uri
-
-                        theobj.get_queue.put(
-                            (
-                                href,
-                                includelogs,
-                                loadcomplete,
-                                crawl,
-                                rel,
-                                init,
-                                None,
-                                originaluri,
-                                theobj,
-                            )
-                        )
-                    else:
-                        next_link_uri = (
-                            path + "?page=" + str(resp.dict["links"]["NextPage"]["page"])
-                        )
-
-                        href = "%s" % next_link_uri
-                        theobj.get_queue.put(
-                            (
-                                href,
-                                includelogs,
-                                loadcomplete,
-                                crawl,
-                                rel,
-                                init,
-                                None,
-                                path,
-                                theobj,
-                            )
-                        )
-
-                # Only use monolith if we are set to
-                matchrdirpath = (
-                    next(
-                        (
-                            match
-                            for match in matches
-                            if match.value == theobj._resourcedir
-                        ),
-                        None,
-                    )
-                    if theobj.directory_load
-                    else None
-                )
-                if not matchrdirpath and crawl:
-                    for match in matches:
-                        if path == "/rest/v1" and not loadcomplete:
-                            if (
-                                str(match.full_path) == "links.Schemas.href"
-                                or str(match.full_path) == "links.Registries.href"
-                            ):
-                                continue
-                        elif not loadcomplete:
-                            if (
-                                str(match.full_path) == "Registries.@odata.id"
-                                or str(match.full_path) == "JsonSchemas.@odata.id"
-                            ):
-                                continue
-
-                        if match.value == path:
-                            continue
-                        elif not isinstance(match.value, six.string_types):
-                            continue
-
-                        href = "%s" % match.value
-                        theobj.get_queue.put(
-                            (
-                                href,
-                                includelogs,
-                                loadcomplete,
-                                crawl,
-                                rel,
-                                init,
-                                fpath(str(match.full_path), path),
-                                originaluri,
-                                theobj,
-                            )
-                        )
-                elif crawl:
-                    href = "%s" % matchrdirpath.value
-                    theobj.get_queue.put(
-                        (
-                            href,
-                            includelogs,
-                            loadcomplete,
-                            crawl,
-                            rel,
-                            init,
-                            path,
-                            originaluri,
-                            theobj,
-                        )
-                    )
-                if loadcomplete:
-                    if path == "/rest/v1":
-                        schemamatch = jsonpath_rw.parse("$..extref")
-                    else:
-                        schemamatch = jsonpath_rw.parse("$..Uri")
-                    smatches = schemamatch.find(resp.dict)
-                    matches = matches + smatches
-                    for match in matches:
-                        if isinstance(match.value, six.string_types):
-                            theobj.get_queue.put(
-                                (
-                                    match.value,
-                                    includelogs,
-                                    loadcomplete,
-                                    crawl,
-                                    rel,
-                                    init,
-                                    fpath(str(match.full_path), path),
-                                    originaluri,
-                                    theobj,
-                                )
-                            )
-                self.queue.task_done()
-        except Empty:
-            pass
-        except Exception as excp:
-            self.exception = excp
-
-    def get_exception(self):
-        """Get any exception from the thread"""
-        return self.exception
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+# -*- coding: utf-8 -*-
+"""A threaded version of RIS _load for quicker searching"""
+# ---------Imports---------
+
+import logging
+import threading
+
+# Added for py3 compatibility
+import six
+
+from queue import Empty
+from six.moves.urllib.parse import urlparse, urlunparse
+
+import jsonpath_rw
+
+import redfish.ris
+
+# ---------End of imports---------
+
+# ---------Debug logger---------
+
+LOGGER = logging.getLogger(__name__)
+
+# ---------End of debug logger---------
+
+
+class LoadWorker(threading.Thread):
+    """A threaded implementation of _load for quicker crawling"""
+
+    def __init__(self, queue):
+        threading.Thread.__init__(self)
+        self.queue = queue
+        self.exception = None
+
+    def run(self):
+        """Main worker function"""
+        try:
+            while True:
+                (
+                    path,
+                    includelogs,
+                    loadcomplete,
+                    crawl,
+                    rel,
+                    init,
+                    prevpath,
+                    originaluri,
+                    theobj,
+                ) = self.queue.get()
+                if (
+                    path
+                    == includelogs
+                    == loadcomplete
+                    == crawl
+                    == rel
+                    == init
+                    == prevpath
+                    == originaluri
+                    == theobj
+                    == "KILL"
+                ):
+                    break
+
+                if path.endswith("?page=1") and not loadcomplete:
+                    # Don't download schemas in crawl unless we are loading absolutely everything
+                    self.queue.task_done()
+                    continue
+                elif not includelogs and crawl:
+                    # Only include logs when asked as there can be an extreme amount of entries
+                    if "/log" in path.lower():
+                        self.queue.task_done()
+                        continue
+
+                # TODO: need to find a better way to support non ascii characters
+                path = path.replace("|", "%7C")
+                # remove fragments
+                newpath = urlparse(path)
+                newpath = list(newpath[:])
+                newpath[-1] = ""
+                path = urlunparse(tuple(newpath))
+
+                if prevpath and prevpath != path:
+                    theobj.ctree[prevpath].update([path])
+                if not rel:
+                    if path.lower() in theobj.visited_urls:
+                        self.queue.task_done()
+                        continue
+                LOGGER.debug("_loading %s", path)
+
+                resp = theobj._client.get(path)
+
+                if resp.status != 200 and path.lower() == theobj.typepath.defs.biospath:
+                    self.queue.task_done()
+                    raise redfish.ris.ris.BiosUnregisteredError()
+                elif resp.status == 401:
+                    self.queue.task_done()
+                    raise redfish.ris.ris.SessionExpired(
+                        "Invalid session. Please logout and "
+                        "log back in or include credentials."
+                    )
+                elif resp.status not in (201, 200):
+                    theobj.removepath(path)
+                    self.queue.task_done()
+                    continue
+
+                theobj.update_member(resp=resp, path=path, init=init)
+
+                fpath = (
+                    lambda pa, path: path
+                    if pa.endswith(theobj.typepath.defs.hrefstring)
+                    and pa.startswith((theobj.collstr, "Entries"))
+                    else None
+                )
+
+                # follow all the href attributes
+                if theobj.is_redfish:
+                    jsonpath_expr = jsonpath_rw.parse("$..'@odata.id'")
+                else:
+                    jsonpath_expr = jsonpath_rw.parse("$..href")
+                matches = jsonpath_expr.find(resp.dict)
+
+                if "links" in resp.dict and "NextPage" in resp.dict["links"]:
+                    if originaluri:
+                        next_link_uri = (
+                            originaluri
+                            + "?page="
+                            + str(resp.dict["links"]["NextPage"]["page"])
+                        )
+                        href = "%s" % next_link_uri
+
+                        theobj.get_queue.put(
+                            (
+                                href,
+                                includelogs,
+                                loadcomplete,
+                                crawl,
+                                rel,
+                                init,
+                                None,
+                                originaluri,
+                                theobj,
+                            )
+                        )
+                    else:
+                        next_link_uri = (
+                            path + "?page=" + str(resp.dict["links"]["NextPage"]["page"])
+                        )
+
+                        href = "%s" % next_link_uri
+                        theobj.get_queue.put(
+                            (
+                                href,
+                                includelogs,
+                                loadcomplete,
+                                crawl,
+                                rel,
+                                init,
+                                None,
+                                path,
+                                theobj,
+                            )
+                        )
+
+                # Only use monolith if we are set to
+                matchrdirpath = (
+                    next(
+                        (
+                            match
+                            for match in matches
+                            if match.value == theobj._resourcedir
+                        ),
+                        None,
+                    )
+                    if theobj.directory_load
+                    else None
+                )
+                if not matchrdirpath and crawl:
+                    for match in matches:
+                        if path == "/rest/v1" and not loadcomplete:
+                            if (
+                                str(match.full_path) == "links.Schemas.href"
+                                or str(match.full_path) == "links.Registries.href"
+                            ):
+                                continue
+                        elif not loadcomplete:
+                            if (
+                                str(match.full_path) == "Registries.@odata.id"
+                                or str(match.full_path) == "JsonSchemas.@odata.id"
+                            ):
+                                continue
+
+                        if match.value == path:
+                            continue
+                        elif not isinstance(match.value, six.string_types):
+                            continue
+
+                        href = "%s" % match.value
+                        theobj.get_queue.put(
+                            (
+                                href,
+                                includelogs,
+                                loadcomplete,
+                                crawl,
+                                rel,
+                                init,
+                                fpath(str(match.full_path), path),
+                                originaluri,
+                                theobj,
+                            )
+                        )
+                elif crawl:
+                    href = "%s" % matchrdirpath.value
+                    theobj.get_queue.put(
+                        (
+                            href,
+                            includelogs,
+                            loadcomplete,
+                            crawl,
+                            rel,
+                            init,
+                            path,
+                            originaluri,
+                            theobj,
+                        )
+                    )
+                if loadcomplete:
+                    if path == "/rest/v1":
+                        schemamatch = jsonpath_rw.parse("$..extref")
+                    else:
+                        schemamatch = jsonpath_rw.parse("$..Uri")
+                    smatches = schemamatch.find(resp.dict)
+                    matches = matches + smatches
+                    for match in matches:
+                        if isinstance(match.value, six.string_types):
+                            theobj.get_queue.put(
+                                (
+                                    match.value,
+                                    includelogs,
+                                    loadcomplete,
+                                    crawl,
+                                    rel,
+                                    init,
+                                    fpath(str(match.full_path), path),
+                                    originaluri,
+                                    theobj,
+                                )
+                            )
+                self.queue.task_done()
+        except Empty:
+            pass
+        except Exception as excp:
+            self.exception = excp
+
+    def get_exception(self):
+        """Get any exception from the thread"""
+        return self.exception
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/rmc.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/rmc.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,1797 +1,1817 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-# -*- coding: utf-8 -*-
-
-"""A convenience layer that combines multiple lower level classes and functions into one."""
-
-# ---------Imports---------
-import sys
-import time
-import copy
-import shutil
-import logging
-import hashlib
-import six
-
-try:
-    from collections import OrderedDict
-except ImportError:
-    from collections.abc import OrderedDict
-
-import jsonpatch
-import jsonpointer
-import redfish.ris.gen_compat
-import redfish.ris.validation
-
-from redfish.rest.v1 import RestClient
-from redfish.ris.ris import SessionExpired, RisMonolith, SchemaValidationError
-from redfish.ris.validation import ValidationManager, Typepathforval
-from redfish.ris.resp_handler import ResponseHandler
-from redfish.ris.utils import (
-    merge_dict,
-    getattributeregistry,
-    diffdict,
-    navigatejson,
-    iterateandclear,
-    skipnonsettingsinst,
-    warning_handler,
-    validate_headers,
-    checkallowablevalues,
-)
-from redfish.ris.rmc_helper import (
-    UndefinedClientError,
-    InstanceNotFoundError,
-    NothingSelectedError,
-    ValidationError,
-    RmcFileCacheManager,
-    NothingSelectedSetError,
-    LoadSkipSettingError,
-    ValueChangedError,
-    IloResponseError,
-    EmptyRaiseForEAFP,
-    IncompatibleiLOVersionError,
-)
-
-# ---------End of imports---------
-
-# ---------Debug logger---------
-
-LOGGER = logging.getLogger(__name__)
-
-
-# ---------End of debug logger---------
-
-
-class RmcApp(object):
-    """A convenience class that combines the client, compatibility, validation, caching,
-    and monolith into one class.
-
-    :param showwarnings: Flag to print warnings to std.out (True) or log in log file (False)
-    :type showwarnings: bool
-    :param cache_dir: Cache directory to save cache data to, if None, RmcApp will not cache data.
-                      Cache can allow your RmcApp to persist between scripts.
-    :type cache_dir: str
-    """
-
-    def __init__(self, showwarnings=False, cache_dir=None):
-        self.logger = LOGGER
-        self.redfishinst = None
-        self.sessioninst = None
-        self._cm = RmcFileCacheManager(self)
-        self.monolith = None
-        self._iloversion = None
-        self._validationmanager = None
-        self._selector = None
-        self._cachedir = cache_dir
-        self.verbose = 1
-        self._sessionid = None
-        self.typepath = redfish.ris.gen_compat.Typesandpathdefines()
-        Typepathforval(typepathobj=self.typepath)
-
-        if not showwarnings:
-            self.logger.setLevel(logging.WARNING)
-            if self.logger.handlers and self.logger.handlers[0].name == "lerr":
-                self.logger.handlers.remove(self.logger.handlers[0])
-
-    @property
-    def monolith(self):
-        """Get the monolith from the current client"""
-        return self._monolith
-
-    @monolith.setter
-    def monolith(self, monolith):
-        """Set the monolith"""
-        self._monolith = monolith
-
-    @property
-    def current_client(self):
-        """Get the current client"""
-        if self.redfishinst:
-            return self.redfishinst
-        raise UndefinedClientError()
-
-    @property
-    def validationmanager(self):
-        """Get the valdation manager"""
-        if self.getiloversion():
-            if self._validationmanager:
-                self._validationmanager.reset_errors_warnings()
-            else:
-                monolith = self.monolith
-                self._validationmanager = ValidationManager(
-                    monolith, defines=self.typepath
-                )
-            self._validationmanager.updatevalidationdata()
-        else:
-            self._validationmanager = None
-        return self._validationmanager
-
-    @property
-    def selector(self):
-        """The selector that will be used to gather data if no selector or instance argument is
-        passed."""
-        return self._selector
-
-    @selector.setter
-    def selector(self, sel):
-        """Set the selector"""
-        self._selector = sel
-
-    @property
-    def cachedir(self):
-        """The cache directory that is used to cache app data to a file,
-        None if not caching data."""
-        return self._cachedir
-
-    @cachedir.setter
-    def cachedir(self, cache_dir):
-        """Set the cachedir"""
-        self._cachedir = cache_dir
-
-    @property
-    def cache(self):
-        """True if we are caching data, False if we are not"""
-        return True if self.cachedir else False
-
-    def restore(self, creds=None, enc=False):
-        """Restores the monolith from cache. Used to load a monolith data back into a new app
-        class. Keyword arguments are only needed in a local client when in a high security mode.
-
-        :param creds: Credentials to create the client with.
-        :type creds: str
-        :param enc: Flag to determine if encoding functions are being used. True if being used false
-                    if not.
-        :type enc: bool
-        """
-        self._cm.uncache_rmc(creds=creds, enc=enc)
-
-    def set_encode_funct(self, funct):
-        """Set the encoding function for cache to use. Can be used to protect sensitive data when
-        it is at rest.
-
-        :param funct: The function to use for encoding data
-        :type funct: function
-        """
-        self._cm.encodefunct = funct
-
-    def set_decode_funct(self, funct):
-        """Set the decoding function for cache to use. Is used in conjunction with the
-        `set_encode_funct` to turn the encoded data back into a usable string.
-
-        :param funct: The function to use for decoding data
-        :type funct: function
-        """
-        self._cm.decodefunct = funct
-
-    def save(self):
-        """Updates the cache with the latest monolith data."""
-        self._cm.cache_rmc()
-
-    def login(
-        self,
-        username=None,
-        password=None,
-        sessionid=None,
-        base_url="blobstore://.",
-        path=None,
-        skipbuild=False,
-        includelogs=False,
-        biospassword=None,
-        is_redfish=False,
-        proxy=None,
-        ssl_cert=None,
-        user_ca_cert_data=None,
-        json_out=False,
-    ):
-        """Performs a login on a the server specified by the keyword arguments. Will also create
-        a monolith, client, and update the compatibility classes for the app instance. If base_url
-        is not included the login is assumed to be locally on the OS.
-
-        :param username: The user name required to login to server.
-        :type: str
-        :param password: The password credentials required to login.
-        :type password: str
-        :param base_url: The redfish host name or ip address to login to.
-        :type base_url: str
-        :param path: The path to initiate the monolith crawl from. If None, it will start from the
-                     root. See monolith documentation on how the path is used.
-        :type path: str
-        :param proxy: The proxy required for connection (if any).
-        :type proxy: str
-        :param ssl_cert: The path to the CA bundle or SSL certificate to use with connection
-                        (if any).
-        :type ssl_cert: str
-        :param user_ca_cert_data: Dictionary of user certificate data for iLO Certificate-based
-          authentication including iLO User TLS certificate, iLO User CA Root Key, \
-          iLO User CA Root Key Password (for encrypted CAs)
-        :type: user_ca_pass: str
-        :param skipbuild: The flag to determine monolith download. If True, monolith will be
-                          initiated empty, if False will build the monolith.
-        :type skipbuild: bool
-        :param includelogs: The flag to determine id logs should be downloaded in the crawl.
-        :type includelogs: bool
-        :param biospassword: The BIOS password for the server if set.
-        :type biospassword: str
-        :param is_redfish: If True, a Redfish specific header (OData) will be
-            added to every request. Only required if the system has both LegacyREST and Redfish.
-        :type is_redfish: bool
-        """
-
-        self.typepath.getgen(
-            url=base_url,
-            username=username,
-            password=password,
-            sessionid=sessionid,
-            ca_cert_data=user_ca_cert_data,
-            proxy=proxy,
-            isredfish=is_redfish,
-        )
-        if user_ca_cert_data and self.typepath.iloversion < 5.23:
-            raise IncompatibleiLOVersionError(
-                "Certificate based login is incompatible with this "
-                "iLO version: %s\n" % self.typepath.iloversion
-            )
-        is_redfish = self.typepath.updatedefinesflag(redfishflag=is_redfish)
-
-        if self.redfishinst and self.redfishinst.session_key:
-            self.logout()
-
-        self.redfishinst = RestClient(
-            base_url=base_url,
-            username=username,
-            password=password,
-            session_key=sessionid,
-            default_prefix=self.typepath.defs.startpath,
-            biospassword=biospassword,
-            is_redfish=is_redfish,
-            proxy=proxy,
-            ca_cert_data=user_ca_cert_data,
-        )
-
-        self.current_client.login(self.current_client.auth_type)
-
-        inittime = time.time()
-
-        self._build_monolith(
-            path=path, includelogs=includelogs, skipbuild=skipbuild, json_out=json_out
-        )
-        endtime = time.time()
-
-        if self.verbose > 1:
-            sys.stdout.write("Monolith build process time: %s\n" % (endtime - inittime))
-        self.save()
-        if not self.monolith:
-            self.monolith.update_member(
-                resp=self.current_client.root,
-                path=self.typepath.defs.startpath,
-                init=False,
-            )
-
-    def logout(self, url=None):
-        """Performs a logout of the server and prepares the app for another system, setting app
-        variables to default values.
-
-        :param url: The URL for the logout request. Only needed when using a cache.
-        :type url: str
-        """
-        sessionlocs = []
-        self._validationmanager = None
-        self._iloversion = None
-
-        try:
-            self.monolith.killthreads()
-        except Exception:
-            pass
-
-        try:
-            self.current_client.logout()
-        except Exception:
-            sessionlocs = self._cm.logout_del_function(url)
-        else:
-            self._cm.logout_del_function(url)
-
-        for session in sessionlocs:
-            try:
-                self.delete_handler(session[0], silent=True, service=True)
-            except:
-                pass
-        self.redfishinst = None
-
-        cachedir = self.cachedir
-        if cachedir:
-            try:
-                shutil.rmtree(cachedir)
-            except Exception:
-                pass
-
-    def select(self, selector=None, fltrvals=(None, None), path_refresh=False):
-        """Selects instances based on selector and filter values. The select specified is saved in
-        the app for further use. If another selector is sent, it overwrites the current one.
-
-        :param selector: The type (@odata.type for Redfish) to select.
-        :type selector: str
-        :param fltrvals: The filter values for the select operation (Key,Val). If a selector returns
-                         multiple instances fltrvals can filter the instances by a key/value pair,
-                         limiting the returned instances to the one you want.
-        :type fltrvals: tuple
-        :param path_refresh: The flag to reload the selected instances. If True, each instance will be
-                    grabbed again from the server to make sure responses are up to date.
-        :type path_refresh: bool
-        :returns: A list of selected monolith member instances.
-        :rtype: RisMonolithMemberv100
-        """
-        if not selector:
-            selector = self.selector
-        # Still nothing selected and selector is NULL
-        if not selector:
-            raise NothingSelectedError()
-        selector = self.typepath.modifyselectorforgen(selector)
-        instances = self._getinstances(selector=selector, path_refresh=path_refresh)
-        val = (
-            fltrvals[1].strip("'\"")
-            if isinstance(fltrvals[1], six.string_types)
-            else fltrvals[1]
-        )
-        instances = [
-            inst
-            for inst in instances
-            if not fltrvals[0]
-            or navigatejson(fltrvals[0].split("/"), copy.deepcopy(inst.dict), val)
-        ]
-        if any(instances):
-            self.selector = selector
-            self.save()
-            return instances
-
-        errmsg = (
-            "Unable to locate instance for '{0}' and filter '{1}={2}'".format(
-                selector, fltrvals[0], fltrvals[1]
-            )
-            if fltrvals[0] and fltrvals[1]
-            else "Unable to locate instance for {}\n".format(selector)
-        )
-
-        raise InstanceNotFoundError(errmsg)
-
-    def types(self, fulltypes=False):
-        """Returns a list of types available to be queried and selected with monolith.
-
-        :param fulltypes: Flag to determine if types return Redfish full name, if False will return
-                          a shortened version of the type string.
-        :type fulltypes: bool
-        :returns: A list of type strings.
-        :rtype: list
-        """
-        instances = list()
-
-        if self.monolith:
-            monolith = self.monolith
-            rdirtype = next(
-                monolith.gettypename(self.typepath.defs.resourcedirectorytype), None
-            )
-
-            if not rdirtype:
-                for inst in monolith.iter():
-                    if not any(
-                        [
-                            x
-                            for x in ["ExtendedError", "object", "string"]
-                            if x in inst.type
-                        ]
-                    ):
-                        instances.append(inst.type)
-            else:
-                for instance in monolith.iter(rdirtype):
-                    for item in instance.resp.dict["Instances"]:
-                        if (
-                            item
-                            and instance._typestring in list(item.keys())
-                            and not "ExtendedError" in item[instance._typestring]
-                        ):
-                            if not fulltypes and instance._typestring == "@odata.type":
-                                tval = item["@odata.type"].split("#")
-                                tval = tval[-1].split(".")[:-1]
-                                tval = ".".join(tval)
-                                instances.append(tval)
-                            elif item:
-                                instances.append(item[instance._typestring])
-        return instances
-
-    def getprops(
-        self,
-        selector=None,
-        props=None,
-        nocontent=None,
-        skipnonsetting=True,
-        remread=False,
-        insts=None,
-    ):
-        """Gets properties from a specified selector. If no selector is specified, uses the selector
-        property in the app class. Instead of a selector a list of instances to search can be used
-        instead. If both **selector** and **insts** are passed, **insts** is used.
-
-        Specific values for multi-level dictionaries can be returned by passing each key
-        separated by a "/" Ex: Key/Sub-Key/Sub-Sub-Key
-
-        :param selector: The type selection for the get operation.
-        :type selector: str
-        :param skipnonsetting: Flag to remove non settings path.
-        :type skipnonsetting: bool
-        :param nocontent: Keys not found are added to the list provided.
-        :type nocontent: list
-        :param remread: Flag to remove readonly properties.
-        :type remread: bool
-        :param props: The keys to search for within current selection.
-        :type props: list
-        :param insts: List of RisMonolithMemberv100 to be searched for specific keys.
-        :type insts: list
-        :returns: A list of properties found in dictionary form.
-        :rtype: list
-        """
-        results = list()
-        nocontent = set() if nocontent is None else nocontent
-        if props:
-            if isinstance(props, list):
-                noprop = {prop: False for prop in props}
-            else:
-                noprop = {props: False}
-        else:
-            noprop = {}
-        instances = insts if insts else self._getinstances(selector=selector)
-        instances = skipnonsettingsinst(instances) if skipnonsetting else instances
-
-        if selector != "UpdateService.":
-            if not instances or len(instances) == 0:
-                if not selector:
-                    raise NothingSelectedError()
-
-        for instance in instances:
-            currdict = instance.dict
-            for patch in instance.patches:
-                currdict = jsonpatch.apply_patch(currdict, patch)
-            _ = self.removereadonlyprops(currdict, emptyraise=True) if remread else None
-            temp_dict = dict()
-            if props:
-                if isinstance(props, six.string_types):
-                    props = [props]
-                for prop in props:
-                    copydict = copy.deepcopy(currdict)
-                    propsdict = navigatejson(prop.split("/"), copydict)
-                    if propsdict is None:
-                        continue
-                    noprop[prop] = True
-                    merge_dict(temp_dict, propsdict)
-                if temp_dict:
-                    if temp_dict not in results:
-                        results.append(temp_dict)
-            else:
-                results.append(currdict)
-        if props:
-            _ = [nocontent.add(prop) for prop in props if not noprop[prop]]
-        return results
-
-    def info(self, selector=None, props=None, dumpjson=True, latestschema=False):
-        """Gets schema information for properties from a specified selector. If no selector is
-        specified, uses the selector property in the app class. If no properties are specified
-        the entire schema dictionary is returned in a list.
-
-        :param selector: The type selection for the info operation.
-        :type selector: str
-        :param props: The keys to gather schema data for within current selection.
-        :type props: str or list
-        :param dumpjson: Flag to determine if output should be human readable or json schema.
-        :type dumpjson: bool
-        :param latestschema: Flag to determine if we should drop the schema version when we try to
-                             match schema information. If True, the version will be dropped.
-        :type latestschema: bool
-        :returns: A list of property schema information if dumpjson is True or string if dumpjson is
-                  False.
-        :rtype: list or string
-        """
-        model = None
-        outdata = ""
-        nokey = False
-        results = None
-        typestring = self.typepath.defs.typestring
-        iloversion = self.getiloversion()
-        if not iloversion:
-            return results
-        instances = self._getinstances(selector)
-        attributeregistry = getattributeregistry(instances)
-        instances = skipnonsettingsinst(instances)
-
-        if not instances or len(instances) == 0:
-            raise NothingSelectedError()
-
-        for inst in instances:
-            bsmodel = None
-            currdict = inst.resp.dict
-            proppath = (
-                inst.resp.getheader("Link").split(";")[0].strip("<>")
-                if inst.resp.getheader("Link")
-                else None
-            )
-            seldict = {}
-            if not props:
-                model, bsmodel = self.get_model(
-                    currdict, attributeregistry, latestschema, proppath=proppath
-                )
-                results = model
-                break
-            if isinstance(props, six.string_types):
-                props = props.split("/") if "/" in props else props
-                props = [props] if not isinstance(props, (list, tuple)) else props
-                seldict = navigatejson(props, copy.deepcopy(currdict))
-                if seldict is None:
-                    nokey = True
-                    continue
-            if self.typepath.defs.typestring in currdict:
-                seldict[typestring] = currdict[typestring]
-                model, bsmodel = self.get_model(
-                    currdict,
-                    attributeregistry,
-                    latestschema,
-                    newarg=props[:-1],
-                    proppath=proppath,
-                )
-            if not model and not bsmodel:
-                errmsg = "/".join(props)
-                warning_handler(
-                    "Unable to locate registry model or "
-                    "No data available for entry: {}\n".format(errmsg)
-                )
-                continue
-            found = model.get_validator(props[-1]) if model else None
-            found = bsmodel.get_validator(props[-1]) if not found and bsmodel else found
-            outdata = (
-                found
-                if found and dumpjson
-                else found.print_help(props[-1])
-                if found
-                else outdata
-            )
-
-        if outdata or results:
-            return outdata if outdata else results
-
-        errmsg = (
-            "Entry {} not found in current selection\n".format("/".join(props))
-            if nokey
-            else "Entry {} not found in current" " selection\n".format("/".join(props))
-        )
-        warning_handler(errmsg)
-
-    def loadset(
-        self,
-        seldict=None,
-        fltrvals=(None, None),
-        diffonly=False,
-        latestschema=False,
-        uniqueoverride=False,
-        selector=None,
-    ):
-        """Creates json patches in monolith if the supplied dictionary passes schema validation.
-        In the event schemas are unavailable the patches are always added. Patches that are created
-        this way are not sent to the server until the :meth:`commit` function is called, sending the
-        patches to the server. A list of patches that have not been sent to the server can be
-        returned with the :meth:`status` function.
-
-        :param selector: The type selection for the loadset operation.
-        :type selector: str
-        :param seldict: Dictionary with the patches to apply to the selected instances.
-        :type seldict: dict
-        :param fltrvals: The filter values for the operation (Key,Val). If a selector returns
-                         multiple instances fltrvals can filter the instances by a key/value pair,
-                         limiting the returned instances to the one you want. If no filter is
-                         supplied the patch dictionary will be applied to all instances.
-        :type fltrvals: tuple
-        :param latestschema: Flag to determine if we should drop the schema version when we try to
-                             match schema information. If True, the version will be dropped.
-        :type latestschema: bool
-        :param diffonly: flag to differentiate only existing properties.
-        :type diffonly: bool
-        :param uniqueoverride: Flag to determine if system unique properties should also be patched.
-                               If this is True, then unique properties will be patched.
-        :type uniqueoverride: bool
-        :returns: returns a list of properties that have successfully been set
-        """
-        results = list()
-        nochangesmade = False
-        settingskipped = [False]
-
-        selector = self.selector if not selector else selector
-        instances = self.select(selector=selector, fltrvals=fltrvals)
-        attributeregistry = getattributeregistry(instances=instances)
-        instances = skipnonsettingsinst(instances=instances)
-
-        if not instances or len(instances) == 0:
-            raise NothingSelectedSetError()
-
-        for instance in instances:
-            if validate_headers(instance, verbose=self.verbose):
-                continue
-            else:
-                nochangesmade = True
-
-            currdict = instance.resp.dict
-            if "@odata.id" in seldict:
-                if currdict["@odata.id"] != seldict["@odata.id"]:
-                    continue
-            diff_resp = diffdict(
-                newdict=copy.deepcopy(seldict),
-                oridict=copy.deepcopy(currdict),
-                settingskipped=settingskipped,
-            )
-
-            iloversion = self.getiloversion()
-            if iloversion:
-                proppath = (
-                    instance.resp.getheader("Link").split(";")[0].strip("<>")
-                    if instance.resp.getheader("Link")
-                    else None
-                )
-                try:
-                    self._validatechanges(
-                        instance=instance,
-                        attributeregistry=attributeregistry,
-                        newdict=diff_resp,
-                        oridict=currdict,
-                        unique=uniqueoverride,
-                        latestschema=latestschema,
-                        proppath=proppath,
-                    )
-                except SchemaValidationError:
-                    LOGGER.error("Cannot validate changes, error found in schema.")
-
-            patches = jsonpatch.make_patch(currdict, diff_resp)
-
-            if patches:
-                torem = []
-                _ = [
-                    torem.append(patch)
-                    for patch in patches.patch
-                    if patch["op"] == "remove"
-                ]
-                _ = [patches.patch.remove(patch) for patch in torem]
-
-            for ind, item in enumerate(instance.patches):
-                ppath = (
-                    item.patch[0]["path"] if hasattr(item, "patch") else item[0]["path"]
-                )
-                # ppath = ["path"](getattr(item, "patch"), item)[0]["path"]
-                jpath = jsonpointer.JsonPointer(ppath.lower())
-                jval = jpath.resolve(seldict, default="kasjdk?!")
-                if not jval == "kasjdk?!":
-                    del instance.patches[ind]
-
-            if patches:
-                for patch in patches.patch:
-                    forprint = (
-                        patch["value"]
-                        if "value" in patch
-                        else (patch["op"] + " " + patch["from"])
-                    )
-                    results.append({patch["path"][1:]: forprint})
-                if "Managers/1/EthernetInterfaces/1" not in instance.path:
-                    self.monolith.path(instance.path).patches.append(patches)
-            else:
-                nochangesmade = True
-
-        if not nochangesmade:
-            return results
-        elif settingskipped[0] is True:
-            raise LoadSkipSettingError()
-        else:
-            return results
-
-    def status(self):
-        """Returns all pending changes that have not been committed yet."""
-        iloversion = self.getiloversion()
-
-        finalresults = list()
-        monolith = self.monolith
-        (_, _) = self.get_selection(setenable=True)
-        attrreg = getattributeregistry([ele for ele in monolith.iter() if ele])
-        for instance in monolith.iter():
-            results = list()
-
-            if not (instance.patches and len(instance.patches) > 0):
-                continue
-            for item in instance.patches:
-                if isinstance(item, list):
-                    results.extend(jsonpatch.JsonPatch(item))
-                else:
-                    results.extend(item)
-
-            currdict = instance.resp.dict
-            itemholder = list()
-            for mainitem in results:
-                item = copy.deepcopy(mainitem)
-
-                if iloversion:
-                    _, bsmodel = self.get_model(currdict, attrreg)
-                    if bsmodel:
-                        prop = item["path"][1:].split("/")[-1]
-                        validator = bsmodel.get_validator(prop)
-                        if validator:
-                            if isinstance(
-                                validator, redfish.ris.validation.PasswordValidator
-                            ):
-                                item["value"] = "******"
-
-                itemholder.append(item)
-            if itemholder:
-                finalresults.append(
-                    {instance.maj_type + "(" + instance.path + ")": itemholder}
-                )
-
-        return finalresults
-
-    def commit(self):
-        """Applies all pending json patches to the server.
-
-        :yields: Two strings.
-
-                1. Path being PATCHed
-                2. True if an error occurred during the PATCH, False if no error.
-        """
-        # Protect iLO Network Interface changes.
-        instances = [
-            inst
-            for inst in self.monolith.iter()
-            if inst.patches and "Managers/1/EthernetInterfaces/1" not in inst.path
-        ]
-
-        if not instances or len(instances) == 0:
-            raise NothingSelectedError()
-
-        for instance in instances:
-            if validate_headers(instance, verbose=self.verbose):
-                continue
-
-            currdict = dict()
-            oridict = instance.resp.dict
-            totpayload = dict()
-            # apply patches to represent current edits
-            for patches in instance.patches:
-                if not self._iloversion:
-                    self._iloversion = self.getiloversion()
-                if self._iloversion < 5.130:
-                    self._checkforetagchange(instance=instance)
-                fulldict = jsonpatch.apply_patch(oridict, patches)
-                for patch in patches:
-                    currdict = copy.deepcopy(fulldict)
-                    patchpath = patch["path"]
-                    pobj = jsonpointer.JsonPointer(patchpath)
-                    indpayloadcount = 0
-                    for item in pobj.parts:
-                        payload = pobj.walk(currdict, item)
-                        indpayloadcount = indpayloadcount + 1
-                        if isinstance(payload, list):
-                            break
-                        else:
-                            if not isinstance(payload, dict):
-                                break
-                            currdict = copy.deepcopy(payload)
-                    indices = pobj.parts[:indpayloadcount]
-                    createdict = lambda x, y: {x: y}
-                    while len(indices):
-                        payload = createdict(indices.pop(), payload)
-                    merge_dict(totpayload, payload)
-                currdict = copy.deepcopy(totpayload)
-
-            if currdict:
-                yield instance.resp.request.path
-
-                put_path = instance.resp.request.path
-                etag = self.monolith.paths[put_path].etag
-                headers = dict([("If-Match", etag)]) if self._iloversion > 5.130 else None
-                for key, value in currdict.items():
-                    if key == "OldAdminPassword" and (value != ""):
-                        if (value == "null") or (value == "none") or (value == "None"):
-                            currdict["OldAdminPassword"] = ""
-                        else:
-                            hash = hashlib.sha256(value.encode()).hexdigest().upper()
-                            headers = dict([("X-HPRESTFULAPI-AuthToken", hash)])
-                    elif key == "AdminPassword" and (
-                        (value == None)
-                        or (value == "none")
-                        or (value == "None")
-                        or (value == "null")
-                    ):
-                        currdict["AdminPassword"] = ""
-                try:
-                    self.patch_handler(
-                        put_path,
-                        currdict,
-                        optionalpassword=self.current_client.bios_password,
-                        headers=headers,
-                    )
-                except IloResponseError:
-                    yield True  # Failure
-                else:
-                    yield False  # Success
-
-    def patch_handler(
-        self,
-        put_path,
-        body,
-        headers=None,
-        silent=False,
-        service=False,
-        optionalpassword=None,
-    ):
-        """Performs the client HTTP PATCH operation with monolith and response handling support.
-        Response handling will output to logger or string depending on showmessages app argument.
-
-        :param put_path: The REST path to perform the patch operation on.
-        :type put_path: str
-        :param body: the body to perform the operation with.
-        :type body: dict
-        :param headers: Any additional headers to be added to the request.
-        :type headers: dict
-        :param optionalpassword: The bios password if it is required for the operation.
-        :type optionalpassword: str
-        :param silent: If False response will be parsed based on service flag and output to a log or
-                       stdout. If True response will not be parsed and no message output or error
-                       messages raised from the response handler.
-        :type silent: bool
-        :param service: When handling the response, if True registries will be gathered and a full,
-                        response will be output if False they will not and response handler will
-                        instead return a generic message.
-        :type service: bool
-        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
-        """
-        (put_path, body) = self._checkpostpatch(body=body, path=put_path, patch=True)
-
-        if optionalpassword:
-            self.current_client.bios_password = optionalpassword
-
-        results = self.current_client.patch(put_path, body=body, headers=headers)
-
-        if results and getattr(results, "status", None) and results.status == 401:
-            raise SessionExpired()
-
-        self._modifiedpath(results, replace=True)
-
-        # if results and getattr(results, "status", None) and results.status == 412:
-        if results and hasattr(results, "status") and results.status == 412:
-            self._updatemono(path=put_path, path_refresh=True)
-
-        if not silent:
-            ResponseHandler(
-                self.validationmanager, self.typepath.defs.messageregistrytype
-            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
-
-        return results
-
-    def get_handler(
-        self,
-        get_path,
-        sessionid=None,
-        silent=False,
-        uncache=False,
-        headers=None,
-        service=False,
-        username=None,
-        password=None,
-        base_url=None,
-    ):
-        """Performs the client HTTP GET operation with monolith and response handling support.
-        Response handling will output to logger or string depending on showmessages app argument.
-
-        :param put_path: The REST path to perform the get operation on.
-        :type put_path: str
-        :param uncache: flag to not store the data downloaded into monolith.
-        :type uncache: bool
-        :param headers: Any additional headers to be added to the request.
-        :type headers: dict
-        :param silent: If False response will be parsed based on service flag and output to a log or
-                       stdout. If True response will not be parsed and no message output or error
-                       messages raised from the response handler.
-        :type silent: bool
-        :param service: When handling the response, if True registries will be gathered and a full,
-                        response will be output if False they will not and response handler will
-                        instead return a generic message.
-        :type service: bool
-        :returns: A :class:`redfish.rest.containers.RestResponse` object
-        """
-        try:
-            results = self.current_client.get(get_path, headers=headers)
-        except UndefinedClientError:
-            if sessionid:
-                self.redfishinst = RestClient(
-                    sessionid=sessionid,
-                    username=username,
-                    password=password,
-                    base_url=base_url,
-                )
-                if not headers:
-                    headers = dict()
-                headers["X-Auth-Token"] = sessionid
-                results = self.current_client.get(get_path, headers=headers)
-
-        if results and getattr(results, "status", None) and results.status == 404:
-            return results
-        
-        if results and results.status == 200 and sessionid:
-            return results
-
-        if not uncache and results.status == 200 and not sessionid:
-            if self.monolith:
-                self.monolith.update_member(resp=results, path=get_path, init=False)
-
-        if results and getattr(results, "status", None) and results.status == 401:
-            raise SessionExpired()
-
-        if not silent:
-            ResponseHandler(
-                self.validationmanager, self.typepath.defs.messageregistrytype
-            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
-
-        return results
-
-    def post_handler(self, put_path, body, headers=None, silent=False, service=False):
-        """Performs the client HTTP POST operation with monolith and response handling support.
-        Response handling will output to logger or string depending on showmessages app argument.
-
-        :param put_path: The REST path to perform the post operation on.
-        :type put_path: str
-        :param body: the body to perform the operation with.
-        :type body: dict
-        :param headers: Any additional headers to be added to the request.
-        :type headers: dict
-        :param silent: If False response will be parsed based on service flag and output to a log or
-                       stdout. If True response will not be parsed and no message output or error
-                       messages raised from the response handler.
-        :type silent: bool
-        :param service: When handling the response, if True registries will be gathered and a full,
-                        response will be output if False they will not and response handler will
-                        instead return a generic message.
-        :type service: bool
-        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
-        """
-        (put_path, body) = self._checkpostpatch(body=body, path=put_path)
-
-        results = self.current_client.post(put_path, body=body, headers=headers)
-
-        if results and getattr(results, "status", None) and results.status == 401:
-            raise SessionExpired()
-
-        self._modifiedpath(results)
-
-        if not silent:
-            ResponseHandler(
-                self.validationmanager, self.typepath.defs.messageregistrytype
-            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
-
-        return results
-
-    def put_handler(
-        self,
-        put_path,
-        body,
-        headers=None,
-        silent=False,
-        optionalpassword=None,
-        service=False,
-    ):
-        """Performs the client HTTP PUT operation with monolith and response handling support.
-        Response handling will output to logger or string depending on showmessages app argument.
-
-        :param put_path: The REST path to perform the put operation on.
-        :type put_path: str
-        :param body: the body to perform the operation with.
-        :type body: dict
-        :param headers: Any additional headers to be added to the request.
-        :type headers: dict
-        :param optionalpassword: The bios password if it is required for the operation.
-        :type optionalpassword: str
-        :param silent: If False response will be parsed based on service flag and output to a log or
-                       stdout. If True response will not be parsed and no message output or error
-                       messages raised from the response handler.
-        :type silent: bool
-        :param service: When handling the response, if True registries will be gathered and a full,
-                        response will be output if False they will not and response handler will
-                        instead return a generic message.
-        :type service: bool
-        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
-        """
-        if optionalpassword:
-            self.current_client.bios_password = optionalpassword
-        results = self.current_client.put(put_path, body=body, headers=headers)
-        if results and getattr(results, "status", None) and results.status == 401:
-            raise SessionExpired()
-
-        self._modifiedpath(results, replace=True)
-
-        if not silent:
-            ResponseHandler(
-                self.validationmanager, self.typepath.defs.messageregistrytype
-            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
-
-        return results
-
-    def delete_handler(self, put_path, headers=None, silent=False, service=False):
-        """Performs the client HTTP DELETE operation with monolith and response handling support.
-        Response handling will output to logger or string depending on showmessages app argument.
-
-        :param put_path: The REST path to perform the delete operation on.
-        :type put_path: str
-        :param headers: Any additional headers to be added to the request.
-        :type headers: dict
-        :param silent: If False response will be parsed based on service flag and output to a log or
-                       stdout. If True response will not be parsed and no message output or error
-                       messages raised from the response handler.
-        :type silent: bool
-        :param service: When handling the response, if True registries will be gathered and a full,
-                        response will be output if False they will not and response handler will
-                        instead return a generic message.
-        :type service: bool
-        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
-        """
-        results = self.current_client.delete(put_path, headers=headers)
-
-        if results and getattr(results, "status", None) and results.status == 401:
-            raise SessionExpired()
-        self._modifiedpath(results, delete=True)
-
-        if not silent:
-            ResponseHandler(
-                self.validationmanager, self.typepath.defs.messageregistrytype
-            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
-
-        return results
-
-    def head_handler(self, put_path, silent=False, service=False):
-        """Performs the client HTTP HEAD operation with monolith and response handling support.
-        Response handling will output to logger or string depending on showmessages app argument.
-
-        :param put_path: The REST path to perform the head operation on.
-        :type put_path: str
-        :param silent: If False response will be parsed based on service flag and output to a log or
-                       stdout. If True response will not be parsed and no message output or error
-                       messages raised from the response handler.
-        :type silent: bool
-        :param service: When handling the response, if True registries will be gathered and a full,
-                        response will be output if False they will not and response handler will
-                        instead return a generic message.
-        :type service: bool
-        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
-        """
-        results = self.current_client.head(put_path)
-
-        if results and getattr(results, "status", None) and results.status == 401:
-            raise SessionExpired()
-
-        if not silent:
-            ResponseHandler(
-                self.validationmanager, self.typepath.defs.messageregistrytype
-            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
-
-        return results
-
-    def removereadonlyprops(
-        self, currdict, emptyraise=False, removeunique=True, specify_props=None
-    ):
-        """Remove read only properties from a dictionary. Requires schemas to be available.
-
-        :param currdict: The dictionary to remove read only properties from.
-        :type currdict: dictionary
-        :param emptyraise: Flag to raise an empty error for handling and failure to parse.
-        :type emptyraise: boolean
-        :type removeunique: Flag to remove system unique values as well as read only.
-        :type removeunique: boolean
-        :parm specify_props: Optionally set list of properties to be removed instead of the default.
-        :type specify_props: list
-        """
-        try:
-            type_str = self.typepath.defs.typestring
-            currtype = currdict.get(type_str, None)
-            oridict = copy.deepcopy(currdict)
-            if specify_props:
-                templist = specify_props
-            else:
-                templist = [
-                    "Modified",
-                    "Type",
-                    "Description",
-                    "Status",
-                    "links",
-                    "SettingsResult",
-                    "Attributes",
-                    "@odata.context",
-                    "@odata.type",
-                    "@odata.id",
-                    "@odata.etag",
-                    "Links",
-                    "Actions",
-                    "AvailableActions",
-                    "BiosVersion",
-                    "AddressOrigin",
-                ]
-            # Attributes removed and readded later as a validation workaround
-            currdict = iterateandclear(currdict, templist)
-            iloversion = self.getiloversion()
-            if not iloversion:
-                return currdict
-            self.validationmanager.validatedict(
-                currdict,
-                currtype=currtype,
-                monolith=self.monolith,
-                unique=removeunique,
-                searchtype=None,
-            )
-            if oridict.get("Attributes", None):
-                currdict["Attributes"] = oridict["Attributes"]
-            return currdict
-        except:
-            if emptyraise is True:
-                raise EmptyRaiseForEAFP()
-            elif emptyraise == "pass":
-                pass
-            else:
-                raise
-
-    def getidbytype(self, tpe):
-        """Return a list of URIs that correspond to the supplied type string.
-
-        :param tpe: type string to search for.
-        :type tpe: string.
-        """
-        urls = list()
-        val = next(self.monolith.gettypename(tpe), None)
-        urls.extend(self.monolith.typesadded[val] if val else [])
-        return urls
-
-    def getcollectionmembers(self, path, fullresp=False):
-        """Returns collection/item lists of the provided path.
-
-        :param path: path to return.
-        :type path: string.
-        :param fullresp: Return full json data instead of only members.
-        :type path: bool.
-        :returns: list of collection members
-        """
-        if (
-            self.typepath.defs.isgen10
-            and self.typepath.gencompany
-            and "?$expand=." not in path
-        ):
-            path += "?$expand=." if path.endswith("/") else "/?$expand=."
-
-        members = self.get_handler(path, service=True, silent=True)
-        if members and not fullresp:
-            try:
-                members = (
-                    members.dict["Members"]
-                    if self.typepath.defs.isgen10
-                    else members.dict["Current"]
-                )
-            except KeyError:
-                members = members
-        elif fullresp:
-            members = [members.dict]
-
-        return members
-
-    def getbiosfamilyandversion(self):
-        """Function that returns the current BIOS version information."""
-        self._updatemono(currtype="ComputerSystem.", crawl=False)
-
-        try:
-            for inst in self.monolith.iter("ComputerSystem."):
-                if "Current" in inst.resp.obj["Bios"]:
-                    oemjson = inst.resp.obj["Bios"]["Current"]
-                    parts = oemjson["VersionString"].split(" ")
-                    return parts[0], parts[1][1:]
-                else:
-                    parts = inst.resp.obj["BiosVersion"].split(" ")
-                    return parts[0], parts[1][1:]
-        except Exception:
-            pass
-
-        return None, None
-
-    def getiloversion(self, skipschemas=False):
-        """Function that returns the current iLO version.
-
-        :param skipschemas: flag to determine whether to skip schema download. If False, this will
-                            also verify if schemas are available.
-        :type skipschemas: bool
-        :returns: returns current iLO version
-        """
-        iloversion = self._iloversion = (
-            self._iloversion if self._iloversion else self.typepath.iloversion
-        )
-
-        if not iloversion and hasattr(self.redfishinst, "iloversion"):
-            iloversion = (
-                self._iloversion
-            ) = self.typepath.iloversion = self.redfishinst.iloversion
-
-        if (
-            self.typepath.gencompany
-            and not self._iloversion
-            and not self.typepath.noschemas
-        ):
-            self.monolith.load(self.typepath.defs.managerpath, crawl=False)
-            results = next(
-                iter(self.getprops("Manager.", ["FirmwareVersion", "Firmware"]))
-            )
-
-            def quickdrill(_dict, key):
-                """function to find key in nested dictionary"""
-                return _dict[key]
-
-            while isinstance(results, dict):
-                results = quickdrill(results, next(iter(results.keys())))
-            iloversionlist = results.replace("v", "").replace(".", "").split(" ")
-            iloversion = float(".".join(iloversionlist[1:3]))
-
-            model = self.getprops("Manager.", ["Model"])
-            if model:
-                if next(iter(model))["Model"] == "iLO CM":
-                    # Assume iLO 4 types in Moonshot
-                    iloversion = None
-
-            self._iloversion = iloversion
-        elif (
-            not self.typepath.gencompany
-        ):  # Assume schemas are available somewhere in non-hpe redfish
-            self._iloversion = iloversion = 4.210
-
-        conf = None if not skipschemas else True
-        if not skipschemas:
-            if iloversion and iloversion >= 4.210:
-                conf = self._verifyschemasdownloaded(self.monolith)
-            elif iloversion and iloversion < 4.210:
-                warning_handler(
-                    "Please upgrade to iLO 4 version 2.1 or above for schema support."
-                )
-            else:
-                warning_handler(
-                    "Schema support unavailable on the currently logged in system."
-                )
-
-        return iloversion if iloversion and iloversion >= 4.210 and conf else None
-
-    def get_selection(self, selector=None, setenable=False, path_refresh=False):
-        """Gathers instances and optionally the attributeregistry based on selector.
-
-        :param selector: The type selection for the get operation.
-        :type selector: str.
-        :param setenable: Flag to determine if registry should also be returned.
-        :type setenable: boolean.
-        :param path_refresh: Flag to reload the selected instances.
-        :type path_refresh: boolean.
-        :returns: returns a list of selected items
-        """
-        instances = self._getinstances(selector=selector, path_refresh=path_refresh)
-        if setenable:
-            attributeregistryfound = getattributeregistry(instances=instances)
-            instances = skipnonsettingsinst(instances=instances)
-            return instances, attributeregistryfound
-
-        return instances
-
-    def create_save_header(self):
-        """Adds save file headers to show what server the data came from.
-
-        :param selector: The type selection for the get save operation.
-        :type selector: str.
-        :param selectignore: Return the save header even if there isn't a selection to add it to.
-        :type selectignore: boolean
-        :returns: returns an header ordered dictionary
-        """
-        instances = OrderedDict()
-        monolith = self.monolith
-
-        self._updatemono(currtype="ComputerSystem.", crawl=False)
-        self._updatemono(currtype=self.typepath.defs.biostype, crawl=False)
-        self._updatemono(currtype="Manager.", crawl=False)
-
-        instances["Comments"] = OrderedDict()
-        for instance in monolith.iter("ComputerSystem."):
-            if instance.resp.obj.get("Manufacturer"):
-                instances["Comments"]["Manufacturer"] = instance.resp.obj["Manufacturer"]
-            if instance.resp.obj.get("Model"):
-                instances["Comments"]["Model"] = instance.resp.obj["Model"]
-            try:
-                if instance.resp.obj["Oem"][self.typepath.defs.oemhp]["Bios"]["Current"]:
-                    oemjson = instance.resp.obj["Oem"][self.typepath.defs.oemhp]["Bios"][
-                        "Current"
-                    ]
-                    instances["Comments"]["BIOSFamily"] = oemjson["Family"]
-                    instances["Comments"]["BIOSDate"] = oemjson["Date"]
-            except KeyError:
-                pass
-        for instance in monolith.iter(self.typepath.defs.biostype):
-            try:
-                if getattr(instance.resp.obj, "Attributes", False):
-                    if instance.resp.obj["Attributes"].get("SerialNumber"):
-                        instances["Comments"]["SerialNumber"] = instance.resp.obj[
-                            "Attributes"
-                        ]["SerialNumber"]
-                if instance.resp.obj.get("SerialNumber"):
-                    instances["Comments"]["SerialNumber"] = instance.resp.obj[
-                        "SerialNumber"
-                    ]
-            except KeyError as e:
-                pass
-        for instance in monolith.iter("Manager."):
-            if instance.resp.obj.get("FirmwareVersion"):
-                instances["Comments"]["iLOVersion"] = instance.resp.obj["FirmwareVersion"]
-
-        return instances
-
-    def download_path(self, paths, crawl=True, path_refresh=False):
-        """Loads paths into the monolith.
-
-        :param paths: list of paths to download
-        :type paths: list
-        :param path_refresh: Flag to reload the paths or not.
-        :type path_refresh: bool.
-        :param crawl: Flag to determine if load should traverse found links.
-        :type crawl: boolean.
-        """
-        if not paths:
-            return
-        try:
-            list(
-                map(
-                    lambda x: self.monolith.load(
-                        path=x,
-                        init=False,
-                        path_refresh=path_refresh,
-                        crawl=crawl,
-                        includelogs=True,
-                    ),
-                    paths,
-                )
-            )
-        except Exception as excp:
-            try:
-                if excp.errno == 10053:
-                    raise SessionExpired()
-            except:
-                raise excp
-            else:
-                raise excp
-
-    def get_model(
-        self, currdict, attributeregistry, latestschema=None, newarg=None, proppath=None
-    ):
-        """Returns a model and possibly a bios model for the current instance's schema/registry.
-        This model can be used to read schema data and validate patches.
-
-        :param currdict: The dictionary to gather the schema model from.
-        :type currdict: dict
-        :param attributeregistry: The current systems attribute registry. If not gathering a bios
-                                  registry this can be set to None.
-        :type attributeregistry: dict
-        :param latestschema: Flag to determine if we should drop the schema version when we try to
-                             match schema information. If True, the version will be dropped.
-        :type latestschema: bool
-        :param newargs: List of multi level properties to be gathered.
-        :type newargs: list
-        :param proppath: The path of the schema you want to validate (from Location header).
-        :type proppath: str
-        :returns: model and bios model
-        """
-        type_str = self.typepath.defs.typestring
-        bsmodel = None
-        valobj = self.validationmanager
-        model = valobj.get_registry_model(
-            currtype=currdict[type_str],
-            newarg=newarg,
-            latestschema=latestschema,
-            proppath=proppath,
-        )
-        if not attributeregistry and model:
-            return model, bsmodel
-        if not model and not attributeregistry:
-            LOGGER.warning(
-                "Unable to locate registry/schema for %s\n", currdict[type_str]
-            )
-            return None, None
-        attrval = currdict.get("AttributeRegistry", None)
-        attrval = (
-            list(attributeregistry.values())[0]
-            if not attrval and attributeregistry
-            else attrval
-        )
-        bsmodel = valobj.get_registry_model(
-            currtype=attrval if attrval else currdict[type_str],
-            newarg=newarg,
-            latestschema=latestschema,
-            searchtype=self.typepath.defs.attributeregtype,
-        )
-        return model, bsmodel
-
-    def _build_monolith(
-        self, path=None, includelogs=False, skipbuild=False, json_out=False
-    ):
-        """Run through the RIS tree to build monolith
-
-        :param path: path to initiate login to.
-        :type path: str.
-        :param includelogs: flag to determine id logs should be downloaded.
-        :type includelogs: boolean.
-        :param skipbuild: if true, skip build of monolith (initialize empty)
-        :type skipbuild: True
-        """
-        self.monolith = RisMonolith(self.current_client, self.typepath)
-        if not skipbuild:
-            self.monolith.load(
-                path=path, includelogs=includelogs, init=True, json_out=json_out
-            )
-        else:
-            self.monolith.update_member(
-                resp=self.current_client.root,
-                path=self.current_client.default_prefix,
-                init=False,
-            )
-
-    def _modifiedpath(self, results, delete=False, replace=False):
-        """Check the path and set the modified flag
-
-        :param delete: Flag to delete the path in the results
-        :type delete: bool
-        :param replace: Flag to replace the path from the results
-        :type replace: bool
-        :param results: Response for the path
-        :type results: RestResponse
-        """
-        if not results or not results.status in (200, 201):
-            return
-        path = results.path
-        path = path.split("/Actions")[0] if "Actions" in path else path
-        path = path + "/" if self.typepath.defs.isgen10 and path[-1] != "/" else path
-        if not replace and path in self.monolith.paths:
-            self.monolith.paths[path].modified = True
-            _ = self.monolith.markmodified(path)
-        if delete and path in self.monolith.paths:
-            self.monolith.removepath(path)
-        if replace and path in self.monolith.paths:
-            self.monolith.paths[path].modified = True
-            self.monolith.paths[path].patches = []
-
-    def _checkforchange(self, paths, crawl=True):
-        """Check if the given paths have been modified and updates monolith if it has
-
-        :param paths: paths to be checked
-        :type paths: list
-        """
-        (pathtoetag, _) = self._gettypeswithetag()
-        mono = self.monolith
-        self.download_path(list(paths), crawl=crawl, path_refresh=True)
-        etags = [
-            None if not path in mono.paths else mono.paths[path].etag for path in paths
-        ]
-        sametag = [
-            path
-            for ind, path in enumerate(paths)
-            if path in pathtoetag
-            and path in self.monolith.paths
-            and pathtoetag[path] != etags[ind]
-        ]
-        for path in sametag:
-            self.monolith.paths[path].patches = []
-        if sametag:
-            LOGGER.warning(
-                "The data in the following paths have been updated. "
-                "Recheck the changes made to . %s",
-                ",".join([str(path) for path in sametag]),
-            )
-
-    def _updatemono(self, currtype=None, path=None, crawl=False, path_refresh=False):
-        """Check if type/path exists in current monolith
-
-        :param entrytype: the found entry type.
-        :type entrytype: str.
-        :param currtype: the current entry type.
-        :type currtype: str.
-        :param crawl: flag to determine if load should traverse found links.
-        :type crawl: boolean.
-        """
-        monolith = self.monolith
-        currtype = None if currtype == '"*"' else currtype
-        paths = set()
-        if currtype:
-            for path, resp in monolith.paths.items():
-                if currtype and currtype.lower() not in resp.maj_type.lower():
-                    continue
-                if path_refresh or not resp:
-                    paths.add(path)
-                if resp:
-                    try:
-                        if not resp.dict:
-                            raise AttributeError
-                    except AttributeError:
-                        paths.add(path)
-                if resp.modified:
-                    paths.add(path)
-                    paths.update(
-                        monolith.checkmodified(path) if path in monolith.ctree else set()
-                    )
-        elif path:
-            if monolith.paths and not list(monolith.paths)[0][-1] == "/":
-                path = path[:-1] if path[-1] == "/" else path
-            if path_refresh or not monolith.path(path):
-                paths.add(path)
-            if path in monolith.paths and monolith.paths[path].modified:
-                paths.add(path)
-                paths.update(
-                    monolith.checkmodified(path) if path in monolith.ctree else set()
-                )
-        if paths:
-            self._checkforchange(list(paths), crawl=crawl)
-
-    def _verifyschemasdownloaded(self, monolith):
-        """Function to verify that the schema has been downloaded
-
-        :param monolith: full data model retrieved from server.
-        :type monolith: dict.
-        """
-
-        schemaid = self.typepath.schemapath
-        regid = self.typepath.regpath
-
-        if not (schemaid and regid):
-            warning_handler("Missing Schemas or registries.")
-            return None
-
-        schemacoll = next(
-            monolith.gettypename(self.typepath.defs.schemafilecollectiontype), None
-        )
-        if not schemacoll or any(
-            paths.lower() == schemaid and monolith.paths[paths]
-            for paths in monolith.typesadded[schemacoll]
-        ):
-            self.download_path([schemaid], crawl=False)
-            schemacoll = next(
-                monolith.gettypename(self.typepath.defs.schemafilecollectiontype), None
-            )
-
-        regcoll = next(
-            monolith.gettypename(self.typepath.defs.regfilecollectiontype), None
-        )
-        if not regcoll or any(
-            paths.lower() == regid and monolith.paths[paths]
-            for paths in monolith.typesadded[regcoll]
-        ):
-            self.download_path([regid], crawl=False)
-            regcoll = next(
-                monolith.gettypename(self.typepath.defs.regfilecollectiontype), None
-            )
-
-        return any(
-            paths.lower() in (schemaid.lower(), regid.lower()) and monolith.paths[paths]
-            for paths in monolith.paths
-        )
-
-    def _validatechanges(
-        self,
-        instance=None,
-        attributeregistry=None,
-        latestschema=None,
-        proppath=None,
-        newdict=None,
-        oridict=None,
-        unique=False,
-    ):
-        """Validate the changes that are requested by the user.
-
-        :param newdict: dictionary with only the properties that have changed
-        :type newdict: dict.
-        :param oridict: selection dictionary with current state.
-        :type oridict: dict.
-        :param unique: flag to determine override for unique properties.
-        :type unique: str.
-        :param iloversion: current iLO version.
-        :type iloversion: float.
-        :param instance: current selection instance.
-        :type instance: RisMonolithMemberv100.
-        :param attrreg: Registry entry of the given attribute.
-        :type attrreg: RepoRegistryEntry.
-        """
-        entrymono = self.monolith
-        currtype = oridict[self.typepath.defs.typestring]
-        validation_manager = self.validationmanager
-        errors, warnings = validation_manager.validatedict(
-            newdict,
-            currtype=attributeregistry[instance.maj_type]
-            if attributeregistry
-            else currtype,
-            monolith=entrymono,
-            unique=unique,
-            searchtype=self.typepath.defs.attributeregtype if attributeregistry else None,
-            latestschema=latestschema,
-            proppath=proppath,
-        )
-
-        validation_errors = errors
-        for warninngs in warnings:
-            warning_handler(warninngs, override=True)
-        if validation_errors and len(validation_errors) > 0:
-            raise ValidationError(validation_errors)
-        checkallowablevalues(newdict=newdict, oridict=oridict)
-
-    def _getinstances(self, selector=None, path_refresh=False, crawl=False):
-        """Main function to get instances of particular type and reload
-
-        :param selector: the type selection for the get operation.
-        :type selector: str.
-        :param setenable: flag to determine if registry should also be returned.
-        :type setenable: boolean.
-        :param setenable: flag to determine if registry should also be returned.
-        :type setenable: boolean.
-        :param path_refresh: flag to reload the selected instances.
-        :type path_refresh: boolean.
-        :returns: returns a list of selected items
-        """
-        instances = list()
-        selector = self.selector if not selector else selector
-        if selector:
-            selector = ".".join(selector.split("#")[-1].split(".")[:2])
-            if self.monolith:
-                self._updatemono(
-                    currtype=selector, crawl=crawl, path_refresh=path_refresh
-                )
-        if not selector:
-            return instances
-        selector = None if selector == '"*"' else selector
-        if self.monolith:
-            if self.redfishinst.is_redfish:
-                instances = [
-                    inst
-                    for inst in self.monolith.iter(selector)
-                    if inst.maj_type not in ["object", "string"]
-                    and "redfish" in inst.path
-                ]
-            else:
-                instances = [
-                    inst
-                    for inst in self.monolith.iter(selector)
-                    if inst.maj_type not in ["object", "string"] and "rest" in inst.path
-                ]
-
-        _ = [setattr(inst, "patches", []) for inst in instances if path_refresh]
-        return instances
-
-    def _checkpostpatch(self, body=None, path=None, patch=False):
-        """Make the post file compatible with the system generation
-
-        :param body: contents to be checked
-        :type body: str.
-        :param path: The URL location to check
-        :type path: str.
-        :param service: flag to determine if minimum calls should be done.
-        :type service: boolean.
-        :param url: originating url.
-        :type url: str.
-        :param sessionid: session id to be used instead of iLO credentials.
-        :type sessionid: str.
-        :param headers: additional headers to be added to the request.
-        :type headers: str.
-        :param iloresponse: flag to return the iLO response.
-        :type iloresponse: str.
-        :param silent: flag to determine if no output should be done.
-        :type silent: boolean.
-        :param patch: flag to determine if a patch is being made
-        :type patch: boolean.
-        :returns: modified body and path parameter for target and action respectively
-        """
-        try:
-            if self.typepath.defs.flagforrest:
-                if "Target" not in body and not patch:
-                    if "/Oem/Hp" in path:
-                        body["Target"] = self.typepath.defs.oempath
-
-                if path.startswith("/redfish/v1"):
-                    path = path.replace("/redfish", "/rest", 1)
-
-                if "/Actions/" in path:
-                    ind = path.find("/Actions/")
-                    path = path[:ind]
-
-                if path.endswith("/"):
-                    path = path[:-1]
-            elif path.startswith("/rest/") and self.typepath.defs.isgen9:
-                results = self.get_handler(put_path=path, service=True, silent=True)
-                if results and results.status == 200:
-                    if results.dict:
-                        if "Target" in body:
-                            actions = results.dict["Oem"][self.typepath.defs.oemhp][
-                                "Actions"
-                            ]
-                        elif "Actions" in body:
-                            actions = results.dict["Actions"]
-                        else:
-                            return path, body
-
-                    allkeys = list(actions.keys())
-                    targetkey = [x for x in allkeys if x.endswith(body["Action"])]
-
-                    if targetkey[0].startswith("#"):
-                        targetkey[0] = targetkey[0][1:]
-
-                path = path.replace("/rest", "/redfish", 1)
-                path = path + "/Actions"
-
-                if "Target" in body:
-                    path = path + self.typepath.defs.oempath
-                    del body["Target"]
-
-                if targetkey:
-                    path = path + "/" + targetkey[0] + "/"
-
-            return path, body
-        except Exception as excp:
-            raise excp
-
-    def _checkforetagchange(self, instance=None):
-        """Function to check the status of the etag
-
-        :param instance: retrieved instance to check etag for change.
-        :type instance: dict.
-        """
-        if instance:
-            path = instance.path
-            (oldtag, _) = self._gettypeswithetag()
-            self._updatemono(path=path, path_refresh=True)
-            (newtag, _) = self._gettypeswithetag()
-            if (
-                oldtag[path] != newtag[path]
-            ) and not self.typepath.defs.hpilodatetimetype in instance.maj_type:
-                warning_handler(
-                    "The property you are trying to change "
-                    "has been updated. Please check entry again "
-                    " before manipulating it.\n"
-                )
-                raise ValueChangedError()
-
-    def _gettypeswithetag(self):
-        """Gathers etags of all paths in monolith and their type associations"""
-        instancepath = dict()
-        instances = dict()
-
-        for inst in self.monolith.iter():
-            instancepath[inst.path] = inst.maj_type
-            instances[inst.path] = inst.etag
-
-        return [instances, instancepath]
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+# -*- coding: utf-8 -*-
+
+"""A convenience layer that combines multiple lower level classes and functions into one."""
+
+# ---------Imports---------
+import sys
+import time
+import copy
+import shutil
+import logging
+import hashlib
+import six
+
+try:
+    from collections import OrderedDict
+except ImportError:
+    from collections.abc import OrderedDict
+
+import jsonpatch
+import jsonpointer
+import redfish.ris.gen_compat
+import redfish.ris.validation
+
+from redfish.rest.v1 import RestClient
+from redfish.ris.ris import SessionExpired, RisMonolith, SchemaValidationError
+from redfish.ris.validation import ValidationManager, Typepathforval
+from redfish.ris.resp_handler import ResponseHandler
+from redfish.ris.utils import (
+    print_handler,
+    merge_dict,
+    getattributeregistry,
+    diffdict,
+    navigatejson,
+    iterateandclear,
+    skipnonsettingsinst,
+    warning_handler,
+    validate_headers,
+    checkallowablevalues,
+)
+from redfish.ris.rmc_helper import (
+    UndefinedClientError,
+    InstanceNotFoundError,
+    NothingSelectedError,
+    ValidationError,
+    RmcFileCacheManager,
+    NothingSelectedSetError,
+    LoadSkipSettingError,
+    ValueChangedError,
+    IloResponseError,
+    EmptyRaiseForEAFP,
+    IncompatibleiLOVersionError,
+)
+
+# ---------End of imports---------
+
+# ---------Debug logger---------
+
+LOGGER = logging.getLogger(__name__)
+
+
+# ---------End of debug logger---------
+
+
+class RmcApp(object):
+    """A convenience class that combines the client, compatibility, validation, caching,
+    and monolith into one class.
+
+    :param showwarnings: Flag to print warnings to std.out (True) or log in log file (False)
+    :type showwarnings: bool
+    :param cache_dir: Cache directory to save cache data to, if None, RmcApp will not cache data.
+                      Cache can allow your RmcApp to persist between scripts.
+    :type cache_dir: str
+    """
+
+    def __init__(self, showwarnings=False, cache_dir=None):
+        self.logger = LOGGER
+        self.redfishinst = None
+        self.sessioninst = None
+        self._cm = RmcFileCacheManager(self)
+        self.monolith = None
+        self._iloversion = None
+        self._validationmanager = None
+        self._selector = None
+        self._cachedir = cache_dir
+        self.verbose = 1
+        self._sessionid = None
+        self.typepath = redfish.ris.gen_compat.Typesandpathdefines()
+        Typepathforval(typepathobj=self.typepath)
+
+        if not showwarnings:
+            self.logger.setLevel(logging.WARNING)
+            if self.logger.handlers and self.logger.handlers[0].name == "lerr":
+                self.logger.handlers.remove(self.logger.handlers[0])
+
+    @property
+    def monolith(self):
+        """Get the monolith from the current client"""
+        return self._monolith
+
+    @monolith.setter
+    def monolith(self, monolith):
+        """Set the monolith"""
+        self._monolith = monolith
+
+    @property
+    def current_client(self):
+        """Get the current client"""
+        if self.redfishinst:
+            return self.redfishinst
+        raise UndefinedClientError()
+
+    @property
+    def validationmanager(self):
+        """Get the valdation manager"""
+        if self.getiloversion():
+            if self._validationmanager:
+                self._validationmanager.reset_errors_warnings()
+            else:
+                monolith = self.monolith
+                self._validationmanager = ValidationManager(
+                    monolith, defines=self.typepath
+                )
+            self._validationmanager.updatevalidationdata()
+        else:
+            self._validationmanager = None
+        return self._validationmanager
+
+    @property
+    def selector(self):
+        """The selector that will be used to gather data if no selector or instance argument is
+        passed."""
+        return self._selector
+
+    @selector.setter
+    def selector(self, sel):
+        """Set the selector"""
+        self._selector = sel
+
+    @property
+    def cachedir(self):
+        """The cache directory that is used to cache app data to a file,
+        None if not caching data."""
+        return self._cachedir
+
+    @cachedir.setter
+    def cachedir(self, cache_dir):
+        """Set the cachedir"""
+        self._cachedir = cache_dir
+
+    @property
+    def cache(self):
+        """True if we are caching data, False if we are not"""
+        return True if self.cachedir else False
+
+    def restore(self, creds=None, enc=False):
+        """Restores the monolith from cache. Used to load a monolith data back into a new app
+        class. Keyword arguments are only needed in a local client when in a high security mode.
+
+        :param creds: Credentials to create the client with.
+        :type creds: str
+        :param enc: Flag to determine if encoding functions are being used. True if being used false
+                    if not.
+        :type enc: bool
+        """
+        self._cm.uncache_rmc(creds=creds, enc=enc)
+
+    def set_encode_funct(self, funct):
+        """Set the encoding function for cache to use. Can be used to protect sensitive data when
+        it is at rest.
+
+        :param funct: The function to use for encoding data
+        :type funct: function
+        """
+        self._cm.encodefunct = funct
+
+    def set_decode_funct(self, funct):
+        """Set the decoding function for cache to use. Is used in conjunction with the
+        `set_encode_funct` to turn the encoded data back into a usable string.
+
+        :param funct: The function to use for decoding data
+        :type funct: function
+        """
+        self._cm.decodefunct = funct
+
+    def save(self):
+        """Updates the cache with the latest monolith data."""
+        self._cm.cache_rmc()
+
+    def login(
+        self,
+        username=None,
+        password=None,
+        sessionid=None,
+        base_url="blobstore://.",
+        path=None,
+        skipbuild=False,
+        includelogs=False,
+        biospassword=None,
+        is_redfish=False,
+        proxy=None,
+        ssl_cert=None,
+        user_ca_cert_data=None,
+        json_out=False,
+    ):
+        """Performs a login on a the server specified by the keyword arguments. Will also create
+        a monolith, client, and update the compatibility classes for the app instance. If base_url
+        is not included the login is assumed to be locally on the OS.
+
+        :param username: The user name required to login to server.
+        :type: str
+        :param password: The password credentials required to login.
+        :type password: str
+        :param base_url: The redfish host name or ip address to login to.
+        :type base_url: str
+        :param path: The path to initiate the monolith crawl from. If None, it will start from the
+                     root. See monolith documentation on how the path is used.
+        :type path: str
+        :param proxy: The proxy required for connection (if any).
+        :type proxy: str
+        :param ssl_cert: The path to the CA bundle or SSL certificate to use with connection
+                        (if any).
+        :type ssl_cert: str
+        :param user_ca_cert_data: Dictionary of user certificate data for iLO Certificate-based
+          authentication including iLO User TLS certificate, iLO User CA Root Key, \
+          iLO User CA Root Key Password (for encrypted CAs)
+        :type: user_ca_pass: str
+        :param skipbuild: The flag to determine monolith download. If True, monolith will be
+                          initiated empty, if False will build the monolith.
+        :type skipbuild: bool
+        :param includelogs: The flag to determine id logs should be downloaded in the crawl.
+        :type includelogs: bool
+        :param biospassword: The BIOS password for the server if set.
+        :type biospassword: str
+        :param is_redfish: If True, a Redfish specific header (OData) will be
+            added to every request. Only required if the system has both LegacyREST and Redfish.
+        :type is_redfish: bool
+        """
+
+        self.typepath.getgen(
+            url=base_url,
+            username=username,
+            password=password,
+            sessionid=sessionid,
+            ca_cert_data=user_ca_cert_data,
+            proxy=proxy,
+            isredfish=is_redfish,
+        )
+        if user_ca_cert_data and self.typepath.iloversion < 5.23:
+            raise IncompatibleiLOVersionError(
+                "Certificate based login is incompatible with this "
+                "iLO version: %s\n" % self.typepath.iloversion
+            )
+        is_redfish = self.typepath.updatedefinesflag(redfishflag=is_redfish)
+
+        if self.redfishinst and self.redfishinst.session_key:
+            self.logout()
+
+        self.redfishinst = RestClient(
+            base_url=base_url,
+            username=username,
+            password=password,
+            session_key=sessionid,
+            default_prefix=self.typepath.defs.startpath,
+            biospassword=biospassword,
+            is_redfish=is_redfish,
+            proxy=proxy,
+            ca_cert_data=user_ca_cert_data,
+        )
+
+        self.current_client.login(self.current_client.auth_type)
+
+        inittime = time.time()
+
+        self._build_monolith(
+            path=path, includelogs=includelogs, skipbuild=skipbuild, json_out=json_out
+        )
+        endtime = time.time()
+
+        if self.verbose > 1:
+            sys.stdout.write("Monolith build process time: %s\n" % (endtime - inittime))
+        self.save()
+        if not self.monolith:
+            self.monolith.update_member(
+                resp=self.current_client.root,
+                path=self.typepath.defs.startpath,
+                init=False,
+            )
+
+    def logout(self, url=None):
+        """Performs a logout of the server and prepares the app for another system, setting app
+        variables to default values.
+
+        :param url: The URL for the logout request. Only needed when using a cache.
+        :type url: str
+        """
+        sessionlocs = []
+        self._validationmanager = None
+        self._iloversion = None
+
+        try:
+            self.monolith.killthreads()
+        except Exception:
+            pass
+
+        try:
+            self.current_client.logout()
+        except Exception:
+            sessionlocs = self._cm.logout_del_function(url)
+        else:
+            self._cm.logout_del_function(url)
+
+        for session in sessionlocs:
+            try:
+                self.delete_handler(session[0], silent=True, service=True)
+            except:
+                pass
+        self.redfishinst = None
+
+        cachedir = self.cachedir
+        if cachedir:
+            try:
+                shutil.rmtree(cachedir)
+            except Exception:
+                pass
+
+    def select(self, selector=None, fltrvals=(None, None), path_refresh=False):
+        """Selects instances based on selector and filter values. The select specified is saved in
+        the app for further use. If another selector is sent, it overwrites the current one.
+
+        :param selector: The type (@odata.type for Redfish) to select.
+        :type selector: str
+        :param fltrvals: The filter values for the select operation (Key,Val). If a selector returns
+                         multiple instances fltrvals can filter the instances by a key/value pair,
+                         limiting the returned instances to the one you want.
+        :type fltrvals: tuple
+        :param path_refresh: The flag to reload the selected instances. If True, each instance will be
+                    grabbed again from the server to make sure responses are up to date.
+        :type path_refresh: bool
+        :returns: A list of selected monolith member instances.
+        :rtype: RisMonolithMemberv100
+        """
+        if not selector:
+            selector = self.selector
+        # Still nothing selected and selector is NULL
+        if not selector:
+            raise NothingSelectedError()
+        selector = self.typepath.modifyselectorforgen(selector)
+        instances = self._getinstances(selector=selector, path_refresh=path_refresh)
+        val = (
+            fltrvals[1].strip("'\"")
+            if isinstance(fltrvals[1], six.string_types)
+            else fltrvals[1]
+        )
+        instances = [
+            inst
+            for inst in instances
+            if not fltrvals[0]
+            or navigatejson(fltrvals[0].split("/"), copy.deepcopy(inst.dict), val)
+        ]
+        if any(instances):
+            self.selector = selector
+            self.save()
+            return instances
+
+        errmsg = (
+            "Unable to locate instance for '{0}' and filter '{1}={2}'".format(
+                selector, fltrvals[0], fltrvals[1]
+            )
+            if fltrvals[0] and fltrvals[1]
+            else "Unable to locate instance for {}\n".format(selector)
+        )
+
+        raise InstanceNotFoundError(errmsg)
+
+    def types(self, fulltypes=False):
+        """Returns a list of types available to be queried and selected with monolith.
+
+        :param fulltypes: Flag to determine if types return Redfish full name, if False will return
+                          a shortened version of the type string.
+        :type fulltypes: bool
+        :returns: A list of type strings.
+        :rtype: list
+        """
+        instances = list()
+
+        if self.monolith:
+            monolith = self.monolith
+            rdirtype = next(
+                monolith.gettypename(self.typepath.defs.resourcedirectorytype), None
+            )
+
+            if not rdirtype:
+                for inst in monolith.iter():
+                    if not any(
+                        [
+                            x
+                            for x in ["ExtendedError", "object", "string"]
+                            if x in inst.type
+                        ]
+                    ):
+                        instances.append(inst.type)
+            else:
+                for instance in monolith.iter(rdirtype):
+                    for item in instance.resp.dict["Instances"]:
+                        if (
+                            item
+                            and instance._typestring in list(item.keys())
+                            and not "ExtendedError" in item[instance._typestring]
+                        ):
+                            if not fulltypes and instance._typestring == "@odata.type":
+                                tval = item["@odata.type"].split("#")
+                                tval = tval[-1].split(".")[:-1]
+                                tval = ".".join(tval)
+                                instances.append(tval)
+                            elif item:
+                                instances.append(item[instance._typestring])
+        return instances
+
+    def getprops(
+        self,
+        selector=None,
+        props=None,
+        nocontent=None,
+        skipnonsetting=True,
+        remread=False,
+        insts=None,
+    ):
+        """Gets properties from a specified selector. If no selector is specified, uses the selector
+        property in the app class. Instead of a selector a list of instances to search can be used
+        instead. If both **selector** and **insts** are passed, **insts** is used.
+
+        Specific values for multi-level dictionaries can be returned by passing each key
+        separated by a "/" Ex: Key/Sub-Key/Sub-Sub-Key
+
+        :param selector: The type selection for the get operation.
+        :type selector: str
+        :param skipnonsetting: Flag to remove non settings path.
+        :type skipnonsetting: bool
+        :param nocontent: Keys not found are added to the list provided.
+        :type nocontent: list
+        :param remread: Flag to remove readonly properties.
+        :type remread: bool
+        :param props: The keys to search for within current selection.
+        :type props: list
+        :param insts: List of RisMonolithMemberv100 to be searched for specific keys.
+        :type insts: list
+        :returns: A list of properties found in dictionary form.
+        :rtype: list
+        """
+        results = list()
+        nocontent = set() if nocontent is None else nocontent
+        if props:
+            if isinstance(props, list):
+                noprop = {prop: False for prop in props}
+            else:
+                noprop = {props: False}
+        else:
+            noprop = {}
+        instances = insts if insts else self._getinstances(selector=selector)
+        instances = skipnonsettingsinst(instances) if skipnonsetting else instances
+
+        if selector != "UpdateService.":
+            if not instances or len(instances) == 0:
+                if not selector:
+                    raise NothingSelectedError()
+
+        for instance in instances:
+            currdict = instance.dict
+            for patch in instance.patches:
+                currdict = jsonpatch.apply_patch(currdict, patch)
+            _ = self.removereadonlyprops(currdict, emptyraise=True) if remread else None
+            temp_dict = dict()
+            if props:
+                if isinstance(props, six.string_types):
+                    props = [props]
+                for prop in props:
+                    copydict = copy.deepcopy(currdict)
+                    propsdict = navigatejson(prop.split("/"), copydict)
+                    if propsdict is None:
+                        continue
+                    noprop[prop] = True
+                    merge_dict(temp_dict, propsdict)
+                if temp_dict:
+                    if temp_dict not in results:
+                        results.append(temp_dict)
+            else:
+                results.append(currdict)
+        if props:
+            _ = [nocontent.add(prop) for prop in props if not noprop[prop]]
+        return results
+
+    def info(self, selector=None, props=None, dumpjson=True, latestschema=False):
+        """Gets schema information for properties from a specified selector. If no selector is
+        specified, uses the selector property in the app class. If no properties are specified
+        the entire schema dictionary is returned in a list.
+
+        :param selector: The type selection for the info operation.
+        :type selector: str
+        :param props: The keys to gather schema data for within current selection.
+        :type props: str or list
+        :param dumpjson: Flag to determine if output should be human readable or json schema.
+        :type dumpjson: bool
+        :param latestschema: Flag to determine if we should drop the schema version when we try to
+                             match schema information. If True, the version will be dropped.
+        :type latestschema: bool
+        :returns: A list of property schema information if dumpjson is True or string if dumpjson is
+                  False.
+        :rtype: list or string
+        """
+        model = None
+        outdata = ""
+        nokey = False
+        results = None
+        typestring = self.typepath.defs.typestring
+        iloversion = self.getiloversion()
+        if not iloversion:
+            return results
+        instances = self._getinstances(selector)
+        attributeregistry = getattributeregistry(instances)
+        instances = skipnonsettingsinst(instances)
+
+        if not instances or len(instances) == 0:
+            raise NothingSelectedError()
+
+        for inst in instances:
+            bsmodel = None
+            currdict = inst.resp.dict
+            proppath = (
+                inst.resp.getheader("Link").split(";")[0].strip("<>")
+                if inst.resp.getheader("Link")
+                else None
+            )
+            seldict = {}
+            if not props:
+                model, bsmodel = self.get_model(
+                    currdict, attributeregistry, latestschema, proppath=proppath
+                )
+                results = model
+                break
+            if isinstance(props, six.string_types):
+                props = props.split("/") if "/" in props else props
+                props = [props] if not isinstance(props, (list, tuple)) else props
+                seldict = navigatejson(props, copy.deepcopy(currdict))
+                if seldict is None:
+                    nokey = True
+                    continue
+            if self.typepath.defs.typestring in currdict:
+                seldict[typestring] = currdict[typestring]
+                model, bsmodel = self.get_model(
+                    currdict,
+                    attributeregistry,
+                    latestschema,
+                    newarg=props[:-1],
+                    proppath=proppath,
+                )
+            if not model and not bsmodel:
+                errmsg = "/".join(props)
+                warning_handler(
+                    "Unable to locate registry model or "
+                    "No data available for entry: {}\n".format(errmsg)
+                )
+                continue
+            found = model.get_validator(props[-1]) if model else None
+            found = bsmodel.get_validator(props[-1]) if not found and bsmodel else found
+            outdata = (
+                found
+                if found and dumpjson
+                else found.print_help(props[-1])
+                if found
+                else outdata
+            )
+
+        if outdata or results:
+            return outdata if outdata else results
+
+        errmsg = (
+            "Entry {} not found in current selection\n".format("/".join(props))
+            if nokey
+            else "Entry {} not found in current" " selection\n".format("/".join(props))
+        )
+        warning_handler(errmsg)
+
+    def loadset(
+        self,
+        seldict=None,
+        fltrvals=(None, None),
+        diffonly=False,
+        latestschema=False,
+        uniqueoverride=False,
+        selector=None,
+    ):
+        """Creates json patches in monolith if the supplied dictionary passes schema validation.
+        In the event schemas are unavailable the patches are always added. Patches that are created
+        this way are not sent to the server until the :meth:`commit` function is called, sending the
+        patches to the server. A list of patches that have not been sent to the server can be
+        returned with the :meth:`status` function.
+
+        :param selector: The type selection for the loadset operation.
+        :type selector: str
+        :param seldict: Dictionary with the patches to apply to the selected instances.
+        :type seldict: dict
+        :param fltrvals: The filter values for the operation (Key,Val). If a selector returns
+                         multiple instances fltrvals can filter the instances by a key/value pair,
+                         limiting the returned instances to the one you want. If no filter is
+                         supplied the patch dictionary will be applied to all instances.
+        :type fltrvals: tuple
+        :param latestschema: Flag to determine if we should drop the schema version when we try to
+                             match schema information. If True, the version will be dropped.
+        :type latestschema: bool
+        :param diffonly: flag to differentiate only existing properties.
+        :type diffonly: bool
+        :param uniqueoverride: Flag to determine if system unique properties should also be patched.
+                               If this is True, then unique properties will be patched.
+        :type uniqueoverride: bool
+        :returns: returns a list of properties that have successfully been set
+        """
+        results = list()
+        nochangesmade = False
+        settingskipped = [False]
+
+        selector = self.selector if not selector else selector
+        instances = self.select(selector=selector, fltrvals=fltrvals)
+        attributeregistry = getattributeregistry(instances=instances)
+        instances = skipnonsettingsinst(instances=instances)
+
+        if not instances or len(instances) == 0:
+            raise NothingSelectedSetError()
+
+        for instance in instances:
+            if validate_headers(instance, verbose=self.verbose):
+                continue
+            else:
+                nochangesmade = True
+
+            currdict = instance.resp.dict
+            if "@odata.id" in seldict:
+                if currdict["@odata.id"] != seldict["@odata.id"]:
+                    continue
+            diff_resp = diffdict(
+                newdict=copy.deepcopy(seldict),
+                oridict=copy.deepcopy(currdict),
+                settingskipped=settingskipped,
+            )
+
+            iloversion = self.getiloversion()
+            if iloversion:
+                proppath = (
+                    instance.resp.getheader("Link").split(";")[0].strip("<>")
+                    if instance.resp.getheader("Link")
+                    else None
+                )
+                try:
+                    self._validatechanges(
+                        instance=instance,
+                        attributeregistry=attributeregistry,
+                        newdict=diff_resp,
+                        oridict=currdict,
+                        unique=uniqueoverride,
+                        latestschema=latestschema,
+                        proppath=proppath,
+                    )
+                except SchemaValidationError:
+                    LOGGER.error("Cannot validate changes, error found in schema.")
+
+            patches = jsonpatch.make_patch(currdict, diff_resp)
+
+            if patches:
+                torem = []
+                _ = [
+                    torem.append(patch)
+                    for patch in patches.patch
+                    if patch["op"] == "remove"
+                ]
+                _ = [patches.patch.remove(patch) for patch in torem]
+
+            for ind, item in enumerate(instance.patches):
+                ppath = (
+                    item.patch[0]["path"] if hasattr(item, "patch") else item[0]["path"]
+                )
+                # ppath = ["path"](getattr(item, "patch"), item)[0]["path"]
+                jpath = jsonpointer.JsonPointer(ppath.lower())
+                jval = jpath.resolve(seldict, default="kasjdk?!")
+                if not jval == "kasjdk?!":
+                    del instance.patches[ind]
+
+            if patches:
+                for patch in patches.patch:
+                    forprint = (
+                        patch["value"]
+                        if "value" in patch
+                        else (patch["op"] + " " + patch["from"])
+                    )
+                    results.append({patch["path"][1:]: forprint})
+                if "Managers/1/EthernetInterfaces/1" not in instance.path:
+                    self.monolith.path(instance.path).patches.append(patches)
+            else:
+                nochangesmade = True
+
+        if not nochangesmade:
+            return results
+        elif settingskipped[0] is True:
+            raise LoadSkipSettingError()
+        else:
+            return results
+
+    def status(self):
+        """Returns all pending changes that have not been committed yet."""
+        iloversion = self.getiloversion()
+
+        finalresults = list()
+        monolith = self.monolith
+        (_, _) = self.get_selection(setenable=True)
+        attrreg = getattributeregistry([ele for ele in monolith.iter() if ele])
+        for instance in monolith.iter():
+            results = list()
+
+            if not (instance.patches and len(instance.patches) > 0):
+                continue
+            for item in instance.patches:
+                if isinstance(item, list):
+                    results.extend(jsonpatch.JsonPatch(item))
+                else:
+                    results.extend(item)
+
+            currdict = instance.resp.dict
+            itemholder = list()
+            for mainitem in results:
+                item = copy.deepcopy(mainitem)
+
+                if iloversion:
+                    _, bsmodel = self.get_model(currdict, attrreg)
+                    if bsmodel:
+                        prop = item["path"][1:].split("/")[-1]
+                        validator = bsmodel.get_validator(prop)
+                        if validator:
+                            if isinstance(
+                                validator, redfish.ris.validation.PasswordValidator
+                            ):
+                                item["value"] = "******"
+
+                itemholder.append(item)
+            if itemholder:
+                finalresults.append(
+                    {instance.maj_type + "(" + instance.path + ")": itemholder}
+                )
+
+        return finalresults
+
+    def commit(self):
+        """Applies all pending json patches to the server.
+
+        :yields: Two strings.
+
+                1. Path being PATCHed
+                2. True if an error occurred during the PATCH, False if no error.
+        """
+        # Protect iLO Network Interface changes.
+        instances = [
+            inst
+            for inst in self.monolith.iter()
+            if inst.patches and "Managers/1/EthernetInterfaces/1" not in inst.path
+        ]
+
+        if not instances or len(instances) == 0:
+            raise NothingSelectedError()
+
+        for instance in instances:
+            if validate_headers(instance, verbose=self.verbose):
+                continue
+
+            currdict = dict()
+            oridict = instance.resp.dict
+            totpayload = dict()
+            # apply patches to represent current edits
+            for patches in instance.patches:
+                if not self._iloversion:
+                    self._iloversion = self.getiloversion()
+                if self._iloversion < 5.130:
+                    self._checkforetagchange(instance=instance)
+                fulldict = jsonpatch.apply_patch(oridict, patches)
+                for patch in patches:
+                    currdict = copy.deepcopy(fulldict)
+                    patchpath = patch["path"]
+                    pobj = jsonpointer.JsonPointer(patchpath)
+                    indpayloadcount = 0
+                    for item in pobj.parts:
+                        payload = pobj.walk(currdict, item)
+                        indpayloadcount = indpayloadcount + 1
+                        if isinstance(payload, list):
+                            break
+                        else:
+                            if not isinstance(payload, dict):
+                                break
+                            currdict = copy.deepcopy(payload)
+                    indices = pobj.parts[:indpayloadcount]
+                    createdict = lambda x, y: {x: y}
+                    while len(indices):
+                        payload = createdict(indices.pop(), payload)
+                    merge_dict(totpayload, payload)
+                currdict = copy.deepcopy(totpayload)
+
+            if currdict:
+                yield instance.resp.request.path
+
+                put_path = instance.resp.request.path
+                etag = self.monolith.paths[put_path].etag
+                headers = dict([("If-Match", etag)]) if self._iloversion > 5.130 else None
+                for key, value in currdict.items():
+                    if key == "OldAdminPassword" and (value != ""):
+                        if (value == "null") or (value == "none") or (value == "None"):
+                            currdict["OldAdminPassword"] = ""
+                        else:
+                            hash = hashlib.sha256(value.encode()).hexdigest().upper()
+                            headers = dict([("X-HPRESTFULAPI-AuthToken", hash)])
+                    elif key == "AdminPassword" and (
+                        (value == None)
+                        or (value == "none")
+                        or (value == "None")
+                        or (value == "null")
+                    ):
+                        currdict["AdminPassword"] = ""
+                try:
+                    self.patch_handler(
+                        put_path,
+                        currdict,
+                        optionalpassword=self.current_client.bios_password,
+                        headers=headers,
+                    )
+                except IloResponseError:
+                    yield True  # Failure
+                else:
+                    yield False  # Success
+
+    def patch_handler(
+        self,
+        put_path,
+        body,
+        headers=None,
+        silent=False,
+        service=False,
+        optionalpassword=None,
+    ):
+        """Performs the client HTTP PATCH operation with monolith and response handling support.
+        Response handling will output to logger or string depending on showmessages app argument.
+
+        :param put_path: The REST path to perform the patch operation on.
+        :type put_path: str
+        :param body: the body to perform the operation with.
+        :type body: dict
+        :param headers: Any additional headers to be added to the request.
+        :type headers: dict
+        :param optionalpassword: The bios password if it is required for the operation.
+        :type optionalpassword: str
+        :param silent: If False response will be parsed based on service flag and output to a log or
+                       stdout. If True response will not be parsed and no message output or error
+                       messages raised from the response handler.
+        :type silent: bool
+        :param service: When handling the response, if True registries will be gathered and a full,
+                        response will be output if False they will not and response handler will
+                        instead return a generic message.
+        :type service: bool
+        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
+        """
+        (put_path, body) = self._checkpostpatch(body=body, path=put_path, patch=True)
+
+        if optionalpassword:
+            self.current_client.bios_password = optionalpassword
+
+        results = self.current_client.patch(put_path, body=body, headers=headers)
+
+        if results and getattr(results, "status", None) and results.status == 401:
+            raise SessionExpired()
+
+        self._modifiedpath(results, replace=True)
+
+        # if results and getattr(results, "status", None) and results.status == 412:
+        if results and hasattr(results, "status") and results.status == 412:
+            self._updatemono(path=put_path, path_refresh=True)
+
+        if not silent and hasattr(self.typepath.defs, "messageregistrytype"):
+            ResponseHandler(
+                self.validationmanager, self.typepath.defs.messageregistrytype
+            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
+
+        return results
+
+    def get_handler(
+        self,
+        get_path,
+        sessionid=None,
+        silent=False,
+        uncache=False,
+        headers=None,
+        service=False,
+        username=None,
+        password=None,
+        base_url=None,
+    ):
+        """Performs the client HTTP GET operation with monolith and response handling support.
+        Response handling will output to logger or string depending on showmessages app argument.
+
+        :param put_path: The REST path to perform the get operation on.
+        :type put_path: str
+        :param uncache: flag to not store the data downloaded into monolith.
+        :type uncache: bool
+        :param headers: Any additional headers to be added to the request.
+        :type headers: dict
+        :param silent: If False response will be parsed based on service flag and output to a log or
+                       stdout. If True response will not be parsed and no message output or error
+                       messages raised from the response handler.
+        :type silent: bool
+        :param service: When handling the response, if True registries will be gathered and a full,
+                        response will be output if False they will not and response handler will
+                        instead return a generic message.
+        :type service: bool
+        :returns: A :class:`redfish.rest.containers.RestResponse` object
+        """
+        try:
+            results = self.current_client.get(get_path, headers=headers)
+        except UndefinedClientError:
+            if sessionid:
+                self.redfishinst = RestClient(
+                    sessionid=sessionid,
+                    username=username,
+                    password=password,
+                    base_url=base_url,
+                )
+                if not headers:
+                    headers = dict()
+                headers["X-Auth-Token"] = sessionid
+                results = self.current_client.get(get_path, headers=headers)
+
+        if results and getattr(results, "status", None) and results.status == 404:
+            return results
+
+        if results and results.status == 200 and sessionid:
+            if not silent:
+                if hasattr(self.typepath.defs, "messageregistrytype"):
+                    ResponseHandler(self.validationmanager, self.typepath.defs.messageregistrytype).output_resp(results, dl_reg=service, verbosity=self.verbose)
+                else:
+                    print_handler("[" + str(results.status) + "]" + " The operation completed successfully.\n")
+            return results
+
+        if not uncache and results.status == 200 and not sessionid:
+            if self.monolith:
+                self.monolith.update_member(resp=results, path=get_path, init=False)
+
+        if results and getattr(results, "status", None) and results.status == 401:
+            raise SessionExpired()
+
+        if not silent:
+            if hasattr(self.typepath.defs, "messageregistrytype"):
+                ResponseHandler(
+                    self.validationmanager, self.typepath.defs.messageregistrytype
+                ).output_resp(results, dl_reg=service, verbosity=self.verbose)
+            else:
+                print_handler("[" + str(results.status) + "]" + " The operation completed successfully.\n")
+
+        return results
+
+    def post_handler(self, put_path, body, headers=None, silent=False, service=False):
+        """Performs the client HTTP POST operation with monolith and response handling support.
+        Response handling will output to logger or string depending on showmessages app argument.
+
+        :param put_path: The REST path to perform the post operation on.
+        :type put_path: str
+        :param body: the body to perform the operation with.
+        :type body: dict
+        :param headers: Any additional headers to be added to the request.
+        :type headers: dict
+        :param silent: If False response will be parsed based on service flag and output to a log or
+                       stdout. If True response will not be parsed and no message output or error
+                       messages raised from the response handler.
+        :type silent: bool
+        :param service: When handling the response, if True registries will be gathered and a full,
+                        response will be output if False they will not and response handler will
+                        instead return a generic message.
+        :type service: bool
+        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
+        """
+        (put_path, body) = self._checkpostpatch(body=body, path=put_path)
+
+        results = self.current_client.post(put_path, body=body, headers=headers)
+
+        if results and getattr(results, "status", None) and results.status == 401:
+            raise SessionExpired()
+
+        self._modifiedpath(results)
+
+        if not silent and hasattr(self.typepath.defs, "messageregistrytype"):
+            ResponseHandler(
+                self.validationmanager, self.typepath.defs.messageregistrytype
+            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
+
+        return results
+
+    def put_handler(
+        self,
+        put_path,
+        body,
+        headers=None,
+        silent=False,
+        optionalpassword=None,
+        service=False,
+    ):
+        """Performs the client HTTP PUT operation with monolith and response handling support.
+        Response handling will output to logger or string depending on showmessages app argument.
+
+        :param put_path: The REST path to perform the put operation on.
+        :type put_path: str
+        :param body: the body to perform the operation with.
+        :type body: dict
+        :param headers: Any additional headers to be added to the request.
+        :type headers: dict
+        :param optionalpassword: The bios password if it is required for the operation.
+        :type optionalpassword: str
+        :param silent: If False response will be parsed based on service flag and output to a log or
+                       stdout. If True response will not be parsed and no message output or error
+                       messages raised from the response handler.
+        :type silent: bool
+        :param service: When handling the response, if True registries will be gathered and a full,
+                        response will be output if False they will not and response handler will
+                        instead return a generic message.
+        :type service: bool
+        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
+        """
+        if optionalpassword:
+            self.current_client.bios_password = optionalpassword
+        results = self.current_client.put(put_path, body=body, headers=headers)
+        if results and getattr(results, "status", None) and results.status == 401:
+            raise SessionExpired()
+
+        self._modifiedpath(results, replace=True)
+
+        if not silent and hasattr(self.typepath.defs, "messageregistrytype"):
+            ResponseHandler(
+                self.validationmanager, self.typepath.defs.messageregistrytype
+            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
+
+        return results
+
+    def delete_handler(self, put_path, headers=None, silent=False, service=False):
+        """Performs the client HTTP DELETE operation with monolith and response handling support.
+        Response handling will output to logger or string depending on showmessages app argument.
+
+        :param put_path: The REST path to perform the delete operation on.
+        :type put_path: str
+        :param headers: Any additional headers to be added to the request.
+        :type headers: dict
+        :param silent: If False response will be parsed based on service flag and output to a log or
+                       stdout. If True response will not be parsed and no message output or error
+                       messages raised from the response handler.
+        :type silent: bool
+        :param service: When handling the response, if True registries will be gathered and a full,
+                        response will be output if False they will not and response handler will
+                        instead return a generic message.
+        :type service: bool
+        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
+        """
+        results = self.current_client.delete(put_path, headers=headers)
+
+        if results and getattr(results, "status", None) and results.status == 401:
+            raise SessionExpired()
+        self._modifiedpath(results, delete=True)
+
+        if not silent and hasattr(self.typepath.defs, "messageregistrytype"):
+            ResponseHandler(
+                self.validationmanager, self.typepath.defs.messageregistrytype
+            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
+
+        return results
+
+    def head_handler(self, put_path, silent=False, service=False):
+        """Performs the client HTTP HEAD operation with monolith and response handling support.
+        Response handling will output to logger or string depending on showmessages app argument.
+
+        :param put_path: The REST path to perform the head operation on.
+        :type put_path: str
+        :param silent: If False response will be parsed based on service flag and output to a log or
+                       stdout. If True response will not be parsed and no message output or error
+                       messages raised from the response handler.
+        :type silent: bool
+        :param service: When handling the response, if True registries will be gathered and a full,
+                        response will be output if False they will not and response handler will
+                        instead return a generic message.
+        :type service: bool
+        :returns: A :class:`redfish.rest.containers.RestResponse` object containing response data
+        """
+        results = self.current_client.head(put_path)
+
+        if results and getattr(results, "status", None) and results.status == 401:
+            raise SessionExpired()
+
+        if not silent and hasattr(self.typepath.defs, "messageregistrytype"):
+            ResponseHandler(
+                self.validationmanager, self.typepath.defs.messageregistrytype
+            ).output_resp(results, dl_reg=service, verbosity=self.verbose)
+
+        return results
+
+    def removereadonlyprops(
+        self, currdict, emptyraise=False, removeunique=True, specify_props=None
+    ):
+        """Remove read only properties from a dictionary. Requires schemas to be available.
+
+        :param currdict: The dictionary to remove read only properties from.
+        :type currdict: dictionary
+        :param emptyraise: Flag to raise an empty error for handling and failure to parse.
+        :type emptyraise: boolean
+        :type removeunique: Flag to remove system unique values as well as read only.
+        :type removeunique: boolean
+        :parm specify_props: Optionally set list of properties to be removed instead of the default.
+        :type specify_props: list
+        """
+        try:
+            type_str = self.typepath.defs.typestring
+            currtype = currdict.get(type_str, None)
+            oridict = copy.deepcopy(currdict)
+            if specify_props:
+                templist = specify_props
+            else:
+                templist = [
+                    "Modified",
+                    "Type",
+                    "Description",
+                    "Status",
+                    "links",
+                    "SettingsResult",
+                    "Attributes",
+                    "@odata.context",
+                    "@odata.type",
+                    "@odata.id",
+                    "@odata.etag",
+                    "Links",
+                    "Actions",
+                    "AvailableActions",
+                    "BiosVersion",
+                    "AddressOrigin",
+                ]
+            # Attributes removed and readded later as a validation workaround
+            currdict = iterateandclear(currdict, templist)
+            iloversion = self.getiloversion()
+            if not iloversion:
+                return currdict
+            self.validationmanager.validatedict(
+                currdict,
+                currtype=currtype,
+                monolith=self.monolith,
+                unique=removeunique,
+                searchtype=None,
+            )
+            if oridict.get("Attributes", None):
+                currdict["Attributes"] = oridict["Attributes"]
+            return currdict
+        except:
+            if emptyraise is True:
+                raise EmptyRaiseForEAFP()
+            elif emptyraise == "pass":
+                pass
+            else:
+                raise
+
+    def getidbytype(self, tpe):
+        """Return a list of URIs that correspond to the supplied type string.
+
+        :param tpe: type string to search for.
+        :type tpe: string.
+        """
+        urls = list()
+        val = next(self.monolith.gettypename(tpe), None)
+        urls.extend(self.monolith.typesadded[val] if val else [])
+        return urls
+
+    def getcollectionmembers(self, path, fullresp=False):
+        """Returns collection/item lists of the provided path.
+
+        :param path: path to return.
+        :type path: string.
+        :param fullresp: Return full json data instead of only members.
+        :type path: bool.
+        :returns: list of collection members
+        """
+        if (
+            self.typepath.defs.isgen10
+            and hasattr(self.typepath, "gencompany")
+            and self.typepath.gencompany
+            and "?$expand=." not in path
+        ):
+            path += "?$expand=." if path.endswith("/") else "/?$expand=."
+
+        members = self.get_handler(path, service=True, silent=True)
+        if members and not fullresp:
+            try:
+                members = (
+                    members.dict["Members"]
+                    if self.typepath.defs.isgen10
+                    else members.dict["Current"]
+                )
+            except KeyError:
+                members = members
+        elif fullresp:
+            members = [members.dict]
+
+        return members
+
+    def getbiosfamilyandversion(self):
+        """Function that returns the current BIOS version information."""
+        self._updatemono(currtype="ComputerSystem.", crawl=False)
+
+        try:
+            for inst in self.monolith.iter("ComputerSystem."):
+                if "Current" in inst.resp.obj["Bios"]:
+                    oemjson = inst.resp.obj["Bios"]["Current"]
+                    parts = oemjson["VersionString"].split(" ")
+                    return parts[0], parts[1][1:]
+                else:
+                    parts = inst.resp.obj["BiosVersion"].split(" ")
+                    return parts[0], parts[1][1:]
+        except Exception:
+            pass
+
+        return None, None
+
+    def getiloversion(self, skipschemas=False):
+        """Function that returns the current iLO version.
+
+        :param skipschemas: flag to determine whether to skip schema download. If False, this will
+                            also verify if schemas are available.
+        :type skipschemas: bool
+        :returns: returns current iLO version
+        """
+        iloversion = self._iloversion = (
+            self._iloversion if self._iloversion else self.typepath.iloversion
+        )
+
+        if not iloversion and hasattr(self.redfishinst, "iloversion"):
+            iloversion = (
+                self._iloversion
+            ) = self.typepath.iloversion = self.redfishinst.iloversion
+
+        if (
+            hasattr(self.typepath, "gencompany")
+            and self.typepath.gencompany
+            and not self._iloversion
+            and not self.typepath.noschemas
+        ):
+            self.monolith.load(self.typepath.defs.managerpath, crawl=False)
+            results = next(
+                iter(self.getprops("Manager.", ["FirmwareVersion", "Firmware"]))
+            )
+
+            def quickdrill(_dict, key):
+                """function to find key in nested dictionary"""
+                return _dict[key]
+
+            while isinstance(results, dict):
+                results = quickdrill(results, next(iter(results.keys())))
+            iloversionlist = results.replace("v", "").replace(".", "").split(" ")
+            iloversion = float(".".join(iloversionlist[1:3]))
+
+            model = self.getprops("Manager.", ["Model"])
+            if model:
+                if next(iter(model))["Model"] == "iLO CM":
+                    # Assume iLO 4 types in Moonshot
+                    iloversion = None
+
+            self._iloversion = iloversion
+        elif (
+            hasattr(self.typepath, "gencompany") and
+            not self.typepath.gencompany
+        ):  # Assume schemas are available somewhere in non-hpe redfish
+            self._iloversion = iloversion = 4.210
+
+        conf = None if not skipschemas else True
+        if not skipschemas:
+            if iloversion and iloversion >= 4.210:
+                conf = self._verifyschemasdownloaded(self.monolith)
+            elif iloversion and iloversion < 4.210:
+                warning_handler(
+                    "Please upgrade to iLO 4 version 2.1 or above for schema support."
+                )
+            else:
+                warning_handler(
+                    "Schema support unavailable on the currently logged in system."
+                )
+
+        return iloversion if iloversion and iloversion >= 4.210 and conf else None
+
+    def get_selection(self, selector=None, setenable=False, path_refresh=False):
+        """Gathers instances and optionally the attributeregistry based on selector.
+
+        :param selector: The type selection for the get operation.
+        :type selector: str.
+        :param setenable: Flag to determine if registry should also be returned.
+        :type setenable: boolean.
+        :param path_refresh: Flag to reload the selected instances.
+        :type path_refresh: boolean.
+        :returns: returns a list of selected items
+        """
+        instances = self._getinstances(selector=selector, path_refresh=path_refresh)
+        if setenable:
+            attributeregistryfound = getattributeregistry(instances=instances)
+            instances = skipnonsettingsinst(instances=instances)
+            return instances, attributeregistryfound
+
+        return instances
+
+    def create_save_header(self):
+        """Adds save file headers to show what server the data came from.
+
+        :param selector: The type selection for the get save operation.
+        :type selector: str.
+        :param selectignore: Return the save header even if there isn't a selection to add it to.
+        :type selectignore: boolean
+        :returns: returns an header ordered dictionary
+        """
+        instances = OrderedDict()
+        monolith = self.monolith
+
+        self._updatemono(currtype="ComputerSystem.", crawl=False)
+        self._updatemono(currtype=self.typepath.defs.biostype, crawl=False)
+        self._updatemono(currtype="Manager.", crawl=False)
+
+        instances["Comments"] = OrderedDict()
+        for instance in monolith.iter("ComputerSystem."):
+            if instance.resp.obj.get("Manufacturer"):
+                instances["Comments"]["Manufacturer"] = instance.resp.obj["Manufacturer"]
+            if instance.resp.obj.get("Model"):
+                instances["Comments"]["Model"] = instance.resp.obj["Model"]
+            try:
+                if instance.resp.obj["Oem"][self.typepath.defs.oemhp]["Bios"]["Current"]:
+                    oemjson = instance.resp.obj["Oem"][self.typepath.defs.oemhp]["Bios"][
+                        "Current"
+                    ]
+                    instances["Comments"]["BIOSFamily"] = oemjson["Family"]
+                    instances["Comments"]["BIOSDate"] = oemjson["Date"]
+            except KeyError:
+                pass
+        for instance in monolith.iter(self.typepath.defs.biostype):
+            try:
+                if getattr(instance.resp.obj, "Attributes", False):
+                    if instance.resp.obj["Attributes"].get("SerialNumber"):
+                        instances["Comments"]["SerialNumber"] = instance.resp.obj[
+                            "Attributes"
+                        ]["SerialNumber"]
+                if instance.resp.obj.get("SerialNumber"):
+                    instances["Comments"]["SerialNumber"] = instance.resp.obj[
+                        "SerialNumber"
+                    ]
+            except KeyError as e:
+                pass
+        for instance in monolith.iter("Manager."):
+            if instance.resp.obj.get("FirmwareVersion"):
+                instances["Comments"]["iLOVersion"] = instance.resp.obj["FirmwareVersion"]
+
+        return instances
+
+    def download_path(self, paths, crawl=True, path_refresh=False):
+        """Loads paths into the monolith.
+
+        :param paths: list of paths to download
+        :type paths: list
+        :param path_refresh: Flag to reload the paths or not.
+        :type path_refresh: bool.
+        :param crawl: Flag to determine if load should traverse found links.
+        :type crawl: boolean.
+        """
+        if not paths:
+            return
+        try:
+            list(
+                map(
+                    lambda x: self.monolith.load(
+                        path=x,
+                        init=False,
+                        path_refresh=path_refresh,
+                        crawl=crawl,
+                        includelogs=True,
+                    ),
+                    paths,
+                )
+            )
+        except Exception as excp:
+            try:
+                if excp.errno == 10053:
+                    raise SessionExpired()
+            except:
+                raise excp
+            else:
+                raise excp
+
+    def get_model(
+        self, currdict, attributeregistry, latestschema=None, newarg=None, proppath=None
+    ):
+        """Returns a model and possibly a bios model for the current instance's schema/registry.
+        This model can be used to read schema data and validate patches.
+
+        :param currdict: The dictionary to gather the schema model from.
+        :type currdict: dict
+        :param attributeregistry: The current systems attribute registry. If not gathering a bios
+                                  registry this can be set to None.
+        :type attributeregistry: dict
+        :param latestschema: Flag to determine if we should drop the schema version when we try to
+                             match schema information. If True, the version will be dropped.
+        :type latestschema: bool
+        :param newargs: List of multi level properties to be gathered.
+        :type newargs: list
+        :param proppath: The path of the schema you want to validate (from Location header).
+        :type proppath: str
+        :returns: model and bios model
+        """
+        type_str = self.typepath.defs.typestring
+        bsmodel = None
+        valobj = self.validationmanager
+        model = valobj.get_registry_model(
+            currtype=currdict[type_str],
+            newarg=newarg,
+            latestschema=latestschema,
+            proppath=proppath,
+        )
+        if not attributeregistry and model:
+            return model, bsmodel
+        if not model and not attributeregistry:
+            LOGGER.warning(
+                "Unable to locate registry/schema for %s\n", currdict[type_str]
+            )
+            return None, None
+        attrval = currdict.get("AttributeRegistry", None)
+        attrval = (
+            list(attributeregistry.values())[0]
+            if not attrval and attributeregistry
+            else attrval
+        )
+        bsmodel = valobj.get_registry_model(
+            currtype=attrval if attrval else currdict[type_str],
+            newarg=newarg,
+            latestschema=latestschema,
+            searchtype=self.typepath.defs.attributeregtype,
+        )
+        return model, bsmodel
+
+    def _build_monolith(
+        self, path=None, includelogs=False, skipbuild=False, json_out=False
+    ):
+        """Run through the RIS tree to build monolith
+
+        :param path: path to initiate login to.
+        :type path: str.
+        :param includelogs: flag to determine id logs should be downloaded.
+        :type includelogs: boolean.
+        :param skipbuild: if true, skip build of monolith (initialize empty)
+        :type skipbuild: True
+        """
+        self.monolith = RisMonolith(self.current_client, self.typepath)
+        if not skipbuild:
+            self.monolith.load(
+                path=path, includelogs=includelogs, init=True, json_out=json_out
+            )
+        else:
+            self.monolith.update_member(
+                resp=self.current_client.root,
+                path=self.current_client.default_prefix,
+                init=False,
+            )
+
+    def _modifiedpath(self, results, delete=False, replace=False):
+        """Check the path and set the modified flag
+
+        :param delete: Flag to delete the path in the results
+        :type delete: bool
+        :param replace: Flag to replace the path from the results
+        :type replace: bool
+        :param results: Response for the path
+        :type results: RestResponse
+        """
+        if not results or not results.status in (200, 201):
+            return
+        path = results.path
+        path = path.split("/Actions")[0] if "Actions" in path else path
+        path = path + "/" if self.typepath.defs.isgen10 and path[-1] != "/" else path
+        if not replace and path in self.monolith.paths:
+            self.monolith.paths[path].modified = True
+            _ = self.monolith.markmodified(path)
+        if delete and path in self.monolith.paths:
+            self.monolith.removepath(path)
+        if replace and path in self.monolith.paths:
+            self.monolith.paths[path].modified = True
+            self.monolith.paths[path].patches = []
+
+    def _checkforchange(self, paths, crawl=True):
+        """Check if the given paths have been modified and updates monolith if it has
+
+        :param paths: paths to be checked
+        :type paths: list
+        """
+        (pathtoetag, _) = self._gettypeswithetag()
+        mono = self.monolith
+        self.download_path(list(paths), crawl=crawl, path_refresh=True)
+        etags = [
+            None if not path in mono.paths else mono.paths[path].etag for path in paths
+        ]
+        sametag = [
+            path
+            for ind, path in enumerate(paths)
+            if path in pathtoetag
+            and path in self.monolith.paths
+            and pathtoetag[path] != etags[ind]
+        ]
+        for path in sametag:
+            self.monolith.paths[path].patches = []
+        if sametag:
+            LOGGER.warning(
+                "The data in the following paths have been updated. "
+                "Recheck the changes made to . %s",
+                ",".join([str(path) for path in sametag]),
+            )
+
+    def _updatemono(self, currtype=None, path=None, crawl=False, path_refresh=False):
+        """Check if type/path exists in current monolith
+
+        :param entrytype: the found entry type.
+        :type entrytype: str.
+        :param currtype: the current entry type.
+        :type currtype: str.
+        :param crawl: flag to determine if load should traverse found links.
+        :type crawl: boolean.
+        """
+        monolith = self.monolith
+        currtype = None if currtype == '"*"' else currtype
+        paths = set()
+        if currtype:
+            for path, resp in monolith.paths.items():
+                if currtype and currtype.lower() not in resp.maj_type.lower():
+                    continue
+                if path_refresh or not resp:
+                    paths.add(path)
+                if resp:
+                    try:
+                        if not resp.dict:
+                            raise AttributeError
+                    except AttributeError:
+                        paths.add(path)
+                if resp.modified:
+                    paths.add(path)
+                    paths.update(
+                        monolith.checkmodified(path) if path in monolith.ctree else set()
+                    )
+        elif path:
+            if monolith.paths and not list(monolith.paths)[0][-1] == "/":
+                path = path[:-1] if path[-1] == "/" else path
+            if path_refresh or not monolith.path(path):
+                paths.add(path)
+            if path in monolith.paths and monolith.paths[path].modified:
+                paths.add(path)
+                paths.update(
+                    monolith.checkmodified(path) if path in monolith.ctree else set()
+                )
+        if paths:
+            self._checkforchange(list(paths), crawl=crawl)
+
+    def _verifyschemasdownloaded(self, monolith):
+        """Function to verify that the schema has been downloaded
+
+        :param monolith: full data model retrieved from server.
+        :type monolith: dict.
+        """
+
+        schemaid = self.typepath.schemapath
+        regid = self.typepath.regpath
+
+        if not (schemaid and regid):
+            warning_handler("Missing Schemas or registries.")
+            return None
+
+        schemacoll = next(
+            monolith.gettypename(self.typepath.defs.schemafilecollectiontype), None
+        )
+        if not schemacoll or any(
+            paths.lower() == schemaid and monolith.paths[paths]
+            for paths in monolith.typesadded[schemacoll]
+        ):
+            self.download_path([schemaid], crawl=False)
+            schemacoll = next(
+                monolith.gettypename(self.typepath.defs.schemafilecollectiontype), None
+            )
+
+        regcoll = next(
+            monolith.gettypename(self.typepath.defs.regfilecollectiontype), None
+        )
+        if not regcoll or any(
+            paths.lower() == regid and monolith.paths[paths]
+            for paths in monolith.typesadded[regcoll]
+        ):
+            self.download_path([regid], crawl=False)
+            regcoll = next(
+                monolith.gettypename(self.typepath.defs.regfilecollectiontype), None
+            )
+
+        return any(
+            paths.lower() in (schemaid.lower(), regid.lower()) and monolith.paths[paths]
+            for paths in monolith.paths
+        )
+
+    def _validatechanges(
+        self,
+        instance=None,
+        attributeregistry=None,
+        latestschema=None,
+        proppath=None,
+        newdict=None,
+        oridict=None,
+        unique=False,
+    ):
+        """Validate the changes that are requested by the user.
+
+        :param newdict: dictionary with only the properties that have changed
+        :type newdict: dict.
+        :param oridict: selection dictionary with current state.
+        :type oridict: dict.
+        :param unique: flag to determine override for unique properties.
+        :type unique: str.
+        :param iloversion: current iLO version.
+        :type iloversion: float.
+        :param instance: current selection instance.
+        :type instance: RisMonolithMemberv100.
+        :param attrreg: Registry entry of the given attribute.
+        :type attrreg: RepoRegistryEntry.
+        """
+        entrymono = self.monolith
+        currtype = oridict[self.typepath.defs.typestring]
+        validation_manager = self.validationmanager
+        errors, warnings = validation_manager.validatedict(
+            newdict,
+            currtype=attributeregistry[instance.maj_type]
+            if attributeregistry
+            else currtype,
+            monolith=entrymono,
+            unique=unique,
+            searchtype=self.typepath.defs.attributeregtype if attributeregistry else None,
+            latestschema=latestschema,
+            proppath=proppath,
+        )
+
+        validation_errors = errors
+        for warninngs in warnings:
+            warning_handler(warninngs, override=True)
+        if validation_errors and len(validation_errors) > 0:
+            raise ValidationError(validation_errors)
+        checkallowablevalues(newdict=newdict, oridict=oridict)
+
+    def _getinstances(self, selector=None, path_refresh=False, crawl=False):
+        """Main function to get instances of particular type and reload
+
+        :param selector: the type selection for the get operation.
+        :type selector: str.
+        :param setenable: flag to determine if registry should also be returned.
+        :type setenable: boolean.
+        :param setenable: flag to determine if registry should also be returned.
+        :type setenable: boolean.
+        :param path_refresh: flag to reload the selected instances.
+        :type path_refresh: boolean.
+        :returns: returns a list of selected items
+        """
+        instances = list()
+        selector = self.selector if not selector else selector
+        if selector:
+            selector = ".".join(selector.split("#")[-1].split(".")[:2])
+            if self.monolith:
+                self._updatemono(
+                    currtype=selector, crawl=crawl, path_refresh=path_refresh
+                )
+        if not selector:
+            return instances
+        selector = None if selector == '"*"' else selector
+        if self.monolith:
+            if self.redfishinst.is_redfish:
+                if selector in ["Bios.", "hpeserverbootsettings."]:
+                    instances = [
+                        inst
+                        for inst in self.monolith.iter(selector)
+                        if inst.maj_type not in ["object", "string"]
+                        and "redfish" in inst.path and "settings" in inst.path
+                        ]
+                else:
+                    instances = [
+                        inst
+                        for inst in self.monolith.iter(selector)
+                        if inst.maj_type not in ["object", "string"]
+                        and "redfish" in inst.path and "settings" not in inst.path
+                        ]
+            else:
+                instances = [
+                    inst
+                    for inst in self.monolith.iter(selector)
+                    if inst.maj_type not in ["object", "string"] and "rest" in inst.path and "settings" not in inst.path
+                ]
+
+        _ = [setattr(inst, "patches", []) for inst in instances if path_refresh]
+        return instances
+
+    def _checkpostpatch(self, body=None, path=None, patch=False):
+        """Make the post file compatible with the system generation
+
+        :param body: contents to be checked
+        :type body: str.
+        :param path: The URL location to check
+        :type path: str.
+        :param service: flag to determine if minimum calls should be done.
+        :type service: boolean.
+        :param url: originating url.
+        :type url: str.
+        :param sessionid: session id to be used instead of iLO credentials.
+        :type sessionid: str.
+        :param headers: additional headers to be added to the request.
+        :type headers: str.
+        :param iloresponse: flag to return the iLO response.
+        :type iloresponse: str.
+        :param silent: flag to determine if no output should be done.
+        :type silent: boolean.
+        :param patch: flag to determine if a patch is being made
+        :type patch: boolean.
+        :returns: modified body and path parameter for target and action respectively
+        """
+        try:
+            if self.typepath.defs.flagforrest:
+                if "Target" not in body and not patch:
+                    if "/Oem/Hp" in path:
+                        body["Target"] = self.typepath.defs.oempath
+
+                if path.startswith("/redfish/v1"):
+                    path = path.replace("/redfish", "/rest", 1)
+
+                if "/Actions/" in path:
+                    ind = path.find("/Actions/")
+                    path = path[:ind]
+
+                if path.endswith("/"):
+                    path = path[:-1]
+            elif path.startswith("/rest/") and self.typepath.defs.isgen9:
+                results = self.get_handler(put_path=path, service=True, silent=True)
+                if results and results.status == 200:
+                    if results.dict:
+                        if "Target" in body:
+                            actions = results.dict["Oem"][self.typepath.defs.oemhp][
+                                "Actions"
+                            ]
+                        elif "Actions" in body:
+                            actions = results.dict["Actions"]
+                        else:
+                            return path, body
+
+                    allkeys = list(actions.keys())
+                    targetkey = [x for x in allkeys if x.endswith(body["Action"])]
+
+                    if targetkey[0].startswith("#"):
+                        targetkey[0] = targetkey[0][1:]
+
+                path = path.replace("/rest", "/redfish", 1)
+                path = path + "/Actions"
+
+                if "Target" in body:
+                    path = path + self.typepath.defs.oempath
+                    del body["Target"]
+
+                if targetkey:
+                    path = path + "/" + targetkey[0] + "/"
+
+            return path, body
+        except Exception as excp:
+            raise excp
+
+    def _checkforetagchange(self, instance=None):
+        """Function to check the status of the etag
+
+        :param instance: retrieved instance to check etag for change.
+        :type instance: dict.
+        """
+        if instance:
+            path = instance.path
+            (oldtag, _) = self._gettypeswithetag()
+            self._updatemono(path=path, path_refresh=True)
+            (newtag, _) = self._gettypeswithetag()
+            if (
+                oldtag[path] != newtag[path]
+            ) and not self.typepath.defs.hpilodatetimetype in instance.maj_type:
+                warning_handler(
+                    "The property you are trying to change "
+                    "has been updated. Please check entry again "
+                    " before manipulating it.\n"
+                )
+                raise ValueChangedError()
+
+    def _gettypeswithetag(self):
+        """Gathers etags of all paths in monolith and their type associations"""
+        instancepath = dict()
+        instances = dict()
+
+        for inst in self.monolith.iter():
+            instancepath[inst.path] = inst.maj_type
+            instances[inst.path] = inst.etag
+
+        return [instances, instancepath]
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/rmc_helper.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/rmc_helper.py`

 * *Files identical despite different names*

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/sharedtypes.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/sharedtypes.py`

 * *Files identical despite different names*

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/utils.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/utils.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,565 +1,565 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-# -*- coding: utf-8 -*-
-"""Utility functions for internal and external use. Contains general json navigating functions as
-well as some monolith utility functions."""
-import re
-import sys
-import six
-import copy
-import logging
-
-if six.PY3:
-    from functools import reduce
-
-try:
-    from collections import Mapping
-except ImportError:
-    from collections.abc import Mapping
-
-import jsonpath_rw
-
-from six import iterkeys, string_types
-
-from redfish.ris.rmc_helper import IncorrectPropValue
-
-try:
-    # itertools ifilter compatibility for python 2
-    from future_builtins import filter
-except ImportError:
-    # filter function provides the same functionality in python 3
-    pass
-
-# ---------Debug logger---------
-
-LOGGER = logging.getLogger()
-
-
-# ---------End of debug logger---------
-
-
-def print_handler(msg):
-    """Helper function for handling warning messages appropriately. If LOGGER level is set to 40
-    print out the warnings, else log them as a warning.
-
-    :param msg: The warning message.
-    :type msg: str
-    """
-    #if override:
-    sys.stdout.write(msg)
-    #else:
-    #if LOGGER.getEffectiveLevel() == 40:
-    #LOGGER.warning(msg)
-
-def warning_handler(msg, override=False):
-    """Helper function for handling warning messages appropriately. If LOGGER level is set to 40
-    print out the warnings, else log them as a warning.
-
-    :param msg: The warning message.
-    :type msg: str
-    """
-    #if override:
-    #sys.stdout.write(msg)
-    #else:
-    #if LOGGER.getEffectiveLevel() == 40:
-    LOGGER.warning(msg)
-
-
-def validate_headers(instance, verbose=False):
-    """Validates an instance is patchable.
-
-    :param instance: Instance of the property to check.
-    :type instance: :class:`redfish.ris.RisMonolithMemberv100`
-    :param verbose: Flag to print or log more information.
-    :type verbose: bool
-    :returns: True if the setting is not patchable, False if it is.
-    """
-    skip = False
-    try:
-        headervals = instance.resp.getheaders()
-        for kii, val in headervals.items():
-            if kii.lower() == "allow":
-                if not "PATCH" in val:
-                    if verbose:
-                        warning_handler(
-                            "Skipping read-only path: %s\n" % instance.resp.request.path
-                        )
-                    skip = True
-    except:
-        pass
-    return skip
-
-
-def merge_dict(currdict, newdict):
-    """Merges dictionaries together.
-
-    :param currdict: Dictionary that will absorb the second.
-    :type currdict: dict
-    :param newdict: Dictionary to merge into the first.
-    :type newdict: dict
-    """
-    for k, itemv2 in list(newdict.items()):
-        itemv1 = currdict.get(k)
-
-        if isinstance(itemv1, Mapping) and isinstance(itemv2, Mapping):
-            merge_dict(itemv1, itemv2)
-        else:
-            currdict[k] = itemv2
-
-
-def get_errmsg_type(results):
-    """Return the registry type of a response.
-
-    :param results: rest response.
-    :type results: :class:`redfish.rest.containers.RestResponse`
-    :returns: A Registry Id type string, None if not match is found, or no_id if the
-              response is not an error message
-    :rtype: None or string
-    """
-
-    message_type = None
-    try:
-        jsonpath_expr = jsonpath_rw.parse("$..MessageId")
-        messageid = [match.value for match in jsonpath_expr.find(results.dict)]
-        if not messageid:
-            jsonpath_expr = jsonpath_rw.parse("$..MessageID")
-            messageid = [match.value for match in jsonpath_expr.find(results.dict)]
-        if messageid:
-            message_type = messageid[0].split(".")[0]
-    except:
-        pass
-
-    return message_type
-
-
-def filter_output(output, sel, val):
-    """Filters a list of dictionaries based on a key:value pair only returning the dictionaries
-    that include the key and value.
-
-    :param output: List of dictionaries to check for the key:value.
-    :type output: list
-    :param sel: the key for the property to be filtered by.
-    :type sel: str
-    :param val: value for the property be filtered by.
-    :type val: str
-    :returns: A filtered list from output parameter
-    :rtype: list
-    """
-    # TODO: check if this can be replaced by navigatejson
-    newoutput = []
-    if isinstance(output, list):
-        for entry in output:
-            if isinstance(entry, dict):
-                if "/" in sel:
-                    sellist = sel.split("/")
-                    newentry = copy.copy(entry)
-
-                    for item in sellist:
-                        if item in list(newentry.keys()):
-                            if item == sellist[-1] and str(newentry[item]) == str(val):
-                                newoutput.append(entry)
-                            else:
-                                newentry = newentry[item]
-                else:
-                    if sel in list(entry.keys()) and entry[sel] == val:
-                        newoutput.append(entry)
-            else:
-                return output
-
-    return newoutput
-
-
-def checkallowablevalues(newdict=None, oridict=None):
-    """Validate dictionary changes with Redfish allowable values. This will raise an
-    :class:`redfish.ris.rmc_helper.IncorrectPropValue` error if the dictionary is not valid.
-
-    :param newdict: dictionary with only the properties that have changed.
-    :type newdict: dict
-    :param oridict: Full dictionary with current state. (Includes @Redfish.AllowableValues)
-    :type oridict: dict
-    """
-    for strmatch in re.finditer("@Redfish.AllowableValues", str(oridict)):
-        propname = str(oridict)[: strmatch.start()].split("'")[-1]
-        strtomatch = "$..'{0}@Redfish.AllowableValues'".format(propname)
-        jsonpath_expr = jsonpath_rw.parse(strtomatch)
-        matches = jsonpath_expr.find(oridict)
-        if matches:
-            for match in matches:
-                fullpath = str(match.full_path)
-                if "Actions" in fullpath:
-                    continue
-                checkpath = fullpath.split("@Redfish.AllowableValues")[0]
-                jexpr2 = jsonpath_rw.parse(checkpath)
-                valmatches = jexpr2.find(newdict)
-                if valmatches:
-                    for mat in valmatches:
-                        res = [
-                            val for val in match.value if mat.value.lower() == val.lower()
-                        ]
-                        if not res:
-                            raise IncorrectPropValue(
-                                "Incorrect Value "
-                                "entered. Please enter one of the below "
-                                "values for {0}:\n{1}".format(
-                                    "/".join(checkpath.split(".")), str(match.value)[1:-1]
-                                )
-                            )
-
-
-def navigatejson(selector, currdict, val=None):
-    """Function for navigating the json dictionary. Searches a dictionary for specific keys
-    and possibly values, returning only the dictionary sections for the requested keys and values.
-
-    :param selector: the property required from current dictionary.
-    :type selector: list
-    :param val: value to be filtered by.
-    :type val: str or int or bool
-    :param currdict: json dictionary of list to be filtered
-    :type currdict: json dictionary/list
-    :returns: returns a dictionary of selected items
-    """
-    # TODO: Check for val of different types(bool, int, etc)
-    temp_dict = dict()
-    createdict = lambda y, x: {x: y}
-    getkey = lambda cdict, sel: next(
-        (item for item in iterkeys(cdict) if sel.lower() == item.lower()), sel
-    )
-    getval = lambda cdict, sele: [
-        cdict[sel] if sel in cdict else "~!@#$%^&*)()" for sel in [getkey(cdict, sele)]
-    ][0]
-    fullbreak = False
-    seldict = copy.deepcopy(currdict)
-    for ind, sel in enumerate(selector):
-        if isinstance(seldict, dict):
-            selector[ind] = getkey(seldict, sel)
-            seldict = getval(seldict, sel)
-            if seldict == "~!@#$%^&*)()":
-                return None
-            if val and ind == len(selector) - 1:
-                cval = (
-                    ",".join(seldict) if isinstance(seldict, (list, tuple)) else seldict
-                )
-                if not (
-                    (val[-1] == "*" and str(cval).lower().startswith(val[:-1].lower()))
-                    or str(cval).lower() == val.lower()
-                ):
-                    fullbreak = True
-        elif isinstance(seldict, (list, tuple)):
-            returndict = []
-            for items in seldict:
-                correctcase = selector[ind:]
-                returnseldict = navigatejson(correctcase, items)
-                selector[ind:] = correctcase
-                if returnseldict is not None:
-                    returndict.append(returnseldict)
-            if returndict:
-                seldict = returndict
-            else:
-                fullbreak = True
-            if seldict:
-                seldict = {selector[ind - 1]: seldict}
-                selsdict = reduce(createdict, [seldict] + selector[: ind - 1][::-1])
-                merge_dict(temp_dict, selsdict)
-                return temp_dict
-            else:
-                break
-        else:
-            fullbreak = True
-            break
-    if fullbreak:
-        return None
-    else:
-        selsdict = reduce(createdict, [seldict] + selector[::-1])
-        merge_dict(temp_dict, selsdict)
-    return temp_dict
-
-
-def iterateandclear(dictbody, proplist):
-    """Iterate over a dictionary and remove listed properties.
-
-    :param dictbody: json body
-    :type dictbody: dict or list
-    :param proplist: property list
-    :type proplist: list
-    """
-    if isinstance(dictbody, dict):
-        _ = [dictbody.pop(key) for key in proplist if key in dictbody]
-        for key in dictbody:
-            dictbody[key] = iterateandclear(dictbody[key], proplist)
-    if isinstance(dictbody, list):
-        for ind, val in enumerate(dictbody):
-            dictbody[ind] = iterateandclear(val, proplist)
-    return dictbody
-
-
-def skipnonsettingsinst(instances):
-    """Removes non /settings sections. Useful for only returning settings monolith members.
-    Example: Members with paths `/redfish/v1/systems/1/bios/` and
-    `/redfish/v1/systems/1/bios/settings`
-    will return only the `/redfish/v1/systems/1/bios/settings` member.
-
-    :param instances: list of :class:`redfish.ris.ris.RisMonolithMemberv100`
-      instances to check for settings paths.
-    :type instances: list
-    :returns: list of :class:`redfish.ris.ris.RisMonolithMemberv100` setting instances
-    :rtype: list
-    """
-    instpaths = [inst.path.lower() for inst in instances]
-    cond = list(filter(lambda x: x.endswith(("/settings", "settings/")), instpaths))
-    paths = [path.split("settings/")[0].split("/settings")[0] for path in cond]
-    newinst = [inst for inst in instances if inst.path.lower() not in paths]
-    return newinst
-
-
-def getattributeregistry(instances, adict=None):
-    # add try except return {} after test
-    """Gets an attribute registry in given monolith instances.
-
-    :param instances: list of :class:`redfish.ris.ris.RisMonolithMemberv100` instances to be
-      checked for attribute registry.
-    :type instances: list
-    :param adict: A dictionary containing an AttributeRegistry
-    :type adict: dict
-    :return: returns a dictionary containing the attribute registry string(s)
-    :rtype: dict
-    """
-
-    if adict:
-        return adict.get("AttributeRegistry", None)
-    newdict = {}
-    for inst in instances:
-        try:
-            if "AttributeRegistry" in inst.resp.dict:
-                if inst.defpath is not None:
-                    if not ("bios/settings" in inst.defpath):
-                        newdict[inst.maj_type] = inst.resp.obj["AttributeRegistry"]
-                        return newdict
-                newdict[inst.maj_type] = inst.resp.obj["AttributeRegistry"]
-        except AttributeError as excp:
-            LOGGER.warning(
-                "Invalid/Unpopulated Response: %s\nType:%s\nPath:%s\n"
-                % (inst.resp, inst.type, inst.path)
-            )
-    return newdict
-
-
-def diffdict(newdict=None, oridict=None, settingskipped=[False]):
-    """Diff two dictionaries, returning only the values that are different between the two.
-
-    :param newdict: The first dictionary to check for differences.
-    :type newdict: dict
-    :param oridict: The second dictionary to check for differences.
-    :type oridict: dict
-    :param settingskipped: Flag to determine if any settings were missing.
-    :type settingskipped: list
-    :returns: dictionary with only the properties that have changed.
-    :rtype: dict
-    """
-    try:
-        if newdict == oridict:
-            return {}
-    except:
-        try:
-            if set(newdict) == set(oridict):
-                return {}
-        except:
-            pass
-
-    newdictkeys = list(newdict.keys())
-    newdictlist = []
-    if type(oridict) is list:
-        oridict = oridict[0]
-        newdictlist.append(newdict)
-    oridictkeys = list(oridict.keys())
-    newdictkeyslower = [ki.lower() for ki in newdictkeys]
-    oridictkeyslower = [ki.lower() for ki in list(oridict.keys())]
-    missingkeys = list(set(newdictkeyslower) - set(oridictkeyslower))
-    for kis in missingkeys:
-        del newdict[newdictkeys[newdictkeyslower.index(kis)]]
-        warning_handler("Attribute {0} not found in the selection...".format(kis))
-        settingskipped = [True]
-    for key, val in list(newdict.items()):
-        if key not in oridict:
-            keycase = oridictkeys[oridictkeyslower.index(key.lower())]
-            del newdict[key]
-            key = keycase
-            newdict[key] = val
-        if isinstance(val, dict):
-            res = diffdict(newdict[key], oridict[key])
-            if res:
-                newdict[key] = res
-            else:
-                del newdict[key]
-        elif isinstance(val, list):
-            if val == oridict[key]:
-                del newdict[key]
-                continue
-            if len(val) == 1 and isinstance(val[0], dict):
-                if newdict[key] and oridict[key]:
-                    res = diffdict(newdict[key][0], oridict[key][0], settingskipped)
-                    if res:
-                        newdict[key][0] = res
-                    else:
-                        del newdict[key]
-            if [li for li in val if not isinstance(li, string_types)]:
-                continue
-            else:
-                if val:
-                    if [va.lower() for va in val] == [
-                        va.lower() if va else va for va in oridict[key]
-                    ]:
-                        del newdict[key]
-        # TODO: check if lowercase is correct or buggy for string types
-        elif isinstance(val, (string_types, int, type(None))):
-            if newdict[key] == oridict[key]:
-                del newdict[key]
-    if not newdictlist:
-        return newdict
-    else:
-        return newdictlist
-
-
-def json_traversal(data, key_to_find, ret_dict=False):
-    """
-    PENDING MODIFICATION TO MORE GENERALIZED NOTATION
-
-    Recursive function to traverse a JSON resposne object and retrieve the array of
-    relevant data (value or full key/value pair). Only a single key needs to be found within the
-    dictionary in order to return a valid dictionary or value.
-
-    #Intended Usage:
-    - Error response message parsing
-    - Checkreadunique in Validation
-
-    :param data: json data to be parsed
-    :type data: JSON error response object
-    :param key_to_find: JSON key to be found
-    :type key_to_find: String
-    :param ret_dict: return dictionary instead of just value
-    :type ret_dict: boolean
-    :returns: value or dictionary containing 'key_to_find'
-                (and all additional keys at the same level).
-    """
-
-    try:
-        for i, _iter in enumerate(data):
-            try:
-                if _iter == data:
-                    return None
-            except Exception as exp:
-                pass
-            try:
-                if key_to_find.lower() == _iter.lower():
-                    if ret_dict:
-                        return data
-                    else:
-                        return data[_iter]
-            except Exception as exp:
-                pass
-            try:
-                if key_to_find.lower() in [str(_.lower()) for _ in _iter.keys()]:
-                    if ret_dict:
-                        return data
-                    else:
-                        return data[_iter]
-            except Exception as exp:
-                pass
-            _tmp = None
-            try:
-                if isinstance(data[_iter], dict):
-                    for k in data[_iter].keys():
-                        if k.lower() == key_to_find.lower():
-                            if ret_dict:
-                                return data[_iter]
-                            else:
-                                return data[_iter][k]
-                    _tmp = json_traversal(data[_iter], key_to_find, ret_dict)
-                elif isinstance(data[_iter], list) or isinstance(data[_iter], tuple):
-                    try:
-                        _tmp = json_traversal(data[i], key_to_find, ret_dict)
-                    except Exception as exp:
-                        _tmp = json_traversal(data[_iter], key_to_find, ret_dict)
-            except Exception as exp:
-                _tmp = json_traversal(data[i], key_to_find, ret_dict)
-            finally:
-                if _tmp:
-                    return _tmp
-    except Exception as exp:
-        pass
-
-
-def json_traversal_delete_empty(data, old_key=None, _iter=None, remove_list=None):
-    """
-    Recursive function to traverse a dictionary and delete things which
-    match elements in the remove_list
-
-    :param data: to be truncated
-    :type data: list or dict
-    :param old_key: key from previous recursive call (higher in stack)
-    :type old_key: dictionary key
-    :param _iter: iterator tracker for list (tracks iteration across
-    recursive calls)
-    :type _iter: numerical iterator
-    :param remove_list: list of items to be removed
-    :type: list
-    :returns: none
-    """
-
-    if not remove_list:
-        remove_list = ["NONE", None, "", {}, [], "::", "0.0.0.0", "Unknown"]
-    list_quick_scan = False
-
-    if isinstance(data, list):
-        if _iter is None:
-            for idx, val in enumerate(data):
-                if idx is (len(data) - 1):
-                    list_quick_scan = True
-
-                json_traversal_delete_empty(val, old_key, idx, remove_list)
-
-            if list_quick_scan:
-                for j in remove_list:
-                    for _ in range(data.count(j)):
-                        data.remove(j)
-
-    elif isinstance(data, dict):
-        delete_list = []
-        for key, value in data.items():
-            if (
-                (isinstance(value, dict) and len(value) < 1)
-                or (isinstance(value, list) and len(value) < 1)
-                or None
-                or value in remove_list
-                or key in remove_list
-            ):
-                delete_list.append(key)
-
-            else:
-                json_traversal_delete_empty(value, key, remove_list=remove_list)
-                # would be great to not need this section; however,
-                # since recursive deletion is not possible, this is needed
-                # if you can figure out how to pass by reference then fix me!
-                if (
-                    (isinstance(value, dict) and len(value) < 1)
-                    or None
-                    or value in remove_list
-                ):
-                    delete_list.append(key)
-        for dl_entry in delete_list:
-            try:
-                del data[dl_entry]
-            except KeyError:
-                pass
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+# -*- coding: utf-8 -*-
+"""Utility functions for internal and external use. Contains general json navigating functions as
+well as some monolith utility functions."""
+import re
+import sys
+import six
+import copy
+import logging
+
+if six.PY3:
+    from functools import reduce
+
+try:
+    from collections import Mapping
+except ImportError:
+    from collections.abc import Mapping
+
+import jsonpath_rw
+
+from six import iterkeys, string_types
+
+from redfish.ris.rmc_helper import IncorrectPropValue
+
+try:
+    # itertools ifilter compatibility for python 2
+    from future_builtins import filter
+except ImportError:
+    # filter function provides the same functionality in python 3
+    pass
+
+# ---------Debug logger---------
+
+LOGGER = logging.getLogger()
+
+
+# ---------End of debug logger---------
+
+
+def print_handler(msg):
+    """Helper function for handling warning messages appropriately. If LOGGER level is set to 40
+    print out the warnings, else log them as a warning.
+
+    :param msg: The warning message.
+    :type msg: str
+    """
+    #if override:
+    sys.stdout.write(msg)
+    #else:
+    #if LOGGER.getEffectiveLevel() == 40:
+    #LOGGER.warning(msg)
+
+def warning_handler(msg, override=False):
+    """Helper function for handling warning messages appropriately. If LOGGER level is set to 40
+    print out the warnings, else log them as a warning.
+
+    :param msg: The warning message.
+    :type msg: str
+    """
+    #if override:
+    #sys.stdout.write(msg)
+    #else:
+    #if LOGGER.getEffectiveLevel() == 40:
+    LOGGER.warning(msg)
+
+
+def validate_headers(instance, verbose=False):
+    """Validates an instance is patchable.
+
+    :param instance: Instance of the property to check.
+    :type instance: :class:`redfish.ris.RisMonolithMemberv100`
+    :param verbose: Flag to print or log more information.
+    :type verbose: bool
+    :returns: True if the setting is not patchable, False if it is.
+    """
+    skip = False
+    try:
+        headervals = instance.resp.getheaders()
+        for kii, val in headervals.items():
+            if kii.lower() == "allow":
+                if not "PATCH" in val:
+                    if verbose:
+                        warning_handler(
+                            "Skipping read-only path: %s\n" % instance.resp.request.path
+                        )
+                    skip = True
+    except:
+        pass
+    return skip
+
+
+def merge_dict(currdict, newdict):
+    """Merges dictionaries together.
+
+    :param currdict: Dictionary that will absorb the second.
+    :type currdict: dict
+    :param newdict: Dictionary to merge into the first.
+    :type newdict: dict
+    """
+    for k, itemv2 in list(newdict.items()):
+        itemv1 = currdict.get(k)
+
+        if isinstance(itemv1, Mapping) and isinstance(itemv2, Mapping):
+            merge_dict(itemv1, itemv2)
+        else:
+            currdict[k] = itemv2
+
+
+def get_errmsg_type(results):
+    """Return the registry type of a response.
+
+    :param results: rest response.
+    :type results: :class:`redfish.rest.containers.RestResponse`
+    :returns: A Registry Id type string, None if not match is found, or no_id if the
+              response is not an error message
+    :rtype: None or string
+    """
+
+    message_type = None
+    try:
+        jsonpath_expr = jsonpath_rw.parse("$..MessageId")
+        messageid = [match.value for match in jsonpath_expr.find(results.dict)]
+        if not messageid:
+            jsonpath_expr = jsonpath_rw.parse("$..MessageID")
+            messageid = [match.value for match in jsonpath_expr.find(results.dict)]
+        if messageid:
+            message_type = messageid[0].split(".")[0]
+    except:
+        pass
+
+    return message_type
+
+
+def filter_output(output, sel, val):
+    """Filters a list of dictionaries based on a key:value pair only returning the dictionaries
+    that include the key and value.
+
+    :param output: List of dictionaries to check for the key:value.
+    :type output: list
+    :param sel: the key for the property to be filtered by.
+    :type sel: str
+    :param val: value for the property be filtered by.
+    :type val: str
+    :returns: A filtered list from output parameter
+    :rtype: list
+    """
+    # TODO: check if this can be replaced by navigatejson
+    newoutput = []
+    if isinstance(output, list):
+        for entry in output:
+            if isinstance(entry, dict):
+                if "/" in sel:
+                    sellist = sel.split("/")
+                    newentry = copy.copy(entry)
+
+                    for item in sellist:
+                        if item in list(newentry.keys()):
+                            if item == sellist[-1] and str(newentry[item]) == str(val):
+                                newoutput.append(entry)
+                            else:
+                                newentry = newentry[item]
+                else:
+                    if sel in list(entry.keys()) and entry[sel] == val:
+                        newoutput.append(entry)
+            else:
+                return output
+
+    return newoutput
+
+
+def checkallowablevalues(newdict=None, oridict=None):
+    """Validate dictionary changes with Redfish allowable values. This will raise an
+    :class:`redfish.ris.rmc_helper.IncorrectPropValue` error if the dictionary is not valid.
+
+    :param newdict: dictionary with only the properties that have changed.
+    :type newdict: dict
+    :param oridict: Full dictionary with current state. (Includes @Redfish.AllowableValues)
+    :type oridict: dict
+    """
+    for strmatch in re.finditer("@Redfish.AllowableValues", str(oridict)):
+        propname = str(oridict)[: strmatch.start()].split("'")[-1]
+        strtomatch = "$..'{0}@Redfish.AllowableValues'".format(propname)
+        jsonpath_expr = jsonpath_rw.parse(strtomatch)
+        matches = jsonpath_expr.find(oridict)
+        if matches:
+            for match in matches:
+                fullpath = str(match.full_path)
+                if "Actions" in fullpath:
+                    continue
+                checkpath = fullpath.split("@Redfish.AllowableValues")[0]
+                jexpr2 = jsonpath_rw.parse(checkpath)
+                valmatches = jexpr2.find(newdict)
+                if valmatches:
+                    for mat in valmatches:
+                        res = [
+                            val for val in match.value if mat.value.lower() == val.lower()
+                        ]
+                        if not res:
+                            raise IncorrectPropValue(
+                                "Incorrect Value "
+                                "entered. Please enter one of the below "
+                                "values for {0}:\n{1}".format(
+                                    "/".join(checkpath.split(".")), str(match.value)[1:-1]
+                                )
+                            )
+
+
+def navigatejson(selector, currdict, val=None):
+    """Function for navigating the json dictionary. Searches a dictionary for specific keys
+    and possibly values, returning only the dictionary sections for the requested keys and values.
+
+    :param selector: the property required from current dictionary.
+    :type selector: list
+    :param val: value to be filtered by.
+    :type val: str or int or bool
+    :param currdict: json dictionary of list to be filtered
+    :type currdict: json dictionary/list
+    :returns: returns a dictionary of selected items
+    """
+    # TODO: Check for val of different types(bool, int, etc)
+    temp_dict = dict()
+    createdict = lambda y, x: {x: y}
+    getkey = lambda cdict, sel: next(
+        (item for item in iterkeys(cdict) if sel.lower() == item.lower()), sel
+    )
+    getval = lambda cdict, sele: [
+        cdict[sel] if sel in cdict else "~!@#$%^&*)()" for sel in [getkey(cdict, sele)]
+    ][0]
+    fullbreak = False
+    seldict = copy.deepcopy(currdict)
+    for ind, sel in enumerate(selector):
+        if isinstance(seldict, dict):
+            selector[ind] = getkey(seldict, sel)
+            seldict = getval(seldict, sel)
+            if seldict == "~!@#$%^&*)()":
+                return None
+            if val and ind == len(selector) - 1:
+                cval = (
+                    ",".join(seldict) if isinstance(seldict, (list, tuple)) else seldict
+                )
+                if not (
+                    (val[-1] == "*" and str(cval).lower().startswith(val[:-1].lower()))
+                    or str(cval).lower() == val.lower()
+                ):
+                    fullbreak = True
+        elif isinstance(seldict, (list, tuple)):
+            returndict = []
+            for items in seldict:
+                correctcase = selector[ind:]
+                returnseldict = navigatejson(correctcase, items)
+                selector[ind:] = correctcase
+                if returnseldict is not None:
+                    returndict.append(returnseldict)
+            if returndict:
+                seldict = returndict
+            else:
+                fullbreak = True
+            if seldict:
+                seldict = {selector[ind - 1]: seldict}
+                selsdict = reduce(createdict, [seldict] + selector[: ind - 1][::-1])
+                merge_dict(temp_dict, selsdict)
+                return temp_dict
+            else:
+                break
+        else:
+            fullbreak = True
+            break
+    if fullbreak:
+        return None
+    else:
+        selsdict = reduce(createdict, [seldict] + selector[::-1])
+        merge_dict(temp_dict, selsdict)
+    return temp_dict
+
+
+def iterateandclear(dictbody, proplist):
+    """Iterate over a dictionary and remove listed properties.
+
+    :param dictbody: json body
+    :type dictbody: dict or list
+    :param proplist: property list
+    :type proplist: list
+    """
+    if isinstance(dictbody, dict):
+        _ = [dictbody.pop(key) for key in proplist if key in dictbody]
+        for key in dictbody:
+            dictbody[key] = iterateandclear(dictbody[key], proplist)
+    if isinstance(dictbody, list):
+        for ind, val in enumerate(dictbody):
+            dictbody[ind] = iterateandclear(val, proplist)
+    return dictbody
+
+
+def skipnonsettingsinst(instances):
+    """Removes non /settings sections. Useful for only returning settings monolith members.
+    Example: Members with paths `/redfish/v1/systems/1/bios/` and
+    `/redfish/v1/systems/1/bios/settings`
+    will return only the `/redfish/v1/systems/1/bios/settings` member.
+
+    :param instances: list of :class:`redfish.ris.ris.RisMonolithMemberv100`
+      instances to check for settings paths.
+    :type instances: list
+    :returns: list of :class:`redfish.ris.ris.RisMonolithMemberv100` setting instances
+    :rtype: list
+    """
+    instpaths = [inst.path.lower() for inst in instances]
+    cond = list(filter(lambda x: x.endswith(("/settings", "settings/")), instpaths))
+    paths = [path.split("settings/")[0].split("/settings")[0] for path in cond]
+    newinst = [inst for inst in instances if inst.path.lower() not in paths]
+    return newinst
+
+
+def getattributeregistry(instances, adict=None):
+    # add try except return {} after test
+    """Gets an attribute registry in given monolith instances.
+
+    :param instances: list of :class:`redfish.ris.ris.RisMonolithMemberv100` instances to be
+      checked for attribute registry.
+    :type instances: list
+    :param adict: A dictionary containing an AttributeRegistry
+    :type adict: dict
+    :return: returns a dictionary containing the attribute registry string(s)
+    :rtype: dict
+    """
+
+    if adict:
+        return adict.get("AttributeRegistry", None)
+    newdict = {}
+    for inst in instances:
+        try:
+            if "AttributeRegistry" in inst.resp.dict:
+                if inst.defpath is not None:
+                    if not ("bios/settings" in inst.defpath):
+                        newdict[inst.maj_type] = inst.resp.obj["AttributeRegistry"]
+                        return newdict
+                newdict[inst.maj_type] = inst.resp.obj["AttributeRegistry"]
+        except AttributeError as excp:
+            LOGGER.warning(
+                "Invalid/Unpopulated Response: %s\nType:%s\nPath:%s\n"
+                % (inst.resp, inst.type, inst.path)
+            )
+    return newdict
+
+
+def diffdict(newdict=None, oridict=None, settingskipped=[False]):
+    """Diff two dictionaries, returning only the values that are different between the two.
+
+    :param newdict: The first dictionary to check for differences.
+    :type newdict: dict
+    :param oridict: The second dictionary to check for differences.
+    :type oridict: dict
+    :param settingskipped: Flag to determine if any settings were missing.
+    :type settingskipped: list
+    :returns: dictionary with only the properties that have changed.
+    :rtype: dict
+    """
+    try:
+        if newdict == oridict:
+            return {}
+    except:
+        try:
+            if set(newdict) == set(oridict):
+                return {}
+        except:
+            pass
+
+    newdictkeys = list(newdict.keys())
+    newdictlist = []
+    if type(oridict) is list:
+        oridict = oridict[0]
+        newdictlist.append(newdict)
+    oridictkeys = list(oridict.keys())
+    newdictkeyslower = [ki.lower() for ki in newdictkeys]
+    oridictkeyslower = [ki.lower() for ki in list(oridict.keys())]
+    missingkeys = list(set(newdictkeyslower) - set(oridictkeyslower))
+    for kis in missingkeys:
+        del newdict[newdictkeys[newdictkeyslower.index(kis)]]
+        warning_handler("Attribute {0} not found in the selection...".format(kis))
+        settingskipped = [True]
+    for key, val in list(newdict.items()):
+        if key not in oridict:
+            keycase = oridictkeys[oridictkeyslower.index(key.lower())]
+            del newdict[key]
+            key = keycase
+            newdict[key] = val
+        if isinstance(val, dict):
+            res = diffdict(newdict[key], oridict[key])
+            if res:
+                newdict[key] = res
+            else:
+                del newdict[key]
+        elif isinstance(val, list):
+            if val == oridict[key]:
+                del newdict[key]
+                continue
+            if len(val) == 1 and isinstance(val[0], dict):
+                if newdict[key] and oridict[key]:
+                    res = diffdict(newdict[key][0], oridict[key][0], settingskipped)
+                    if res:
+                        newdict[key][0] = res
+                    else:
+                        del newdict[key]
+            if [li for li in val if not isinstance(li, string_types)]:
+                continue
+            else:
+                if val:
+                    if [va.lower() for va in val] == [
+                        va.lower() if va else va for va in oridict[key]
+                    ]:
+                        del newdict[key]
+        # TODO: check if lowercase is correct or buggy for string types
+        elif isinstance(val, (string_types, int, type(None))):
+            if newdict[key] == oridict[key]:
+                del newdict[key]
+    if not newdictlist:
+        return newdict
+    else:
+        return newdictlist
+
+
+def json_traversal(data, key_to_find, ret_dict=False):
+    """
+    PENDING MODIFICATION TO MORE GENERALIZED NOTATION
+
+    Recursive function to traverse a JSON resposne object and retrieve the array of
+    relevant data (value or full key/value pair). Only a single key needs to be found within the
+    dictionary in order to return a valid dictionary or value.
+
+    #Intended Usage:
+    - Error response message parsing
+    - Checkreadunique in Validation
+
+    :param data: json data to be parsed
+    :type data: JSON error response object
+    :param key_to_find: JSON key to be found
+    :type key_to_find: String
+    :param ret_dict: return dictionary instead of just value
+    :type ret_dict: boolean
+    :returns: value or dictionary containing 'key_to_find'
+                (and all additional keys at the same level).
+    """
+
+    try:
+        for i, _iter in enumerate(data):
+            try:
+                if _iter == data:
+                    return None
+            except Exception as exp:
+                pass
+            try:
+                if key_to_find.lower() == _iter.lower():
+                    if ret_dict:
+                        return data
+                    else:
+                        return data[_iter]
+            except Exception as exp:
+                pass
+            try:
+                if key_to_find.lower() in [str(_.lower()) for _ in _iter.keys()]:
+                    if ret_dict:
+                        return data
+                    else:
+                        return data[_iter]
+            except Exception as exp:
+                pass
+            _tmp = None
+            try:
+                if isinstance(data[_iter], dict):
+                    for k in data[_iter].keys():
+                        if k.lower() == key_to_find.lower():
+                            if ret_dict:
+                                return data[_iter]
+                            else:
+                                return data[_iter][k]
+                    _tmp = json_traversal(data[_iter], key_to_find, ret_dict)
+                elif isinstance(data[_iter], list) or isinstance(data[_iter], tuple):
+                    try:
+                        _tmp = json_traversal(data[i], key_to_find, ret_dict)
+                    except Exception as exp:
+                        _tmp = json_traversal(data[_iter], key_to_find, ret_dict)
+            except Exception as exp:
+                _tmp = json_traversal(data[i], key_to_find, ret_dict)
+            finally:
+                if _tmp:
+                    return _tmp
+    except Exception as exp:
+        pass
+
+
+def json_traversal_delete_empty(data, old_key=None, _iter=None, remove_list=None):
+    """
+    Recursive function to traverse a dictionary and delete things which
+    match elements in the remove_list
+
+    :param data: to be truncated
+    :type data: list or dict
+    :param old_key: key from previous recursive call (higher in stack)
+    :type old_key: dictionary key
+    :param _iter: iterator tracker for list (tracks iteration across
+    recursive calls)
+    :type _iter: numerical iterator
+    :param remove_list: list of items to be removed
+    :type: list
+    :returns: none
+    """
+
+    if not remove_list:
+        remove_list = ["NONE", None, "", {}, [], "::", "0.0.0.0", "Unknown"]
+    list_quick_scan = False
+
+    if isinstance(data, list):
+        if _iter is None:
+            for idx, val in enumerate(data):
+                if idx is (len(data) - 1):
+                    list_quick_scan = True
+
+                json_traversal_delete_empty(val, old_key, idx, remove_list)
+
+            if list_quick_scan:
+                for j in remove_list:
+                    for _ in range(data.count(j)):
+                        data.remove(j)
+
+    elif isinstance(data, dict):
+        delete_list = []
+        for key, value in data.items():
+            if (
+                (isinstance(value, dict) and len(value) < 1)
+                or (isinstance(value, list) and len(value) < 1)
+                or None
+                or value in remove_list
+                or key in remove_list
+            ):
+                delete_list.append(key)
+
+            else:
+                json_traversal_delete_empty(value, key, remove_list=remove_list)
+                # would be great to not need this section; however,
+                # since recursive deletion is not possible, this is needed
+                # if you can figure out how to pass by reference then fix me!
+                if (
+                    (isinstance(value, dict) and len(value) < 1)
+                    or None
+                    or value in remove_list
+                ):
+                    delete_list.append(key)
+        for dl_entry in delete_list:
+            try:
+                del data[dl_entry]
+            except KeyError:
+                pass
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/validation.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/validation.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,1397 +1,1397 @@
-###
-# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###
-
-# -*- coding: utf-8 -*-
-"""Handles schema and registry gathering as well as schema parsing and validation."""
-
-# ---------Imports---------
-
-import re
-import six
-import json
-import logging
-import textwrap
-import jsonpath_rw
-
-try:
-    from collections import OrderedDict
-except ImportError:
-    from collections.abc import OrderedDict
-from redfish.rest.containers import RisObject
-from redfish.ris.utils import json_traversal
-from .sharedtypes import JSONEncoder
-
-# ---------End of imports---------
-
-
-# ---------Debug logger---------
-
-LOGGER = logging.getLogger(__name__)
-
-
-# ---------End of debug logger---------
-
-
-class InvalidPathsError(Exception):
-    """Raised when requested path is not found"""
-
-    pass
-
-
-class RegistryValidationError(Exception):
-    """Registration Validation Class Error"""
-
-    def __init__(self, msg, regentry=None, selector=None):
-        super(RegistryValidationError, self).__init__(msg)
-        self.reg = regentry
-        self.sel = selector
-        self.message = msg
-
-
-class UnknownValidatorError(Exception):
-    """Raised when we find an attribute type that we don't know how to validate."""
-
-    pass
-
-
-class ValidationManager(object):
-    """Keeps track of all the schemas and registries and provides helpers
-    to simplify validation."""
-
-    def __init__(self, monolith, defines=None):
-        """init of ValidationManager"""
-        super(ValidationManager, self).__init__()
-
-        self._schemaid = Typepathforval.typepath.schemapath
-        self._regid = Typepathforval.typepath.regpath
-
-        self._classes = list()
-        self._classpaths = list()
-        # type and path defines object
-        self.defines = defines
-        self.monolith = monolith
-        # error
-        self._errors = list()
-        self._warnings = list()
-        self.updatevalidationdata()
-
-    @property
-    def errors(self):
-        """All errors found by the last validation."""
-        return self._errors
-
-    @property
-    def warnings(self):
-        """All warnings found by the last validation."""
-        return self._warnings
-
-    def reset_errors_warnings(self):
-        """Resets warnings and errors, getting ready for the next validation."""
-        self._errors = list()
-        self._warnings = list()
-
-    def updatevalidationdata(self):
-        """Loads the types into the validation manager from monolith."""
-        monolith = self.monolith
-        for instance in monolith.iter():
-            if (
-                (
-                    x.lower() in instance.maj_type.lower()
-                    for x in (
-                        self.defines.defs.schemafilecollectiontype,
-                        "Collection.",
-                        self.defines.defs.regfilecollectiontype,
-                    )
-                )
-                and any(
-                    x.lower() in instance.path.lower()
-                    for x in (self._schemaid, self._regid)
-                )
-                and instance
-                and instance.path not in self._classpaths
-            ):
-                self._classpaths.append(instance.path)
-                self._classes.append(instance.resp.dict)
-
-    def find_prop(self, propname, latestschema=False, proppath=None):
-        """Searches through all locations and returns the schema
-        found for the provided propname type.
-
-        :param propname: String containing the schema name.
-        :type propname: str
-        :param proppath: String containing the schema path if you wish to use that instead.
-        :type proppath: str
-        :param latestschema: Flag to determine if we should drop the schema version when we try to
-                             match schema information. If True, the version will be dropped.
-        :type latestschema: bool
-        """
-        if proppath:
-            self.monolith.load(path=proppath, crawl=False, loadtype="ref")
-            return True
-        for cls in self._classes:
-            found = self.find_property(propname, cls=cls, latestschema=latestschema)
-            if found:
-                return found
-        return None
-
-    def itermems(self, membername=None):
-        """Searches through all locations and yields each entry.
-
-        :param membername: string containing the registry name. If not passed we use the typedefines
-                           string by default.
-        :type membername: str
-        """
-        if not membername:
-            membername = self.defines.defs.collectionstring
-        for items in self._classes:
-            for item in items[membername]:
-                yield item
-
-    def iterregmems(self, membername=None):
-        """Searches through all registries and yields each entry.
-
-        :param membername: string containing the registry name. If not passed we use the typedefines
-                           string by default.
-        :type membername: str
-        """
-        if not membername:
-            membername = self.defines.defs.collectionstring
-        for items in self._classes:
-            if "registr" in items["Name"].lower():  # For Gen9 type/name issue
-                for item in items[membername]:
-                    yield item
-
-    def iterschemamems(self, membername=None):
-        """Searches through all schemas and yields each entry
-
-        :param membername: string containing the registry name. If not passed we use the typedefines
-                           string by default.
-        :type membername: str
-        """
-        if not membername:
-            membername = self.defines.defs.collectionstring
-        for items in self._classes:
-            if "schema" in items["Name"].lower():  # For Gen9 type/name issue
-                for item in items[membername]:
-                    yield item
-
-    def find_property(self, propname, cls=None, latestschema=False):
-        """Returns iLO/BIOS registries/schemas
-
-        :param propname: string containing the registry/schema name.
-        :type propname: str
-        :param cls: self._classes list of dictionaries.
-        :type cls: list
-        :param latestschema: flag to drop the versioning in the type string.
-        :type latestschema: bool.
-
-        :returns: iLO/BIOS registries/schemas that match the supplied name.
-        """
-        result = []
-        dataloc = cls.get("Items", None)
-        dataloc = cls.get("Members", None) if not dataloc else dataloc
-        keyword = "Schema"
-        if dataloc and isinstance(dataloc, list):
-            splitname = propname.split(".")[0].strip("#")
-            propname = propname.split(".")[0].strip("#") if latestschema else propname
-            for entry in dataloc:
-                if entry:
-                    if "Schema" in entry:
-                        if propname.lower() in entry["Schema"].lower():
-                            result.append(entry)
-                    elif "Registry" in entry:
-                        if (
-                            propname.lower() in entry["@odata.id"].lower()
-                            and propname.lower() in entry["Registry"].lower()
-                        ):
-                            result.append(entry)
-                            keyword = "Registry"
-                    else:
-                        if "@odata.id" in entry:
-                            reglink = entry["@odata.id"].split("/")
-                            reglink = reglink[len(reglink) - 2]
-                            if reglink.lower().startswith(propname.lower()):
-                                self.monolith.load(path=entry["@odata.id"], crawl=False)
-                                result.append(
-                                    self.monolith.paths[entry["@odata.id"]].dict
-                                )
-
-        if result:
-            result = max(
-                result,
-                key=lambda res: res[Typepathforval.typepath.defs.hrefstring]
-                if res.get(Typepathforval.typepath.defs.hrefstring, None)
-                else res[keyword],
-            )
-            schemapath = self.geturidict(result["Location"][0])
-            self.monolith.load(path=schemapath, crawl=False, loadtype="ref")
-            return result
-
-    def geturidict(self, locationobj):
-        """Return the external reference link.
-
-        :param locationobj: Dictionary to get the URI reference from.
-        :type locationobj: dict
-        """
-        if Typepathforval.typepath.defs.isgen10:
-            try:
-                return locationobj["Uri"]
-            except KeyError:
-                raise InvalidPathsError("Error accessing Uri path!/n")
-        elif Typepathforval.typepath.defs.isgen9:
-            try:
-                return locationobj["Uri"]["extref"]
-            except KeyError:
-                raise InvalidPathsError("Error accessing extref path!/n")
-
-    def validatedict(
-        self,
-        tdict,
-        currtype=None,
-        proppath=None,
-        latestschema=False,
-        searchtype=None,
-        monolith=None,
-        reg=None,
-        unique=None,
-    ):
-        """Load the schema file and validate tdict against it.
-
-        :param tdict: the dictionary to test against.
-        :type tdict: dict
-        :param currtype: String containing the type the tdict dictionary is.
-        :type currtype: str
-        :param proppath: String containing the schema path of the tdict dictionary if you wish to
-                         use that instead.
-        :type proppath: str
-        :param latestschema: Flag to determine if we should drop the schema version when we try to
-                             match schema information. If True, the version will be dropped.
-        :type latestschema: bool
-        :param searchtype: Include the attribute registry of you are validating a bios registry.
-        :type searchtype: str
-        :param monolith: Full data model retrieved from server.
-        :type monolith: dict
-        :param unique: Flag to override for skipping unique properties.
-        :type unique: bool
-        :param reg: Registry entry of the given attribute. If this is not provided we will attempt
-                    to search based on the searchtype and currtype/proppath arguments.
-        :type reg: dict.
-        :returns: returns an error list.
-        """
-        if not reg:
-            reg = self.get_registry_model(
-                currtype=currtype,
-                searchtype=searchtype,
-                proppath=proppath,
-                latestschema=latestschema,
-            )
-
-        if reg:
-            list(
-                map(
-                    lambda x: self.checkreadunique(
-                        tdict,
-                        x,
-                        reg=reg,
-                        warnings=self._warnings,
-                        unique=unique,
-                        searchtype=searchtype,
-                    ),
-                    list(tdict.keys()),
-                )
-            )
-            orireg = reg.copy()
-            ttdict = {
-                key: val
-                for key, val in list(tdict.items())
-                if not isinstance(val, (dict, list))
-            }
-            results = reg.validate_attribute_values(ttdict)
-            self._errors.extend(results)
-
-            for ki, val in list(tdict.items()):
-                if ki in ttdict:
-                    tdict[ki] = ttdict[ki]
-                    continue
-                reg = orireg.copy()
-                valexists = False
-                if val and isinstance(val, list):
-                    valexists = True
-                    # TODO: only validates if its a single dict within list
-                    if len(val) == 1 and isinstance(val[0], dict):
-                        treg = self.nestedreg(reg=reg, args=[ki])
-                        self.validatedict(
-                            val[0],
-                            unique=unique,
-                            monolith=monolith,
-                            reg=treg,
-                            currtype=currtype,
-                            searchtype=searchtype,
-                        )
-                    else:
-                        continue
-                elif val and isinstance(val, dict):
-                    valexists = True
-                    treg = self.nestedreg(reg=reg, args=[ki])
-                    self.validatedict(
-                        val,
-                        monolith=monolith,
-                        reg=treg,
-                        unique=unique,
-                        searchtype=searchtype,
-                    )
-                if not val and valexists:
-                    del tdict[ki]
-
-        else:
-            self._errors.append(
-                RegistryValidationError("Unable to locate registry model")
-            )
-        return self._errors, self._warnings
-
-    def checkreadunique(
-        self, tdict, tkey, reg=None, warnings=None, unique=None, searchtype=None
-    ):
-        """Check for and remove the readonly and unique attributes if required.
-
-        :param tdict: the dictionary to test against.
-        :type tdict: dict.
-        :param tkey: The attribute key value to be tested.
-        :type tkey: str.
-        :param warnings: list containing found warnings.
-        :type warnings: list.
-        :param unique: flag to determine override for unique properties.
-        :type unique: str.
-        :param reg: Registry entry of the given attribute.
-        :type reg: dict.
-        :returns: returns boolean.
-        """
-        if "Attributes" in tdict:
-            return False
-            # key = list(tdict[tkey])[0]
-            # reg = reg["Attributes"][key]
-        else:
-            if tkey in reg:
-                reg = reg[tkey]
-
-        if not unique and reg.get("IsSystemUniqueProperty", None):
-            if tdict[tkey] and not isinstance(tdict[tkey], bool):
-                self._warnings.append(
-                    "Property '%s' is unique and override not authorized. Skipping...\n"
-                    % str(tkey)
-                )
-                del tdict[tkey]
-                return True
-        if not reg.get("ReadOnly") or (
-            reg.get(tkey, None) and not reg[tkey].get("readonly")
-        ):
-            if unique and reg.get("IsSystemUniqueProperty", None):
-                self._warnings.append(
-                    "Property '%s' is unique, but override authorized...Patching..\n"
-                    % str(tkey)
-                )
-                return False
-        # if not searchtype or (reg.get("ReadOnly") or (reg.get(tkey)
-        #                                                and reg[tkey].get("readonly"))):
-        #    self._warnings.append("Property is read-only. skipping... '%s'" % str(tkey))
-        #    del tdict[tkey]
-        #    return True
-        elif reg.get("ReadOnly") or (reg.get(tkey) and reg[tkey].get("readonly")):
-            if tdict[tkey]:
-                self._warnings.append(
-                    "Property '%s' is read-only. Skipping...\n" % str(tkey)
-                )
-                del tdict[tkey]
-                return True
-        else:
-            return False
-
-    def get_registry_model(
-        self,
-        currtype=None,
-        proppath=None,
-        getmsg=False,
-        searchtype=None,
-        newarg=None,
-        latestschema=False,
-    ):
-        """Loads the schema file and find the registry model if available. A registry model is a
-        object built for schema/bios registry data.
-
-        :param currtype: Type selection string.
-        :type currtype: dict.
-        :param proppath: String containing the schema path if you wish to use that instead.
-        :type proppath: str
-        :param getmsg: Flag to determine if commit should be skipped.
-        :type getmsg: bool
-        :param searchtype: Include the attribute registry of you are validating a bios registry.
-        :type searchtype: str
-        :param newarg: List of multi level properties to be modified.
-        :type newarg: list
-        :param latestschema: Flag to determine if we should drop the schema version when we try to
-                             match schema information. If True, the version will be dropped.
-        :type latestschema: bool
-        :returns: Schema in object form called a registry object.
-        """
-        regdict = None
-        monolith = self.monolith
-        currtype = (
-            currtype.split("#")[-1].split(".")[0] + "."
-            if currtype and latestschema
-            else currtype
-        )
-        if (
-            not currtype
-            or not self.find_prop(
-                currtype,
-                latestschema=latestschema,
-                proppath=proppath if not searchtype else None,
-            )
-        ) and (not searchtype):
-            self._errors.append(RegistryValidationError("Location info is missing.\n"))
-            return None
-        if not searchtype:
-            searchtype = "object"
-
-        try:
-            for instance in monolith.iter(searchtype):
-                if (
-                    (searchtype == Typepathforval.typepath.defs.attributeregtype)
-                    or (
-                        searchtype == "object"
-                        and any(
-                            currtype in xtitle
-                            for xtitle in (
-                                instance.resp.dict.get("title", ""),
-                                instance.resp.dict.get("oldtitle", ""),
-                            )
-                        )
-                    )
-                    or (
-                        searchtype != "object"
-                        and currtype.split("#")[-1].split(".")[0]
-                        == instance.dict.get("RegistryPrefix", "")
-                    )
-                ):
-                    regdict = instance.resp.dict
-                    break
-        except BaseException:
-            pass
-
-        if not regdict:
-            self._errors.append(RegistryValidationError("Location data is empty.\n"))
-            return None
-
-        jsonreg = json.loads(json.dumps(regdict, indent=2, cls=JSONEncoder))
-
-        if getmsg:
-            return {jsonreg["RegistryPrefix"]: jsonreg["Messages"]}
-
-        # This was done for bios registry model compatibility
-        if "RegistryEntries" in jsonreg:
-            regitem = jsonreg["RegistryEntries"]
-            if "Attributes" in regitem:
-                newitem = {
-                    item[Typepathforval.typepath.defs.attributenametype]: item
-                    for item in regitem["Attributes"]
-                }
-                regitem["Attributes"] = newitem
-                if not Typepathforval.typepath.flagiften:
-                    del regitem["Attributes"]
-                    newitem.update(regitem)
-                    regitem = newitem
-                reg = HpPropertiesRegistry.parse(regitem)
-            return self.nestedreg(reg=reg, args=newarg) if newarg else reg
-
-        if "properties" in jsonreg:
-            regitem = jsonreg["properties"]
-            if "Properties" in regitem:
-                regitem.update(regitem["Properties"])
-                del regitem["Properties"]
-            reg = HpPropertiesRegistry.parse(regitem)
-
-            return self.nestedreg(reg=reg, args=newarg) if newarg else reg
-
-    def nestedreg(self, reg=None, args=None):
-        """Go through the registry entry to find the required nested attribute.
-
-        :param reg: Registry entry of the given attribute.
-        :type reg: dict
-        :param args: List of multi level properties to be modified.
-        :type args: list
-        :returns: dict of Registry entry
-        """
-        for arg in args:
-            try:
-                arg = next(
-                    (key for key in list(reg.keys()) if key.lower() == arg.lower()), None
-                )
-                if not arg:
-                    return None
-                if ("properties" in reg[arg].keys()) and (
-                    "patternProperties" in reg[arg].keys()
-                ):
-                    reg[arg]["properties"].update(reg[arg]["patternProperties"])
-                    reg = reg[arg]["properties"]
-                elif "oneOf" in reg[arg]:
-                    oneof = reg[arg]["oneOf"]
-                    for item in oneof:
-                        reg = item["properties"]
-                elif (
-                    "type" in reg[arg]
-                    and reg[arg]["type"] == "array"
-                    and "items" in reg[arg]
-                    and "properties" in reg[arg]["items"]
-                ):
-                    reg = reg[arg]["items"]["properties"]
-                elif (not "properties" in reg[arg].keys()) or (
-                    "patternProperties" in reg[arg].keys()
-                ):
-                    reg = reg[arg]
-                else:
-                    reg = reg[arg]["properties"]
-            except:
-                try:
-                    reg = reg[arg]["patternProperties"]
-                except:
-                    return None
-        return reg
-
-
-class HpPropertiesRegistry(RisObject):
-    """Models a schema or bios attribute registry. Registry model."""
-
-    def __init__(self, d):
-        super(HpPropertiesRegistry, self).__init__(d)
-
-    def validate_attribute_values(self, tdict):
-        """Look for tdict in the attribute list and attempt to validate its value.
-
-        :param tdict: the dictionary to test against.
-        :type tdict: dict
-        :returns: A validated list
-        """
-        result = list()
-
-        for tkey in tdict:
-            if not tkey in self:
-                # Added for Gen 9 Bios properties not in registry
-                continue
-            elif self[tkey] and (
-                checkattr(self[tkey], "type") or checkattr(self[tkey], "Type")
-            ):
-                keyval = list()
-                keyval.append(tdict[tkey])
-                temp = self.validate_attribute(self[tkey], keyval, tkey)
-                tdict[tkey] = keyval[0]
-
-                for err in temp:
-                    if isinstance(err, RegistryValidationError):
-                        if err.reg:
-                            err.sel = tkey
-
-                result.extend(temp)
-
-        return result
-
-    def get_validator(self, attrname, newargs=None, oneof=None):
-        """Returns attribute validator type.
-
-        :param attrname: attribute name to validate. Ex: In A/B/C, this will be A.
-        :type attrname: str
-        :param newargs: List of multi level properties to be modified. Ex: In A/B/C this will be
-                        a list of B and C.
-        :type newargs: list
-        :param oneof: Special string for "oneof" options within validation.
-        :type oneof: string
-        :returns: The validator type class for the property passed.
-        """
-        if oneof:
-            self = oneof
-
-        if newargs:
-            for arg in newargs:
-                try:
-                    self = self["properties"]
-                except Exception:
-                    pass
-
-                if not checkattr(self, arg):
-                    return None
-                elif not arg == newargs[-1]:
-                    self = self[arg]
-
-        if not checkattr(self, attrname):
-            return None
-
-        validator = None
-        if EnumValidator.is_type(self[attrname]):
-            validator = EnumValidator.parse(self[attrname])
-        elif StringValidator.is_type(self[attrname]):
-            validator = StringValidator.parse(self[attrname])
-        elif ObjectValidator.is_type(self[attrname]):
-            validator = ObjectValidator.parse(self[attrname])
-        elif IntegerValidator.is_type(self[attrname]):
-            validator = IntegerValidator.parse(self[attrname])
-        elif BoolValidator.is_type(self[attrname]):
-            validator = BoolValidator.parse(self[attrname])
-        elif PasswordValidator.is_type(self[attrname]):
-            validator = PasswordValidator.parse(self[attrname])
-        elif "oneOf" in list(self[attrname].keys()):
-            for item in self[attrname]["oneOf"]:
-                validator = self.get_validator(
-                    attrname, newargs, HpPropertiesRegistry({attrname: item})
-                )
-                if validator:
-                    break
-        return validator
-
-    def validate_attribute(self, attrentry, attrvallist, name):
-        """Function to validate attribute against its schema.
-
-        :param attrentry: Key of property to validate.
-        :type attrentry: str
-        :param attrval: Value of Key to validate.
-        :type attrval: str
-        :param name: Clean name for outputting information to users.
-        :type name: str
-        :returns: returns list with validated attributes
-        """
-        result = list()
-        validator = None
-        if self.nulltypevalidationcheck(attrval=attrvallist[0], attrentry=attrentry):
-            return result
-
-        if EnumValidator.is_type(attrentry):
-            validator = EnumValidator.parse(attrentry)
-        elif StringValidator.is_type(attrentry):
-            validator = StringValidator.parse(attrentry)
-        elif IntegerValidator.is_type(attrentry):
-            validator = IntegerValidator.parse(attrentry)
-        elif BoolValidator.is_type(attrentry):
-            validator = BoolValidator.parse(attrentry)
-        elif ObjectValidator.is_type(attrentry):
-            validator = ObjectValidator.parse(attrentry)
-        elif PasswordValidator.is_type(attrentry):
-            validator = PasswordValidator.parse(attrentry)
-        else:
-            raise UnknownValidatorError(attrentry)
-
-        if validator:
-            result.extend(validator.is_array(attrentry, attrvallist, name))
-            result.extend(validator.validate(attrvallist, name))
-        return result
-
-    def nulltypevalidationcheck(self, attrval=None, attrentry=None):
-        """Function to validate null attributes against iLO schema
-
-        :param attrentry: Key of property to validate.
-        :type attrentry: str
-        :param attrval: Value of Key to validate.
-        :type attrval: str
-        :returns: True if entry is null and valid.
-        """
-        if "type" in attrentry and attrval is None:
-            if isinstance(attrentry["type"], list):
-                for item in attrentry["type"]:
-                    if item.lower() == "null":
-                        return True
-        return False
-
-
-class BaseValidator(RisObject):
-    """Base class for all validators."""
-
-    def __init__(self, d):
-        super(BaseValidator, self).__init__(d)
-
-    def validate(self):
-        """Overridable function for validation"""
-        raise RuntimeError("You must override this method in your derived class")
-
-    def common_print_help(self, name):
-        """Common human readable schema data.
-
-        :param name: clean name for outputting.
-        :type name: str
-        :returns: A human readable string of schema data.
-        """
-        outdata = ""
-        wrapper = textwrap.TextWrapper()
-        wrapper.initial_indent = " " * 4
-        wrapper.subsequent_indent = " " * 4
-
-        outdata += "\nNAME\n"
-        outdata += "%s\n" % wrapper.fill("%s" % name)
-        outdata += "\n"
-
-        if "DisplayName" in self:
-            outdata += "\nDISPLAY NAME\n"
-            outdata += "%s\n" % wrapper.fill("%(DisplayName)s" % self)
-            outdata += "\n"
-
-        if "description" in self:
-            outdata += "\nDESCRIPTION\n"
-            outdata += "%s\n" % wrapper.fill("%(description)s" % self)
-            outdata += "\n"
-
-        if "HelpText" in self:
-            outdata += "\nHELP TEXT\n"
-            outdata += "%s\n" % wrapper.fill("%(HelpText)s" % self)
-            outdata += "\n"
-
-        if "WarningText" in self:
-            outdata += "\n************************************************\n"
-            outdata += "\nWARNING\n"
-            outdata += "%s\n" % wrapper.fill("%(WarningText)s" % self)
-            outdata += "\n\n**********************************************\n"
-            outdata += "\n"
-
-        if "type" in self and isinstance(self["type"], list):
-            outdata += "\nTYPE\n"
-            for item in self["type"]:
-                outdata += "%s\n" % wrapper.fill("%s" % item)
-            outdata += "\n"
-        elif "type" in self:
-            outdata += "\nTYPE\n"
-            outdata += "%s\n" % wrapper.fill("%(type)s" % self)
-            outdata += "\n"
-        elif "Type" in self:
-            outdata += "\nTYPE\n"
-            outdata += "%s\n" % wrapper.fill("%(Type)s" % self)
-            outdata += "\n"
-
-        if "ReadOnly" in self:
-            outdata += "\nREAD-ONLY\n"
-            outdata += "%s\n" % wrapper.fill("%(ReadOnly)s" % self)
-            outdata += "\n"
-        elif "readonly" in self:
-            outdata += "\nREAD-ONLY\n"
-            outdata += "%s\n" % wrapper.fill("%(readonly)s" % self)
-            outdata += "\n"
-        return outdata
-
-    def is_arrtype(self, attrentry):
-        """Validate that the type is an array.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :returns: A boolean based on whether type is an array.
-        """
-        if "type" in attrentry and attrentry["type"] == "array":
-            return True
-        return False
-
-    def is_array(self, attrentry, arrval, name):
-        """Validate that the given value is an array type.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :param attrval: Value of Key to validate.
-        :type attrval: str
-        :returns: A boolean based on whether type is array and the value is valid for array type.
-        """
-        result = []
-
-        if self.is_arrtype(attrentry):
-            if isinstance(
-                arrval[0],
-                (
-                    frozenset,
-                    list,
-                    set,
-                    tuple,
-                ),
-            ):
-                return []
-            else:
-                result.append(
-                    RegistryValidationError(
-                        "'%s' is not a valid setting "
-                        "for '%s', expecting an array" % (arrval[0], name),
-                        regentry=self,
-                    )
-                )
-        return result
-
-
-class EnumValidator(BaseValidator):
-    """Enum validator class"""
-
-    def __init__(self, d):
-        super(EnumValidator, self).__init__(d)
-
-    @staticmethod
-    def is_type(attrentry):
-        """Validate that the type is enumeration.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :returns: A boolean based on whether type is eneumeration.
-        """
-        if "type" in attrentry:
-            if isinstance(attrentry["type"], list):
-                for item in attrentry["type"]:
-                    if item.lower() == "enumeration":
-                        return True
-                    elif "enum" in attrentry and item.lower() == "string":
-                        return True
-            elif "enum" in attrentry and attrentry["type"] == "array":
-                for key, value in attrentry["items"].items():
-                    if key.lower() == "type" and value.lower() == "string":
-                        return True
-            else:
-                if attrentry["type"].lower() == "enumeration":
-                    return True
-                elif "enum" in attrentry and attrentry["type"].lower() == "string":
-                    return True
-        elif "Type" in attrentry:
-            if attrentry["Type"].lower() == "enumeration":
-                return True
-
-        return False
-
-    def validate(self, keyval, name):
-        """Validate against schemas.
-
-        :param keyval: New value to be used for validation in a list
-        :type keyval: list
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: An error if validation fails.
-        """
-        result = list()
-        newval = keyval[0]
-
-        try:
-            for possibleval in self.enum:
-                if (
-                    possibleval
-                    and (
-                        isinstance(possibleval, type(newval))
-                        or (
-                            isinstance(possibleval, six.string_types)
-                            and isinstance(newval, six.string_types)
-                        )
-                    )
-                    and possibleval.lower() == str(newval).lower()
-                ):
-                    keyval[0] = possibleval
-                    return result
-        except Exception:
-            for possibleval in self.Value:
-                if possibleval.ValueName.lower() == str(newval).lower():
-                    keyval[0] = possibleval.ValueName
-                    return result
-
-        result.append(
-            RegistryValidationError(
-                "'%s' is not a valid setting " "for '%s'" % (newval, name), regentry=self
-            )
-        )
-
-        return result
-
-    def print_help(self, name):
-        """Human readable schema information specific to Enum data.
-
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: A human readable string of schema data.
-        """
-        outdata = self.common_print_help(name)
-        outdata += "\nPOSSIBLE VALUES\n"
-        try:
-            for possibleval in self.enum:
-                outdata += "    %s\n" % possibleval
-        except Exception:
-            for possibleval in self.Value:
-                outdata += "    %(ValueName)s\n" % possibleval
-        outdata += "\n"
-        return outdata
-
-
-class BoolValidator(BaseValidator):
-    """Bool validator class"""
-
-    def __init__(self, d):
-        super(BoolValidator, self).__init__(d)
-
-    @staticmethod
-    def is_type(attrentry):
-        """Validate that the type is boolean.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :returns: A boolean based on whether type is boolean.
-        """
-        if "type" in attrentry:
-            if isinstance(attrentry["type"], list):
-                for item in attrentry["type"]:
-                    if item.lower() == "boolean":
-                        return True
-            elif attrentry["type"] == "array":
-                for key, value in attrentry["items"].items():
-                    if key.lower() == "type" and value.lower() == "boolean":
-                        return True
-            else:
-                if attrentry["type"].lower() == "boolean":
-                    return True
-        elif "Type" in attrentry:
-            if attrentry["Type"].lower() == "boolean":
-                return True
-
-        return False
-
-    def validate(self, newval, name):
-        """Validate against schemas.
-
-        :param newval: New value to be used for validation in a list
-        :type newval: list
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: An error if value is invalid.
-        """
-        result = list()
-        if newval[0] is False or newval[0] is True:
-            return result
-
-        result.append(
-            RegistryValidationError(
-                "'%s' is not a valid setting for '%s'" % (newval[0], name), regentry=self
-            )
-        )
-
-        return result
-
-    def print_help(self, name):
-        """Human readable schema information specific to Boolean data.
-
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: A human readable string of schema data.
-        """
-        outdata = self.common_print_help(name)
-        outdata += "\nPOSSIBLE VALUES\n"
-        outdata += "    True or False\n"
-        outdata += "\n"
-        return outdata
-
-
-class StringValidator(BaseValidator):
-    """Constructor"""
-
-    def __init__(self, d):
-        super(StringValidator, self).__init__(d)
-
-    @staticmethod
-    def is_type(attrentry):
-        """Validate that the type is string.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :returns: A boolean based on whether type is string.
-        """
-        if "type" in attrentry:
-            if isinstance(attrentry["type"], list):
-                for item in attrentry["type"]:
-                    if item.lower() == "string":
-                        return True
-            elif attrentry["type"] == "array":
-                for key, value in attrentry["items"].items():
-                    if key.lower() == "type" and "string" in value:
-                        return True
-            else:
-                if attrentry["type"].lower() == "string":
-                    return True
-        elif "Type" in attrentry:
-            if attrentry["Type"].lower() == "string":
-                return True
-
-        return False
-
-    def validate(self, newvallist, _):
-        """Validate against schemas.
-
-        :param newvallist: New value to be used for validation in a list
-        :type newvallist: list
-        :returns: An error if validation fails criteria.
-        """
-        newval = newvallist[0]
-        result = list()
-        namestr = Typepathforval.typepath.defs.attributenametype
-        if not isinstance(newval, str):
-            result.append(RegistryValidationError("Given value must be a string"))
-            return result
-        if "MinLength" in self:
-            if len(newval) < int(self["MinLength"]):
-                result.append(
-                    RegistryValidationError(
-                        "'%s' must be at least '%s' characters long"
-                        % (self[namestr], int(self["MinLength"])),
-                        regentry=self,
-                    )
-                )
-
-        if "MaxLength" in self:
-            if len(newval) > int(self["MaxLength"]):
-                result.append(
-                    RegistryValidationError(
-                        "'%s' must be less than '%s' characters long"
-                        % (self[namestr], int(self["MaxLength"])),
-                        regentry=self,
-                    )
-                )
-
-        if "ValueExpression" in self:
-            if self["ValueExpression"]:
-                pat = re.compile(self["ValueExpression"])
-                if newval and not pat.match(newval):
-                    result.append(
-                        RegistryValidationError(
-                            "'%s' must match the regular expression "
-                            "'%s'" % (self[namestr], self["ValueExpression"]),
-                            regentry=self,
-                        )
-                    )
-
-        return result
-
-    def print_help(self, name):
-        """Human readable schema information specific to String data.
-
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: A human readable string of schema data.
-        """
-        wrapper = textwrap.TextWrapper()
-        wrapper.initial_indent = " " * 4
-        wrapper.subsequent_indent = " " * 4
-        outdata = self.common_print_help(name)
-        if "MinLength" in self:
-            outdata += "\nMIN LENGTH\n"
-            outdata += "%s" % wrapper.fill("%(MinLength)s" % self)
-            outdata += "\n"
-
-        if "MaxLength" in self:
-            outdata += "\nMAX LENGTH\n"
-            outdata += "%s" % wrapper.fill("%(MaxLength)s" % self)
-            outdata += "\n"
-        return outdata
-
-
-class IntegerValidator(BaseValidator):
-    """Interger validator class"""
-
-    def __init__(self, d):
-        super(IntegerValidator, self).__init__(d)
-
-    @staticmethod
-    def is_type(attrentry):
-        """Validate that the type is integer.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :returns: A boolean based on whether type is integer.
-        """
-        if "type" in attrentry:
-            if isinstance(attrentry["type"], list):
-                for item in attrentry["type"]:
-                    if item.lower() == "integer" or item.lower() == "number":
-                        return True
-            elif attrentry["type"] == "array":
-                for key, value in attrentry["items"].items():
-                    if key.lower() == "type":
-                        if value.lower() == "integer" or value.lower() == "number":
-                            return True
-            else:
-                if (
-                    attrentry["type"].lower() == "integer"
-                    or attrentry["type"].lower().lower() == "number"
-                ):
-                    return True
-        elif "Type" in attrentry:
-            if attrentry["Type"].lower() == "integer":
-                return True
-
-        return False
-
-    def validate(self, newvallist, _):
-        """Validate against schemas.
-
-        :param newvallist: New value to be used for validation in a list
-        :type newvallist: list
-        :returns: An error if validation fails criteria.
-        """
-        result = list()
-        try:
-            intval = int(newvallist[0])
-            newvallist[0] = intval
-        except:
-            result.append(
-                RegistryValidationError(
-                    "'%(Name)s' must " "be an integer value'" % (self), regentry=self
-                )
-            )
-            return result
-
-        if newvallist[0] and not str(intval).isdigit():
-            result.append(
-                RegistryValidationError(
-                    "'%(Name)s' must " "be an integer value'" % (self), regentry=self
-                )
-            )
-            return result
-
-        if "LowerBound" in self:
-            if intval < int(self["LowerBound"]):
-                result.append(
-                    RegistryValidationError(
-                        "'%s' must be greater"
-                        " than or equal to '%s'" % (self.Name, int(self["LowerBound"])),
-                        regentry=self,
-                    )
-                )
-
-        if "UpperBound" in self:
-            if intval > int(self["UpperBound"]):
-                result.append(
-                    RegistryValidationError(
-                        "'%s' must be less "
-                        "than or equal to '%s'" % (self.Name, int(self["LowerBound"])),
-                        regentry=self,
-                    )
-                )
-
-        return result
-
-    def print_help(self, name):
-        """Human readable schema information specific to Integer data.
-
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: A human readable string of schema data.
-        """
-        outdata = self.common_print_help(name)
-        return outdata
-
-
-class ObjectValidator(BaseValidator):
-    """Object validator class"""
-
-    def __init__(self, d):
-        super(ObjectValidator, self).__init__(d)
-
-    @staticmethod
-    def is_type(attrentry):
-        """Validate that the type is object.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :returns: A boolean based on whether type is object.
-        """
-        if "type" in attrentry:
-            if isinstance(attrentry["type"], list):
-                for item in attrentry["type"]:
-                    if item.lower() == "object":
-                        return True
-            elif attrentry["type"] == "array":
-                for key, value in attrentry["items"].items():
-                    if key.lower() == "type" and value.lower() == "object":
-                        return True
-                    elif key.lower() == "anyof":
-                        try:
-                            if value[0]["type"] == "object":
-                                return True
-                        except Exception:
-                            continue
-            else:
-                if attrentry["type"].lower() == "object":
-                    return True
-        elif "Type" in attrentry:
-            if attrentry["Type"].lower() == "object":
-                return True
-
-        return False
-
-    def validate(self, newval, name):
-        """Validate against schemas.
-
-        :param newval: New value to be used for validation in a list
-        :type newval: list
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: An error if value is invalid.
-        """
-        # TODO: need to add logic for true postive and false negatives.
-        result = list()
-        if isinstance(newval[0], (dict, six.string_types, int)):
-            result.append(
-                RegistryValidationError(
-                    "'%s' is not a valid setting for '%s'" % (newval[0], name),
-                    regentry=self,
-                )
-            )
-        return result
-
-    def print_help(self, name):
-        """Human readable schema information specific to Object data.
-
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: A human readable string of schema data.
-        """
-        wrapper = textwrap.TextWrapper()
-        wrapper.initial_indent = " " * 4
-        wrapper.subsequent_indent = " " * 4
-        outdata = self.common_print_help(name)
-        if "properties" in self:
-            outdata += "\nSUB-PROPERTIES\n"
-            propdata = ", ".join(self.properties.keys())
-            outdata += "%s" % wrapper.fill("%s" % propdata)
-            outdata += "\n"
-        elif "items" in self:
-            outdata += "\nSUB-PROPERTIES\n"
-            propdata = ", ".join(self["items"].properties.keys())
-            outdata += "%s" % wrapper.fill("%s" % propdata)
-            outdata += "\n"
-
-        return outdata
-
-
-class PasswordValidator(BaseValidator):
-    """Password validator class"""
-
-    def __init__(self, d):
-        super(PasswordValidator, self).__init__(d)
-
-    @staticmethod
-    def is_type(attrentry):
-        """Validate that the type is a password.
-
-        :param attrentry: Registry model entry used for validation.
-        :type attrentry: dict
-        :returns: A boolean based on whether type is a password.
-        """
-        if "type" in attrentry:
-            if isinstance(attrentry["type"], list):
-                for item in attrentry["type"]:
-                    if item.lower() == "password":
-                        return True
-            elif attrentry["type"] == "array":
-                for key, value in attrentry["items"].items():
-                    if key.lower() == "type" and value.lower() == "password":
-                        return True
-            else:
-                if attrentry["type"].lower() == "password":
-                    return True
-        elif "Type" in attrentry:
-            if attrentry["Type"].lower() == "password":
-                return True
-
-        return False
-
-    def validate(self, newvallist, _):
-        """Validate against schemas.
-
-        :param newvallist: New value to be used for validation in a list
-        :type newvallist: list
-        :returns: An error if validation fails criteria.
-        """
-        result = list()
-        newval = newvallist[0]
-
-        if newval is None:
-            return result
-
-        if not isinstance(newval, str):
-            result.append(RegistryValidationError("Given value must be a string"))
-        if "MinLength" in self:
-            if len(newval) < int(self["MinLength"]):
-                result.append(
-                    RegistryValidationError(
-                        "'%s' must be at least"
-                        " '%s' characters long" % (self.Name, int(self["MinLength"])),
-                        regentry=self,
-                    )
-                )
-
-        if "MaxLength" in self:
-            if len(newval) > int(self["MaxLength"]):
-                result.append(
-                    RegistryValidationError(
-                        "'%s' must be less "
-                        "than '%s' characters long" % (self.Name, int(self["MaxLength"])),
-                        regentry=self,
-                    )
-                )
-
-        if "ValueExpression" in self:
-            if self["ValueExpression"]:
-                pat = re.compile(self["ValueExpression"])
-                if newval and not pat.match(newval):
-                    result.append(
-                        RegistryValidationError(
-                            "'%(Name)s' must "
-                            "match the regular expression '%(Value"
-                            "Expression)s'" % (self),
-                            regentry=self,
-                        )
-                    )
-
-        return result
-
-    def print_help(self, name):
-        """Human readable schema information specific to Password data.
-
-        :param name: Clean name for outputting human readable info.
-        :type name: str
-        :returns: A human readable string of schema data.
-        """
-        wrapper = textwrap.TextWrapper()
-        wrapper.initial_indent = " " * 4
-        wrapper.subsequent_indent = " " * 4
-        outdata = self.common_print_help(name)
-        if "MinLength" in self:
-            outdata += "\nMIN LENGTH\n"
-            outdata += "%s" % wrapper.fill("%(MinLength)s" % self)
-            outdata += "\n"
-
-        if "MaxLength" in self:
-            outdata += "\nMAX LENGTH\n"
-            outdata += "%s" % wrapper.fill("%(MaxLength)s" % self)
-            outdata += "\n"
-        return outdata
-
-
-class Typepathforval(object):
-    """Way to store the typepath defines object."""
-
-    typepath = None
-
-    def __new__(cls, typepathobj):
-        if typepathobj:
-            Typepathforval.typepath = typepathobj
-
-
-def checkattr(aobj, prop):
-    """Check if an attribute exists"""
-    try:
-        if hasattr(aobj, prop):
-            return True
-    except:
-        pass
-    return False
+###
+# Copyright 2020 Hewlett Packard Enterprise, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+###
+
+# -*- coding: utf-8 -*-
+"""Handles schema and registry gathering as well as schema parsing and validation."""
+
+# ---------Imports---------
+
+import re
+import six
+import json
+import logging
+import textwrap
+import jsonpath_rw
+
+try:
+    from collections import OrderedDict
+except ImportError:
+    from collections.abc import OrderedDict
+from redfish.rest.containers import RisObject
+from redfish.ris.utils import json_traversal
+from .sharedtypes import JSONEncoder
+
+# ---------End of imports---------
+
+
+# ---------Debug logger---------
+
+LOGGER = logging.getLogger(__name__)
+
+
+# ---------End of debug logger---------
+
+
+class InvalidPathsError(Exception):
+    """Raised when requested path is not found"""
+
+    pass
+
+
+class RegistryValidationError(Exception):
+    """Registration Validation Class Error"""
+
+    def __init__(self, msg, regentry=None, selector=None):
+        super(RegistryValidationError, self).__init__(msg)
+        self.reg = regentry
+        self.sel = selector
+        self.message = msg
+
+
+class UnknownValidatorError(Exception):
+    """Raised when we find an attribute type that we don't know how to validate."""
+
+    pass
+
+
+class ValidationManager(object):
+    """Keeps track of all the schemas and registries and provides helpers
+    to simplify validation."""
+
+    def __init__(self, monolith, defines=None):
+        """init of ValidationManager"""
+        super(ValidationManager, self).__init__()
+
+        self._schemaid = Typepathforval.typepath.schemapath
+        self._regid = Typepathforval.typepath.regpath
+
+        self._classes = list()
+        self._classpaths = list()
+        # type and path defines object
+        self.defines = defines
+        self.monolith = monolith
+        # error
+        self._errors = list()
+        self._warnings = list()
+        self.updatevalidationdata()
+
+    @property
+    def errors(self):
+        """All errors found by the last validation."""
+        return self._errors
+
+    @property
+    def warnings(self):
+        """All warnings found by the last validation."""
+        return self._warnings
+
+    def reset_errors_warnings(self):
+        """Resets warnings and errors, getting ready for the next validation."""
+        self._errors = list()
+        self._warnings = list()
+
+    def updatevalidationdata(self):
+        """Loads the types into the validation manager from monolith."""
+        monolith = self.monolith
+        for instance in monolith.iter():
+            if (
+                (
+                    x.lower() in instance.maj_type.lower()
+                    for x in (
+                        self.defines.defs.schemafilecollectiontype,
+                        "Collection.",
+                        self.defines.defs.regfilecollectiontype,
+                    )
+                )
+                and any(
+                    x.lower() in instance.path.lower()
+                    for x in (self._schemaid, self._regid)
+                )
+                and instance
+                and instance.path not in self._classpaths
+            ):
+                self._classpaths.append(instance.path)
+                self._classes.append(instance.resp.dict)
+
+    def find_prop(self, propname, latestschema=False, proppath=None):
+        """Searches through all locations and returns the schema
+        found for the provided propname type.
+
+        :param propname: String containing the schema name.
+        :type propname: str
+        :param proppath: String containing the schema path if you wish to use that instead.
+        :type proppath: str
+        :param latestschema: Flag to determine if we should drop the schema version when we try to
+                             match schema information. If True, the version will be dropped.
+        :type latestschema: bool
+        """
+        if proppath:
+            self.monolith.load(path=proppath, crawl=False, loadtype="ref")
+            return True
+        for cls in self._classes:
+            found = self.find_property(propname, cls=cls, latestschema=latestschema)
+            if found:
+                return found
+        return None
+
+    def itermems(self, membername=None):
+        """Searches through all locations and yields each entry.
+
+        :param membername: string containing the registry name. If not passed we use the typedefines
+                           string by default.
+        :type membername: str
+        """
+        if not membername:
+            membername = self.defines.defs.collectionstring
+        for items in self._classes:
+            for item in items[membername]:
+                yield item
+
+    def iterregmems(self, membername=None):
+        """Searches through all registries and yields each entry.
+
+        :param membername: string containing the registry name. If not passed we use the typedefines
+                           string by default.
+        :type membername: str
+        """
+        if not membername:
+            membername = self.defines.defs.collectionstring
+        for items in self._classes:
+            if "registr" in items["Name"].lower():  # For Gen9 type/name issue
+                for item in items[membername]:
+                    yield item
+
+    def iterschemamems(self, membername=None):
+        """Searches through all schemas and yields each entry
+
+        :param membername: string containing the registry name. If not passed we use the typedefines
+                           string by default.
+        :type membername: str
+        """
+        if not membername:
+            membername = self.defines.defs.collectionstring
+        for items in self._classes:
+            if "schema" in items["Name"].lower():  # For Gen9 type/name issue
+                for item in items[membername]:
+                    yield item
+
+    def find_property(self, propname, cls=None, latestschema=False):
+        """Returns iLO/BIOS registries/schemas
+
+        :param propname: string containing the registry/schema name.
+        :type propname: str
+        :param cls: self._classes list of dictionaries.
+        :type cls: list
+        :param latestschema: flag to drop the versioning in the type string.
+        :type latestschema: bool.
+
+        :returns: iLO/BIOS registries/schemas that match the supplied name.
+        """
+        result = []
+        dataloc = cls.get("Items", None)
+        dataloc = cls.get("Members", None) if not dataloc else dataloc
+        keyword = "Schema"
+        if dataloc and isinstance(dataloc, list):
+            splitname = propname.split(".")[0].strip("#")
+            propname = propname.split(".")[0].strip("#") if latestschema else propname
+            for entry in dataloc:
+                if entry:
+                    if "Schema" in entry:
+                        if propname.lower() in entry["Schema"].lower():
+                            result.append(entry)
+                    elif "Registry" in entry:
+                        if (
+                            propname.lower() in entry["@odata.id"].lower()
+                            and propname.lower() in entry["Registry"].lower()
+                        ):
+                            result.append(entry)
+                            keyword = "Registry"
+                    else:
+                        if "@odata.id" in entry:
+                            reglink = entry["@odata.id"].split("/")
+                            reglink = reglink[len(reglink) - 2]
+                            if reglink.lower().startswith(propname.lower()):
+                                self.monolith.load(path=entry["@odata.id"], crawl=False)
+                                result.append(
+                                    self.monolith.paths[entry["@odata.id"]].dict
+                                )
+
+        if result:
+            result = max(
+                result,
+                key=lambda res: res[Typepathforval.typepath.defs.hrefstring]
+                if res.get(Typepathforval.typepath.defs.hrefstring, None)
+                else res[keyword],
+            )
+            schemapath = self.geturidict(result["Location"][0])
+            self.monolith.load(path=schemapath, crawl=False, loadtype="ref")
+            return result
+
+    def geturidict(self, locationobj):
+        """Return the external reference link.
+
+        :param locationobj: Dictionary to get the URI reference from.
+        :type locationobj: dict
+        """
+        if Typepathforval.typepath.defs.isgen10:
+            try:
+                return locationobj["Uri"]
+            except KeyError:
+                raise InvalidPathsError("Error accessing Uri path!/n")
+        elif Typepathforval.typepath.defs.isgen9:
+            try:
+                return locationobj["Uri"]["extref"]
+            except KeyError:
+                raise InvalidPathsError("Error accessing extref path!/n")
+
+    def validatedict(
+        self,
+        tdict,
+        currtype=None,
+        proppath=None,
+        latestschema=False,
+        searchtype=None,
+        monolith=None,
+        reg=None,
+        unique=None,
+    ):
+        """Load the schema file and validate tdict against it.
+
+        :param tdict: the dictionary to test against.
+        :type tdict: dict
+        :param currtype: String containing the type the tdict dictionary is.
+        :type currtype: str
+        :param proppath: String containing the schema path of the tdict dictionary if you wish to
+                         use that instead.
+        :type proppath: str
+        :param latestschema: Flag to determine if we should drop the schema version when we try to
+                             match schema information. If True, the version will be dropped.
+        :type latestschema: bool
+        :param searchtype: Include the attribute registry of you are validating a bios registry.
+        :type searchtype: str
+        :param monolith: Full data model retrieved from server.
+        :type monolith: dict
+        :param unique: Flag to override for skipping unique properties.
+        :type unique: bool
+        :param reg: Registry entry of the given attribute. If this is not provided we will attempt
+                    to search based on the searchtype and currtype/proppath arguments.
+        :type reg: dict.
+        :returns: returns an error list.
+        """
+        if not reg:
+            reg = self.get_registry_model(
+                currtype=currtype,
+                searchtype=searchtype,
+                proppath=proppath,
+                latestschema=latestschema,
+            )
+
+        if reg:
+            list(
+                map(
+                    lambda x: self.checkreadunique(
+                        tdict,
+                        x,
+                        reg=reg,
+                        warnings=self._warnings,
+                        unique=unique,
+                        searchtype=searchtype,
+                    ),
+                    list(tdict.keys()),
+                )
+            )
+            orireg = reg.copy()
+            ttdict = {
+                key: val
+                for key, val in list(tdict.items())
+                if not isinstance(val, (dict, list))
+            }
+            results = reg.validate_attribute_values(ttdict)
+            self._errors.extend(results)
+
+            for ki, val in list(tdict.items()):
+                if ki in ttdict:
+                    tdict[ki] = ttdict[ki]
+                    continue
+                reg = orireg.copy()
+                valexists = False
+                if val and isinstance(val, list):
+                    valexists = True
+                    # TODO: only validates if its a single dict within list
+                    if len(val) == 1 and isinstance(val[0], dict):
+                        treg = self.nestedreg(reg=reg, args=[ki])
+                        self.validatedict(
+                            val[0],
+                            unique=unique,
+                            monolith=monolith,
+                            reg=treg,
+                            currtype=currtype,
+                            searchtype=searchtype,
+                        )
+                    else:
+                        continue
+                elif val and isinstance(val, dict):
+                    valexists = True
+                    treg = self.nestedreg(reg=reg, args=[ki])
+                    self.validatedict(
+                        val,
+                        monolith=monolith,
+                        reg=treg,
+                        unique=unique,
+                        searchtype=searchtype,
+                    )
+                if not val and valexists:
+                    del tdict[ki]
+
+        else:
+            self._errors.append(
+                RegistryValidationError("Unable to locate registry model")
+            )
+        return self._errors, self._warnings
+
+    def checkreadunique(
+        self, tdict, tkey, reg=None, warnings=None, unique=None, searchtype=None
+    ):
+        """Check for and remove the readonly and unique attributes if required.
+
+        :param tdict: the dictionary to test against.
+        :type tdict: dict.
+        :param tkey: The attribute key value to be tested.
+        :type tkey: str.
+        :param warnings: list containing found warnings.
+        :type warnings: list.
+        :param unique: flag to determine override for unique properties.
+        :type unique: str.
+        :param reg: Registry entry of the given attribute.
+        :type reg: dict.
+        :returns: returns boolean.
+        """
+        if "Attributes" in tdict:
+            return False
+            # key = list(tdict[tkey])[0]
+            # reg = reg["Attributes"][key]
+        else:
+            if tkey in reg:
+                reg = reg[tkey]
+
+        if not unique and reg.get("IsSystemUniqueProperty", None):
+            if tdict[tkey] and not isinstance(tdict[tkey], bool):
+                self._warnings.append(
+                    "Property '%s' is unique and override not authorized. Skipping...\n"
+                    % str(tkey)
+                )
+                del tdict[tkey]
+                return True
+        if not reg.get("ReadOnly") or (
+            reg.get(tkey, None) and not reg[tkey].get("readonly")
+        ):
+            if unique and reg.get("IsSystemUniqueProperty", None):
+                self._warnings.append(
+                    "Property '%s' is unique, but override authorized...Patching..\n"
+                    % str(tkey)
+                )
+                return False
+        # if not searchtype or (reg.get("ReadOnly") or (reg.get(tkey)
+        #                                                and reg[tkey].get("readonly"))):
+        #    self._warnings.append("Property is read-only. skipping... '%s'" % str(tkey))
+        #    del tdict[tkey]
+        #    return True
+        elif reg.get("ReadOnly") or (reg.get(tkey) and reg[tkey].get("readonly")):
+            if tdict[tkey]:
+                self._warnings.append(
+                    "Property '%s' is read-only. Skipping...\n" % str(tkey)
+                )
+                del tdict[tkey]
+                return True
+        else:
+            return False
+
+    def get_registry_model(
+        self,
+        currtype=None,
+        proppath=None,
+        getmsg=False,
+        searchtype=None,
+        newarg=None,
+        latestschema=False,
+    ):
+        """Loads the schema file and find the registry model if available. A registry model is a
+        object built for schema/bios registry data.
+
+        :param currtype: Type selection string.
+        :type currtype: dict.
+        :param proppath: String containing the schema path if you wish to use that instead.
+        :type proppath: str
+        :param getmsg: Flag to determine if commit should be skipped.
+        :type getmsg: bool
+        :param searchtype: Include the attribute registry of you are validating a bios registry.
+        :type searchtype: str
+        :param newarg: List of multi level properties to be modified.
+        :type newarg: list
+        :param latestschema: Flag to determine if we should drop the schema version when we try to
+                             match schema information. If True, the version will be dropped.
+        :type latestschema: bool
+        :returns: Schema in object form called a registry object.
+        """
+        regdict = None
+        monolith = self.monolith
+        currtype = (
+            currtype.split("#")[-1].split(".")[0] + "."
+            if currtype and latestschema
+            else currtype
+        )
+        if (
+            not currtype
+            or not self.find_prop(
+                currtype,
+                latestschema=latestschema,
+                proppath=proppath if not searchtype else None,
+            )
+        ) and (not searchtype):
+            self._errors.append(RegistryValidationError("Location info is missing.\n"))
+            return None
+        if not searchtype:
+            searchtype = "object"
+
+        try:
+            for instance in monolith.iter(searchtype):
+                if (
+                    (searchtype == Typepathforval.typepath.defs.attributeregtype)
+                    or (
+                        searchtype == "object"
+                        and any(
+                            currtype in xtitle
+                            for xtitle in (
+                                instance.resp.dict.get("title", ""),
+                                instance.resp.dict.get("oldtitle", ""),
+                            )
+                        )
+                    )
+                    or (
+                        searchtype != "object"
+                        and currtype.split("#")[-1].split(".")[0]
+                        == instance.dict.get("RegistryPrefix", "")
+                    )
+                ):
+                    regdict = instance.resp.dict
+                    break
+        except BaseException:
+            pass
+
+        if not regdict:
+            self._errors.append(RegistryValidationError("Location data is empty.\n"))
+            return None
+
+        jsonreg = json.loads(json.dumps(regdict, indent=2, cls=JSONEncoder))
+
+        if getmsg:
+            return {jsonreg["RegistryPrefix"]: jsonreg["Messages"]}
+
+        # This was done for bios registry model compatibility
+        if "RegistryEntries" in jsonreg:
+            regitem = jsonreg["RegistryEntries"]
+            if "Attributes" in regitem:
+                newitem = {
+                    item[Typepathforval.typepath.defs.attributenametype]: item
+                    for item in regitem["Attributes"]
+                }
+                regitem["Attributes"] = newitem
+                if not Typepathforval.typepath.flagiften:
+                    del regitem["Attributes"]
+                    newitem.update(regitem)
+                    regitem = newitem
+                reg = HpPropertiesRegistry.parse(regitem)
+            return self.nestedreg(reg=reg, args=newarg) if newarg else reg
+
+        if "properties" in jsonreg:
+            regitem = jsonreg["properties"]
+            if "Properties" in regitem:
+                regitem.update(regitem["Properties"])
+                del regitem["Properties"]
+            reg = HpPropertiesRegistry.parse(regitem)
+
+            return self.nestedreg(reg=reg, args=newarg) if newarg else reg
+
+    def nestedreg(self, reg=None, args=None):
+        """Go through the registry entry to find the required nested attribute.
+
+        :param reg: Registry entry of the given attribute.
+        :type reg: dict
+        :param args: List of multi level properties to be modified.
+        :type args: list
+        :returns: dict of Registry entry
+        """
+        for arg in args:
+            try:
+                arg = next(
+                    (key for key in list(reg.keys()) if key.lower() == arg.lower()), None
+                )
+                if not arg:
+                    return None
+                if ("properties" in reg[arg].keys()) and (
+                    "patternProperties" in reg[arg].keys()
+                ):
+                    reg[arg]["properties"].update(reg[arg]["patternProperties"])
+                    reg = reg[arg]["properties"]
+                elif "oneOf" in reg[arg]:
+                    oneof = reg[arg]["oneOf"]
+                    for item in oneof:
+                        reg = item["properties"]
+                elif (
+                    "type" in reg[arg]
+                    and reg[arg]["type"] == "array"
+                    and "items" in reg[arg]
+                    and "properties" in reg[arg]["items"]
+                ):
+                    reg = reg[arg]["items"]["properties"]
+                elif (not "properties" in reg[arg].keys()) or (
+                    "patternProperties" in reg[arg].keys()
+                ):
+                    reg = reg[arg]
+                else:
+                    reg = reg[arg]["properties"]
+            except:
+                try:
+                    reg = reg[arg]["patternProperties"]
+                except:
+                    return None
+        return reg
+
+
+class HpPropertiesRegistry(RisObject):
+    """Models a schema or bios attribute registry. Registry model."""
+
+    def __init__(self, d):
+        super(HpPropertiesRegistry, self).__init__(d)
+
+    def validate_attribute_values(self, tdict):
+        """Look for tdict in the attribute list and attempt to validate its value.
+
+        :param tdict: the dictionary to test against.
+        :type tdict: dict
+        :returns: A validated list
+        """
+        result = list()
+
+        for tkey in tdict:
+            if not tkey in self:
+                # Added for Gen 9 Bios properties not in registry
+                continue
+            elif self[tkey] and (
+                checkattr(self[tkey], "type") or checkattr(self[tkey], "Type")
+            ):
+                keyval = list()
+                keyval.append(tdict[tkey])
+                temp = self.validate_attribute(self[tkey], keyval, tkey)
+                tdict[tkey] = keyval[0]
+
+                for err in temp:
+                    if isinstance(err, RegistryValidationError):
+                        if err.reg:
+                            err.sel = tkey
+
+                result.extend(temp)
+
+        return result
+
+    def get_validator(self, attrname, newargs=None, oneof=None):
+        """Returns attribute validator type.
+
+        :param attrname: attribute name to validate. Ex: In A/B/C, this will be A.
+        :type attrname: str
+        :param newargs: List of multi level properties to be modified. Ex: In A/B/C this will be
+                        a list of B and C.
+        :type newargs: list
+        :param oneof: Special string for "oneof" options within validation.
+        :type oneof: string
+        :returns: The validator type class for the property passed.
+        """
+        if oneof:
+            self = oneof
+
+        if newargs:
+            for arg in newargs:
+                try:
+                    self = self["properties"]
+                except Exception:
+                    pass
+
+                if not checkattr(self, arg):
+                    return None
+                elif not arg == newargs[-1]:
+                    self = self[arg]
+
+        if not checkattr(self, attrname):
+            return None
+
+        validator = None
+        if EnumValidator.is_type(self[attrname]):
+            validator = EnumValidator.parse(self[attrname])
+        elif StringValidator.is_type(self[attrname]):
+            validator = StringValidator.parse(self[attrname])
+        elif ObjectValidator.is_type(self[attrname]):
+            validator = ObjectValidator.parse(self[attrname])
+        elif IntegerValidator.is_type(self[attrname]):
+            validator = IntegerValidator.parse(self[attrname])
+        elif BoolValidator.is_type(self[attrname]):
+            validator = BoolValidator.parse(self[attrname])
+        elif PasswordValidator.is_type(self[attrname]):
+            validator = PasswordValidator.parse(self[attrname])
+        elif "oneOf" in list(self[attrname].keys()):
+            for item in self[attrname]["oneOf"]:
+                validator = self.get_validator(
+                    attrname, newargs, HpPropertiesRegistry({attrname: item})
+                )
+                if validator:
+                    break
+        return validator
+
+    def validate_attribute(self, attrentry, attrvallist, name):
+        """Function to validate attribute against its schema.
+
+        :param attrentry: Key of property to validate.
+        :type attrentry: str
+        :param attrval: Value of Key to validate.
+        :type attrval: str
+        :param name: Clean name for outputting information to users.
+        :type name: str
+        :returns: returns list with validated attributes
+        """
+        result = list()
+        validator = None
+        if self.nulltypevalidationcheck(attrval=attrvallist[0], attrentry=attrentry):
+            return result
+
+        if EnumValidator.is_type(attrentry):
+            validator = EnumValidator.parse(attrentry)
+        elif StringValidator.is_type(attrentry):
+            validator = StringValidator.parse(attrentry)
+        elif IntegerValidator.is_type(attrentry):
+            validator = IntegerValidator.parse(attrentry)
+        elif BoolValidator.is_type(attrentry):
+            validator = BoolValidator.parse(attrentry)
+        elif ObjectValidator.is_type(attrentry):
+            validator = ObjectValidator.parse(attrentry)
+        elif PasswordValidator.is_type(attrentry):
+            validator = PasswordValidator.parse(attrentry)
+        else:
+            raise UnknownValidatorError(attrentry)
+
+        if validator:
+            result.extend(validator.is_array(attrentry, attrvallist, name))
+            result.extend(validator.validate(attrvallist, name))
+        return result
+
+    def nulltypevalidationcheck(self, attrval=None, attrentry=None):
+        """Function to validate null attributes against iLO schema
+
+        :param attrentry: Key of property to validate.
+        :type attrentry: str
+        :param attrval: Value of Key to validate.
+        :type attrval: str
+        :returns: True if entry is null and valid.
+        """
+        if "type" in attrentry and attrval is None:
+            if isinstance(attrentry["type"], list):
+                for item in attrentry["type"]:
+                    if item.lower() == "null":
+                        return True
+        return False
+
+
+class BaseValidator(RisObject):
+    """Base class for all validators."""
+
+    def __init__(self, d):
+        super(BaseValidator, self).__init__(d)
+
+    def validate(self):
+        """Overridable function for validation"""
+        raise RuntimeError("You must override this method in your derived class")
+
+    def common_print_help(self, name):
+        """Common human readable schema data.
+
+        :param name: clean name for outputting.
+        :type name: str
+        :returns: A human readable string of schema data.
+        """
+        outdata = ""
+        wrapper = textwrap.TextWrapper()
+        wrapper.initial_indent = " " * 4
+        wrapper.subsequent_indent = " " * 4
+
+        outdata += "\nNAME\n"
+        outdata += "%s\n" % wrapper.fill("%s" % name)
+        outdata += "\n"
+
+        if "DisplayName" in self:
+            outdata += "\nDISPLAY NAME\n"
+            outdata += "%s\n" % wrapper.fill("%(DisplayName)s" % self)
+            outdata += "\n"
+
+        if "description" in self:
+            outdata += "\nDESCRIPTION\n"
+            outdata += "%s\n" % wrapper.fill("%(description)s" % self)
+            outdata += "\n"
+
+        if "HelpText" in self:
+            outdata += "\nHELP TEXT\n"
+            outdata += "%s\n" % wrapper.fill("%(HelpText)s" % self)
+            outdata += "\n"
+
+        if "WarningText" in self:
+            outdata += "\n************************************************\n"
+            outdata += "\nWARNING\n"
+            outdata += "%s\n" % wrapper.fill("%(WarningText)s" % self)
+            outdata += "\n\n**********************************************\n"
+            outdata += "\n"
+
+        if "type" in self and isinstance(self["type"], list):
+            outdata += "\nTYPE\n"
+            for item in self["type"]:
+                outdata += "%s\n" % wrapper.fill("%s" % item)
+            outdata += "\n"
+        elif "type" in self:
+            outdata += "\nTYPE\n"
+            outdata += "%s\n" % wrapper.fill("%(type)s" % self)
+            outdata += "\n"
+        elif "Type" in self:
+            outdata += "\nTYPE\n"
+            outdata += "%s\n" % wrapper.fill("%(Type)s" % self)
+            outdata += "\n"
+
+        if "ReadOnly" in self:
+            outdata += "\nREAD-ONLY\n"
+            outdata += "%s\n" % wrapper.fill("%(ReadOnly)s" % self)
+            outdata += "\n"
+        elif "readonly" in self:
+            outdata += "\nREAD-ONLY\n"
+            outdata += "%s\n" % wrapper.fill("%(readonly)s" % self)
+            outdata += "\n"
+        return outdata
+
+    def is_arrtype(self, attrentry):
+        """Validate that the type is an array.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :returns: A boolean based on whether type is an array.
+        """
+        if "type" in attrentry and attrentry["type"] == "array":
+            return True
+        return False
+
+    def is_array(self, attrentry, arrval, name):
+        """Validate that the given value is an array type.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :param attrval: Value of Key to validate.
+        :type attrval: str
+        :returns: A boolean based on whether type is array and the value is valid for array type.
+        """
+        result = []
+
+        if self.is_arrtype(attrentry):
+            if isinstance(
+                arrval[0],
+                (
+                    frozenset,
+                    list,
+                    set,
+                    tuple,
+                ),
+            ):
+                return []
+            else:
+                result.append(
+                    RegistryValidationError(
+                        "'%s' is not a valid setting "
+                        "for '%s', expecting an array" % (arrval[0], name),
+                        regentry=self,
+                    )
+                )
+        return result
+
+
+class EnumValidator(BaseValidator):
+    """Enum validator class"""
+
+    def __init__(self, d):
+        super(EnumValidator, self).__init__(d)
+
+    @staticmethod
+    def is_type(attrentry):
+        """Validate that the type is enumeration.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :returns: A boolean based on whether type is eneumeration.
+        """
+        if "type" in attrentry:
+            if isinstance(attrentry["type"], list):
+                for item in attrentry["type"]:
+                    if item.lower() == "enumeration":
+                        return True
+                    elif "enum" in attrentry and item.lower() == "string":
+                        return True
+            elif "enum" in attrentry and attrentry["type"] == "array":
+                for key, value in attrentry["items"].items():
+                    if key.lower() == "type" and value.lower() == "string":
+                        return True
+            else:
+                if attrentry["type"].lower() == "enumeration":
+                    return True
+                elif "enum" in attrentry and attrentry["type"].lower() == "string":
+                    return True
+        elif "Type" in attrentry:
+            if attrentry["Type"].lower() == "enumeration":
+                return True
+
+        return False
+
+    def validate(self, keyval, name):
+        """Validate against schemas.
+
+        :param keyval: New value to be used for validation in a list
+        :type keyval: list
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: An error if validation fails.
+        """
+        result = list()
+        newval = keyval[0]
+
+        try:
+            for possibleval in self.enum:
+                if (
+                    possibleval
+                    and (
+                        isinstance(possibleval, type(newval))
+                        or (
+                            isinstance(possibleval, six.string_types)
+                            and isinstance(newval, six.string_types)
+                        )
+                    )
+                    and possibleval.lower() == str(newval).lower()
+                ):
+                    keyval[0] = possibleval
+                    return result
+        except Exception:
+            for possibleval in self.Value:
+                if possibleval.ValueName.lower() == str(newval).lower():
+                    keyval[0] = possibleval.ValueName
+                    return result
+
+        result.append(
+            RegistryValidationError(
+                "'%s' is not a valid setting " "for '%s'" % (newval, name), regentry=self
+            )
+        )
+
+        return result
+
+    def print_help(self, name):
+        """Human readable schema information specific to Enum data.
+
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: A human readable string of schema data.
+        """
+        outdata = self.common_print_help(name)
+        outdata += "\nPOSSIBLE VALUES\n"
+        try:
+            for possibleval in self.enum:
+                outdata += "    %s\n" % possibleval
+        except Exception:
+            for possibleval in self.Value:
+                outdata += "    %(ValueName)s\n" % possibleval
+        outdata += "\n"
+        return outdata
+
+
+class BoolValidator(BaseValidator):
+    """Bool validator class"""
+
+    def __init__(self, d):
+        super(BoolValidator, self).__init__(d)
+
+    @staticmethod
+    def is_type(attrentry):
+        """Validate that the type is boolean.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :returns: A boolean based on whether type is boolean.
+        """
+        if "type" in attrentry:
+            if isinstance(attrentry["type"], list):
+                for item in attrentry["type"]:
+                    if item.lower() == "boolean":
+                        return True
+            elif attrentry["type"] == "array":
+                for key, value in attrentry["items"].items():
+                    if key.lower() == "type" and value.lower() == "boolean":
+                        return True
+            else:
+                if attrentry["type"].lower() == "boolean":
+                    return True
+        elif "Type" in attrentry:
+            if attrentry["Type"].lower() == "boolean":
+                return True
+
+        return False
+
+    def validate(self, newval, name):
+        """Validate against schemas.
+
+        :param newval: New value to be used for validation in a list
+        :type newval: list
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: An error if value is invalid.
+        """
+        result = list()
+        if newval[0] is False or newval[0] is True:
+            return result
+
+        result.append(
+            RegistryValidationError(
+                "'%s' is not a valid setting for '%s'" % (newval[0], name), regentry=self
+            )
+        )
+
+        return result
+
+    def print_help(self, name):
+        """Human readable schema information specific to Boolean data.
+
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: A human readable string of schema data.
+        """
+        outdata = self.common_print_help(name)
+        outdata += "\nPOSSIBLE VALUES\n"
+        outdata += "    True or False\n"
+        outdata += "\n"
+        return outdata
+
+
+class StringValidator(BaseValidator):
+    """Constructor"""
+
+    def __init__(self, d):
+        super(StringValidator, self).__init__(d)
+
+    @staticmethod
+    def is_type(attrentry):
+        """Validate that the type is string.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :returns: A boolean based on whether type is string.
+        """
+        if "type" in attrentry:
+            if isinstance(attrentry["type"], list):
+                for item in attrentry["type"]:
+                    if item.lower() == "string":
+                        return True
+            elif attrentry["type"] == "array":
+                for key, value in attrentry["items"].items():
+                    if key.lower() == "type" and "string" in value:
+                        return True
+            else:
+                if attrentry["type"].lower() == "string":
+                    return True
+        elif "Type" in attrentry:
+            if attrentry["Type"].lower() == "string":
+                return True
+
+        return False
+
+    def validate(self, newvallist, _):
+        """Validate against schemas.
+
+        :param newvallist: New value to be used for validation in a list
+        :type newvallist: list
+        :returns: An error if validation fails criteria.
+        """
+        newval = newvallist[0]
+        result = list()
+        namestr = Typepathforval.typepath.defs.attributenametype
+        if not isinstance(newval, str):
+            result.append(RegistryValidationError("Given value must be a string"))
+            return result
+        if "MinLength" in self:
+            if len(newval) < int(self["MinLength"]):
+                result.append(
+                    RegistryValidationError(
+                        "'%s' must be at least '%s' characters long"
+                        % (self[namestr], int(self["MinLength"])),
+                        regentry=self,
+                    )
+                )
+
+        if "MaxLength" in self:
+            if len(newval) > int(self["MaxLength"]):
+                result.append(
+                    RegistryValidationError(
+                        "'%s' must be less than '%s' characters long"
+                        % (self[namestr], int(self["MaxLength"])),
+                        regentry=self,
+                    )
+                )
+
+        if "ValueExpression" in self:
+            if self["ValueExpression"]:
+                pat = re.compile(self["ValueExpression"])
+                if newval and not pat.match(newval):
+                    result.append(
+                        RegistryValidationError(
+                            "'%s' must match the regular expression "
+                            "'%s'" % (self[namestr], self["ValueExpression"]),
+                            regentry=self,
+                        )
+                    )
+
+        return result
+
+    def print_help(self, name):
+        """Human readable schema information specific to String data.
+
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: A human readable string of schema data.
+        """
+        wrapper = textwrap.TextWrapper()
+        wrapper.initial_indent = " " * 4
+        wrapper.subsequent_indent = " " * 4
+        outdata = self.common_print_help(name)
+        if "MinLength" in self:
+            outdata += "\nMIN LENGTH\n"
+            outdata += "%s" % wrapper.fill("%(MinLength)s" % self)
+            outdata += "\n"
+
+        if "MaxLength" in self:
+            outdata += "\nMAX LENGTH\n"
+            outdata += "%s" % wrapper.fill("%(MaxLength)s" % self)
+            outdata += "\n"
+        return outdata
+
+
+class IntegerValidator(BaseValidator):
+    """Interger validator class"""
+
+    def __init__(self, d):
+        super(IntegerValidator, self).__init__(d)
+
+    @staticmethod
+    def is_type(attrentry):
+        """Validate that the type is integer.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :returns: A boolean based on whether type is integer.
+        """
+        if "type" in attrentry:
+            if isinstance(attrentry["type"], list):
+                for item in attrentry["type"]:
+                    if item.lower() == "integer" or item.lower() == "number":
+                        return True
+            elif attrentry["type"] == "array":
+                for key, value in attrentry["items"].items():
+                    if key.lower() == "type":
+                        if value.lower() == "integer" or value.lower() == "number":
+                            return True
+            else:
+                if (
+                    attrentry["type"].lower() == "integer"
+                    or attrentry["type"].lower().lower() == "number"
+                ):
+                    return True
+        elif "Type" in attrentry:
+            if attrentry["Type"].lower() == "integer":
+                return True
+
+        return False
+
+    def validate(self, newvallist, _):
+        """Validate against schemas.
+
+        :param newvallist: New value to be used for validation in a list
+        :type newvallist: list
+        :returns: An error if validation fails criteria.
+        """
+        result = list()
+        try:
+            intval = int(newvallist[0])
+            newvallist[0] = intval
+        except:
+            result.append(
+                RegistryValidationError(
+                    "'%(Name)s' must " "be an integer value'" % (self), regentry=self
+                )
+            )
+            return result
+
+        if newvallist[0] and not str(intval).isdigit():
+            result.append(
+                RegistryValidationError(
+                    "'%(Name)s' must " "be an integer value'" % (self), regentry=self
+                )
+            )
+            return result
+
+        if "LowerBound" in self:
+            if intval < int(self["LowerBound"]):
+                result.append(
+                    RegistryValidationError(
+                        "'%s' must be greater"
+                        " than or equal to '%s'" % (self.Name, int(self["LowerBound"])),
+                        regentry=self,
+                    )
+                )
+
+        if "UpperBound" in self:
+            if intval > int(self["UpperBound"]):
+                result.append(
+                    RegistryValidationError(
+                        "'%s' must be less "
+                        "than or equal to '%s'" % (self.Name, int(self["LowerBound"])),
+                        regentry=self,
+                    )
+                )
+
+        return result
+
+    def print_help(self, name):
+        """Human readable schema information specific to Integer data.
+
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: A human readable string of schema data.
+        """
+        outdata = self.common_print_help(name)
+        return outdata
+
+
+class ObjectValidator(BaseValidator):
+    """Object validator class"""
+
+    def __init__(self, d):
+        super(ObjectValidator, self).__init__(d)
+
+    @staticmethod
+    def is_type(attrentry):
+        """Validate that the type is object.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :returns: A boolean based on whether type is object.
+        """
+        if "type" in attrentry:
+            if isinstance(attrentry["type"], list):
+                for item in attrentry["type"]:
+                    if item.lower() == "object":
+                        return True
+            elif attrentry["type"] == "array":
+                for key, value in attrentry["items"].items():
+                    if key.lower() == "type" and value.lower() == "object":
+                        return True
+                    elif key.lower() == "anyof":
+                        try:
+                            if value[0]["type"] == "object":
+                                return True
+                        except Exception:
+                            continue
+            else:
+                if attrentry["type"].lower() == "object":
+                    return True
+        elif "Type" in attrentry:
+            if attrentry["Type"].lower() == "object":
+                return True
+
+        return False
+
+    def validate(self, newval, name):
+        """Validate against schemas.
+
+        :param newval: New value to be used for validation in a list
+        :type newval: list
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: An error if value is invalid.
+        """
+        # TODO: need to add logic for true postive and false negatives.
+        result = list()
+        if isinstance(newval[0], (dict, six.string_types, int)):
+            result.append(
+                RegistryValidationError(
+                    "'%s' is not a valid setting for '%s'" % (newval[0], name),
+                    regentry=self,
+                )
+            )
+        return result
+
+    def print_help(self, name):
+        """Human readable schema information specific to Object data.
+
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: A human readable string of schema data.
+        """
+        wrapper = textwrap.TextWrapper()
+        wrapper.initial_indent = " " * 4
+        wrapper.subsequent_indent = " " * 4
+        outdata = self.common_print_help(name)
+        if "properties" in self:
+            outdata += "\nSUB-PROPERTIES\n"
+            propdata = ", ".join(self.properties.keys())
+            outdata += "%s" % wrapper.fill("%s" % propdata)
+            outdata += "\n"
+        elif "items" in self:
+            outdata += "\nSUB-PROPERTIES\n"
+            propdata = ", ".join(self["items"].properties.keys())
+            outdata += "%s" % wrapper.fill("%s" % propdata)
+            outdata += "\n"
+
+        return outdata
+
+
+class PasswordValidator(BaseValidator):
+    """Password validator class"""
+
+    def __init__(self, d):
+        super(PasswordValidator, self).__init__(d)
+
+    @staticmethod
+    def is_type(attrentry):
+        """Validate that the type is a password.
+
+        :param attrentry: Registry model entry used for validation.
+        :type attrentry: dict
+        :returns: A boolean based on whether type is a password.
+        """
+        if "type" in attrentry:
+            if isinstance(attrentry["type"], list):
+                for item in attrentry["type"]:
+                    if item.lower() == "password":
+                        return True
+            elif attrentry["type"] == "array":
+                for key, value in attrentry["items"].items():
+                    if key.lower() == "type" and value.lower() == "password":
+                        return True
+            else:
+                if attrentry["type"].lower() == "password":
+                    return True
+        elif "Type" in attrentry:
+            if attrentry["Type"].lower() == "password":
+                return True
+
+        return False
+
+    def validate(self, newvallist, _):
+        """Validate against schemas.
+
+        :param newvallist: New value to be used for validation in a list
+        :type newvallist: list
+        :returns: An error if validation fails criteria.
+        """
+        result = list()
+        newval = newvallist[0]
+
+        if newval is None:
+            return result
+
+        if not isinstance(newval, str):
+            result.append(RegistryValidationError("Given value must be a string"))
+        if "MinLength" in self:
+            if len(newval) < int(self["MinLength"]):
+                result.append(
+                    RegistryValidationError(
+                        "'%s' must be at least"
+                        " '%s' characters long" % (self.Name, int(self["MinLength"])),
+                        regentry=self,
+                    )
+                )
+
+        if "MaxLength" in self:
+            if len(newval) > int(self["MaxLength"]):
+                result.append(
+                    RegistryValidationError(
+                        "'%s' must be less "
+                        "than '%s' characters long" % (self.Name, int(self["MaxLength"])),
+                        regentry=self,
+                    )
+                )
+
+        if "ValueExpression" in self:
+            if self["ValueExpression"]:
+                pat = re.compile(self["ValueExpression"])
+                if newval and not pat.match(newval):
+                    result.append(
+                        RegistryValidationError(
+                            "'%(Name)s' must "
+                            "match the regular expression '%(Value"
+                            "Expression)s'" % (self),
+                            regentry=self,
+                        )
+                    )
+
+        return result
+
+    def print_help(self, name):
+        """Human readable schema information specific to Password data.
+
+        :param name: Clean name for outputting human readable info.
+        :type name: str
+        :returns: A human readable string of schema data.
+        """
+        wrapper = textwrap.TextWrapper()
+        wrapper.initial_indent = " " * 4
+        wrapper.subsequent_indent = " " * 4
+        outdata = self.common_print_help(name)
+        if "MinLength" in self:
+            outdata += "\nMIN LENGTH\n"
+            outdata += "%s" % wrapper.fill("%(MinLength)s" % self)
+            outdata += "\n"
+
+        if "MaxLength" in self:
+            outdata += "\nMAX LENGTH\n"
+            outdata += "%s" % wrapper.fill("%(MaxLength)s" % self)
+            outdata += "\n"
+        return outdata
+
+
+class Typepathforval(object):
+    """Way to store the typepath defines object."""
+
+    typepath = None
+
+    def __new__(cls, typepathobj):
+        if typepathobj:
+            Typepathforval.typepath = typepathobj
+
+
+def checkattr(aobj, prop):
+    """Check if an attribute exists"""
+    try:
+        if hasattr(aobj, prop):
+            return True
+    except:
+        pass
+    return False
```

## Comparing `python-ilorest-library-4.1.0.0/src/redfish/ris/__init__.py` & `python-ilorest-library-4.2.0.0/src/redfish/ris/__init__.py`

 * *Files identical despite different names*

