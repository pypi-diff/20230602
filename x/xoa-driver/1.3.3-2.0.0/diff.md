# Comparing `tmp/xoa-driver-1.3.3.tar.gz` & `tmp/xoa-driver-2.0.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "xoa-driver-1.3.3.tar", last modified: Fri Apr 28 18:56:05 2023, max compression
+gzip compressed data, was "xoa-driver-2.0.0.tar", last modified: Fri Jun  2 07:24:41 2023, max compression
```

## Comparing `xoa-driver-1.3.3.tar` & `xoa-driver-2.0.0.tar`

### file list

```diff
@@ -1,357 +1,377 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.218397 xoa-driver-1.3.3/
--rw-r--r--   0 runner    (1001) docker     (123)    11344 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     7894 2023-04-28 18:56:05.218397 xoa-driver-1.3.3/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     6717 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/README.md
--rw-r--r--   0 runner    (1001) docker     (123)       84 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)      113 2023-04-28 18:56:05.218397 xoa-driver-1.3.3/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     1714 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.138395 xoa-driver-1.3.3/xoa_driver/
--rw-r--r--   0 runner    (1001) docker     (123)       48 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3747 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/enums.py
--rw-r--r--   0 runner    (1001) docker     (123)      426 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.142395 xoa-driver-1.3.3/xoa_driver/functions/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/functions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    20530 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/functions/anlt.py
--rw-r--r--   0 runner    (1001) docker     (123)     9330 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/functions/anlt_ll_debug.py
--rw-r--r--   0 runner    (1001) docker     (123)     2742 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/functions/exceptions.py
--rw-r--r--   0 runner    (1001) docker     (123)    13860 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/functions/mgmt.py
--rw-r--r--   0 runner    (1001) docker     (123)     7175 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/functions/tools.py
--rw-r--r--   0 runner    (1001) docker     (123)      193 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/hlfuncs.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.142395 xoa-driver-1.3.3/xoa_driver/internals/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.142395 xoa-driver-1.3.3/xoa_driver/internals/core/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.150395 xoa-driver-1.3.3/xoa_driver/internals/core/commands/
--rw-r--r--   0 runner    (1001) docker     (123)      834 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    65399 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/c_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    44878 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/enums.py
--rw-r--r--   0 runner    (1001) docker     (123)    23391 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/m4_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)     2991 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/m4e_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    61833 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/m_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    73098 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/p4_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)     5061 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/p4e_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)   299854 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/p4g_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)   168261 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/p_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    12712 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pc_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    12437 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pd_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    40101 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pe_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    10171 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pec_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    40359 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/ped_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    90908 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pef_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    14813 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pf_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    19685 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pl1_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)     6508 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pl_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)     9627 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pm_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    76126 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pp_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    32823 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pr_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    90606 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/ps_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)    14472 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/pt_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)     6281 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/px_commands.py
--rw-r--r--   0 runner    (1001) docker     (123)     1717 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/commands/subtypes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/interfaces.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.150395 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/
--rw-r--r--   0 runner    (1001) docker     (123)      115 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1552 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/command_builders.py
--rw-r--r--   0 runner    (1001) docker     (123)     1865 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/constants.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.150395 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/fields/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/fields/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1183 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/fields/add_on.py
--rw-r--r--   0 runner    (1001) docker     (123)    10848 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/fields/data_types.py
--rw-r--r--   0 runner    (1001) docker     (123)     3367 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/fields/exceptions.py
--rw-r--r--   0 runner    (1001) docker     (123)     5069 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/fields/field.py
--rw-r--r--   0 runner    (1001) docker     (123)     1001 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/fields/interfaces.py
--rw-r--r--   0 runner    (1001) docker     (123)     1751 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/struct_header.py
--rw-r--r--   0 runner    (1001) docker     (123)     2296 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/struct_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     5381 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/struct_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3050 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/protocol/utils.py
--rw-r--r--   0 runner    (1001) docker     (123)      626 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/registry.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.154396 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/
--rw-r--r--   0 runner    (1001) docker     (123)      170 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1103 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/commands_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)      951 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/events_observer.py
--rw-r--r--   0 runner    (1001) docker     (123)     1597 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/exceptions.py
--rw-r--r--   0 runner    (1001) docker     (123)     2090 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/funcs.py
--rw-r--r--   0 runner    (1001) docker     (123)     3418 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/logging.py
--rw-r--r--   0 runner    (1001) docker     (123)      725 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/request_id.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/token.py
--rw-r--r--   0 runner    (1001) docker     (123)     6776 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/core/transporter/transportation_handler.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.154396 xoa-driver-1.3.3/xoa_driver/internals/exceptions/
--rw-r--r--   0 runner    (1001) docker     (123)      184 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/exceptions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      485 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/exceptions/modules.py
--rw-r--r--   0 runner    (1001) docker     (123)      431 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/exceptions/testers.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.154396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.154396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/base_index.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.158396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4784 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/cg.py
--rw-r--r--   0 runner    (1001) docker     (123)     2703 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/histogram.py
--rw-r--r--   0 runner    (1001) docker     (123)     2733 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/l2.py
--rw-r--r--   0 runner    (1001) docker     (123)     4152 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/l3.py
--rw-r--r--   0 runner    (1001) docker     (123)     5911 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/raw.py
--rw-r--r--   0 runner    (1001) docker     (123)     3384 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/replay.py
--rw-r--r--   0 runner    (1001) docker     (123)    10037 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/tcp.py
--rw-r--r--   0 runner    (1001) docker     (123)     6393 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/tls.py
--rw-r--r--   0 runner    (1001) docker     (123)     4244 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/udp.py
--rw-r--r--   0 runner    (1001) docker     (123)      841 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/user_state.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.158396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/filter/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/filter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1768 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/filter/base_filter.py
--rw-r--r--   0 runner    (1001) docker     (123)      711 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/filter/genuine_filter.py
--rw-r--r--   0 runner    (1001) docker     (123)     1460 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/length_term.py
--rw-r--r--   0 runner    (1001) docker     (123)     1921 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/match_term.py
--rw-r--r--   0 runner    (1001) docker     (123)     2037 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/port_dataset.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.158396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/streams/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/streams/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    11054 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/streams/base_stream.py
--rw-r--r--   0 runner    (1001) docker     (123)     1360 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/streams/genuine_stream.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.162396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      417 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/__interfaces.py
--rw-r--r--   0 runner    (1001) docker     (123)     3712 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/base_module.py
--rw-r--r--   0 runner    (1001) docker     (123)    10176 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/module_chimera.py
--rw-r--r--   0 runner    (1001) docker     (123)     2103 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/module_l23ve.py
--rw-r--r--   0 runner    (1001) docker     (123)    11046 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/module_l47.py
--rw-r--r--   0 runner    (1001) docker     (123)      171 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/module_l47ve.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.162396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2835 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_combi.py
--rw-r--r--   0 runner    (1001) docker     (123)     2561 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_d.py
--rw-r--r--   0 runner    (1001) docker     (123)     3188 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_e.py
--rw-r--r--   0 runner    (1001) docker     (123)     4847 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_f.py
--rw-r--r--   0 runner    (1001) docker     (123)     2609 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_g.py
--rw-r--r--   0 runner    (1001) docker     (123)     1445 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_h.py
--rw-r--r--   0 runner    (1001) docker     (123)      882 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_i.py
--rw-r--r--   0 runner    (1001) docker     (123)      882 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_j.py
--rw-r--r--   0 runner    (1001) docker     (123)      874 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_k.py
--rw-r--r--   0 runner    (1001) docker     (123)     2053 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_l.py
--rw-r--r--   0 runner    (1001) docker     (123)     4780 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_l1.py
--rw-r--r--   0 runner    (1001) docker     (123)      912 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_m.py
--rw-r--r--   0 runner    (1001) docker     (123)     1442 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_n.py
--rw-r--r--   0 runner    (1001) docker     (123)    10117 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/module_l23_base.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.162396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3667 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/base_port.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.166396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.170396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1960 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_capture.py
--rw-r--r--   0 runner    (1001) docker     (123)    13632 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23.py
--rw-r--r--   0 runner    (1001) docker     (123)     5585 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23_genuine.py
--rw-r--r--   0 runner    (1001) docker     (123)     5718 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_reception_statistics.py
--rw-r--r--   0 runner    (1001) docker     (123)     2596 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transceiver.py
--rw-r--r--   0 runner    (1001) docker     (123)     2844 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transmission_statistics.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.170396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.174396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      461 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    13567 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/general.py
--rw-r--r--   0 runner    (1001) docker     (123)     2732 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/shadow.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/working.py
--rw-r--r--   0 runner    (1001) docker     (123)     3788 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_custom_distribution.py
--rw-r--r--   0 runner    (1001) docker     (123)     5963 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_distribution.py
--rw-r--r--   0 runner    (1001) docker     (123)     3203 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_chimera.py
--rw-r--r--   0 runner    (1001) docker     (123)     7088 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_emulation.py
--rw-r--r--   0 runner    (1001) docker     (123)      686 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/reception_statistics.py
--rw-r--r--   0 runner    (1001) docker     (123)      689 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/transmission_statistics.py
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_combi.py
--rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_d.py
--rw-r--r--   0 runner    (1001) docker     (123)     2683 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_e.py
--rw-r--r--   0 runner    (1001) docker     (123)     3669 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_f.py
--rw-r--r--   0 runner    (1001) docker     (123)     1891 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_g.py
--rw-r--r--   0 runner    (1001) docker     (123)     1452 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_h.py
--rw-r--r--   0 runner    (1001) docker     (123)     2252 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_i.py
--rw-r--r--   0 runner    (1001) docker     (123)     1875 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_j.py
--rw-r--r--   0 runner    (1001) docker     (123)     1875 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_k.py
--rw-r--r--   0 runner    (1001) docker     (123)     2165 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_l.py
--rw-r--r--   0 runner    (1001) docker     (123)     2594 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_l1.py
--rw-r--r--   0 runner    (1001) docker     (123)      629 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_m.py
--rw-r--r--   0 runner    (1001) docker     (123)      646 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/fault_jkl.py
--rw-r--r--   0 runner    (1001) docker     (123)    10533 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ghijkl.py
--rw-r--r--   0 runner    (1001) docker     (123)     1628 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ijkl_chimera.py
--rw-r--r--   0 runner    (1001) docker     (123)     2253 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_l.py
--rw-r--r--   0 runner    (1001) docker     (123)     3045 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/port_l23ve.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.174396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5821 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/counters.py
--rw-r--r--   0 runner    (1001) docker     (123)     6398 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/main.py
--rw-r--r--   0 runner    (1001) docker     (123)      811 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/packet_engine.py
--rw-r--r--   0 runner    (1001) docker     (123)      402 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/revisions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.174396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6594 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/_base_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     3376 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/_tester_session.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.174396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.178396 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      861 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/rest_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1376 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/time_keeper.py
--rw-r--r--   0 runner    (1001) docker     (123)      686 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/upload_file.py
--rw-r--r--   0 runner    (1001) docker     (123)      950 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/management_interface.py
--rw-r--r--   0 runner    (1001) docker     (123)     4843 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l23_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     3111 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l23ve_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     3094 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l47_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     1388 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l47ve_tester.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.178396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/
--rw-r--r--   0 runner    (1001) docker     (123)        3 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.178396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/base_index.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.182396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3746 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/cg.py
--rw-r--r--   0 runner    (1001) docker     (123)     2192 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/histogram.py
--rw-r--r--   0 runner    (1001) docker     (123)     2283 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/l2.py
--rw-r--r--   0 runner    (1001) docker     (123)     3299 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/l3.py
--rw-r--r--   0 runner    (1001) docker     (123)     5642 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/raw.py
--rw-r--r--   0 runner    (1001) docker     (123)     3257 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/replay.py
--rw-r--r--   0 runner    (1001) docker     (123)     9747 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/tcp.py
--rw-r--r--   0 runner    (1001) docker     (123)     6252 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/tls.py
--rw-r--r--   0 runner    (1001) docker     (123)     4127 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/udp.py
--rw-r--r--   0 runner    (1001) docker     (123)      847 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/user_state.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.186396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/filter/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/filter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1621 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/filter/base_filter.py
--rw-r--r--   0 runner    (1001) docker     (123)      666 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/filter/genuine_filter.py
--rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/length_term.py
--rw-r--r--   0 runner    (1001) docker     (123)     1665 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/match_term.py
--rw-r--r--   0 runner    (1001) docker     (123)     1767 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/port_dataset.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.186396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/streams/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/streams/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8995 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/streams/base_stream.py
--rw-r--r--   0 runner    (1001) docker     (123)     1220 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/streams/genuine_stream.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.190396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      417 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/__interfaces.py
--rw-r--r--   0 runner    (1001) docker     (123)     3718 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/base_module.py
--rw-r--r--   0 runner    (1001) docker     (123)     8339 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/module_chimera.py
--rw-r--r--   0 runner    (1001) docker     (123)     1918 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/module_l23ve.py
--rw-r--r--   0 runner    (1001) docker     (123)     8424 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/module_l47.py
--rw-r--r--   0 runner    (1001) docker     (123)      155 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/module_l47ve.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.198396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2726 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_combi.py
--rw-r--r--   0 runner    (1001) docker     (123)     2564 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_d.py
--rw-r--r--   0 runner    (1001) docker     (123)     3191 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_e.py
--rw-r--r--   0 runner    (1001) docker     (123)     4850 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_f.py
--rw-r--r--   0 runner    (1001) docker     (123)     2613 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_g.py
--rw-r--r--   0 runner    (1001) docker     (123)     1448 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_h.py
--rw-r--r--   0 runner    (1001) docker     (123)      885 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_i.py
--rw-r--r--   0 runner    (1001) docker     (123)      885 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_j.py
--rw-r--r--   0 runner    (1001) docker     (123)      877 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_k.py
--rw-r--r--   0 runner    (1001) docker     (123)     2056 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_l.py
--rw-r--r--   0 runner    (1001) docker     (123)     4783 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_l1.py
--rw-r--r--   0 runner    (1001) docker     (123)      915 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_m.py
--rw-r--r--   0 runner    (1001) docker     (123)     1445 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_n.py
--rw-r--r--   0 runner    (1001) docker     (123)     9921 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/module_l23_base.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.198396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3609 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/base_port.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.202396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.206396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1972 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_capture.py
--rw-r--r--   0 runner    (1001) docker     (123)    13069 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23.py
--rw-r--r--   0 runner    (1001) docker     (123)     5384 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23_genuine.py
--rw-r--r--   0 runner    (1001) docker     (123)     4643 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_reception_statistics.py
--rw-r--r--   0 runner    (1001) docker     (123)     2596 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transceiver.py
--rw-r--r--   0 runner    (1001) docker     (123)     1820 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transmission_statistics.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.206396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.206396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      461 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    13631 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/general.py
--rw-r--r--   0 runner    (1001) docker     (123)     2738 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/shadow.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/working.py
--rw-r--r--   0 runner    (1001) docker     (123)     3794 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_custom_distribution.py
--rw-r--r--   0 runner    (1001) docker     (123)     3650 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_distribution.py
--rw-r--r--   0 runner    (1001) docker     (123)     3215 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_chimera.py
--rw-r--r--   0 runner    (1001) docker     (123)    14848 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_emulation.py
--rw-r--r--   0 runner    (1001) docker     (123)      690 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/reception_statistics.py
--rw-r--r--   0 runner    (1001) docker     (123)      693 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/transmission_statistics.py
--rw-r--r--   0 runner    (1001) docker     (123)     1008 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_combi.py
--rw-r--r--   0 runner    (1001) docker     (123)     1175 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_d.py
--rw-r--r--   0 runner    (1001) docker     (123)     2653 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_e.py
--rw-r--r--   0 runner    (1001) docker     (123)     3683 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_f.py
--rw-r--r--   0 runner    (1001) docker     (123)     1622 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_g.py
--rw-r--r--   0 runner    (1001) docker     (123)     1355 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_h.py
--rw-r--r--   0 runner    (1001) docker     (123)     2044 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_i.py
--rw-r--r--   0 runner    (1001) docker     (123)     1663 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_j.py
--rw-r--r--   0 runner    (1001) docker     (123)     1663 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_k.py
--rw-r--r--   0 runner    (1001) docker     (123)     1953 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_l.py
--rw-r--r--   0 runner    (1001) docker     (123)     2441 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_l1.py
--rw-r--r--   0 runner    (1001) docker     (123)      631 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_m.py
--rw-r--r--   0 runner    (1001) docker     (123)      649 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/fault_jkl.py
--rw-r--r--   0 runner    (1001) docker     (123)    10187 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ghijkl.py
--rw-r--r--   0 runner    (1001) docker     (123)     1546 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ijkl_chimera.py
--rw-r--r--   0 runner    (1001) docker     (123)     2133 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_l.py
--rw-r--r--   0 runner    (1001) docker     (123)     2716 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/port_l23ve.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.210396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5877 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/counters.py
--rw-r--r--   0 runner    (1001) docker     (123)     5595 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/main.py
--rw-r--r--   0 runner    (1001) docker     (123)      780 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/packet_engine.py
--rw-r--r--   0 runner    (1001) docker     (123)      402 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/revisions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.210396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5261 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/_base_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     2738 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/_tester_session.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.210396 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.214397 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      837 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/rest_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1334 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/time_keeper.py
--rw-r--r--   0 runner    (1001) docker     (123)      668 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/upload_file.py
--rw-r--r--   0 runner    (1001) docker     (123)      945 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/management_interface.py
--rw-r--r--   0 runner    (1001) docker     (123)     3388 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/l23_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     1993 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/l23ve_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)     2232 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/l47_tester.py
--rw-r--r--   0 runner    (1001) docker     (123)      700 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/l47ve_tester.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.214397 xoa-driver-1.3.3/xoa_driver/internals/state_storage/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/state_storage/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4204 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/state_storage/_speed_detector.py
--rw-r--r--   0 runner    (1001) docker     (123)     3727 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/state_storage/modules_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     5066 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/state_storage/ports_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     2987 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/state_storage/testers_state.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.214397 xoa-driver-1.3.3/xoa_driver/internals/utils/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      790 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/_base_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/attributes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1786 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/cap_id.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.218397 xoa-driver-1.3.3/xoa_driver/internals/utils/indices/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/indices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/indices/_interfaces.py
--rw-r--r--   0 runner    (1001) docker     (123)     1535 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/indices/header_modifier_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     3138 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/indices/index_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)      437 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/indices/observer.py
--rw-r--r--   0 runner    (1001) docker     (123)      378 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/kind.py
--rw-r--r--   0 runner    (1001) docker     (123)     2619 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/modules_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     2540 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/ports_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     3575 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/utils/rev_tool.py
--rw-r--r--   0 runner    (1001) docker     (123)      726 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/internals/warn.py
--rw-r--r--   0 runner    (1001) docker     (123)      399 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/lli.py
--rw-r--r--   0 runner    (1001) docker     (123)     1736 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/misc.py
--rw-r--r--   0 runner    (1001) docker     (123)     4483 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/modules.py
--rw-r--r--   0 runner    (1001) docker     (123)     4478 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/ports.py
--rw-r--r--   0 runner    (1001) docker     (123)      668 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/testers.py
--rw-r--r--   0 runner    (1001) docker     (123)      155 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.218397 xoa-driver-1.3.3/xoa_driver/v2/
--rw-r--r--   0 runner    (1001) docker     (123)      310 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/v2/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1708 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/v2/misc.py
--rw-r--r--   0 runner    (1001) docker     (123)     4506 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/v2/modules.py
--rw-r--r--   0 runner    (1001) docker     (123)     4362 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/v2/ports.py
--rw-r--r--   0 runner    (1001) docker     (123)      551 2023-04-28 18:55:50.000000 xoa-driver-1.3.3/xoa_driver/v2/testers.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-28 18:56:05.138395 xoa-driver-1.3.3/xoa_driver.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     7894 2023-04-28 18:56:05.000000 xoa-driver-1.3.3/xoa_driver.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    16494 2023-04-28 18:56:05.000000 xoa-driver-1.3.3/xoa_driver.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-28 18:56:05.000000 xoa-driver-1.3.3/xoa_driver.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)       25 2023-04-28 18:56:05.000000 xoa-driver-1.3.3/xoa_driver.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       11 2023-04-28 18:56:05.000000 xoa-driver-1.3.3/xoa_driver.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.281916 xoa-driver-2.0.0/
+-rw-r--r--   0 runner    (1001) docker     (123)    11344 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     7894 2023-06-02 07:24:41.281916 xoa-driver-2.0.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     6717 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)      113 2023-06-02 07:24:41.281916 xoa-driver-2.0.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1773 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.241915 xoa-driver-2.0.0/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     4137 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/tests/test_config_importer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1390 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/tests/test_hli.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3395 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/tests/test_lli.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6928 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/tests/test_req_parsing.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8056 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/tests/test_resp_parsing.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.241915 xoa-driver-2.0.0/xoa_driver/
+-rw-r--r--   0 runner    (1001) docker     (123)       48 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6826 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/enums.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1910 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.241915 xoa-driver-2.0.0/xoa_driver/functions/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/functions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21354 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/functions/anlt.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14823 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/functions/anlt_ll_debug.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22282 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/functions/config_cli_convert.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2353 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/functions/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13319 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/functions/mgmt.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6887 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/functions/tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)      193 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/hlfuncs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.241915 xoa-driver-2.0.0/xoa_driver/internals/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.245916 xoa-driver-2.0.0/xoa_driver/internals/commands/
+-rw-r--r--   0 runner    (1001) docker     (123)     1271 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    63875 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/c_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44944 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/enums.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22834 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/m4_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3059 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/m4e_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    60269 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/m_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    70388 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/p4_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5056 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/p4e_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)   287954 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/p4g_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)   164809 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/p_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11064 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pc_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12492 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pd_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38702 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pe_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10136 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pec_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39759 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/ped_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    82337 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pef_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14540 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pf_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18469 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pl1_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6382 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pl_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9514 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pm_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    74157 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pp_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31264 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pr_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    89005 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/ps_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14119 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/pt_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6440 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/px_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1180 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/commands/subtypes.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.249915 xoa-driver-2.0.0/xoa_driver/internals/core/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/builders.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1693 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2930 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/funcs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1133 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/token.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.249915 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2821 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/_processor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3027 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/_publisher.py
+-rw-r--r--   0 runner    (1001) docker     (123)      731 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/_request_id_counter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3040 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/_stream.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1256 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/_typings.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1387 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4525 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/handler.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.249915 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/logger/
+-rw-r--r--   0 runner    (1001) docker     (123)      133 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/logger/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2828 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/logger/__logger.py
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/logger/__state_off.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2439 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/logger/__state_on_default.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1768 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/logger/__state_on_loguru.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1455 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/logger/__state_on_user.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.249915 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2107 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/_constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1922 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8374 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.253916 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/
+-rw-r--r--   0 runner    (1001) docker     (123)     1211 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8447 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/base_struct.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3456 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/descriptor.py
+-rw-r--r--   0 runner    (1001) docker     (123)      706 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9343 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/field.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4675 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/types.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1738 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/payload/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3421 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/struct_header.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1851 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/struct_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3032 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/protocol/struct_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1477 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/core/transporter/registry.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.253916 xoa-driver-2.0.0/xoa_driver/internals/exceptions/
+-rw-r--r--   0 runner    (1001) docker     (123)      184 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/exceptions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/exceptions/modules.py
+-rw-r--r--   0 runner    (1001) docker     (123)      692 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/exceptions/testers.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.253916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.253916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/base_index.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.253916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4779 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/cg.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2698 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/histogram.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2728 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/l2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4147 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/l3.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5906 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/raw.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3341 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/replay.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9963 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/tcp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6388 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/tls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4239 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/udp.py
+-rw-r--r--   0 runner    (1001) docker     (123)      836 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/user_state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.253916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/filter/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/filter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1763 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/filter/base_filter.py
+-rw-r--r--   0 runner    (1001) docker     (123)      706 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/filter/genuine_filter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1455 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/length_term.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1916 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/match_term.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2032 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/port_dataset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.253916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/streams/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/streams/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11041 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/streams/base_stream.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1355 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/streams/genuine_stream.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.257916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      417 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/__interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3606 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/base_module.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9684 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/module_chimera.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2075 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/module_l23ve.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10978 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/module_l47.py
+-rw-r--r--   0 runner    (1001) docker     (123)      167 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/module_l47ve.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.257916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2825 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_combi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2570 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_d.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3197 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_e.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4856 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_f.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2618 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_g.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1454 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_h.py
+-rw-r--r--   0 runner    (1001) docker     (123)      891 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_i.py
+-rw-r--r--   0 runner    (1001) docker     (123)      891 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_j.py
+-rw-r--r--   0 runner    (1001) docker     (123)      883 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_k.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2062 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_l.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4784 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_l1.py
+-rw-r--r--   0 runner    (1001) docker     (123)      921 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_m.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1451 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_n.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9730 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/module_l23_base.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.257916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3657 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/base_port.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.261916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.261916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1955 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_capture.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13146 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5508 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23_genuine.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5617 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_reception_statistics.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2591 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transceiver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2839 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transmission_statistics.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.261916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.261916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13557 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/general.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2906 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/shadow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1075 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/working.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3763 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_custom_distribution.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5969 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_distribution.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3159 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_chimera.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6877 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_emulation.py
+-rw-r--r--   0 runner    (1001) docker     (123)      665 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/reception_statistics.py
+-rw-r--r--   0 runner    (1001) docker     (123)      684 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/transmission_statistics.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1001 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_combi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_d.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2678 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_e.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3664 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_f.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1830 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_g.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1851 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_h.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2247 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_i.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1870 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_j.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1870 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_k.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2160 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_l.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2589 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_l1.py
+-rw-r--r--   0 runner    (1001) docker     (123)      624 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_m.py
+-rw-r--r--   0 runner    (1001) docker     (123)      641 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/fault_jkl.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10356 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ghijkl.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1623 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ijkl_chimera.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2248 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_l.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3040 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/port_l23ve.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.261916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5816 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/counters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6393 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/main.py
+-rw-r--r--   0 runner    (1001) docker     (123)      806 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/packet_engine.py
+-rw-r--r--   0 runner    (1001) docker     (123)      402 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/revisions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.261916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6784 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/_base_tester.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.265916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.265916 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      856 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/rest_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1371 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/time_keeper.py
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/upload_file.py
+-rw-r--r--   0 runner    (1001) docker     (123)      889 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/management_interface.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5077 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l23_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3383 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l23ve_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3373 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l47_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1668 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l47ve_tester.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.265916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.265916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/base_index.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.265916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3741 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/cg.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2187 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/histogram.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2278 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/l2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3294 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/l3.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5637 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/raw.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3214 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/replay.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9673 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/tcp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6247 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/tls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4122 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/udp.py
+-rw-r--r--   0 runner    (1001) docker     (123)      842 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/user_state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.265916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/filter/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/filter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1616 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/filter/base_filter.py
+-rw-r--r--   0 runner    (1001) docker     (123)      661 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/filter/genuine_filter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1424 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/length_term.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1660 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/match_term.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1762 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/port_dataset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.265916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/streams/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/streams/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8990 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/streams/base_stream.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1215 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/streams/genuine_stream.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.269916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      417 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/__interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3708 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/base_module.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7966 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/module_chimera.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1922 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/module_l23ve.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8428 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/module_l47.py
+-rw-r--r--   0 runner    (1001) docker     (123)      155 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/module_l47ve.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.269916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2730 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_combi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2573 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_d.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3200 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_e.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4859 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_f.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2622 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_g.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1457 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_h.py
+-rw-r--r--   0 runner    (1001) docker     (123)      894 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_i.py
+-rw-r--r--   0 runner    (1001) docker     (123)      894 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_j.py
+-rw-r--r--   0 runner    (1001) docker     (123)      886 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_k.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2065 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_l.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4787 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_l1.py
+-rw-r--r--   0 runner    (1001) docker     (123)      924 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_m.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1454 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_n.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9566 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/module_l23_base.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.269916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3599 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/base_port.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.273916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.273916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1967 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_capture.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13064 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5379 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23_genuine.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4638 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_reception_statistics.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2591 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transceiver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1815 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transmission_statistics.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.273916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.273916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13621 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/general.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2947 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/shadow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1075 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/working.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3994 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_custom_distribution.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3640 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_distribution.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3218 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_chimera.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14830 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_emulation.py
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/reception_statistics.py
+-rw-r--r--   0 runner    (1001) docker     (123)      688 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/transmission_statistics.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1003 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_combi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1170 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_d.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2648 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_e.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3678 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_f.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1830 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_g.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1755 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_h.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2039 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_i.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_j.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_k.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1948 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_l.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2436 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_l1.py
+-rw-r--r--   0 runner    (1001) docker     (123)      626 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_m.py
+-rw-r--r--   0 runner    (1001) docker     (123)      644 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/fault_jkl.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10314 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ghijkl.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1541 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ijkl_chimera.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2128 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_l.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2711 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/port_l23ve.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.273916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5872 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/counters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5590 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/main.py
+-rw-r--r--   0 runner    (1001) docker     (123)      775 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/packet_engine.py
+-rw-r--r--   0 runner    (1001) docker     (123)      402 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/revisions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.277916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5483 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/_base_tester.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.277916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.277916 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      832 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/rest_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1329 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/time_keeper.py
+-rw-r--r--   0 runner    (1001) docker     (123)      663 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/upload_file.py
+-rw-r--r--   0 runner    (1001) docker     (123)      940 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/management_interface.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3678 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/l23_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2283 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/l23ve_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2522 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/l47_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/l47ve_tester.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.277916 xoa-driver-2.0.0/xoa_driver/internals/state_storage/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/state_storage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4199 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/state_storage/_speed_detector.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3647 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/state_storage/modules_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4884 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/state_storage/ports_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3361 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/state_storage/testers_state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.277916 xoa-driver-2.0.0/xoa_driver/internals/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/attributes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1696 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/cap_id.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.277916 xoa-driver-2.0.0/xoa_driver/internals/utils/indices/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/indices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/indices/_interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1503 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/indices/header_modifier_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3138 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/indices/index_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)      437 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/indices/observer.py
+-rw-r--r--   0 runner    (1001) docker     (123)      378 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/kind.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.277916 xoa-driver-2.0.0/xoa_driver/internals/utils/managers/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/managers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      995 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/managers/abc.py
+-rw-r--r--   0 runner    (1001) docker     (123)      628 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/managers/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3217 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/managers/modules_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2958 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/managers/ports_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)      602 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/rev_tool.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3374 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/utils/session.py
+-rw-r--r--   0 runner    (1001) docker     (123)      726 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/internals/warn.py
+-rw-r--r--   0 runner    (1001) docker     (123)      390 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/lli.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1797 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/misc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4483 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/modules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4478 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/ports.py
+-rw-r--r--   0 runner    (1001) docker     (123)      875 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/testers.py
+-rw-r--r--   0 runner    (1001) docker     (123)      143 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.281916 xoa-driver-2.0.0/xoa_driver/v2/
+-rw-r--r--   0 runner    (1001) docker     (123)      310 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/v2/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1691 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/v2/misc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4506 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/v2/modules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4362 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/v2/ports.py
+-rw-r--r--   0 runner    (1001) docker     (123)      551 2023-06-02 07:24:30.000000 xoa-driver-2.0.0/xoa_driver/v2/testers.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:24:41.241915 xoa-driver-2.0.0/xoa_driver.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     7894 2023-06-02 07:24:41.000000 xoa-driver-2.0.0/xoa_driver.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    17261 2023-06-02 07:24:41.000000 xoa-driver-2.0.0/xoa_driver.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-02 07:24:41.000000 xoa-driver-2.0.0/xoa_driver.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-06-02 07:24:41.000000 xoa-driver-2.0.0/xoa_driver.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       11 2023-06-02 07:24:41.000000 xoa-driver-2.0.0/xoa_driver.egg-info/top_level.txt
```

### Comparing `xoa-driver-1.3.3/LICENSE` & `xoa-driver-2.0.0/LICENSE`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/PKG-INFO` & `xoa-driver-2.0.0/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: xoa-driver
-Version: 1.3.3
+Version: 2.0.0
 Summary: Xena OpenAutomation (XOA) Python API is a driver providing user-friendly communication interfaces to Xena's physical and virtual Traffic Generation and Analysis (TGA) testers. It provides a rich collection of programming interfaces that can be used to either write test scripts or develop applications.
 Home-page: https://github.com/xenanetworks/open-automation-python-api
 Author: Artem Constantinov, Ron Ding, Leonard Yu
 Author-email: aco@xenanetworks.com, rdi@xenanetworks.com, hyu@xenanetworks.com
 Maintainer: Xena Networks
 Maintainer-email: support@xenanetworks.com
 License: Apache 2.0
```

### Comparing `xoa-driver-1.3.3/README.md` & `xoa-driver-2.0.0/README.md`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/setup.py` & `xoa-driver-2.0.0/setup.py`

 * *Files 23% similar despite different names*

```diff
@@ -18,18 +18,15 @@
         author="Artem Constantinov, Ron Ding, Leonard Yu",
         author_email="aco@xenanetworks.com, rdi@xenanetworks.com, hyu@xenanetworks.com",
         maintainer="Xena Networks",
         maintainer_email="support@xenanetworks.com",
         url="https://github.com/xenanetworks/open-automation-python-api",
         packages=setuptools.find_packages(),
         license='Apache 2.0',
-        install_requires=[
-        "typing_extensions", 
-        "loguru"
-        ],
+        install_requires=["typing_extensions"],  # we are not able to skip of using typing_extensions, for make code compatible with python 3.8
         classifiers=[
             "Development Status :: 5 - Production/Stable",
             "Intended Audience :: Developers",
             "Topic :: Software Development :: Libraries :: Python Modules",
             "License :: OSI Approved :: Apache Software License",
             "Programming Language :: Python :: 3.8",
             "Programming Language :: Python :: 3.9",
```

### Comparing `xoa-driver-1.3.3/xoa_driver/functions/anlt.py` & `xoa-driver-2.0.0/xoa_driver/functions/anlt.py`

 * *Files 6% similar despite different names*

```diff
@@ -50,16 +50,16 @@
         self._group = get_ctx(self.port)
 
     def __pp_autoneg(self, on: bool) -> Token:
         state = enums.AutoNegMode.ANEG_ON if on else enums.AutoNegMode.ANEG_OFF
         return commands.PP_AUTONEG(*self._group).set(
             state,
             enums.AutoNegTecAbility.DEFAULT_TECH_MODE,
-            enums.AutoNegFECOption.NO_FEC,
-            enums.AutoNegFECOption.NO_FEC,
+            enums.AutoNegFECOption.DEFAULT_FEC,
+            enums.AutoNegFECOption.DEFAULT_FEC,
             enums.PauseMode.NO_PAUSE,
         )
 
     def __pp_link_train(
         self,
         mode: enums.LinkTrainingMode,
         nrz_preset: enums.NRZPreset,
@@ -70,15 +70,15 @@
             pam4_frame_size=enums.PAM4FrameSize.P16K_FRAME,
             nrz_pam4_init_cond=enums.LinkTrainingInitCondition.NO_INIT,
             nrz_preset=nrz_preset,
             timeout_mode=timeout_mode,
         )
 
     def __pl1_cfg_tmp(
-        self, serdes: int, config_type: int, values: list[int]
+        self, serdes: int, config_type: enums.Layer1ConfigType, values: list[int]
     ) -> Token:
         return commands.PL1_CFG_TMP(*self._group, serdes, config_type).set(
             values=values
         )
 
     def __select_modes(self) -> tuple[enums.LinkTrainingMode, enums.TimeoutMode]:
         if self.should_do_an == True and self.should_lt_interactive == False:
@@ -233,19 +233,21 @@
         if (resp.flags & enums.LinkTrainCmdFlags.DONE.value):
             return enums.LinkTrainCmdResults(status)
         await asyncio.sleep(0.01)
     return enums.LinkTrainCmdResults.UNKNOWN
 
 
 async def lt_coeff_inc(
-    port: GenericL23Port, serdes: int, emphasis: enums.LinkTrainCoeffs
+    port: GenericL23Port,
+    serdes: int,
+    emphasis: enums.LinkTrainCoeffs
 ) -> enums.LinkTrainCmdResults:
     """
     .. versionadded:: 1.1
-    
+
     Ask the remote port to increase coeff of the specified serdes.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :param emphasis: the emphasis to increase
@@ -253,39 +255,65 @@
     :return:
     :rtype: None
     """
     return await __lt_coeff(port, serdes, emphasis, cmd=enums.LinkTrainCmd.CMD_INC)
 
 
 async def lt_coeff_dec(
-    port: GenericL23Port, serdes: int, emphasis: enums.LinkTrainCoeffs
+    port: GenericL23Port,
+    serdes: int,
+    emphasis: enums.LinkTrainCoeffs
 ) -> enums.LinkTrainCmdResults:
     """
     .. versionadded:: 1.1
-    
+
     Ask the remote port to decrease coeff of the specified serdes.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :param emphasis: the emphasis to decrease
     :type emphasis: enums.LinkTrainCoeffs
     :return:
     :rtype: None
     """
     return await __lt_coeff(port, serdes, emphasis, cmd=enums.LinkTrainCmd.CMD_DEC)
 
+async def lt_coeff_no_eq(
+    port: GenericL23Port,
+    serdes: int,
+    emphasis: enums.LinkTrainCoeffs
+) -> enums.LinkTrainCmdResults:
+
+    """
+    .. versionadded:: 2.0
+
+    Ask the remote port to set the coeff to NO_EQ on the specified serdes.
+
+    :param port: the port object
+    :type port: :class:`~xoa_driver.ports.GenericL23Port`
+    :param serdes: the serdes index, starting from 0
+    :type serdes: int
+    :param emphasis: the emphasis to set to NO_EQ
+    :type emphasis: enums.LinkTrainCoeffs
+    :return:
+    :rtype: None
+    """
+    return await __lt_coeff(port, serdes, emphasis, cmd=enums.LinkTrainCmd.CMD_NO_EQ)
+
 
 async def lt_preset(
-    port: GenericL23Port, serdes: int, preset: enums.LinkTrainPresets
+    port: GenericL23Port,
+    serdes: int,
+    preset: enums.LinkTrainPresets
 ) -> enums.LinkTrainCmdResults:
     """
     .. versionadded:: 1.1
-    
+
     Ask the remote port to use the preset of the specified serdes.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :param preset: preset index to select for the serdes, 0,1,2,3,4,
@@ -293,19 +321,21 @@
     :return:
     :rtype: None
     """
     return await __lt_coeff(port, serdes, preset, cmd=enums.LinkTrainCmd.CMD_PRESET)
 
 
 async def lt_encoding(
-    port: GenericL23Port, serdes: int, encoding: enums.LinkTrainEncoding
+    port: GenericL23Port,
+    serdes: int,
+    encoding: enums.LinkTrainEncoding
 ) -> enums.LinkTrainCmdResults:
     """
     .. versionadded:: 1.1
-    
+
     Ask the remote port to use the encoding of the specified serdes.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :param encoding: link training encoding
@@ -315,15 +345,15 @@
     """
     return await __lt_coeff(port, serdes, encoding, cmd=enums.LinkTrainCmd.CMD_ENCODING)
 
 
 async def lt_trained(port: GenericL23Port, serdes: int) -> enums.LinkTrainCmdResults:
     """
     .. versionadded:: 1.1
-    
+
     Tell the remote port that the current serdes is trained.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :return:
@@ -336,15 +366,15 @@
         cmd=enums.LinkTrainCmd.CMD_LOCAL_TRAINED,
     )
 
 
 async def lt_status(port: GenericL23Port, serdes: int) -> dict[str, t.Any]:
     """
     .. versionadded:: 1.1
-    
+
     Show the link training status.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :return: LT status of the serdes
@@ -359,26 +389,24 @@
             conn, mid, pid, serdes, enums.Layer1ConfigType.LT_INITIAL_MODULATION
         ).get(),
     )
     total_bit_count = (info.prbs_total_bits_high << 32) + info.prbs_total_bits_low
     total_error_bit_count = (
         info.prbs_total_error_bits_high << 32
     ) + info.prbs_total_error_bits_low
-    ber = (
-        total_error_bit_count / total_bit_count if total_bit_count > 0 else float("nan")
-    )
+    ber = total_error_bit_count / total_bit_count if total_bit_count > 0 else float("nan")
     return dictionize_lt_status(
         status, info, ltconf, cfg, ber, total_bit_count, total_error_bit_count
     )
 
 
 async def txtap_get(port: GenericL23Port, serdes: int) -> dict[str, int]:
     """
     .. versionadded:: 1.1
-    
+
     Get the tap value of the local TX tap.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :return: tap values of the serdes
@@ -396,15 +424,15 @@
     pre2: int,
     pre: int,
     main: int,
     post1: int,
 ) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Set the tap value of the local TX tap.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :param pre3: pre3 value
@@ -431,35 +459,36 @@
         post3=0,
     )
 
 
 async def anlt_link_recovery(port: GenericL23Port, enable: bool) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Should xenaserver automatically do link recovery when detecting down signal.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param enable: should the port automatically do link recovery when link is down.
     :type enable: bool
     :return:
     :rtype:  None
     """
     conn, mid, pid = get_ctx(port)
     cmd_ = commands.PL1_CFG_TMP(
         conn, mid, pid, 0, enums.Layer1ConfigType.ANLT_INTERACTIVE
     )
-    await cmd_.set(values=[int(enable)])
+    param = enums.OnOff.ON if enable else enums.OnOff.OFF
+    await cmd_.set(values=[param])
 
 
 async def anlt_status(port: GenericL23Port) -> dict[str, t.Any]:
     """
     .. versionadded:: 1.1
-    
+
     Get the overview of ANLT status
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :return: AN/LT status of the port
     :rtype: typing.Dict[str, typing.Any]
     """
@@ -472,23 +501,23 @@
             conn, mid, pid, 0, enums.Layer1ConfigType.ANLT_INTERACTIVE
         ).get(),
         commands.PP_AUTONEGSTATUS(conn, mid, pid).get(),
         commands.PP_LINKTRAIN(conn, mid, pid).get(),
         commands.P_CAPABILITIES(conn, mid, pid).get(),
         commands.PL1_CFG_TMP(conn, mid, pid, 0, enums.Layer1ConfigType.AN_LOOPBACK).get(),
     )
-    link_recovery, autoneg, linktrain, capabilities, allow_loopback= r
+    link_recovery, autoneg, linktrain, capabilities, allow_loopback = r
 
     return dictionize_anlt_status(link_recovery, autoneg, linktrain, capabilities, allow_loopback)
 
 
 async def anlt_log(port: GenericL23Port) -> str:
     """
     .. versionadded:: 1.1
-    
+
     Get the anlt log messages
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :return: AN/LT protocol log traces of the port
     :rtype: str
     """
@@ -502,35 +531,32 @@
     .. versionadded:: 1.3
 
     Stop AN & LT
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     """
-    
+
     anlt = DoAnlt(
         port=port,
         should_do_an=False,
         should_do_lt=False,
         an_allow_loopback=False,
         lt_preset0=enums.NRZPreset.NRZ_NO_PRESET,
         lt_initial_modulations={},
         should_lt_interactive=False,
         lt_algorithm={}
     )
     await anlt.run()
 
 
-async def txtap_autotune(
-    port: GenericL23Port,
-    serdes: int,
-) -> None:
+async def txtap_autotune(port: GenericL23Port, serdes: int) -> None:
     """
     .. versionadded:: 1.3
-    
+
     Auto tune the tap value of the local TX tap.
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param serdes: the serdes index, starting from 0
     :type serdes: int
     :return:
@@ -541,15 +567,15 @@
     await phy_autotune.set(on_off=enums.OnOff.OFF)
     await phy_autotune.set(on_off=enums.OnOff.ON)
 
 
 async def lt_im_status(port: GenericL23Port) -> dict[str, t.Any]:
     """
     .. versionadded:: 1.3
-    
+
     Get LT initial modulation config
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :return: LT initial modulation configuration of the port
     :rtype: typing.Dict[str, typing.Any]
     """
@@ -565,15 +591,15 @@
 
     return dictionize_lt_im_status(capabilities, initial_mods)
 
 
 async def lt_algorithm_status(port: GenericL23Port) -> dict[str, t.Any]:
     """
     .. versionadded:: 1.3
-    
+
     Get LT initial modulation config
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :return: LT initial modulation configuration of the port
     :rtype: typing.Dict[str, typing.Any]
     """
@@ -589,50 +615,64 @@
 
     return dictionize_lt_algorithm_status(capabilities, algorithms)
 
 
 async def anlt_strict(port: GenericL23Port, enable: bool) -> None:
     """
     .. versionadded:: 1.3
-    
+
     Should ANLT strict mode be enabled
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param enable: should ANLT strict mode be enabled
     :type enable: bool
     :return:
     :rtype:  None
     """
     conn, mid, pid = get_ctx(port)
     capabilities = await commands.P_CAPABILITIES(conn, mid, pid).get()
+    param = int(enable)
     for i in range(0, capabilities.serdes_count):
-        await commands.PL1_CFG_TMP(conn, mid, pid, i, enums.Layer1ConfigType.ANLT_STRICT_MODE).set(values=[int(enable)])
+        await commands.PL1_CFG_TMP(
+            conn,
+            mid,
+            pid,
+            i,
+            enums.Layer1ConfigType.ANLT_STRICT_MODE
+        ).set(values=[param])
 
 
 async def anlt_log_control(port: GenericL23Port, types: t.List[enums.AnLtLogControl]) -> None:
     """
     .. versionadded:: 1.3
-    
+
     Control what should be logged for ANLT by xenaserver
 
     :param port: the port object
     :type port: :class:`~xoa_driver.ports.GenericL23Port`
     :param types: control what should be logged for ANLT by xenaserver
     :type types: t.List[enums.AnLtLogControl]
     :return:
     :rtype:  None
     """
     conn, mid, pid = get_ctx(port)
     capabilities = await commands.P_CAPABILITIES(conn, mid, pid).get()
-    type = 0
-    for _type in types:
-        type |= _type.value
+    type_ = 0
+    for _t in types:
+        type_ |= _t.value
+    param = int(type_)
     for i in range(0, capabilities.serdes_count):
-        await commands.PL1_CFG_TMP(conn, mid, pid, i, enums.Layer1ConfigType.ANLT_LOG_CONTROL).set(values=[int(type)])
+        await commands.PL1_CFG_TMP(
+            conn,
+            mid,
+            pid,
+            i,
+            enums.Layer1ConfigType.ANLT_LOG_CONTROL
+        ).set(values=[param])
 
 
 __all__ = (
     "anlt_link_recovery",
     "anlt_log",
     "anlt_start",
     "anlt_status",
```

### Comparing `xoa-driver-1.3.3/xoa_driver/functions/exceptions.py` & `xoa-driver-2.0.0/xoa_driver/functions/exceptions.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,34 +1,23 @@
 from __future__ import annotations
 
 from xoa_driver.ports import GenericAnyPort
 from xoa_driver.modules import GenericAnyModule
 
+
 class ConfigError(Exception):
     msg: str
 
 
 class NotConnectedError(ConfigError):
     def __init__(self) -> None:
         self.msg = "No tester is connected!"
         super().__init__(self.msg)
 
 
-class NoSuchModuleError(ConfigError):
-    def __init__(self, module_id: int) -> None:
-        self.msg = f"No such module {module_id}!"
-        super().__init__(self.msg)
-
-
-class NoSuchPortError(ConfigError):
-    def __init__(self, port_id: int) -> None:
-        self.msg = f"No such port {port_id}!"
-        super().__init__(self.msg)
-
-
 class NotSupportPcsPmaError(ConfigError):
     def __init__(self, port: GenericAnyPort) -> None:
         module_id, port_id = port.kind.module_id, port.kind.port_id
         self.msg = f"This port {module_id}/{port_id} does not support pcs_pma!"
         super().__init__(self.msg)
 
 
@@ -59,25 +48,23 @@
 
 
 class NotSupportMedia(ConfigError):
     def __init__(self, module: GenericAnyModule) -> None:
         module_id = module.module_id
         self.msg = f"This module {module_id} does not support the media configuration!"
 
-    
+
 class NotSupportPortSpeed(ConfigError):
     def __init__(self, module: GenericAnyModule) -> None:
         module_id = module.module_id
         self.msg = f"This module {module_id} does not support the port-speed configuration under its current media configuration!"
 
 
 __all__ = (
     "ConfigError",
-    "NoSuchModuleError",
-    "NoSuchPortError",
     "NotConnectedError",
     "NotRightLaneLengthError",
     "NotRightLaneValueError",
     "NotSupportAutoNegError",
     "NotSupportLinkTrainError",
     "NotSupportPcsPmaError",
     "NotSupportMedia",
```

### Comparing `xoa-driver-1.3.3/xoa_driver/functions/mgmt.py` & `xoa-driver-2.0.0/xoa_driver/functions/mgmt.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,114 +5,109 @@
 from xoa_driver.utils import apply
 from xoa_driver.internals.hli_v2.ports.port_l23.family_l import FamilyL
 from xoa_driver.internals.hli_v2.ports.port_l23.family_l1 import FamilyL1
 from xoa_driver.ports import GenericAnyPort
 from xoa_driver.modules import GenericAnyModule, GenericL23Module, ModuleChimera
 from xoa_driver.testers import GenericAnyTester
 from .exceptions import (
-    NoSuchModuleError,
-    NoSuchPortError,
     NotSupportMedia,
     NotSupportPortSpeed,
 )
-from .tools import module_eol_info
-from itertools import chain
+from .tools import MODULE_EOL_INFO
+from itertools import chain  # type: ignore[Pylance false warning]
 from datetime import datetime
 
 PcsPmaSupported = (FamilyL, FamilyL1)
 AutoNegSupported = (FamilyL, FamilyL1)
 LinkTrainingSupported = FamilyL
 
 
 # region Testers
 async def reserve_tester(tester: GenericAnyTester, force: bool = True) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Reserve a tester regardless whether it is owned by others or not.
 
     :param tester: The tester to reserve
     :type tester: :class:`~xoa_driver.testers.GenericAnyTester`
     :param force: Should force reserve the tester
     :type force: boolean
     :return:
     :rtype: None
     """
     r = await tester.reservation.get()
     if force and r.operation == enums.ReservedStatus.RESERVED_BY_OTHER:
-        await asyncio.gather(*[free_module(m) for m in tester.modules])
+        await asyncio.gather(*(free_module(m) for m in tester.modules))
         await tester.reservation.set_reserve()
     elif r.operation == enums.ReservedStatus.RELEASED:
         # can fail in condition if an module or port is reserved by someone else
         await tester.reservation.set_reserve()
 
 
 async def free_tester(tester: GenericAnyTester) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Free a tester. If the tester is reserved by you, release the tester. If the tester is reserved by others, relinquish the tester. The tester should have no owner afterwards.
 
     :param tester: The tester to free
     :type tester: :class:`~xoa_driver.testers.GenericAnyTester`
     :return:
     :rtype: None
     """
     r = await tester.reservation.get()
     if r.operation == enums.ReservedStatus.RESERVED_BY_OTHER:
         await tester.reservation.set_relinquish()
     elif r.operation == enums.ReservedStatus.RESERVED_BY_YOU:
         await tester.reservation.set_release()
-    await asyncio.gather(*[free_module(m) for m in tester.modules])
+    await asyncio.gather(*(free_module(m) for m in tester.modules))
 
 
 # endregion
 
 
 # region Modules
 
 
 def get_module(tester: GenericAnyTester, module_id: int) -> GenericAnyModule:
     """
     .. versionadded:: 1.1
-    
+
     Get a module object of the tester.
 
     :param tester: The tester object
     :type tester: :class:`~xoa_driver.testers.GenericAnyTester`
     :param module_id: the index id of the module
     :type module_id: int
     :raises NoSuchModuleError: No such a module index on the tester
     :return: module object
     :rtype: :class:`~xoa_driver.modules.GenericAnyModule`
     """
-    try:
-        return tester.modules.obtain(module_id)
-    except KeyError:
-        raise NoSuchModuleError(module_id)
+    return tester.modules.obtain(module_id)
 
 
 def get_modules(tester: GenericAnyTester) -> tuple[GenericAnyModule, ...]:
     """
     .. versionadded:: 1.1
-    
+
     Get all modules of the tester
 
     :param tester: The tester object
     :type tester: :class:`~xoa_driver.testers.GenericAnyTester`
     :return: List of module objects
     :rtype: tuple[GenericAnyModule]
     """
     return tuple(tester.modules)
 
 
 async def reserve_module(module: GenericAnyModule, force: bool = True) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Reserve a module regardless whether it is owned by others or not.
 
     :param module: The module to reserve
     :type module: :class:`~xoa_driver.modules.GenericAnyModule`
     :param force: Should force reserve the module, defaults to True
     :type force: boolean
     :return:
@@ -126,15 +121,15 @@
         # will fail in condition coz module can be released but port can be occupied by some one else
         await module.reservation.set_reserve()
 
 
 async def free_module(module: GenericAnyModule, should_free_ports: bool = False) -> None:
     """
     .. versionadded:: 1.2
-    
+
     Free a module. If the module is reserved by you, release the module. If the module is reserved by others, relinquish the module. The module should have no owner afterwards.
 
     :param module: The module to free
     :type module: :class:`~xoa_driver.modules.GenericAnyModule`
     :param should_free_ports: _description_, defaults to False
     :type should_free_ports: bool, optional
     :return:
@@ -145,31 +140,29 @@
         await module.reservation.set_relinquish()
     elif r.operation == enums.ReservedStatus.RESERVED_BY_YOU:
         await module.reservation.set_release()
     if should_free_ports:
         await free_ports(*module.ports)
 
 
-def get_module_supported_media(
-    module: GenericL23Module | ModuleChimera,
-) -> list[dict[str, t.Any]]:
+def get_module_supported_media(module: GenericL23Module | ModuleChimera) -> list[dict[str, t.Any]]:
     """    
     .. versionadded:: 1.3
 
     Get a list of supported media, port speed and count of the module.
 
     :param module: The module object
     :type module: GenericAnyModule
     :return: List of supported media, port speed and count
     :rtype: list[dict[str, t.Any]]
     """
     supported_media_list = []
     item = {}
 
-    for media_item in module.info.media_info_list: # type: ignore
+    for media_item in module.info.media_info_list:  # type: ignore
         for sub_item in media_item.available_speeds:
             item = dict()
             item["media"] = media_item.cage_type
             item["port_count"] = sub_item.port_count
             item["port_speed"] = sub_item.port_speed
             supported_media_list.append(item)
 
@@ -253,15 +246,15 @@
             (
                 item["media"] == enums.MediaConfigurationType(current_media),
                 item["port_count"] == port_count,
                 item["port_speed"] == port_speed,
             )
         ):
             portspeed_list = [port_count] + port_count * [port_speed]
-            await module.cfp.config_extended.set(portspeed_list=portspeed_list)
+            await module.cfp.config.set(portspeed_list=portspeed_list)
             return None
     raise NotSupportPortSpeed(module)
 
 
 async def get_module_eol_date(module: GenericAnyModule) -> str:
     """
     .. versionadded:: 1.3
@@ -269,71 +262,61 @@
     Get module's End-of-Life date
 
     :param module: The module object
     :type module: GenericAnyModule
     :return: Module's EOL date
     :rtype: str
     """
-    m_eol = module_eol_info()
     resp = await module.serial_number.get()
-    for key, value in m_eol.items():
-        if str(resp.serial_number)[-2:] == key:
-            return value
-    return "2999-01-01"
+    module_key = str(resp.serial_number)[-2:]
+    return MODULE_EOL_INFO.get(module_key, "2999-01-01")
 
 
 async def get_module_eol_days(module: GenericAnyModule) -> int:
     """
     .. versionadded:: 1.3
 
     Get days until module's End-of-Life date
 
     :param module: The module object
     :type module: GenericAnyModule
     :return: days until module's End-of-Life date
     :rtype: int
     """
+    eol_string = await get_module_eol_date(module)
     date1 = datetime.now()
-    date2 = datetime.strptime("2999-01-01", '%Y-%M-%d')
+    date2 = datetime.strptime(eol_string, '%Y-%M-%d')
     timedelta = date2 - date1
-    m_eol = module_eol_info()
-    resp = await module.serial_number.get()
-    for key, value in m_eol.items():
-        if str(resp.serial_number)[-2:] == key:
-            date1 = datetime.now()
-            date2 = datetime.strptime(value, '%Y-%M-%d')
-            timedelta = date2 - date1
-            break
     return timedelta.days
 
 # endregion
 
 
 # region Ports
 
 
 def get_all_ports(tester: GenericAnyTester) -> tuple[GenericAnyPort, ...]:
     """
     .. versionadded:: 1.1
-    
+
     Get all ports of the tester
 
     :param tester: The tester object
     :type tester: :class:`~xoa_driver.testers.GenericAnyTester`
     :return: List of port objects
     :rtype: tuple[GenericAnyPort]
     """
     all_ports_ = (m.ports for m in get_modules(tester))
     return tuple(chain.from_iterable(all_ports_))
 
 
 def get_ports(tester: GenericAnyTester, module_id: int) -> tuple[GenericAnyPort, ...]:
     """
     .. versionadded:: 1.1
-    
+
     Get all ports of the module
 
     :param tester: The tester object
     :type tester: :class:`~xoa_driver.testers.GenericAnyTester`
     :param module_id: The module index
     :type module_id: int
     :return: List of port objects
@@ -342,38 +325,35 @@
     module = get_module(tester, module_id)
     return tuple(module.ports)
 
 
 def get_port(tester: GenericAnyTester, module_id: int, port_id: int) -> GenericAnyPort:
     """
     .. versionadded:: 1.1
-    
+
     Get a port of the module
 
     :param tester: The tester object
     :type tester: :class:`~xoa_driver.testers.GenericAnyTester`
     :param module_id: The module index
     :type module_id: int
     :param port_id: The port index
     :type port_id: int
     :raises NoSuchPortError: No port found with the index
     :return: The port object
     :rtype: :class:`~xoa_driver.ports.GenericAnyPort`
     """
     module = get_module(tester, module_id)
-    try:
-        return module.ports.obtain(port_id)
-    except KeyError:
-        raise NoSuchPortError(port_id)
+    return module.ports.obtain(port_id)
 
 
 async def reserve_port(port: GenericAnyPort, force: bool = True) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Reserve a port regardless whether it is owned by others or not.
 
     :param port: The port to reserve
     :type port: :class:`~xoa_driver.ports.GenericAnyPort`
     :param force: Should force reserve the port
     :type force: boolean
     :return:
@@ -388,30 +368,30 @@
     elif r.status == enums.ReservedStatus.RELEASED:
         await port.reservation.set_reserve()
 
 
 async def reset_port(port: GenericAnyPort) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Reserve and reset a port
 
     :param port: The port to reset
     :type port: :class:`~xoa_driver.ports.GenericAnyPort`
     :return:
     :rtype: None
     """
     await reserve_port(port, False)
     await port.reset.set()
 
 
 async def free_port(port: GenericAnyPort) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Free a port. If the port is reserved by you, release the port. If the port is reserved by others, relinquish the port. The port should have no owner afterwards.
 
     :param port: The port to free
     :type port: :class:`~xoa_driver.ports.GenericAnyPort`
     :return:
     :rtype: None
     """
@@ -421,21 +401,21 @@
     elif r.status == enums.ReservedStatus.RESERVED_BY_YOU:
         await port.reservation.set_release()
 
 
 async def free_ports(*ports: GenericAnyPort) -> None:
     """
     .. versionadded:: 1.1
-    
+
     Free all ports on a module.
 
     :param module: The module object
     :type module: GenericAnyModule
     """
-    await asyncio.gather(*[free_port(port=p) for p in ports])
+    await asyncio.gather(*(free_port(port=p) for p in ports))
 
 
 # endregion
 
 
 __all__ = (
     "free_module",
```

### Comparing `xoa-driver-1.3.3/xoa_driver/functions/tools.py` & `xoa-driver-2.0.0/xoa_driver/functions/tools.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,199 +1,198 @@
-from __future__ import annotations
-
-from xoa_driver.ports import GenericAnyPort
-from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.lli import commands
-from xoa_driver import enums
-
-
-def get_ctx(port: GenericAnyPort) -> tuple["itf.IConnection", int, int]:
-    return port._conn, port.kind.module_id, port.kind.port_id
-
-
-def dictionize_autoneg_status(
-    loopback: commands.PL1_CFG_TMP.GetDataAttr,
-    auto_neg_info: commands.PL1_AUTONEGINFO.GetDataAttr,
-    status: commands.PP_AUTONEGSTATUS.GetDataAttr,
-) -> dict:
-    is_enabled = True if status.mode == enums.AutoNegMode.ANEG_ON else False
-    return {
-        
-        "is_enabled": is_enabled,
-        "loopback": "allowed" if loopback.values[0] else "not allowed",
-        "duration": auto_neg_info.duration_us,
-        "successes": auto_neg_info.negotiation_success_count,
-        "timeouts": auto_neg_info.negotiation_timeout_count,
-        "loss_of_sync": auto_neg_info.negotiation_loss_of_sync_count,
-        "fec_negotiation_fails": auto_neg_info.negotiation_fec_fail_count,
-        "hcd_negotiation_fails": auto_neg_info.negotiation_hcd_fail_count,
-        "link_codewords": {
-            "tx": auto_neg_info.tx_link_codeword_count,
-            "rx": auto_neg_info.rx_link_codeword_count,
-        },
-        "next_page_messages": {
-            "tx": auto_neg_info.tx_next_page_message_count,
-            "rx": auto_neg_info.rx_next_page_message_count,
-        },
-        "unformatted_pages": {
-            "tx": auto_neg_info.tx_next_page_unformatted_count,
-            "rx": auto_neg_info.rx_next_page_unformatted_count,
-        },
-    }
-
-
-def _decode_ic(key: int) -> str:
-    dic = {
-        0: "INDV",
-        1: "Preset 4",
-        2: "Preset 1",
-        3: "Preset 5",
-        4: "Preset 2",
-        6: "Preset 3",
-    }
-    return dic.get(key, "Reserved")
-
-
-def _link_info_part(
-    info: commands.PL1_LINKTRAININFO.GetDataAttr, index: str, part: str
-) -> dict:
-    tx_attr = f"{index}_tx_{part}"
-    rx_attr = f"{index}_rx_{part}"
-    return {
-        "rx": getattr(info, rx_attr),
-        "tx": getattr(info, tx_attr),
-    }
-
-
-def _link_info_all(info: commands.PL1_LINKTRAININFO.GetDataAttr, index: str) -> dict:
-    return {
-        "current_level": getattr(info, f"{index}_current_level"),
-        "+req": _link_info_part(info, index, "increment_req_count"),
-        "-req": _link_info_part(info, index, "decrement_req_count"),
-        "coeff_and_eq_limit_reached": _link_info_part(
-            info, index, "coeff_eq_limit_reached_count"
-        ),
-        "eq_limit_reached": _link_info_part(info, index, "eq_limit_reached_count"),
-        "coeff_not_supported": _link_info_part(
-            info, index, "coeff_not_supported_count"
-        ),
-        "coeff_at_limit": _link_info_part(info, index, "coeff_at_limit_count"),
-    }
-
-
-def dictionize_lt_status(
-    status: commands.PP_LINKTRAINSTATUS.GetDataAttr,
-    info: commands.PL1_LINKTRAININFO.GetDataAttr,
-    ltconf: commands.PP_LINKTRAIN.GetDataAttr,
-    cfg: commands.PL1_CFG_TMP.GetDataAttr,
-    ber: float,
-    total_bit_count: float,
-    total_error_bit_count: float,
-) -> dict:
-    is_enabled = True if status.mode == enums.LinkTrainingStatusMode.ENABLED else False
-    is_traind = True if status.status == enums.LinkTrainingStatus.TRAINED else False
-    preset0 = "Existing tap values" if ltconf.nrz_preset == enums.NRZPreset.NRZ_WITH_PRESET else "Standard tap values"
-    ber_str = '{:.2e}'.format(ber)
-    return {
-        "is_enabled": is_enabled,
-        "is_trained": is_traind,
-        "failure": enums.LinkTrainingFailureType(status.failure).name.lower(),
-        "preset0": preset0,
-        "init_modulation": enums.LinkTrainEncoding(cfg.values[0]).name.lower(),
-        "total_bits": total_bit_count,
-        "total_errored_bits": total_error_bit_count,
-        "ber": ber_str,
-        "duration": info.duration_us,
-        "lock_lost": info.lock_lost_count,
-        "frame_lock": enums.LinkTrainFrameLock(info.frame_lock).name.lower(),
-        "remote_frame_lock": enums.LinkTrainFrameLock(
-            info.remote_frame_lock
-        ).name.lower(),
-        "frame_errors": info.num_frame_errors,
-        "overrun_errors": info.num_overruns,
-        "last_ic_received": _decode_ic(info.last_ic_received),
-        "last_ic_sent": _decode_ic(info.last_ic_sent),
-        "c(-3)": _link_info_all(info, "pre3"),
-        "c(-2)": _link_info_all(info, "pre2"),
-        "c(-1)": _link_info_all(info, "pre1"),
-        "c(0)": _link_info_all(info, "main"),
-        "c(1)": _link_info_all(info, "post1"),
-    }
-
-
-def dictionize_txtap_get(r: commands.PP_PHYTXEQ.GetDataAttr) -> dict:
-    return {
-        "c(-3)": r.post2,
-        "c(-2)": r.pre2,
-        "c(-1)": r.pre1,
-        "c(0)": r.main,
-        "c(1)": r.post1,
-    }
-
-
-def dictionize_anlt_status(
-    link_recovery: commands.PL1_CFG_TMP.GetDataAttr,
-    autoneg: commands.PP_AUTONEGSTATUS.GetDataAttr,
-    linktrain: commands.PP_LINKTRAIN.GetDataAttr,
-    capabilities: commands.P_CAPABILITIES.GetDataAttr,
-    allow_loopback: commands.PL1_CFG_TMP.GetDataAttr,
-) -> dict:
-    return {
-        "autoneg_enabled": enums.AutoNegMode(autoneg.mode).name.lower().lstrip("aneg_"),
-        "link_training_mode": enums.LinkTrainingMode(linktrain.mode).name.lower(),
-        "link_training_timeout": enums.TimeoutMode(linktrain.timeout_mode).name.lower(),
-        "link_recovery": "on" if link_recovery.values[0] == 1 else "off",
-        "serdes_count": capabilities.serdes_count,
-        "autoneg_allow_loopback": allow_loopback.values,
-        "link_training_preset0": enums.NRZPreset(linktrain.nrz_preset).name.lower(),
-    }
-
-def dictionize_lt_im_status(
-    capabilities: commands.P_CAPABILITIES.GetDataAttr,
-    initial_mods: dict[str, str]
-) -> dict:
-    return {
-        "serdes_count": capabilities.serdes_count,
-        "initial_mods": initial_mods,
-    }
-
-def dictionize_lt_algorithm_status(
-    capabilities: commands.P_CAPABILITIES.GetDataAttr,
-    algorithms: dict[str, str]
-) -> dict:
-    return {
-        "serdes_count": capabilities.serdes_count,
-        "algorithms": algorithms
-    }
-
-def module_eol_info() -> dict[str, str]:
-    m_eol = {
-        "01": "2014-04-01",
-        "02": "2024-09-01",
-        "03": "2016-03-01",
-        "09": "2022-01-01",
-        "17": "2023-01-01",
-        "18": "2023-01-01",
-        "20": "2024-11-01",
-        "22": "2018-11-01",
-        "24": "2024-11-01",
-        "26": "2023-06-01",
-        "27": "2025-10-01",
-        "30": "2024-01-01",
-        "31": "2021-09-01",
-        "32": "2024-04-01",
-        "34": "2024-08-01",
-        "36": "2024-04-01",
-        "40": "2023-03-01",
-        "50": "2022-02-01",
-        "51": "2023-08-01",
-        "54": "2023-01-01",
-        "55": "2024-01-01",
-        "60": "2025-10-01",
-        "66": "2025-01-31",
-        "90": "2025-10-01",
-        "91": "2025-10-01",
-        "93": "2025-10-01",
-        "94": "2025-10-01",
-        "97": "2025-10-01",
-        }
-    return m_eol
+from __future__ import annotations
+from typing import Any
+
+from xoa_driver.ports import GenericAnyPort
+from xoa_driver.internals.core import interfaces as itf
+from xoa_driver.lli import commands
+from xoa_driver import enums
+
+
+def get_ctx(port: GenericAnyPort) -> tuple["itf.IConnection", int, int]:
+    return (port._conn, *port.kind)
+
+
+def dictionize_autoneg_status(
+    loopback: commands.PL1_CFG_TMP.GetDataAttr,
+    auto_neg_info: commands.PL1_AUTONEGINFO.GetDataAttr,
+    status: commands.PP_AUTONEGSTATUS.GetDataAttr,
+) -> dict[str, Any]:
+    is_enabled = True if status.mode == enums.AutoNegMode.ANEG_ON else False
+    return {
+        "is_enabled": is_enabled,
+        "loopback": "allowed" if loopback.values[0] else "not allowed",
+        "duration": auto_neg_info.duration_us,
+        "successes": auto_neg_info.negotiation_success_count,
+        "timeouts": auto_neg_info.negotiation_timeout_count,
+        "loss_of_sync": auto_neg_info.negotiation_loss_of_sync_count,
+        "fec_negotiation_fails": auto_neg_info.negotiation_fec_fail_count,
+        "hcd_negotiation_fails": auto_neg_info.negotiation_hcd_fail_count,
+        "link_codewords": {
+            "tx": auto_neg_info.tx_link_codeword_count,
+            "rx": auto_neg_info.rx_link_codeword_count,
+        },
+        "next_page_messages": {
+            "tx": auto_neg_info.tx_next_page_message_count,
+            "rx": auto_neg_info.rx_next_page_message_count,
+        },
+        "unformatted_pages": {
+            "tx": auto_neg_info.tx_next_page_unformatted_count,
+            "rx": auto_neg_info.rx_next_page_unformatted_count,
+        },
+    }
+
+
+def _decode_ic(key: int) -> str:
+    dic = {
+        0: "INDV",
+        1: "Preset 4",
+        2: "Preset 1",
+        3: "Preset 5",
+        4: "Preset 2",
+        6: "Preset 3",
+    }
+    return dic.get(key, "Reserved")
+
+
+def _link_info_part(info: commands.PL1_LINKTRAININFO.GetDataAttr, index: str, part: str) -> dict[str, str]:
+    tx_attr = f"{index}_tx_{part}"
+    rx_attr = f"{index}_rx_{part}"
+    return {
+        "rx": getattr(info, rx_attr),
+        "tx": getattr(info, tx_attr),
+    }
+
+
+def _link_info_all(info: commands.PL1_LINKTRAININFO.GetDataAttr, index: str) -> dict[str, Any]:
+    return {
+        "current_level": getattr(info, f"{index}_current_level"),
+        "+req": _link_info_part(info, index, "increment_req_count"),
+        "-req": _link_info_part(info, index, "decrement_req_count"),
+        "coeff_and_eq_limit_reached": _link_info_part(
+            info, index, "coeff_eq_limit_reached_count"
+        ),
+        "eq_limit_reached": _link_info_part(info, index, "eq_limit_reached_count"),
+        "coeff_not_supported": _link_info_part(
+            info, index, "coeff_not_supported_count"
+        ),
+        "coeff_at_limit": _link_info_part(info, index, "coeff_at_limit_count"),
+    }
+
+
+def dictionize_lt_status(
+    status: commands.PP_LINKTRAINSTATUS.GetDataAttr,
+    info: commands.PL1_LINKTRAININFO.GetDataAttr,
+    ltconf: commands.PP_LINKTRAIN.GetDataAttr,
+    cfg: commands.PL1_CFG_TMP.GetDataAttr,
+    ber: float,
+    total_bit_count: float,
+    total_error_bit_count: float,
+) -> dict[str, Any]:
+    is_enabled = True if status.mode == enums.LinkTrainingStatusMode.ENABLED else False
+    is_traind = True if status.status == enums.LinkTrainingStatus.TRAINED else False
+    preset0 = "Existing tap values" if ltconf.nrz_preset == enums.NRZPreset.NRZ_WITH_PRESET else "Standard tap values"
+    ber_str = '{:.2e}'.format(ber)
+    return {
+        "is_enabled": is_enabled,
+        "is_trained": is_traind,
+        "failure": enums.LinkTrainingFailureType(status.failure).name.lower(),
+        "preset0": preset0,
+        "init_modulation": enums.LinkTrainEncoding(cfg.values[0]).name.lower(),
+        "total_bits": total_bit_count,
+        "total_errored_bits": total_error_bit_count,
+        "ber": ber_str,
+        "duration": info.duration_us,
+        "lock_lost": info.lock_lost_count,
+        "frame_lock": enums.LinkTrainFrameLock(info.frame_lock).name.lower(),
+        "remote_frame_lock": enums.LinkTrainFrameLock(
+            info.remote_frame_lock
+        ).name.lower(),
+        "frame_errors": info.num_frame_errors,
+        "overrun_errors": info.num_overruns,
+        "last_ic_received": _decode_ic(info.last_ic_received),
+        "last_ic_sent": _decode_ic(info.last_ic_sent),
+        "c(-3)": _link_info_all(info, "pre3"),
+        "c(-2)": _link_info_all(info, "pre2"),
+        "c(-1)": _link_info_all(info, "pre1"),
+        "c(0)": _link_info_all(info, "main"),
+        "c(1)": _link_info_all(info, "post1"),
+    }
+
+
+def dictionize_txtap_get(r: commands.PP_PHYTXEQ.GetDataAttr) -> dict[str, int]:
+    return {
+        "c(-3)": r.post2,
+        "c(-2)": r.pre2,
+        "c(-1)": r.pre1,
+        "c(0)": r.main,
+        "c(1)": r.post1,
+    }
+
+
+def dictionize_anlt_status(
+    link_recovery: commands.PL1_CFG_TMP.GetDataAttr,
+    autoneg: commands.PP_AUTONEGSTATUS.GetDataAttr,
+    linktrain: commands.PP_LINKTRAIN.GetDataAttr,
+    capabilities: commands.P_CAPABILITIES.GetDataAttr,
+    allow_loopback: commands.PL1_CFG_TMP.GetDataAttr,
+) -> dict[str, Any]:
+    return {
+        "autoneg_enabled": enums.AutoNegMode(autoneg.mode).name.lower().lstrip("aneg_"),
+        "link_training_mode": enums.LinkTrainingMode(linktrain.mode).name.lower(),
+        "link_training_timeout": enums.TimeoutMode(linktrain.timeout_mode).name.lower(),
+        "link_recovery": "on" if link_recovery.values[0] == 1 else "off",
+        "serdes_count": capabilities.serdes_count,
+        "autoneg_allow_loopback": allow_loopback.values,
+        "link_training_preset0": enums.NRZPreset(linktrain.nrz_preset).name.lower(),
+    }
+
+
+def dictionize_lt_im_status(
+    capabilities: commands.P_CAPABILITIES.GetDataAttr,
+    initial_mods: dict[str, str]
+) -> dict[str, Any]:
+    return {
+        "serdes_count": capabilities.serdes_count,
+        "initial_mods": initial_mods,
+    }
+
+
+def dictionize_lt_algorithm_status(
+    capabilities: commands.P_CAPABILITIES.GetDataAttr,
+    algorithms: dict[str, str]
+) -> dict[str, Any]:
+    return {
+        "serdes_count": capabilities.serdes_count,
+        "algorithms": algorithms
+    }
+
+
+MODULE_EOL_INFO: dict[str, str] = {
+    "01": "2014-04-01",
+    "02": "2024-09-01",
+    "03": "2016-03-01",
+    "09": "2022-01-01",
+    "17": "2023-01-01",
+    "18": "2023-01-01",
+    "20": "2024-11-01",
+    "22": "2018-11-01",
+    "24": "2024-11-01",
+    "26": "2023-06-01",
+    "27": "2025-10-01",
+    "30": "2024-01-01",
+    "31": "2021-09-01",
+    "32": "2024-04-01",
+    "34": "2024-08-01",
+    "36": "2024-04-01",
+    "40": "2023-03-01",
+    "50": "2022-02-01",
+    "51": "2023-08-01",
+    "54": "2023-01-01",
+    "55": "2024-01-01",
+    "60": "2025-10-01",
+    "66": "2025-01-31",
+    "90": "2025-10-01",
+    "91": "2025-10-01",
+    "93": "2025-10-01",
+    "94": "2025-10-01",
+    "97": "2025-10-01",
+}
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/c_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/c_commands.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,50 +1,75 @@
-#: Chassis Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import ipaddress
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpIPv4Address,
+    XmpLong,
+    XmpMacAddress,
+    XmpSequence,
+    XmpStr,
+    Hex
+)
+from .enums import (
+    ReservedStatus,
+    ReservedAction,
+    ChassisShutdownAction,
+    OnOff,
+    RESTControlAction,
+    ServiceStatus,
+    ChassisSessionType,
+    TimeKeeperLicenseFileState,
+    TimeKeeperLicenseType,
+    TimeKeeperLicenseError,
+    TimeKeeperServiceStatus,
+    TimeKeeperServiceAction
+)
 
 
 @register_command
 @dataclass
 class C_LOGON:
     """
     You log on to the chassis by setting the value of this command to the correct
     password for the chassis. All other commands will fail if the session has not
     been logged on.
     """
 
     code: typing.ClassVar[int] = 1
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        password: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the password value.
+    class SetDataAttr(RequestBodyStruct):
+        password: str = field(XmpStr())
+        """string, containing the password value."""
 
-    def set(self, password: str) -> "Token":
+    def set(self, password: str) -> Token[None]:
         """Set the password for creating a tester management session and logging on to the tester.
 
         :param password: password for creating a tester management session and logging on to the tester.
         :type password: str
         """
+
         return Token(self._connection, build_set_request(self, password=password))
 
 
 @register_command
 @dataclass
 class C_OWNER:
     """
@@ -58,102 +83,107 @@
     ports for that owner, and will inherit any existing reservations for that owner
     retained at the chassis. Maximum 32 ASCII characters.
     """
 
     code: typing.ClassVar[int] = 2
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        username: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the name of the owner of this session.
+    class GetDataAttr(ResponseBodyStruct):
+        username: str = field(XmpStr())
+        """string, containing the name of the owner of this session."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        username: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the name of the owner of this session.
+    class SetDataAttr(RequestBodyStruct):
+        username: str = field(XmpStr())
+        """string, containing the name of the owner of this session."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the username of this chassis management session.
 
         :return: The username of this chassis management session.
         :rtype: C_OWNER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, username: str) -> "Token":
+    def set(self, username: str) -> Token[None]:
         """Set the username of this chassis management session.
 
         :param username: the username of this chassis management session.
         :type username: str
         """
+
         return Token(self._connection, build_set_request(self, username=username))
 
 
 @register_command
 @dataclass
 class C_KEEPALIVE:
     """
     You can request this value from the chassis, simply to let it (as well as and
     any routers and proxies between you) know that the connection is still valid.
     """
 
     code: typing.ClassVar[int] = 3
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        tick_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, an increasing number from the chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        tick_count: int = field(XmpInt())
+        """integer, an increasing number from the chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the tick count value.
 
         :return: an increasing number from the chassis.
         :rtype: C_KEEPALIVE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_TIMEOUT:
     """
     The maximum number of idle seconds allowed before the connection is timed out by
     the tester.
     """
 
     code: typing.ClassVar[int] = 4
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        second_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the maximum idle interval, default is 130 seconds.
+    class GetDataAttr(ResponseBodyStruct):
+        second_count: int = field(XmpInt())
+        """integer, the maximum idle interval, default is 130 seconds."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        second_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the maximum idle interval, default is 130 seconds.
+    class SetDataAttr(RequestBodyStruct):
+        second_count: int = field(XmpInt())
+        """integer, the maximum idle interval, default is 130 seconds."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the timeout value.
 
         :return: the maximum idle interval, default is 130 seconds.
         :rtype: C_TIMEOUT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, second_count: int) -> "Token":
+    def set(self, second_count: int) -> Token[None]:
         """Set the timeout value.
 
         :param second_count: the maximum idle interval, default is 130 seconds.
         :type second_count: int
         """
+
         return Token(self._connection, build_set_request(self, second_count=second_count))
 
 
 @register_command
 @dataclass
 class C_RESERVATION:
     """
@@ -165,50 +195,54 @@
     NOTICE: Before reserve Tester need to reserve all the ports on it, otherwise
     ``<STATUS_NOTVALID>``
     """
 
     code: typing.ClassVar[int] = 5
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
+
+    class GetDataAttr(ResponseBodyStruct):
+        operation: ReservedStatus = field(XmpByte())
+        """coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get.
+        When set, it contains the operation to perform. When get, it contains the status.
+        """
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        operation: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=ReservedAction
-        )  # coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get. When set, it contains the operation to perform. When get, it contains the status.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        operation: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=ReservedStatus
-        )  # coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get. When set, it contains the operation to perform. When get, it contains the status.
+    class SetDataAttr(RequestBodyStruct):
+        operation: ReservedAction = field(XmpByte())
+        """coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get.
+        When set, it contains the operation to perform. When get, it contains the status.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the chassis reservation status.
 
         :return: the status of chassis reservation.
         :rtype: C_RESERVATION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, operation: ReservedAction) -> "Token":
+    def set(self, operation: ReservedAction) -> Token[None]:
         """Set the chassis reservation operation to be performed.
 
         :param operation: reservation operation to be performed.
         :type operation: ReservedAction
         """
+
         return Token(self._connection, build_set_request(self, operation=operation))
 
     set_release = functools.partialmethod(set, ReservedAction.RELEASE)
     """Release the ownership of the tester.
     """
+
     set_reserve = functools.partialmethod(set, ReservedAction.RESERVE)
     """Reserve the tester.
     """
+
     set_relinquish = functools.partialmethod(set, ReservedAction.RELINQUISH)
     """Release the ownership of the tester from another user.
     """
 
 
 @register_command
 @dataclass
@@ -217,81 +251,85 @@
     Identify the user who has the chassis reserved. The empty string if the chassis
     is not currently reserved.
     """
 
     code: typing.ClassVar[int] = 6
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        username: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the name of the current owner of the chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        username: str = field(XmpStr())
+        """string, containing the name of the current owner of the chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the username of the current owner of the tester.
 
         :return: the username of the current owner of the tester.
         :rtype: C_RESERVEDBY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_LOGOFF:
     """
     Terminates the current scripting session. Courtesy only, the chassis will also
     handle disconnection at the TCP/IP level
     """
 
     code: typing.ClassVar[int] = 7
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Log off from the tester and close the management session.
         """
+
         return Token(self._connection, build_set_request(self))
 
 
 @register_command
 @dataclass
 class C_DOWN:
     """
     Shuts down the chassis, and either restarts it in a clean state or leaves it
     powered off.
     """
 
     code: typing.ClassVar[int] = 8
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        magic: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, must be the special value -1480937026.
-        operation: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ChassisShutdownAction)  # coded byte, what to do after shutting chassis down.
+    class SetDataAttr(RequestBodyStruct):
+        magic: int = field(XmpInt())
+        """integer, must be the special value -1480937026."""
+        operation: ChassisShutdownAction = field(XmpByte())
+        """coded byte, what to do after shutting chassis down."""
 
-    def set(self, operation: ChassisShutdownAction) -> "Token":
+    def set(self, operation: ChassisShutdownAction) -> Token[None]:
         """Shuts down the chassis, and either restarts it in a clean state or leaves it powered off.
 
         :param operation: what to do after shutting chassis down.
         :type operation: ChassisShutdownAction
         """
+
         return Token(self._connection, build_set_request(self, magic=-1480937026, operation=operation))
 
     set_restart = functools.partialmethod(set, ChassisShutdownAction.RESTART)
     """Shuts down the tester and then restarts it.
     """
+
     set_poweroff = functools.partialmethod(set, ChassisShutdownAction.POWER_OFF)
     """Shuts down the tester and leaves it powered off.
     """
 
 
 @register_command
 @dataclass
@@ -300,38 +338,55 @@
     A series of integer values specifying various internal limits (aka.
     capabilities) of the chassis.
     """
 
     code: typing.ClassVar[int] = 9
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        version: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, chassis software build number.
-        max_name_len: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max ASCII characters in chassis name.
-        max_comment_len: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max ASCII characters in chassis comment.
-        max_password_len: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max ASCII characters in chassis password.
-        max_ext_rate: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum rate for external traffic.
-        max_session_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max number of management and scripting sessions.
-        max_chain_depth: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max chain index.
-        max_module_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum number of L23 modules.
-        max_protocol_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max protocol segments in a packet.
-        can_stream_based_arp: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, does server support stream-based ARP/NDP?
-        can_sync_traffic_start: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, does server support synchronous traffic start?
-        can_read_log_files: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, can clients read debug log files from server?
-        can_par_module_upgrade: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, can server handle parallel module upgrades?
-        can_upgrade_timekeeper: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, is server capable of upgrading the TimeKeeper application?
-        can_custom_defaults: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, can server handle custom default values for XMP parameters?
-        can_latency_f2f: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, can server handle first-to-first latency mode?
-        max_owner_name_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max number of ASCII characters in C_OWNER name
-        can_read_temperatures: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, can the server read out chassis and/or CPU temperatures? (C_TEMPERATURE ?)
+    class GetDataAttr(ResponseBodyStruct):
+        version: int = field(XmpInt())
+        """integer, chassis software build number."""
+        max_name_len: int = field(XmpInt())
+        """integer, max ASCII characters in chassis name."""
+        max_comment_len: int = field(XmpInt())
+        """integer, max ASCII characters in chassis comment."""
+        max_password_len: int = field(XmpInt())
+        """integer, max ASCII characters in chassis password."""
+        max_ext_rate: int = field(XmpInt())
+        """integer, maximum rate for external traffic."""
+        max_session_count: int = field(XmpInt())
+        """integer, max number of management and scripting sessions."""
+        max_chain_depth: int = field(XmpInt())
+        """integer, max chain index."""
+        max_module_count: int = field(XmpInt())
+        """integer, maximum number of L23 modules."""
+        max_protocol_count: int = field(XmpInt())
+        """integer, max protocol segments in a packet."""
+        can_stream_based_arp: int = field(XmpInt())
+        """integer, does server support stream-based ARP/NDP?"""
+        can_sync_traffic_start: int = field(XmpInt())
+        """integer, does server support synchronous traffic start?"""
+        can_read_log_files: int = field(XmpInt())
+        """integer, can clients read debug log files from server?"""
+        can_par_module_upgrade: int = field(XmpInt())
+        """integer, can server handle parallel module upgrades?"""
+        can_upgrade_timekeeper: int = field(XmpInt())
+        """integer, is server capable of upgrading the TimeKeeper application?"""
+        can_custom_defaults: int = field(XmpInt())
+        """integer, can server handle custom default values for XMP parameters?"""
+        can_latency_f2f: int = field(XmpInt())
+        """integer, can server handle first-to-first latency mode?"""
+        max_owner_name_length: int = field(XmpInt())
+        """integer, max number of ASCII characters in C_OWNER name"""
+        can_read_temperatures: int = field(XmpInt())
+        """integer, can the server read out chassis and/or CPU temperatures? (C_TEMPERATURE ?)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the internal limits (capabilities) of the tester.
 
         :return: A series of integer values specifying various internal limits
             - chassis software build number
             - max ASCII characters in chassis name
             - max ASCII characters in chassis comment
             - max ASCII characters in chassis password
@@ -348,91 +403,96 @@
             - can server handle custom default values for XMP parameters?
             - can server handle first-to-first latency mode?
             - max number of ASCII characters in ``C_OWNER`` name
             - can the server read out chassis and/or CPU temperatures?
 
         :rtype: C_CAPABILITIES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_MODEL:
     """
     Gets the specific model of this Xena chassis.
     """
 
     code: typing.ClassVar[int] = 10
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        model: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the Xena model designation for the chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        model: str = field(XmpStr())
+        """string, the Xena model designation for the chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the model of this Xena tester.
 
         :return: the model of the Xena tester
         :rtype: C_MODEL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_SERIALNO:
     """
     Gets the unique serial number of this particular Xena chassis.
     """
 
     code: typing.ClassVar[int] = 11
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        serial_number: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the serial number of this chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        serial_number: int = field(XmpInt())
+        """integer, the serial number of this chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the serial number of this Xena tester.
 
         :return: the serial number of the Xena tester
         :rtype: C_SERIALNO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_VERSIONNO:
     """
     Gets the major version numbers for the chassis firmware and the Xena PCI
     driver installed on the chassis.
     """
 
     code: typing.ClassVar[int] = 12
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        chassis_major_version: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the chassis firmware major version number.
-        pci_driver_version: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the cXena PCI driver version.
+    class GetDataAttr(ResponseBodyStruct):
+        chassis_major_version: int = field(XmpInt())
+        """integer, the chassis firmware major version number."""
+        pci_driver_version: int = field(XmpInt())
+        """integer, the cXena PCI driver version."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the major version numbers for the tester firmware and the Xena PCI driver installed on the chassis.
 
         :return: the firmware major version number of the tester and the PCI driver version
         :rtype: C_VERSIONNO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_PORTCOUNTS:
     """
@@ -444,26 +504,27 @@
         CFP modules return the number 8 which is the maximum number of 10G ports, but the actual number of ports can be configured dynamically using the M_CFPCONFIGEXT` command.
 
     """
 
     code: typing.ClassVar[int] = 13
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_counts: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # list of bytes, the number of ports, typically 2 or 6, or 0 for an empty slot.
+    class GetDataAttr(ResponseBodyStruct):
+        port_counts: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of bytes, the number of ports, typically 2 or 6, or 0 for an empty slot."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of ports in each module slot of the tester, and indirectly the number of slots and modules.
 
         :return: the number of ports of each module slot of the tester, 0 for an empty slot.
         :rtype: C_PORTCOUNTS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_PORTERRORS:
     """
@@ -482,30 +543,31 @@
         FCS errors are included, which leads to double-counting for streams detecting lost packets using the test payload mechanism.
 
     """
 
     code: typing.ClassVar[int] = 16
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        error_count: XmpField[xt.XmpLongList] = XmpField(xt.XmpLongList)  # list of long integers, the total number of errors across all streams, and including FCS errors.
+    class GetDataAttr(ResponseBodyStruct):
+        error_count: typing.List[int] = field(XmpSequence(types_chunk=[XmpLong()]))
+        """list of long integers, the total number of errors across all streams, and including FCS errors."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the number of errors detected across all streams on each port of each
         test module of the chassis. The counts are ordered in sequence with those of
         the module in the lowest numbered chassis slot first. Empty slots are skipped
         so that a chassis with a 6-port and a 2-port test module will return eight
         counts regardless of which slots they are in.
 
         :return: the total number of errors across all streams, and including FCS errors.
         :rtype: C_PORTERRORS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_REMOTEPORTCOUNTS:
     """
@@ -514,55 +576,57 @@
     the returned list is always 0 because it represents the xenaserver, which is
     not a remote module.
     """
 
     code: typing.ClassVar[int] = 17
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_counts: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # list of bytes, the number of ports, typically 2 or 6, or 0 for an empty slot.
+    class GetDataAttr(ResponseBodyStruct):
+        port_counts: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of bytes, the number of ports, typically 2 or 6, or 0 for an empty slot."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the number of ports of each remote module. A remote module is a
         relative to the xenaserver, for example, xenal47server. The first integer in
         the returned list is always 0 because it represents the xenaserver, which is
         not a remote module.
 
         :return: the number of ports of each module slot of the tester, 0 for an empty slot.
         :rtype: C_REMOTEPORTCOUNTS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_BUILDSTRING:
     """
     Identify the hostname of the PC that builds the xenaserver. It uniquely
     identifies the build of a xenaserver.
     """
 
     code: typing.ClassVar[int] = 19
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        build_string: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, identify the hostname of the PC that builds the xenaserver
+    class GetDataAttr(ResponseBodyStruct):
+        build_string: str = field(XmpStr())
+        """string, identify the hostname of the PC that builds the xenaserver"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the build string of the xenaserver.
 
         :return: build string that identifies the hostname of the PC that builds the xenaserver
         :rtype: C_BUILDSTRING.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_NAME:
     """
@@ -570,207 +634,217 @@
     The name is also used to distinguish the various chassis contained within a
     testbed  and in files containing the configuration for an entire test case.
     """
 
     code: typing.ClassVar[int] = 20
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        chassis_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the name of the chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        chassis_name: str = field(XmpStr())
+        """string, containing the name of the chassis."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        chassis_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the name of the chassis.
+    class SetDataAttr(RequestBodyStruct):
+        chassis_name: str = field(XmpStr())
+        """string, containing the name of the chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the name of the tester
 
         :return: the name of the tester
         :rtype: C_NAME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, chassis_name: str) -> "Token":
+    def set(self, chassis_name: str) -> Token[None]:
         """Set the name of the tester
 
         :param chassis_name: the name of the tester
         :type chassis_name: str
         """
+
         return Token(self._connection, build_set_request(self, chassis_name=chassis_name))
 
 
 @register_command
 @dataclass
 class C_COMMENT:
     """
     The description of the chassis.
     """
 
     code: typing.ClassVar[int] = 21
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the description of the chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, containing the description of the chassis."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the description of the chassis.
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, containing the description of the chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the description of the tester.
 
         :return: the description of the tester
         :rtype: C_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the description of the tester.
 
         :param comment: the description of the tester
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, comment=comment))
 
 
 @register_command
 @dataclass
 class C_PASSWORD:
     """
     The password of the chassis, which must be provided when logging on to the chassis.
     """
 
     code: typing.ClassVar[int] = 22
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        password: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the password for the chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        password: str = field(XmpStr())
+        """string, containing the password for the chassis."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        password: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the password for the chassis.
+    class SetDataAttr(RequestBodyStruct):
+        password: str = field(XmpStr())
+        """string, containing the password for the chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the password of the tester.
 
         :return: the password of the tester
         :rtype: C_PASSWORD.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, password: str) -> "Token":
+    def set(self, password: str) -> Token[None]:
         """Set the password of the tester.
 
         :param password: the password of the tester
         :type password: str
         """
+
         return Token(self._connection, build_set_request(self, password=password))
 
 
 @register_command
 @dataclass
 class C_IPADDRESS:
     """
     The network configuration parameters of the chassis management port.
     """
 
     code: typing.ClassVar[int] = 24
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the static IP address of the chassis.
-        subnet_mask: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the subnet mask of the local network segment.
-        gateway: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the gateway of the local network segment.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the static IP address of the chassis.
-        subnet_mask: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the subnet mask of the local network segment.
-        gateway: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the gateway of the local network segment.
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the static IP address of the chassis."""
+        subnet_mask: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the subnet mask of the local network segment."""
+        gateway: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the gateway of the local network segment."""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the static IP address of the chassis."""
+        subnet_mask: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the subnet mask of the local network segment."""
+        gateway: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the gateway of the local network segment."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IP configuration information of the tester.
 
         :return:
             - the static IP address of the chassis
             - the subnet mask of the local network segment
             - the gateway of the local network segment
         :rtype: C_IPADDRESS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(
-        self,
-        ipv4_address: typing.Union[str, int, ipaddress.IPv4Address],
-        subnet_mask: typing.Union[str, int, ipaddress.IPv4Address],
-        gateway: typing.Union[str, int, ipaddress.IPv4Address],
-    ) -> "Token":
+    def set(self, ipv4_address: ipaddress.IPv4Address, subnet_mask: ipaddress.IPv4Address, gateway: ipaddress.IPv4Address) -> Token[None]:
         """the IP configuration information of the tester.
 
         :param ipv4_address: the static IP address of the chassis
-        :type ipv4_address: typing.Union[str, int, ipaddress.IPv4Address]
+        :type ipv4_address: ipaddress.IPv4Address
         :param subnet_mask: the subnet mask of the local network segment
-        :type subnet_mask: typing.Union[str, int, ipaddress.IPv4Address]
+        :type subnet_mask: ipaddress.IPv4Address
         :param gateway: the gateway of the local network segment
-        :type gateway: typing.Union[str, int, ipaddress.IPv4Address]
+        :type gateway: ipaddress.IPv4Address
         """
+
         return Token(self._connection, build_set_request(self, ipv4_address=ipv4_address, subnet_mask=subnet_mask, gateway=gateway))
 
 
 @register_command
 @dataclass
 class C_DHCP:
     """
     Controls whether the chassis will use DHCP to get the management IP address.
     """
 
     code: typing.ClassVar[int] = 25
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether DHCP is enabled or disabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether DHCP is enabled or disabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether DHCP is enabled or disabled.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether DHCP is enabled or disabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether DHCP is enabled for getting management IP.
 
         :return: whether DHCP is enabled.
         :rtype: C_DHCP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set DHCP for getting management IP.
 
         :param on_off: whether DHCP is enabled or disabled.
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable DHCP for for getting management IP.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable on to DHCP for for getting management IP.
     """
 
 
 @register_command
 @dataclass
@@ -778,63 +852,66 @@
     """
     Get the MAC address for the chassis management port.
     """
 
     code: typing.ClassVar[int] = 26
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, indicating the MAC address
+    class GetDataAttr(ResponseBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, indicating the MAC address"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the MAC address for the chassis management port.
 
         :return: the MAC address for the chassis management port
         :rtype: C_MACADDRESS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_HOSTNAME:
     """
     Get or set the chassis hostname used when DHCP is enabled.
     """
 
     code: typing.ClassVar[int] = 27
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        hostname: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, hostname for chassis (default value "xena-")
+    class GetDataAttr(ResponseBodyStruct):
+        hostname: str = field(XmpStr())
+        """string, hostname for chassis (default value "xena-")"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        hostname: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, hostname for chassis (default value "xena-")
+    class SetDataAttr(RequestBodyStruct):
+        hostname: str = field(XmpStr())
+        """string, hostname for chassis (default value "xena-")"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the chassis hostname used when DHCP is enabled.
 
         :return: the chassis hostname
         :rtype: C_HOSTNAME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, hostname: str) -> "Token":
+    def set(self, hostname: str) -> Token[None]:
         """Set the chassis hostname.
 
         :param hostname: the chassis hostname
         :type hostname: str
         """
+
         return Token(self._connection, build_set_request(self, hostname=hostname))
 
 
 @register_command
 @dataclass
 class C_FLASH:
     """
@@ -844,43 +921,46 @@
 
     NOTICE: Require Tester to be reserved before change value.
     """
 
     code: typing.ClassVar[int] = 28
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, determines whether to blink all test port LEDs.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, determines whether to blink all test port LEDs."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, determines whether to blink all test port LEDs.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, determines whether to blink all test port LEDs."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of test port LEDs.
 
         :return: the blinking status of test port LEDs
         :rtype: C_FLASH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set test ports LEDs blinking status.
 
         :param on_off: determines whether to blink all test port LEDs.
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable flashing test port LEDs.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable flashing test port LEDs.
     """
 
 
 @register_command
 @dataclass
@@ -888,140 +968,147 @@
     """
     Allows to dump all the logs of a chassis.
     """
 
     code: typing.ClassVar[int] = 30
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        message_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, length of the message.
+    class GetDataAttr(ResponseBodyStruct):
+        message_length: int = field(XmpInt())
+        """integer, length of the message."""
+        data: Hex = field(XmpHex())
+        """list of hex bytes, all the logs of a chassis"""
 
-        data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, all the logs of a chassis
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get chassis logs.
 
         :return: length of the message and all the logs of the chassis
         :rtype: C_DEBUGLOGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_TEMPERATURE:
     """
     Get chassis temperature readings, if supported. Unit is millidegree Celsius.
     """
 
     code: typing.ClassVar[int] = 31
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mb1_temperature: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the temperature of motherboard 1. Unit is millidegree Celsius.
-
-        mb2_temperature: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the temperature of motherboard 2. Unit is millidegree Celsius.
+    _connection: 'interfaces.IConnection'
 
-        cpu_temperature: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the temperature of CPU. Unit is millidegree Celsius.
+    class GetDataAttr(ResponseBodyStruct):
+        mb1_temperature: int = field(XmpInt())
+        """integer, the temperature of motherboard 1. Unit is millidegree Celsius."""
+        mb2_temperature: int = field(XmpInt())
+        """integer, the temperature of motherboard 2. Unit is millidegree Celsius."""
+        cpu_temperature: int = field(XmpInt())
+        """integer, the temperature of CPU. Unit is millidegree Celsius."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get chassis temperature readings.
 
         :return:
             - the temperature of motherboard 1 (millidegree Celsius)
             - the temperature of motherboard 2 (millidegree Celsius)
             - the temperature of CPU (millidegree Celsius)
         :rtype: C_TEMPERATURE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_RESTPORT:
     """
     The TCP port used by the REST API server.
     """
 
     code: typing.ClassVar[int] = 32
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        tcp_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, containing the TCP port number (default 57911)
+    class GetDataAttr(ResponseBodyStruct):
+        tcp_port: int = field(XmpInt())
+        """integer, containing the TCP port number (default 57911)"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        tcp_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, containing the TCP port number (default 57911)
+    class SetDataAttr(RequestBodyStruct):
+        tcp_port: int = field(XmpInt())
+        """integer, containing the TCP port number (default 57911)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the TCP port number used by the REST API server.
 
         :return: the TCP port number used by the REST API server
         :rtype: xt.XmpInt
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, tcp_port: int) -> "Token":
+    def set(self, tcp_port: int) -> Token[None]:
         """Set the TCP port number used by the REST API server.
 
         :param tcp_port: the TCP port number (default 57911)
         :type tcp_port: int
         """
+
         return Token(self._connection, build_set_request(self, tcp_port=tcp_port))
 
 
 @register_command
 @dataclass
 class C_RESTENABLE:
     """
     Controls whether the chassis will run REST API server or not. The command takes
     affect only after chassis reset. To start/stop REST API server use ``C_RESTCONTROL`` command.
     """
 
     code: typing.ClassVar[int] = 33
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, determines whether REST API server should be enabled or disabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, determines whether REST API server should be enabled or disabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, determines whether REST API server should be enabled or disabled.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, determines whether REST API server should be enabled or disabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the On/Off status of the REST API server.
 
         :return: the status of the REST API server, whether it is enabled.
         :rtype: xt.XmpByte
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the On/Off status of the REST API server.
 
         :param on_off: determines whether REST API server should be enabled or disabled
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the REST API server.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the REST API server.
     """
 
 
 @register_command
 @dataclass
@@ -1030,26 +1117,27 @@
     Controls REST API server. This command should be used with extra care as it can
     affect other users using the server.
     """
 
     code: typing.ClassVar[int] = 34
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        operation: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=RESTControlAction)  # coded byte, what to do with the REST API server.
+    class SetDataAttr(RequestBodyStruct):
+        operation: RESTControlAction = field(XmpByte())
+        """coded byte, what to do with the REST API server."""
 
-    def set(self, operation: RESTControlAction) -> "Token":
+    def set(self, operation: RESTControlAction) -> Token[None]:
         """Controlling the REST API server.
 
         :param operation: what to do with the REST API server
         :type operation: RESTControlAction
         """
+
         return Token(self._connection, build_set_request(self, operation=operation))
 
 
 @register_command
 @dataclass
 class C_RESTSTATUS:
     """
@@ -1057,202 +1145,206 @@
     not. To get the admin status (whether the server is enabled or disabled) use
     ``C_RESTCONTROL`` command.
     """
 
     code: typing.ClassVar[int] = 35
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ServiceStatus)  # coded byte, determines the REST API server running status.
+    class GetDataAttr(ResponseBodyStruct):
+        status: ServiceStatus = field(XmpByte())
+        """coded byte, determines the REST API server running status."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the operation status of th REST API server.
 
         :return: the operation status of th REST API server
         :rtype: C_RESTSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_WATCHDOG:
     """
     If the chassis stalls for a long time, when the timer expires the chassis will
     be rebooted automatically.
     """
 
     code: typing.ClassVar[int] = 36
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        timer_value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the timer value that reboots the chassis. Unit = second.
+    class GetDataAttr(ResponseBodyStruct):
+        timer_value: int = field(XmpInt())
+        """integer, the timer value that reboots the chassis. Unit = second."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        timer_value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the timer value that reboots the chassis. Unit = second.
+    class SetDataAttr(RequestBodyStruct):
+        timer_value: int = field(XmpInt())
+        """integer, the timer value that reboots the chassis. Unit = second."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the time value that reboots the chassis if it stalls for a long time.
 
         :return: the timer value that reboots the chassis. Unit = second.
         :rtype: C_WATCHDOG.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, timer_value: int) -> "Token":
+    def set(self, timer_value: int) -> Token[None]:
         """Set the time value that reboots the chassis if it stalls for a long time.
 
         :param timer_value: the timer value that reboots the chassis
         :type timer_value: int
         """
+
         return Token(self._connection, build_set_request(self, timer_value=timer_value))
 
 
 @register_command
 @dataclass
 class C_INDICES:
     """
     Gets the session indices for all current sessions on the chassis.
     """
 
     code: typing.ClassVar[int] = 40
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        """Returned data structure.
+    class GetDataAttr(ResponseBodyStruct):
+        session_ids: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the session indices for all current sessions on the chassis."""
 
-        Attributes:
-
-        :attr session_ids: the session indices for all current sessions on the chassis
-        :type session_ids: List[int]
-        """
-        session_ids: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the session indices for all current sessions on the chassis.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the session indices for all current sessions on the chassis.
 
         :return: the session indices for all current sessions on the chassis
         :rtype: C_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_STATSESSION:
     """
     Gets information and statistics for a particular session on the chassis.
     """
 
     code: typing.ClassVar[int] = 41
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
-    session_xindex: int
+    _connection: 'interfaces.IConnection'
+    _session_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        session_type: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=ChassisSessionType)  # coded integer, which kind of session.
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, client IP address.
-        owner: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the name of the session owner.
-        operation_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of operations done during the session.
-        requested_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of bytes received by the chassis.
-        responded_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of bytes sent by the chassis.
+    class GetDataAttr(ResponseBodyStruct):
+        session_type: ChassisSessionType = field(XmpInt())
+        """coded integer, which kind of session."""
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, client IP address."""
+        owner: str = field(XmpStr())
+        """string, the name of the session owner."""
+        operation_count: int = field(XmpLong())
+        """long integer, number of operations done during the session."""
+        requested_byte_count: int = field(XmpLong())
+        """long integer, number of bytes received by the chassis."""
+        responded_byte_count: int = field(XmpLong())
+        """long integer, number of bytes sent by the chassis."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets information and statistics for a particular session on the chassis.
 
         :return:
             - type of session
             - client IP address
             - the name of the session owner
             - number of operations done during the session
             - number of bytes received by the chassis
             - number of bytes sent by the chassis
         :rtype: C_STATSESSION.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, indices=[self.session_xindex]))
+
+        return Token(self._connection, build_get_request(self, indices=[self._session_xindex]))
 
 
 @register_command
 @dataclass
 class C_TKLICFILE:
     """
     Get Xena TimeKeeper license file content.
     """
 
     code: typing.ClassVar[int] = 49
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        license_content: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # TODO: probably wrong type
+    class GetDataAttr(ResponseBodyStruct):
+        license_content: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        license_content: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # TODO: probably wrong type
+    class SetDataAttr(RequestBodyStruct):
+        license_content: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get Xena TimeKeeper license file content.
 
         :return: Xena TimeKeeper license file content
         :rtype: C_TKLICFILE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, license_content: str) -> "Token":
+    def set(self, license_content: str) -> Token[None]:
         """Set Xena TimeKeeper license file content.
 
         :param license_content: Xena TimeKeeper license file content
         :type license_content: str
         """
+
         return Token(self._connection, build_set_request(self, license_content=license_content))
 
 
 @register_command
 @dataclass
 class C_TKLICSTATE:
     """
     Get the state of the Xena TimeKeeper license file content.
     """
 
     code: typing.ClassVar[int] = 50
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        license_file_state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TimeKeeperLicenseFileState)  # coded byte, timekeeper license state.
+    _connection: 'interfaces.IConnection'
 
-        license_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TimeKeeperLicenseType)  # coded byte, license type.
+    class GetDataAttr(ResponseBodyStruct):
+        license_file_state: TimeKeeperLicenseFileState = field(XmpByte())
+        """coded byte, timekeeper license state."""
+        license_type: TimeKeeperLicenseType = field(XmpByte())
+        """coded byte, license type."""
+        license_errors: typing.List[TimeKeeperLicenseError] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """coded integers, license errors."""
 
-        license_errors: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList, choices=TimeKeeperLicenseError)  # coded integers, license errors.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the state of the Xena TimeKeeper license file content.
 
         :return:
             - timekeeper license state
             - license type
             - license errors
         :rtype: C_TKLICSTATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_FILESTART:
     """
@@ -1260,26 +1352,31 @@
     a sequence og ``C_FILEDATA`` parameters to provide the file content, and finally a
     ``C_FILEFINISH`` to commit the new file to the chassis.
     """
 
     code: typing.ClassVar[int] = 51
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        file_type: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, little-endian integer, the file type, should be 1.
-        size: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, little-endian integer, the number of bytes in the file.
-        time: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, little-endian integer, the Linux date+time of the file.
-        mode: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, little-endian integer, the Linux permissions of the file.
-        checksum: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, little-endian integer, the checksum of the file.
-        name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the name and location of the file, as a full path.
+    class SetDataAttr(RequestBodyStruct):
+        file_type: Hex = field(XmpHex(size=4))
+        """four hex bytes, little-endian integer, the file type, should be 1."""
+        size: Hex = field(XmpHex(size=4))
+        """four hex bytes, little-endian integer, the number of bytes in the file."""
+        time: Hex = field(XmpHex(size=4))
+        """four hex bytes, little-endian integer, the Linux date+time of the file."""
+        mode: Hex = field(XmpHex(size=4))
+        """four hex bytes, little-endian integer, the Linux permissions of the file."""
+        checksum: Hex = field(XmpHex(size=4))
+        """four hex bytes, little-endian integer, the checksum of the file."""
+        name: str = field(XmpStr())
+        """string, the name and location of the file, as a full path."""
 
-    def set(self, file_type: str, size: str, time: str, mode: str, checksum: str, name: str) -> "Token":
+    def set(self, file_type: Hex, size: Hex, time: Hex, mode: Hex, checksum: Hex, name: str) -> Token[None]:
         """Initiates upload of a file to the chassis.
 
         :param file_type: the file type, should be 1
         :type file_type: str
         :param size: the number of bytes in the file
         :type size: str
         :param time: he Linux date+time of the file
@@ -1287,99 +1384,106 @@
         :param mode: the Linux permissions of the file
         :type mode: str
         :param checksum: the checksum of the file
         :type checksum: str
         :param name: the name and location of the file, as a full path
         :type name: str
         """
+
         return Token(self._connection, build_set_request(self, file_type=file_type, size=size, time=time, mode=mode, checksum=checksum, name=name))
 
 
 @register_command
 @dataclass
 class C_FILEDATA:
     """
     Uploads a fragment of a file to the chassis.
     """
 
     code: typing.ClassVar[int] = 52
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the position within the file.
-        data_bytes: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the data content of a section of the file.
+    class SetDataAttr(RequestBodyStruct):
+        offset: int = field(XmpInt())
+        """integer, the position within the file."""
+        data_bytes: Hex = field(XmpHex())
+        """list of hex bytes, the data content of a section of the file."""
 
-    def set(self, offset: int, data_bytes: str) -> "Token":
+    def set(self, offset: int, data_bytes: Hex) -> Token[None]:
         """Uploads a fragment of a file to the chassis.
 
         :param offset: the position within the file
         :type offset: int
         :param data_bytes: the data content of a section of the file
         :type data_bytes: str
         """
+
         return Token(self._connection, build_set_request(self, offset=offset, data_bytes=data_bytes))
 
 
 @register_command
 @dataclass
 class C_FILEFINISH:
     """
     Completes upload of a file to the chassis. After validation it will replace any
     existing file with the same name.
     """
 
     code: typing.ClassVar[int] = 53
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        magic: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, must be the special value -1480937026.
+    class SetDataAttr(RequestBodyStruct):
+        magic: int = field(XmpInt())
+        """integer, must be the special value -1480937026."""
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Completes upload of a file to the chassis. After validation it will replace any existing file with the same name.
         """
+
         return Token(self._connection, build_set_request(self, magic=-1480937026))
 
 
 @register_command
 @dataclass
 class C_TRAFFIC:
     """
     Starts or stops the traffic on a number of ports on the chassis simultaneously.
     The ports are identified by pairs of integers (module port).
     """
 
     code: typing.ClassVar[int] = 55
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, determines whether to start or stop traffic generation.
-        module_ports: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, specifies ports on modules, which should stop or start generating traffic.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, determines whether to start or stop traffic generation."""
+        module_ports: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, specifies ports on modules, which should stop or start generating traffic."""
 
-    def set(self, on_off: OnOff, module_ports: typing.List[int]) -> "Token":
+    def set(self, on_off: OnOff, module_ports: typing.List[int]) -> Token[None]:
         """Starts or stops the traffic on a number of ports on the chassis simultaneously.
 
         :param on_off: determines whether to start or stop traffic generation
         :type on_off: OnOff
         :param module_ports: specifies ports on modules, which should stop or start generating traffic
         :type module_ports: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, on_off=on_off, module_ports=module_ports))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Stop the traffic on a number of ports on the chassis simultaneously.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Start the traffic on a number of ports on the chassis simultaneously.
     """
 
 
 @register_command
 @dataclass
@@ -1389,129 +1493,133 @@
     the chassis firmware is thus where the number is obtained  with the ``C_VERSIONNO``
     command and the number is obtained with the ``C_VERSIONNO_MINOR`` command.
     """
 
     code: typing.ClassVar[int] = 56
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        chassis_minor_version: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the chassis firmware minor version number.
-        reserved_1: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, reserved.
-        reserved_2: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, reserved.
+    class GetDataAttr(ResponseBodyStruct):
+        chassis_minor_version: int = field(XmpInt())
+        """integer, the chassis firmware minor version number."""
+        reserved_1: int = field(XmpInt())
+        """integer, reserved."""
+        reserved_2: int = field(XmpInt())
+        """integer, reserved."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the minor version number for the chassis firmware.
 
         :return:
             - the minor version number for the chassis firmware
             - reserved, 0
             - reserved, 0
         :rtype: C_VERSIONNO_MINOR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_START:
     """
     Start traffic on N ports and each port is described by (module index, port
     index).
     """
 
     code: typing.ClassVar[int] = 60
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        module_ports: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # list of bytes, specifies ports on modules, which should stop or start generating traffic.
+    class SetDataAttr(RequestBodyStruct):
+        module_ports: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of bytes, specifies ports on modules, which should stop or start generating traffic."""
 
-    def set(self, module_ports: typing.List[int]) -> "Token":
+    def set(self, module_ports: typing.List[int]) -> Token[None]:
         """Start traffic on N ports and each port is described by (module index, port index).
 
         :param module_ports: specifies ports on modules, which should stop or start generating traffic
         :type module_ports: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module_ports=module_ports))
 
 
 @register_command
 @dataclass
 class C_STOP:
     """
     Stop traffic on N ports and each port is described by (module index, port index)
     """
 
     code: typing.ClassVar[int] = 61
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        module_ports: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # list of bytes, specifies ports on modules, which should stop or start generating traffic.
+    class SetDataAttr(RequestBodyStruct):
+        module_ports: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of bytes, specifies ports on modules, which should stop or start generating traffic."""
 
-    def set(self, module_ports: typing.List[int]) -> "Token":
+    def set(self, module_ports: typing.List[int]) -> Token[None]:
         """Stop traffic on N ports and each port is described by (module index, port index).
 
         :param module_ports: specifies ports on modules, which should stop or start generating traffic
         :type module_ports: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module_ports=module_ports))
 
 
 @register_command
 @dataclass
 class C_MULTIUSER:
     """
     Enable or disable the ability to control one resource from several different TCP
     connections.
     """
 
     code: typing.ClassVar[int] = 62
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
+
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enable or disable the ability to control one resource from several different TCP connections"""
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=OnOff
-        )  # coded byte, enable or disable the ability to control one resource from several different TCP connections
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=OnOff
-        )  # coded byte, enable or disable the ability to control one resource from several different TCP connections
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enable or disable the ability to control one resource from several different TCP connections"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of the ability to control one resource from several different TCP connections.
 
         :return: the status of the ability to control one resource from several different TCP connections
         :rtype: C_MULTIUSER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Enable or disable the ability to control one resource from several different TCP connections.
 
         :param on_off: enable or disable the ability to control one resource from several different TCP connections
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the ability to control one resource from several different TCP.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the ability to control one resource from several different TCP.
     """
 
 
 @register_command
 @dataclass
@@ -1519,113 +1627,113 @@
     """
     To load and save CLI commands e.g. port configuration, through the binary XMP session.
     """
 
     code: typing.ClassVar[int] = 64
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        command_string: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, text CLI command
+    class SetDataAttr(RequestBodyStruct):
+        command_string: str = field(XmpStr())
+        """string, text CLI command"""
 
-    def set(self, command_string: str) -> "Token":
+    def set(self, command_string: str) -> Token[None]:
         """Set the CLI commands through a binary XMP session.
 
         :param command_string: text CLI command
         :type command_string: str
         """
+
         return Token(self._connection, build_set_request(self, command_string=command_string))
 
 
 @register_command
 @dataclass
 class C_TKSTATUS:
     """
     Report TimeKeeper version and status.
     """
 
     code: typing.ClassVar[int] = 65
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status_string: XmpField[xt.XmpStr] = XmpField(
-            xt.XmpStr
-        )  # string. Version, TimeKeeper license expiration, and TimeKeeper status. The string is formatted as shown in the example below. Each line is separated by \n.
-
-        # TimeKeeper Status\n
-        # ================================================================================\n
-        # TimeKeeper version 8.0.3\n
-        # License expires in 33 days (including grace period)\n
-        # TimeKeeper is not running\n
+    class GetDataAttr(ResponseBodyStruct):
+        status_string: str = field(XmpStr())
+        """string. Version, TimeKeeper license expiration, and TimeKeeper status.
+        The string is formatted as shown in the example below. Each line is separated by.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the version and status of TimeKeeper
 
         :return:
             Version, TimeKeeper license expiration, and TimeKeeper status. The string is formatted as shown in the example below.
 
             The format is shown below.
 
             TimeKeeper Status
             TimeKeeper version 8.0.3
             License expires in 33 days (including grace period)
             TimeKeeper is not running
 
         :rtype: C_TKSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_TKSVCSTATE:
     """
     Get and control TimeKeeper service state.
     """
 
     code: typing.ClassVar[int] = 66
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TimeKeeperServiceAction)  # coded byte, TimeKeeper service state
+    class GetDataAttr(ResponseBodyStruct):
+        state: TimeKeeperServiceStatus = field(XmpByte())
+        """coded byte, TimeKeeper service state"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TimeKeeperServiceStatus)  # coded byte, TimeKeeper service state
+    class SetDataAttr(RequestBodyStruct):
+        state: TimeKeeperServiceAction = field(XmpByte())
+        """coded byte, TimeKeeper service state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get TimeKeeper service state
 
         :return: TimeKeeper service state
         :rtype: C_TKSVCSTATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, state: TimeKeeperServiceAction) -> "Token":
+    def set(self, state: TimeKeeperServiceAction) -> Token[None]:
         """Control TimeKeeper service state
 
         :param state: TimeKeeper service state
         :type state: TimeKeeperServiceAction
         """
+
         return Token(self._connection, build_set_request(self, state=state))
 
     set_stop = functools.partialmethod(set, TimeKeeperServiceAction.STOP)
     """Stop the TimerKeeper service.
     """
+
     set_start = functools.partialmethod(set, TimeKeeperServiceAction.START)
     """Start the TimerKeeper service.
     """
+
     set_restart = functools.partialmethod(set, TimeKeeperServiceAction.RESTART)
     """Restart the TimerKeeper service.
     """
 
 
 @register_command
 @dataclass
@@ -1633,88 +1741,92 @@
     """
     TimeKeeper config file content.
     """
 
     code: typing.ClassVar[int] = 67
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        config_file: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, TimeKeeper config file content
+    class GetDataAttr(ResponseBodyStruct):
+        config_file: str = field(XmpStr())
+        """string, TimeKeeper config file content"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        config_file: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, TimeKeeper config file content
+    class SetDataAttr(RequestBodyStruct):
+        config_file: str = field(XmpStr())
+        """string, TimeKeeper config file content"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get TimeKeeper config file content.
 
         :return: TimeKeeper config file content
         :rtype: C_TKCONFIG.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, config_file: str) -> "Token":
+    def set(self, config_file: str) -> Token[None]:
         """Set TimeKeeper config file content.
 
         :param config_file: TimeKeeper config file content
         :type config_file: str
         """
+
         return Token(self._connection, build_set_request(self, config_file=config_file))
 
 
 @register_command
 @dataclass
 class C_TKGPSSTATE:
     """
     Get TimeKeeper GPS status.
     """
 
     code: typing.ClassVar[int] = 68
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, TimeKeeper GPS status
+    class GetDataAttr(ResponseBodyStruct):
+        status: str = field(XmpStr())
+        """string, TimeKeeper GPS status"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get TimeKeeper GPS status.
 
         :return: TimeKeeper GPS status
         :rtype: C_TKGPSSTATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_TIME:
     """
     Get local chassis time in seconds.
     """
 
     code: typing.ClassVar[int] = 69
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        local_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, local chassis time in seconds
+    class GetDataAttr(ResponseBodyStruct):
+        local_time: int = field(XmpLong())
+        """long integer, local chassis time in seconds"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get local chassis time in seconds.
 
         :return: local chassis time in seconds
         :rtype: C_TIME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
 
 @register_command
 @dataclass
 class C_TRAFFICSYNC:
     """
@@ -1728,58 +1840,61 @@
         This requires that the chassis in question all use the TimeKeeper option to keep their CPU clocks synchronized.
 
     """
 
     code: typing.ClassVar[int] = 70
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, determines whether to start or stop traffic generation.
-        timestamp: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, the time where traffic should be started, expressed as the number of seconds since January 1 2010, 00
-        module_ports: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, specifies ports on modules, which should stop or start traffic generation.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, status traffic generation.
-        timestamp: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, the time where traffic should be started, expressed as the number of seconds since January 1 2010, 00
-        module_ports: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, specifies ports on modules, which should stop or start traffic generation.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, status traffic generation."""
+        timestamp: int = field(XmpLong())
+        """long integer, the time where traffic should be started, expressed as the number of seconds since January 1 2010, 00"""
+        module_ports: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, specifies ports on modules, which should stop or start traffic generation."""
+
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, determines whether to start or stop traffic generation."""
+        timestamp: int = field(XmpLong())
+        """long integer, the time where traffic should be started, expressed as the number of seconds since January 1 2010, 00"""
+        module_ports: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, specifies ports on modules, which should stop or start traffic generation."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of traffic generation.
 
         :return:
             - status traffic generation
             - the time where traffic should be started, expressed as the number of seconds since January 1 2010, 00
             - ports on modules, which should stop or start traffic generation
         :rtype: C_TRAFFICSYNC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
 
-    def set(self, on_off: OnOff, timestamp: int, module_ports: typing.List[int]) -> "Token":
+    def set(self, on_off: OnOff, timestamp: int, module_ports: typing.List[int]) -> Token[None]:
         """Set the status of traffic generation.
 
         :param on_off: determines whether to start or stop traffic generation
         :type on_off: OnOff
         :param timestamp: the time where traffic should be started, expressed as the number of seconds since January 1 2010, 00
         :type timestamp: int
         :param module_ports: specifies ports on modules, which should stop or start traffic generation.
         :type module_ports: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, on_off=on_off, timestamp=timestamp, module_ports=module_ports))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Stop traffic generation on the given ports simultaneously on different chassis.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Start traffic generation on the given ports simultaneously on different chassis.
     """
 
 
 @register_command
 @dataclass
@@ -1787,54 +1902,59 @@
     """
     Report TimeKeeper version and status (extended version).
     """
 
     code: typing.ClassVar[int] = 71
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status_string: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, extended status in JSON format. The string is formatted as shown in the example below.
-
-        # {
-        #     "FormatVersion": 1,
-        #     "ApplicationVersion": 452.0,
-        #     "TimeKeeperStatus":
-        #     {
-        #         "systemtimingstatus": "Waiting for good time source",
-        #         "syncsource": "NTP",
-        #         "sourcestate": "NTP server 10.0.0.110",
-        #         "sourceaccuracy": " No updates yet",
-        #         "versioninfo": "8.0.3",
-        #         "timesincestart": "0 day(s) 0 hours 1 minutes",
-        #         "timesinceboot": "0 day(s) 0 hours 2 minutes",
-        #         "updatetime": 1637916837
-        #     }
-        # }
+    class GetDataAttr(ResponseBodyStruct):
+        status_string: str = field(XmpStr())
+        """string, extended status in JSON format. The string is formatted as shown in the example below.
+            
+            .. code-block::json
+            
+                {
+                    "FormatVersion": 1,
+                    "ApplicationVersion": 452.0,
+                    "TimeKeeperStatus":
+                    {
+                        "systemtimingstatus": "Waiting for good time source",
+                        "syncsource": "NTP",
+                        "sourcestate": "NTP server 10.0.0.110",
+                        "sourceaccuracy": " No updates yet",
+                        "versioninfo": "8.0.3",
+                        "timesincestart": "0 day(s) 0 hours 1 minutes",
+                        "timesinceboot": "0 day(s) 0 hours 2 minutes",
+                        "updatetime": 1637916837
+                    }
+                }
 
-    def get(self) -> "Token[GetDataAttr]":
+        """
+
+    def get(self) -> Token[GetDataAttr]:
         """Get the TimeKeeper version and status.
 
         :return: extended status in JSON format. The string is formatted as shown in the example below.
 
             .. code-block::json
-            
+
                 {
                     "FormatVersion": 1,
                     "ApplicationVersion": 452.0,
                     "TimeKeeperStatus": {
                         "systemtimingstatus": "Waiting for good time source",
                         "syncsource": "NTP",
                         "sourcestate": "NTP server 10.0.0.110",
                         "versioninfo": "8.0.3",
                         "timesincestart": "0 day(s) 0 hours 1 minutes",
                         "timesinceboot": "0 day(s) 0 hours 2 minutes",
                         "updatetime": 1637916837
                     }
                 }
-            
+
 
         :rtype: C_TKSTATUSEXT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/enums.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/enums.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-#: Enumeration Types
 
 from enum import IntEnum
 
 
 # region L23 enums
 class ReservedStatus(IntEnum):
     """Test resource reservation status"""
@@ -1291,15 +1290,14 @@
     LOST = 0
     """No Frame Lock detected"""
 
     LOCKED = 1
     """Frame Lock detected"""
 
 
-
 class PPMSweepMode(IntEnum):
     """Module clock PPM Sweep Modes"""
 
     OFF = 0
     """Off"""
     TRIANGLE = 1
     """Triangle sweeping"""
@@ -1464,17 +1462,25 @@
 
 class LifecycleMode(IntEnum):
     """Connection lifecycle mode"""
 
     ONCE = 0
     """Connections are established during the ramp-up phase and not closed until the ramp-down phase of the load profile. That is, each configured connection only exists once."""
     IMMORTAL = 1
-    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by  P4G_RAW_CONN_LIFETIME). As connections close, new connections are established, attempting to keep the concurrent number of established connections constant. A new connection will have the same IP address as the connection it replaces, but will have a new TCP port number. This will simulate that the user (defined by the client IP address) is living on, and creates new connections as old connections close."""
+    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by  P4G_RAW_CONN_LIFETIME).
+    As connections close, new connections are established, attempting to keep the concurrent number of established connections constant.
+    A new connection will have the same IP address as the connection it replaces, but will have a new TCP port number.
+    This will simulate that the user (defined by the client IP address) is living on, and creates new connections as old connections close.
+    """
     REINCARNATE = 2
-    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by  P4G_RAW_CONN_LIFETIME). As connections close, new connections are established, attempting to keep the concurrent number of established connections constant. A new connection will have the same TCP port number as the connection it replaces, but will have a new IP address. This will simulate that the user (defined by the client IP address) ceases to exist, and new users appear as old users die."""
+    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by  P4G_RAW_CONN_LIFETIME).
+    As connections close, new connections are established, attempting to keep the concurrent number of established connections constant.
+    A new connection will have the same TCP port number as the connection it replaces, but will have a new IP address.
+    This will simulate that the user (defined by the client IP address) ceases to exist, and new users appear as old users die.
+    """
 
 
 class L47IPVersion(IntEnum):
     """IP version of the Connection Group"""
 
     IPV4 = 4
     """IPv4"""
@@ -2090,15 +2096,14 @@
     ANLT_STRICT_MODE = 6
     """Set AN/LT strict mode. In strict mode errored framed will be ignored"""
 
     AN_LT_XLA_MODE = 7
     """Set XLA mode. If enabled XLA dumps will, if triggered, be logged automatically"""
 
 
-
 class Layer1LogType(IntEnum):
     """
 
     .. versionadded:: 1.1
 
     .. warning::
 
@@ -2151,14 +2156,17 @@
 
     CMD_PRESET = 3
     """Set the preset provided in ARG"""
 
     CMD_ENCODING = 4
     """Set encoding provided in ARG"""
 
+    CMD_NO_EQ = 5
+    """Set the coeff to NO_EQ"""
+
     CMD_LOCAL_TRAINED = 255
     """Signal training completed"""
 
 
 class LinkTrainPresets(IntEnum):
     """
     .. versionadded:: 1.1
@@ -2221,18 +2229,18 @@
     Link Training Encoding
 
     """
 
     NRZ = 0
     """NRZ (PAM2)"""
 
-    PAM4 = 1
+    PAM4 = 2
     """PAM4"""
 
-    PAM4_WITH_PRECODING = 2
+    PAM4_WITH_PRECODING = 3
     """PAM4 with precoding"""
 
     UNKNOWN = 255
     """PAM4 with precoding"""
 
 
 class LinkTrainCmdResults(IntEnum):
@@ -2296,14 +2304,15 @@
 
     LOCK_LOST = 16
     """Link lock lost"""
 
     OVERRUN = 32
     """Overrun detected"""
 
+
 class LinkTrainAnnounce(IntEnum):
     """
     .. versionadded:: 1.1
 
     Link Training Announce
 
     """
@@ -2315,14 +2324,15 @@
 class AnLtLogControl(IntEnum):
     """
     .. versionadded:: 1.3
 
     ANLT log control bits
 
     """
+
     # 1st nibble
     LOG_TYPE_DEBUG = 0x2
     """debug log output"""
 
     LOG_TYPE_AN_TRACE = 0x4
     """autonegotiation trace output"""
 
@@ -2355,8 +2365,9 @@
 
     LOG_TYPE_FSM_LT_ALG0 = 0x400000
     """link training algorithm 0 state machine transitions"""
 
     LOG_TYPE_FSM_LT_ALG1 = 0x800000
     """link training algorithm -1 state machine transitions"""
 
+
 # endregion
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/m4_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/m4_commands.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,49 +1,61 @@
-"""
-L47 Module Commands
-"""
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpLong,
+    XmpSequence,
+    XmpStr,
+    Hex,
+)
+from .enums import (
+    CaptureSize,
+    ReplayParserState,
+)
 
 
 @register_command
 @dataclass
 class M4_SYSTEMID:
     """
     Return the system identifier of a L47 module.
     """
 
     code: typing.ClassVar[int] = 803
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        system_id: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, module system identifier.
+    class GetDataAttr(ResponseBodyStruct):
+        system_id: str = field(XmpStr())
+        """string, module system identifier."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the system identifier of a L47 module.
 
         :return: the system identifier of a L47 module.
         :rtype: M4_SYSTEMID.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_VERSIONNO:
     """
@@ -51,155 +63,177 @@
     software version and the build environment. The first part of the string is the
     software build version.
     """
 
     code: typing.ClassVar[int] = 804
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        version_string: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, module version string.
+    class GetDataAttr(ResponseBodyStruct):
+        version_string: str = field(XmpStr())
+        """string, module version string."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a version string containing a combination of information regarding the software version and the build environment.
 
         :return: a version string containing a combination of information regarding the software version and the build environment
         :rtype: M4_VERSIONNO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_SYSTEM_STATUS:
     """
     Returns the L47 module system status in a text string.
     """
 
     code: typing.ClassVar[int] = 805
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status_string: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, module status string.
+    class GetDataAttr(ResponseBodyStruct):
+        status_string: str = field(XmpStr())
+        """string, module status string."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the L47 module system status in a text string
 
         :return: the L47 module system status in a text string
         :rtype: M4_SYSTEM_STATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_COMPATIBLE_CLIENT_VERSION:
     """
     Returns the recommended and required VulcanMananger client version.
     """
 
     code: typing.ClassVar[int] = 806
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        recommended_major: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, recommended major version.
-        recommended_minor: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, recommended minor version.
-        recommended_minor_2: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, recommended minor 2 version.
-        recommended_minor_3: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, recommended minor 3 version.
-        required_major: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, required major version.
-        required_minor: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, required minor version.
-        required_minor_2: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, required minor 2 version.
-        required_minor_3: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # string, required minor 3 version.
+    class GetDataAttr(ResponseBodyStruct):
+        recommended_major: int = field(XmpInt())
+        """string, recommended major version."""
+        recommended_minor: int = field(XmpInt())
+        """string, recommended minor version."""
+        recommended_minor_2: int = field(XmpInt())
+        """string, recommended minor 2 version."""
+        recommended_minor_3: int = field(XmpInt())
+        """string, recommended minor 3 version."""
+        required_major: int = field(XmpInt())
+        """string, required major version."""
+        required_minor: int = field(XmpInt())
+        """string, required minor version."""
+        required_minor_2: int = field(XmpInt())
+        """string, required minor 2 version."""
+        required_minor_3: int = field(XmpInt())
+        """string, required minor 3 version."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the recommended and required VulcanMananger client version.
 
         :return: the recommended and required VulcanMananger client version.
         :rtype: M4_COMPATIBLE_CLIENT_VERSION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_TIME:
     """
     Returns the module time in millisecond.
     """
 
     code: typing.ClassVar[int] = 807
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        time_now: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
+    class GetDataAttr(ResponseBodyStruct):
+        time_now: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the module time in millisecond.
 
         :return: the module time in millisecond.
         :rtype: M4_TIME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_SYSTEM_TIME:
     """
     Sets or returns the modules system time in UTC.
     """
 
     code: typing.ClassVar[int] = 808
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        year: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the year.
-        month: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the month.
-        day: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the day of the mont.
-        hour: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the hour.
-        minute: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minute.
-        second: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the second.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        year: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the year.
-        month: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the month.
-        day: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the day of the mont.
-        hour: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the hour.
-        minute: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minute.
-        second: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the second.
+    class GetDataAttr(ResponseBodyStruct):
+        year: int = field(XmpInt())
+        """integer, the year."""
+        month: int = field(XmpInt())
+        """integer, the month."""
+        day: int = field(XmpInt())
+        """integer, the day of the mont."""
+        hour: int = field(XmpInt())
+        """integer, the hour."""
+        minute: int = field(XmpInt())
+        """integer, the minute."""
+        second: int = field(XmpInt())
+        """integer, the second."""
+
+    class SetDataAttr(RequestBodyStruct):
+        year: int = field(XmpInt())
+        """integer, the year."""
+        month: int = field(XmpInt())
+        """integer, the month."""
+        day: int = field(XmpInt())
+        """integer, the day of the mont."""
+        hour: int = field(XmpInt())
+        """integer, the hour."""
+        minute: int = field(XmpInt())
+        """integer, the minute."""
+        second: int = field(XmpInt())
+        """integer, the second."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the modules system time in UTC.
 
         :return: the modules system time in UTC.
         :rtype: M4_SYSTEM_TIME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> "Token":
+    def set(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> Token[None]:
         """Set the modules system time in UTC.
 
         :param year: the year
         :type year: int
         :param month: the month
         :type month: int
         :param day: the day of the month
@@ -207,84 +241,90 @@
         :param hour: the hour
         :type hour: int
         :param minute: the minute
         :type minute: int
         :param second: the second
         :type second: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, year=year, month=month, day=day, hour=hour, minute=minute, second=second))
 
 
 @register_command
 @dataclass
 class M4_MEM_INFO:
     """
     Return the system memory information.
     """
 
     code: typing.ClassVar[int] = 809
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        year: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total memory.
-        month: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, free memory.
+    class GetDataAttr(ResponseBodyStruct):
+        year: int = field(XmpLong())
+        """long integer, total memory."""
+        month: int = field(XmpLong())
+        """long integer, free memory."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the system memory information.
 
         :return: the system memory information.
         :rtype: M4_MEM_INFO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_CAPTURE_SIZE:
     """
     Specify whether to capture whole packets(large) or truncated packets. When
     truncated (small) is selected only the first 128 bytes of the packet are saved.
     """
 
     code: typing.ClassVar[int] = 810
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        size: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=CaptureSize)  # coded byte, specifying whether to capture whole packets or truncated packets.
+    class GetDataAttr(ResponseBodyStruct):
+        size: CaptureSize = field(XmpByte())
+        """coded byte, specifying whether to capture whole packets or truncated packets."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        size: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=CaptureSize)  # coded byte, specifying whether to capture whole packets or truncated packets.
+    class SetDataAttr(RequestBodyStruct):
+        size: CaptureSize = field(XmpByte())
+        """coded byte, specifying whether to capture whole packets or truncated packets."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether to capture whole packets(large) or truncated packets.
 
         :return: whether to capture whole packets(large) or truncated packets.
         :rtype: M4_CAPTURE_SIZE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, size: CaptureSize) -> "Token":
+    def set(self, size: CaptureSize) -> Token[None]:
         """Set whether to capture whole packets(large) or truncated packets.
 
         :param size: specifying whether to capture whole packets or truncated packets.
         :type size: CaptureSize
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, size=size))
 
     set_full = functools.partialmethod(set, CaptureSize.FULL)
     """Capture whole packets"""
+
     set_small = functools.partialmethod(set, CaptureSize.SMALL)
     """Capture truncated packets"""
 
 
 @register_command
 @dataclass
 class M4_LICENSE_INFO:
@@ -292,46 +332,46 @@
     Returns the number of available and free PE licenses. Only 'available' number of PEs
     can simultaneously be assigned to reserved ports.
     """
 
     code: typing.ClassVar[int] = 820
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pes_available: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of PEs that are licensed on the module, and can be used simultaneously.
-        pes_free: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, number of free PE licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously.
-        N1g_available: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of 1G speed licenses that are licensed on the module, and can be used simultaneously.
-        N1g_free: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, number of 1G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously.
-        N10g_available: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of 10G speed licenses that are licensed on the module, and can be used simultaneously.
-        N10g_free: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, number of free 10G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously.
-        N25g_available: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of 25G speed licenses that are licensed on the module, and can be used simultaneously.
-        N25g_free: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, number of free 25G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously.
-        N40g_available: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of 40G speed licenses that are licensed on the module, and can be used simultaneously.
-        N40g_free: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, number of free 40G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously.
+    class GetDataAttr(ResponseBodyStruct):
+        pes_available: int = field(XmpInt())
+        """integer, number of PEs that are licensed on the module, and can be used simultaneously."""
+        pes_free: int = field(XmpInt())
+        """integer, number of free PE licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously."""
+        N1g_available: int = field(XmpInt())
+        """integer, number of 1G speed licenses that are licensed on the module, and can be used simultaneously."""
+        N1g_free: int = field(XmpInt())
+        """integer, number of 1G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously."""
+        N10g_available: int = field(XmpInt())
+        """integer, number of 10G speed licenses that are licensed on the module, and can be used simultaneously."""
+        N10g_free: int = field(XmpInt())
+        """integer, number of free 10G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously."""
+        N25g_available: int = field(XmpInt())
+        """integer, number of 25G speed licenses that are licensed on the module, and can be used simultaneously."""
+        N25g_free: int = field(XmpInt())
+        """integer, number of free 25G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously."""
+        N40g_available: int = field(XmpInt())
+        """integer, number of 40G speed licenses that are licensed on the module, and can be used simultaneously."""
+        N40g_free: int = field(XmpInt())
+        """integer, number of free 40G speed licenses on the module 1G available: integer, number of 1G licenses on the module, that can be used simultaneously."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of available and free PE licenses.
 
         :return: the number of available and free PE licenses
         :rtype: M4_LICENSE_INFO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_REPLAY_PARSE_START:
     """
@@ -349,231 +389,233 @@
     present for Replay Files generated by the parsing, and the 'root' location is
     /var/ftp/pub/replay/bson/.
     """
 
     code: typing.ClassVar[int] = 830
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filename: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, filename (including relative path and excluding the '.pcap' extension).
+    class SetDataAttr(RequestBodyStruct):
+        filename: str = field(XmpStr())
+        """string, filename (including relative path and excluding the '.pcap' extension)."""
 
-    def set(self, filename: str) -> "Token":
+    def set(self, filename: str) -> Token[None]:
         """Start parsing an uploaded Capture File
 
         :param filename: filename (including relative path and excluding the '.pcap' extension).
         :type filename: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, filename=filename))
 
 
 @register_command
 @dataclass
 class M4_REPLAY_PARSE_STOP:
     """
     Command to stop parsing a Capture File. Parsing of very large Capture Files may
     take several seconds, and may be aborted using this command. No parameters
     """
 
     code: typing.ClassVar[int] = 831
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Stop parsing a Capture File.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_REPLAY_PARSE_STATE:
     """
     Only one Capture File can be parsed at a time. This command returns the state of
     the parser, which can be PARSING or OFF. M4_REPLAY_PARSE_START command is only
     accepted when the parser state is OFF.
     """
 
     code: typing.ClassVar[int] = 832
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ReplayParserState)  # coded byte, state of the replay parser
+    class GetDataAttr(ResponseBodyStruct):
+        state: ReplayParserState = field(XmpByte())
+        """coded byte, state of the replay parser"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get capture file parsing state.
 
         :return: capture file parsing state
         :rtype: M4_REPLAY_PARSE_STATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_REPLAY_PARSER_PARAMS:
     """
     Configuration of parameters for the parsing of pcap files.
     """
 
     code: typing.ClassVar[int] = 833
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        tcp_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, server TCP Port of dummy TCP connection inserted in UDP only replay files
+    class GetDataAttr(ResponseBodyStruct):
+        tcp_port: int = field(XmpInt())
+        """integer, server TCP Port of dummy TCP connection inserted in UDP only replay files"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        tcp_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, server TCP Port of dummy TCP connection inserted in UDP only replay files
+    class SetDataAttr(RequestBodyStruct):
+        tcp_port: int = field(XmpInt())
+        """integer, server TCP Port of dummy TCP connection inserted in UDP only replay files"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of parameters for the parsing of pcap files.
 
         :return: the configuration of parameters for the parsing of pcap files
         :rtype: M4_REPLAY_PARSER_PARAMS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, tcp_port: int) -> "Token":
+    def set(self, tcp_port: int) -> Token[None]:
         """Set the configuration of parameters for the parsing of pcap files.
 
         :param tcp_port: server-side TCP port of the dummy TCP connection inserted in UDP.
         :type tcp_port: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, tcp_port=tcp_port))
 
 
 @register_command
 @dataclass
 class M4_REPLAY_FILE_LIST_BSON:
     """
     Works as ``M4_REPLAY_FILE_LIST``, but returns the file list formatted as a BSON
     document.
     """
 
     code: typing.ClassVar[int] = 840
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        bson: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # list of hex bytes, bson document containing the file list
+    class GetDataAttr(ResponseBodyStruct):
+        bson: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of hex bytes, bson document containing the file list"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the replay file list in BSON document format.
 
         :return: the replay file list in BSON format
         :rtype: M4_REPLAY_FILE_LIST_BSON.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_REPLAY_FILE_LIST:
     """
     Returns a list of Replay Files (``.bson`` files) in the 'user' Replay File
     directory (``/var/ftp/pub/replay/bson/user/``).
     """
 
     code: typing.ClassVar[int] = 841
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        file_list: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, comma separated list of filenames excluding the '.bson' extension.
+    class GetDataAttr(ResponseBodyStruct):
+        file_list: str = field(XmpStr())
+        """string, comma separated list of filenames excluding the '.bson' extension."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Generate a list of Replay Files in BSON document on the tester.
 
         :return: a list of Replay Files in BSON document on the tester
         :rtype: M4_REPLAY_FILE_LIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_CAPTURE_FILE_LIST_BSON:
     """
     Works as ``M4_CAPTURE_FILE_LIST``, but returns the file list formatted as a BSON
     document.
     """
 
     code: typing.ClassVar[int] = 842
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        bson: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # list of hex bytes, bson document containing the file list
+    class GetDataAttr(ResponseBodyStruct):
+        bson: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of hex bytes, bson document containing the file list"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the capture file list in BSON document.
 
         :return: the capture file list in BSON document
         :rtype: M4_CAPTURE_FILE_LIST_BSON.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_CAPTURE_FILE_LIST:
     """
     Returns a list of Capture Files (``.pcap`` files) in the 'user' Capture File
     directory (``/var/ftp/pub/replay/pcap/user/``).
     """
 
     code: typing.ClassVar[int] = 843
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        file_list: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, comma separated list of filenames excluding the '.pcap' extension.
+    class GetDataAttr(ResponseBodyStruct):
+        file_list: str = field(XmpStr())
+        """string, comma separated list of filenames excluding the '.pcap' extension."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Generate a list of Capture Files in BSON document on the tester.
 
         :return: list of Capture Files in BSON document on the tester
         :rtype: M4_CAPTURE_FILE_LIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M4_REPLAY_FILE_DELETE:
     """
@@ -581,27 +623,28 @@
     (``/var/ftp/pub/replay/bson/``). For information about the location and directory
     structure for the Replay Files, see: M4_REPLAY_PARSE_START
     """
 
     code: typing.ClassVar[int] = 845
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filename: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, file name (including relative path and excluding the '.bson' extension).
+    class SetDataAttr(RequestBodyStruct):
+        filename: str = field(XmpStr())
+        """string, file name (including relative path and excluding the '.bson' extension)."""
 
-    def set(self, filename: str) -> "Token":
+    def set(self, filename: str) -> Token[None]:
         """Delete a Replay File in the Replay File directory.
 
         :param filename: file name (including relative path and excluding the ``.bson`` extension).
         :type filename: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, filename=filename))
 
 
 @register_command
 @dataclass
 class M4_CAPTURE_FILE_DELETE:
     """
@@ -609,47 +652,49 @@
     (``/var/ftp/pub/replay/pcap/``). For information about the location and directory
     structure for the Capture Files, see: M4_REPLAY_PARSE_START
     """
 
     code: typing.ClassVar[int] = 846
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filename: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, file name (including relative path and excluding the '.pcap' extension).
+    class SetDataAttr(RequestBodyStruct):
+        filename: str = field(XmpStr())
+        """string, file name (including relative path and excluding the '.pcap' extension)."""
 
-    def set(self, filename: str) -> "Token":
+    def set(self, filename: str) -> Token[None]:
         """Delete a Capture File in the Capture File directory.
 
         :param filename: file name (including relative path and excluding the ``.pcap`` extension).
         :type filename: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, filename=filename))
 
 
 @register_command
 @dataclass
 class M4_TLS_CIPHER_SUITES:
     """
     Returns a list of supported TLS Cipher Suites.
     """
 
     code: typing.ClassVar[int] = 852
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        cipher_suites: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, list of IANA values of supported cipher suites
+    class GetDataAttr(ResponseBodyStruct):
+        cipher_suites: Hex = field(XmpHex())
+        """list of hex bytes, list of IANA values of supported cipher suites"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of supported TLS Cipher Suites.
 
         :return: list of IANA values of supported cipher suites
         :rtype: M4_TLS_CIPHER_SUITES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/m4e_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/m4e_commands.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,98 +1,107 @@
-"""
-L47 Module Packet Engine Commands
-"""
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    Hex,
+)
+from .enums import ResourceAllocationMode
 
 
 @register_command
 @dataclass
 class M4E_MODE:
     """
     Select resource allocation mode.
     """
 
     code: typing.ClassVar[int] = 850
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ResourceAllocationMode)  # coded byte, resource allocation mode.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ResourceAllocationMode)  # coded byte, resource allocation mode.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: ResourceAllocationMode = field(XmpByte())
+        """coded byte, resource allocation mode."""
+
+    class SetDataAttr(RequestBodyStruct):
+        mode: ResourceAllocationMode = field(XmpByte())
+        """coded byte, resource allocation mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the resource allocation mode.
 
         :return: resource allocation mode
         :rtype: M4E_MODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, mode: ResourceAllocationMode) -> "Token":
+    def set(self, mode: ResourceAllocationMode) -> Token[None]:
         """Set the resource allocation mode.
 
         :param mode: resource allocation mode
         :type mode: ResourceAllocationMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, mode=mode))
 
     set_simple = functools.partialmethod(set, ResourceAllocationMode.SIMPLE)
     """Set resource allocation mode to Simple."""
+
     set_advanced = functools.partialmethod(set, ResourceAllocationMode.ADVANCED)
     """Set resource allocation mode to Advanced."""
 
 
 @register_command
 @dataclass
 class M4E_RESERVE:
     """
     Advanced mode only: Reserve a number of PEs so they later can be assigned to specific ports.
     """
 
     code: typing.ClassVar[int] = 851
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mask: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # eight hex bytes, bitmask of PEs to reserve
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mask: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # eight hex bytes, bitmask of PEs to reserve
+    class GetDataAttr(ResponseBodyStruct):
+        mask: Hex = field(XmpHex(size=8))
+        """eight hex bytes, bitmask of PEs to reserve"""
+
+    class SetDataAttr(RequestBodyStruct):
+        mask: Hex = field(XmpHex(size=8))
+        """eight hex bytes, bitmask of PEs to reserve"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the PEs reserved.
 
         :return: the number of PEs reserved.
         :rtype: M4E_RESERVE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, mask: str) -> "Token":
+    def set(self, mask: Hex) -> Token[None]:
         """Set PEs reserved.
 
         :param mask: bitmask of PEs to reserve
         :type mask: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, mask=mask))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/m_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/m_commands.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,24 +1,55 @@
-#: L23 Module Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
-from xoa_driver.internals import warn
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpLong,
+    XmpSequence,
+    XmpStr,
+    Hex,
+)
+from .enums import (
+    ReservedStatus,
+    ReservedAction,
+    OnOff,
+    TimingSource,
+    MediaCFPState,
+    MediaCFPType,
+    SMAInputFunction,
+    SMAOutputFunction,
+    SMAStatus,
+    HasDemo,
+    IsValid,
+    IsPermanent,
+    YesNo,
+    UpdateState,
+    IsOnline,
+    TXClockSource,
+    TXClockStatus,
+    LoopBandwidth,
+    MediaConfigurationType,
+    ImpairmentLatencyMode,
+    PPMSweepStatus,
+    PPMSweepMode,
+)
 
 
 @register_command
 @dataclass
 class M_RESERVATION:
     """
     Set this command to reserve, release, or relinquish a module itself (as
@@ -31,51 +62,55 @@
         The reservation parameters are slightly asymmetric with respect to set/get. When querying for the current reservation state, the chassis will use these values.
 
     """
 
     code: typing.ClassVar[int] = 72
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        operation: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=ReservedAction
-        )  # coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get. When set, it contains the operation to perform. When get, it contains the status.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        operation: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=ReservedStatus
-        )  # coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get. When set, it contains the operation to perform. When get, it contains the status.
+    class GetDataAttr(ResponseBodyStruct):
+        operation: ReservedStatus = field(XmpByte())
+        """coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get.
+        When set, it contains the operation to perform. When get, it contains the status.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    class SetDataAttr(RequestBodyStruct):
+        operation: ReservedAction = field(XmpByte())
+        """coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get.
+        When set, it contains the operation to perform. When get, it contains the status.
+        """
+
+    def get(self) -> Token[GetDataAttr]:
         """Get the reservation status of the test module.
 
         :return: the reservation status of the test module
         :rtype: M_RESERVATION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, operation: ReservedAction) -> "Token":
+    def set(self, operation: ReservedAction) -> Token[None]:
         """Set the reservation status of the test module.
 
         :param operation: reservation operation to perform
         :type operation: ReservedAction
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, operation=operation))
 
     set_release = functools.partialmethod(set, ReservedAction.RELEASE)
     """Release the test module.
     """
+
     set_reserve = functools.partialmethod(set, ReservedAction.RESERVE)
     """Reserve the test module.
     """
+
     set_relinquish = functools.partialmethod(set, ReservedAction.RELINQUISH)
     """Release the ownership of the test module from another user.
     """
 
 
 @register_command
 @dataclass
@@ -84,162 +119,170 @@
     Identify the user who has a module reserved. Returns an empty string if the
     module is not currently reserved by anyone.
     """
 
     code: typing.ClassVar[int] = 73
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        username: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the name of the current owner of the module.
+    class GetDataAttr(ResponseBodyStruct):
+        username: str = field(XmpStr())
+        """string, containing the name of the current owner of the module."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the username who has reserved the test module.
 
         :return: the username who has reserved the test module
         :rtype: M_RESERVEDBY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_MODEL:
     """
     Gets the legacy model P/N name of a Xena test module.
     """
 
     code: typing.ClassVar[int] = 75
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        model: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the legacy model P/N name of a Xena test module.
+    class GetDataAttr(ResponseBodyStruct):
+        model: str = field(XmpStr())
+        """string, the legacy model P/N name of a Xena test module."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the legacy model P/N name of a Xena test module.
 
         :return: the legacy model P/N name of a Xena test module
         :rtype: M_MODEL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_SERIALNO:
     """
     Gets the unique serial number of a module.
     """
 
     code: typing.ClassVar[int] = 76
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        serial_number: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the serial number of this module.
+    class GetDataAttr(ResponseBodyStruct):
+        serial_number: int = field(XmpInt())
+        """integer, the serial number of this module."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the unique serial number of the test module.
 
         :return: the serial number of this test module
         :rtype: M_SERIALNO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_VERSIONNO:
     """
     Gets the version number of the hardware image installed on a module.
     """
 
     code: typing.ClassVar[int] = 77
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        version: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the hardware image version number.
+    class GetDataAttr(ResponseBodyStruct):
+        version: int = field(XmpInt())
+        """integer, the hardware image version number."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the version number of the hardware image installed on the test module.
 
         :return: the hardware image version number of the test module
         :rtype: M_VERSIONNO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_STATUS:
     """
     Get status readings for the test module itself.
     """
 
     code: typing.ClassVar[int] = 79
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        temperature: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, temperature of the main hardware chip, in degrees Celsius.
+    class GetDataAttr(ResponseBodyStruct):
+        temperature: int = field(XmpInt())
+        """integer, temperature of the main hardware chip, in degrees Celsius."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status readings of the test module
 
         :return: temperature of the main hardware chip, in degrees Celsius
         :rtype: M_STATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_PORTCOUNT:
     """
     Gets the maximum number of ports on a module.
 
     .. note::
 
-        For a CFP-type module this number refers to the maximum number of ports possible on the module regardless of the media configuration. So if a CFP-type module can be set in for instance either 1x100G mode or 8x10G mode then this command will always return 8. If you want the current number of ports for a CFP-type module you need to read the M_CFPCONFIGEXT` command which returns the number of current ports.
+        For a CFP-type module this number refers to the maximum number of ports possible on the module regardless of the media configuration.
+        So if a CFP-type module can be set in for instance either 1x100G mode or 8x10G mode then this command will always return 8.
+        If you want the current number of ports for a CFP-type module you need to read the M_CFPCONFIGEXT` command which returns the number of current ports.
 
     """
 
     code: typing.ClassVar[int] = 80
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the maximum number of ports.
+    class GetDataAttr(ResponseBodyStruct):
+        port_count: int = field(XmpInt())
+        """integer, the maximum number of ports."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Gets the maximum number of ports on a module.
 
         :return: the maximum number of ports on the test module
         :rtype: M_PORTCOUNT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_UPGRADE:
     """
@@ -247,30 +290,32 @@
     take effect when the chassis is powered-on the next time. The transfer takes
     approximately 3 minutes, but no further action is required by the client.
     """
 
     code: typing.ClassVar[int] = 81
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        magic: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, must be the special value -1480937026.
-        image_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the fully qualified name of a file previously uploaded to the chassis.
+    class SetDataAttr(RequestBodyStruct):
+        magic: int = field(XmpInt())
+        """integer, must be the special value -1480937026."""
+        image_name: str = field(XmpStr())
+        """string, the fully qualified name of a file previously uploaded to the chassis."""
 
-    def set(self, image_name: str) -> "Token":
+    def set(self, image_name: str) -> Token[None]:
         """Transfers a hardware image file from the chassis to a module. This image will
         take effect when the chassis is powered-on the next time. The transfer takes
         approximately 3 minutes, but no further action is required by the client.
 
         :param image_name: the fully qualified name of a file previously uploaded to the chassis
         :type image_name: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, magic=-1480937026, image_name=image_name))
 
 
 @register_command
 @dataclass
 class M_UPGRADEPROGRESS:
     """
@@ -279,32 +324,40 @@
     completion by itself. The progress values are pushed to the client without it
     having to request them.
     """
 
     code: typing.ClassVar[int] = 82
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        progress: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the current stage within the three phases. 0: Failure. 1-100: Erase completion percentage. 101-200: Write completion percentage. 201-300: Verify completion percentage.
+    class GetDataAttr(ResponseBodyStruct):
+        progress: int = field(XmpInt())
+        """integer, the current stage within the three phases.
+            0: Failure.
+            1-100: Erase completion percentage.
+            101-200: Write completion percentage
+            201-300: Verify completion percentage.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the current stage of an ongoing hardware image
         upgrade operation. This is for information only; the upgrade operation runs to
         completion by itself. The progress values are pushed to the client without it
         having to request them.
 
-        :param progress: the current stage within the three phases. 0: Failure. 1-100: Erase completion percentage. 101-200: Write completion percentage. 201-300: Verify completion percentage.
+        :param progress: the current stage within the three phases.
+            0: Failure.
+            1-100: Erase completion percentage.
+            101-200: Write completion percentage.
+            201-300: Verify completion percentage.
         :type progress: M_UPGRADEPROGRESS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_TIMESYNC:
     """
@@ -315,47 +368,51 @@
     external time enables inter-chassis latency measurements, but can introduce
     small time discontinuities as the test module time is adjusted.
     """
 
     code: typing.ClassVar[int] = 83
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        source: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TimingSource)  # coded byte, selecting the time sync mode.
+    class GetDataAttr(ResponseBodyStruct):
+        source: int = field(XmpByte())
+        """coded byte, selecting the time sync mode."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        source: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TimingSource)  # coded byte, selecting the time sync mode.
+    class SetDataAttr(RequestBodyStruct):
+        source: int = field(XmpByte())
+        """coded byte, selecting the time sync mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the time sync mode of the test module timestamp clock.
 
         :return: the time sync mode of the test module timestamp clock
         :rtype: M_TIMESYNC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, source: TimingSource) -> "Token":
+    def set(self, source: TimingSource) -> Token[None]:
         """Set the time sync mode of the test module timestamp clock.
 
         :param mode: the time sync mode of the test module timestamp clock
         :type mode: TimingSource
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, source=source))
 
     set_chassis = functools.partialmethod(set, TimingSource.CHASSIS)
     """Set the time sync mode of the test module to Chassis Mode.
     """
+
     set_external = functools.partialmethod(set, TimingSource.EXTERNAL)
     """Set the time sync mode of the test module to External Mode.
     """
+
     set_module = functools.partialmethod(set, TimingSource.MODULE)
     """Set the time sync mode of the test module to Module Mode.
     """
 
 
 @register_command
 @dataclass
@@ -363,33 +420,35 @@
     """
     Get information about the transceiver currently inserted into the cages.
     """
 
     code: typing.ClassVar[int] = 84
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MediaCFPState)  # coded byte, specifying the CFP state.
-        type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MediaCFPType)  # coded byte, specifying the CFP type.
+    class GetDataAttr(ResponseBodyStruct):
+        state: MediaCFPState = field(XmpByte())
+        """coded byte, specifying the CFP state."""
+        type: MediaCFPType = field(XmpByte())
+        """coded byte, specifying the CFP type."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get CFP type information about the transceiver currently inserted into the cage.
 
         :return:
             - the CFP state
             - the CFP type
         :rtype: M_CFPTYPE.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module))
 
+        return Token(self._connection, build_get_request(self, module=self._module))
 
+# WAS DEPRICATED IN V1 - Suppose to be removed in V2
 @register_command
 @dataclass
 class M_CFPCONFIG:
     """
     .. deprecated:: 1.3
 
     The current number of ports and their speed of a CFP test module. If the CFP
@@ -398,173 +457,179 @@
     explicitly. The following combinations are possible: 4x10G, 8x10G, 1x40G, 2x40G,
     and 1x100G. (replaced by :class:`M_CFPCONFIGEXT`)
     """
 
     code: typing.ClassVar[int] = 85
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        port_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, number of ports.
-        port_speed: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, port speed, in Gbps.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, number of ports.
-        port_speed: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, port speed, in Gbps.
+    class GetDataAttr(ResponseBodyStruct):
+        port_count: int = field(XmpByte())
+        """byte, number of ports."""
+        port_speed: int = field(XmpByte())
+        """byte, port speed, in Gbps."""
+
+    class SetDataAttr(RequestBodyStruct):
+        port_count: int = field(XmpByte())
+        """byte, number of ports."""
+        port_speed: int = field(XmpByte())
+        """byte, port speed, in Gbps."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the current number of ports and their speed of a CFP test module.
 
         :return:
             - number of ports
             - port speed, in Gbps
         :rtype: M_CFPCONFIG.GetDataAttr
         """
 
-        warn.depricated("module.cfp.config.get() (M_CFPCONFIG) is deprecated. Please use module.cfp.config_extended.get() (M_CFPCONFIGEXT) instead.")
-
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, port_count: int, port_speed: int) -> "Token":
+    def set(self, port_count: int, port_speed: int) -> Token[None]:
         """Set the current number of ports and their speed of a CFP test module.
 
         :param port_count: number of ports
         :type port_count: int
         :param port_speed: port speed, in Gbps
         :type port_speed: int
         """
 
-        warn.depricated("module.cfp.config.set() (M_CFPCONFIG) is deprecated. Please use module.cfp.config_extended.set() (M_CFPCONFIGEXT) instead.")
-
         return Token(self._connection, build_set_request(self, module=self._module, port_count=port_count, port_speed=port_speed))
 
 
 @register_command
 @dataclass
 class M_COMMENT:
     """
     Gets the user-defined description string of a module.
     """
 
     code: typing.ClassVar[int] = 86
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the user-specified comment/description for the module.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the user-specified comment/description for the module."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the user-specified comment/description for the module.
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the user-specified comment/description for the module."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the user-defined description string of a module.
 
         :return: the user-specified comment/description for the module
         :rtype: M_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the user-defined description string of a module.
 
         :param comment: the user-specified comment/description for the module
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, comment=comment))
 
 
 @register_command
 @dataclass
 class M_TIMEADJUSTMENT:
     """
     Control time adjustment for module wall clock.
     """
 
     code: typing.ClassVar[int] = 88
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        adjust: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, adjustment in nanoseconds. This value should be a multiple of 8 as it will be converted to a number of 125 MHz clocks.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        adjust: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, adjustment in nanoseconds. This value should be a multiple of 8 as it will be converted to a number of 125 MHz clocks.
+    class GetDataAttr(ResponseBodyStruct):
+        adjust: int = field(XmpInt())
+        """integer, adjustment in nanoseconds. This value should be a multiple of 8 as it will be converted to a number of 125 MHz clocks."""
+
+    class SetDataAttr(RequestBodyStruct):
+        adjust: int = field(XmpInt())
+        """integer, adjustment in nanoseconds. This value should be a multiple of 8 as it will be converted to a number of 125 MHz clocks."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the time adjustment value for the module clock.
 
         :return: the time adjustment value for the module clock
         :rtype: M_TIMEADJUSTMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, adjust: int) -> "Token":
+    def set(self, adjust: int) -> Token[None]:
         """Set the time adjustment value for the module clock. This value should be a multiple of 8 as it will be converted to a number of 125 MHz clocks.
 
         :param adjust: the time adjustment value for the module clock
         :type adjust: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, adjust=adjust))
 
 
 @register_command
 @dataclass
 class M_CAPABILITIES:
     """
     Gets the module capabilities.
     """
 
     code: typing.ClassVar[int] = 89
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        can_advanced_timing: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, is advanced timing functions supported?
-        can_local_time_adjust: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, is local time adjustment supported?
-        can_media_config: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, is module media configuration supported?
-        require_multi_image: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, does this module switch images during runtime?
-        is_chimera: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, is this a Chimera module?
-        max_clock_ppm: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum supported absolute +- clock ppm setting.
-        can_tsn: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, does this module support Time Sensitive Networking (TSN) ?
-        can_ppm_sweep: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, does this module support Local Clock Adjustment/Sweep (aka. PPM Sweep) ?
+    class GetDataAttr(ResponseBodyStruct):
+        can_advanced_timing: YesNo = field(XmpInt())
+        """coded integer, is advanced timing functions supported?"""
+        can_local_time_adjust: YesNo = field(XmpInt())
+        """coded integer, is local time adjustment supported?"""
+        can_media_config: YesNo = field(XmpInt())
+        """coded integer, is module media configuration supported?"""
+        require_multi_image: YesNo = field(XmpInt())
+        """coded integer, does this module switch images during runtime?"""
+        is_chimera: YesNo = field(XmpInt())
+        """coded integer, is this a Chimera module?"""
+        max_clock_ppm: int = field(XmpInt())
+        """integer, maximum supported absolute +- clock ppm setting."""
+        can_tsn: YesNo = field(XmpInt())
+        """coded integer, does this module support Time Sensitive Networking (TSN) ?"""
+        can_ppm_sweep: YesNo = field(XmpInt())
+        """coded integer, does this module support Local Clock Adjustment/Sweep (aka. PPM Sweep) ?"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the test module capabilities.
 
         :return:
             - is advanced timing functions supported?
             - is local time adjustment supported?
             - is module media configuration supported?
             - does this module switch images during runtime?
             - is this a Chimera module?
             - maximum supported absolute +- clock ppm setting.
             - does this module support Time Sensitive Networking (TSN) ?
             - does this module support Local Clock Adjustment/Sweep (aka. PPM Sweep) ?
 
         :rtype: M_CAPABILITIES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_MEDIASUPPORT:
     """
@@ -573,107 +638,105 @@
     ``[<ports_per_speed> <speed>]`` is repeated until all speeds supported by the ``<cage_type>`` has been listed.
     ``[<cage_type> <available_speed_count>]`` is repeated for all cage types on the module including the related ``<ports_per_speed> <speed>`` information.
     """
 
     code: typing.ClassVar[int] = 90
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        media_info_list: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # coded integer, media information
+    class GetDataAttr(ResponseBodyStruct):
+        media_info_list: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """coded integer, media information"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the media supports by the port, including cage type, available speed count, ports per speed, and the corresponding speed.
 
         :return:
             a list of integers. The structure of the returned value is ``[ <cage_type> <available_speed_count>[<ports_per_speed> <speed>] ]``.
             ``[<ports_per_speed> <speed>]`` is repeated until all speeds supported by the ``<cage_type>`` has been listed.
             ``[<cage_type> <available_speed_count>]`` is repeated for all cage types on the module including the related ``<ports_per_speed> <speed>`` information.
 
         :rtype: M_MEDIASUPPORT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_FPGAREIMAGE:
     """
     Reload FPGA image.
     """
 
     code: typing.ClassVar[int] = 91
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        key_code: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, must be 42.
+    class SetDataAttr(RequestBodyStruct):
+        key_code: int = field(XmpInt())
+        """integer, must be 42."""
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Reload the FPGA image.
 
         :param key_code: must be 42.
         :type key_code: int.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                key_code=42,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, key_code=42))
 
 
 @register_command
 @dataclass
 class M_MULTIUSER:
     """
     Enable or disable multiple sessions to control the same module.
     """
 
     code: typing.ClassVar[int] = 92
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, enable or disable multiple sessions to control the same module.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enable or disable multiple sessions to control the same module."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, enable or disable multiple sessions to control the same module.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enable or disable multiple sessions to control the same module."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of multiple sessions controlling the same module.
 
         :return: the status of multiple sessions controlling the same module
         :rtype: M_MULTIUSER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Enable or disable multiple sessions to control the same module.
 
         :param on_off: Enable or disable multiple sessions to control the same module
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable multiple sessions to control the same module.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable multiple sessions to control the same module.
     """
 
 
 @register_command
 @dataclass
@@ -681,131 +744,138 @@
     """
     This property defines the current number of ports and the speed of each of them
     on a CFP test module. If the CFP type is ``NOTFLEXIBLE`` then it reflects the
     transceiver currently in the CFP cage. If the CFP type is ``FLEXIBLE`` (or
     ``NOTPRESENT``) then the configuration can be changed explicitly. The following
     combinations are possible: 2x10G, 4x10G, 8x10G, 2x25G, 4x25G, 8x25G, 1x40G,
     2x40G, 2x50G, 4x50G, 8x50G, 1x100G, 2x100G, 4x100G, 2x200G, and 1x400G.
-    (replaces :class:`M_CFPCONFIG`)
+    (replaces :class:`M_CFPCONFIGEXT`)
 
     .. note::
 
         ``<portspeed_list>`` is a list of integers, where the first element is the number of ports followed by a number of port speeds in Mbps.
         The number of port speeds equals the value of the number of ports.
         For example if the configuration is 4x25G, ``<portspeed_list>`` will be ``[4, 25000, 25000, 25000, 25000]``.
     """
 
     code: typing.ClassVar[int] = 93
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        portspeed_list: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)
+    class GetDataAttr(ResponseBodyStruct):
+        portspeed_list: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        portspeed_list: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)
+    class SetDataAttr(RequestBodyStruct):
+        portspeed_list: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of port count and corresponding speeds supported by the current module config.
 
         :return: a list of port count and corresponding speeds supported by the current module config
         :rtype: M_CFPCONFIGEXT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, portspeed_list: typing.List[int]) -> "Token":
+    def set(self, portspeed_list: typing.List[int]) -> Token[None]:
+        """"""
+
         return Token(self._connection, build_set_request(self, module=self._module, portspeed_list=portspeed_list))
 
 
 @register_command
 @dataclass
 class M_CLOCKPPB:
     """
     Makes small adjustments to the local clock of the test module, which drives the
     TX rate of the test ports.
     """
 
     code: typing.ClassVar[int] = 94
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ppb: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, adjustment from nominal value, in parts-per-billion, positive or negative.
+    class GetDataAttr(ResponseBodyStruct):
+        ppb: int = field(XmpInt())
+        """integer, adjustment from nominal value, in parts-per-billion, positive or negative."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ppb: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, adjustment from nominal value, in parts-per-billion, positive or negative.
+    class SetDataAttr(RequestBodyStruct):
+        ppb: int = field(XmpInt())
+        """integer, adjustment from nominal value, in parts-per-billion, positive or negative."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the module clock adjustment in ppb.
 
         :return: the module clock adjustment in ppb
         :rtype: M_CLOCKPPB.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, ppb: int) -> "Token":
+    def set(self, ppb: int) -> Token[None]:
         """Set the module clock adjustment in ppb.
 
         :param ppb: adjustment from nominal value, in parts-per-billion, positive or negative
         :type ppb: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, ppb=ppb))
 
 
 @register_command
 @dataclass
 class M_SMAINPUT:
     """
     For test modules with SMA (SubMiniature version A) connectors, selects the function of the SMA input.
     """
 
     code: typing.ClassVar[int] = 95
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        sma_in: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=SMAInputFunction)  # coded byte, specifying the function of the SMA input.
+    class GetDataAttr(ResponseBodyStruct):
+        sma_in: SMAInputFunction = field(XmpByte())
+        """coded byte, specifying the function of the SMA input."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        sma_in: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=SMAInputFunction)  # coded byte, specifying the function of the SMA input.
+    class SetDataAttr(RequestBodyStruct):
+        sma_in: SMAInputFunction = field(XmpByte())
+        """coded byte, specifying the function of the SMA input."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the function of the SMA (SubMiniature version A) input of the module
 
         :return: the function of the SMA (SubMiniature version A) input of the module
         :rtype: M_SMAINPUT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, sma_in: SMAInputFunction) -> "Token":
+    def set(self, sma_in: SMAInputFunction) -> Token[None]:
         """Set the function of the SMA (SubMiniature version A) input of the module
 
         :param sma_in: the function of the SMA (SubMiniature version A) input of the module
         :type sma_in: SMAInputFunction
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, sma_in=sma_in))
 
     set_notused = functools.partialmethod(set, SMAInputFunction.NOT_USED)
     """Set SMA input to Not Used
     """
+
     set_tx2mhz = functools.partialmethod(set, SMAInputFunction.TX2MHZ)
     """Set SMA input to TX Clock Ref. 2.048 MHz
     """
+
     set_tx10mhz = functools.partialmethod(set, SMAInputFunction.TX10MHZ)
     """Set SMA input to TX Clock Ref. 10.0 MHz
     """
 
 
 @register_command
 @dataclass
@@ -813,77 +883,91 @@
     """
     For test modules with SMA (SubMiniature version A) connectors, selects the function of the SMA output.
     """
 
     code: typing.ClassVar[int] = 96
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        sma_out: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=SMAOutputFunction)  # coded byte, specifying the function of the SMA output.
+    class GetDataAttr(ResponseBodyStruct):
+        sma_out: SMAOutputFunction = field(XmpByte())
+        """coded byte, specifying the function of the SMA output."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        sma_out: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=SMAOutputFunction)  # coded byte, specifying the function of the SMA output.
+    class SetDataAttr(RequestBodyStruct):
+        sma_out: SMAOutputFunction = field(XmpByte())
+        """coded byte, specifying the function of the SMA output."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the function of the SMA (SubMiniature version A) output of the module
 
         :return: the function of the SMA (SubMiniature version A) output of the module
         :rtype: M_SMAOUTPUT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, sma_out: SMAOutputFunction) -> "Token":
+    def set(self, sma_out: SMAOutputFunction) -> Token[None]:
         """Set the function of the SMA (SubMiniature version A) output of the module
 
         :param sma_out: the function of the SMA (SubMiniature version A) output of the module
         :type sma_out: SMAOutputFunction
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, sma_out=sma_out))
 
     set_disabled = functools.partialmethod(set, SMAOutputFunction.DISABLED)
     """Set SMA output function to Disabled.
     """
+
     set_passthrough = functools.partialmethod(set, SMAOutputFunction.PASSTHROUGH)
     """Set SMA output function to Pass-Through.
     """
+
     set_p0sof = functools.partialmethod(set, SMAOutputFunction.P0SOF)
     """Set SMA output function to Port 0 Start-of-Frame Pulse.
     """
+
     set_p1sof = functools.partialmethod(set, SMAOutputFunction.P1SOF)
     """Set SMA output function to Port 1 Start-of-Frame Pulse.
     """
+
     set_ref2mhz = functools.partialmethod(set, SMAOutputFunction.REF2MHZ)
     """Set SMA output function to TX Clock (nom. 2.048 MHz).
     """
+
     set_ref10mhz = functools.partialmethod(set, SMAOutputFunction.REF10MHZ)
     """Set SMA output function to TX Clock (nom. 10.0 MHz).
     """
+
     set_ref125mhz = functools.partialmethod(set, SMAOutputFunction.REF125MHZ)
     """Set SMA output function to TX Clock (nom. 125 MHz).
     """
+
     set_ref156mhz = functools.partialmethod(set, SMAOutputFunction.REF156MHZ)
     """Set SMA output function to TX Clock (nom. 156.25 MHz).
     """
+
     set_p0rxclk = functools.partialmethod(set, SMAOutputFunction.P0RXCLK)
     """Set SMA output function to Port 0 RX Clock (nom. 10.0 MHz).
     """
+
     set_p1rxclk = functools.partialmethod(set, SMAOutputFunction.P1RXCLK)
     """Set SMA output function to Port 1 RX Clock (nom. 10.0 MHz).
     """
+
     set_p0rxclk2mhz = functools.partialmethod(set, SMAOutputFunction.P0RXCLK2MHZ)
     """Set SMA output function to Port 0 RX Clock (nom. 2.048 MHz).
     """
+
     set_p1rxclk2mhz = functools.partialmethod(set, SMAOutputFunction.P1RXCLK2MHZ)
     """Set SMA output function to Port 1 RX Clock (nom. 2.048 MHz).
     """
+
     set_ts_pps = functools.partialmethod(set, SMAOutputFunction.TS_PPS)
     """Set SMA output function to Timing Source (Pulse-Per-Second).
     """
 
 
 @register_command
 @dataclass
@@ -891,213 +975,224 @@
     """
     For test modules with SMA connectors, this returns the status of the SMA input.
     """
 
     code: typing.ClassVar[int] = 97
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=SMAStatus)  # coded byte, specifying the status of the SMA input.
+    class GetDataAttr(ResponseBodyStruct):
+        status: SMAStatus = field(XmpByte())
+        """coded byte, specifying the status of the SMA input."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of the SMA input
 
         :return: the status of the SMA input
         :rtype: M_SMASTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_NAME:
     """
     Gets the name of a module.
     """
 
     code: typing.ClassVar[int] = 99
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the name for the module.
+    class GetDataAttr(ResponseBodyStruct):
+        name: str = field(XmpStr())
+        """string, the name for the module."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the name of the module.
 
         :return: the name of the module
         :rtype: M_NAME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_REVISION:
     """
     Gets the model P/N name of a Xena test module.
     """
 
     code: typing.ClassVar[int] = 100
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        revision: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the model P/N name of a Xena test module.
+    class GetDataAttr(ResponseBodyStruct):
+        revision: str = field(XmpStr())
+        """string, the model P/N name of a Xena test module."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the model P/N name of a Xena test module.
 
         :return: the model P/N name of a Xena test module.
         :rtype: M_REVISION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_MEDIA:
     """
     For the test modules that support media configuration (check M_CAPABILITIES), this command sets the desired media
     type (front port).
     """
 
     code: typing.ClassVar[int] = 342
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        media_config: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MediaConfigurationType)  # coded byte, specifying the active front port: CFP4, QSFP28, CXP, SFP28.
+    class GetDataAttr(ResponseBodyStruct):
+        media_config: MediaConfigurationType = field(XmpByte())
+        """coded byte, specifying the active front port: CFP4, QSFP28, CXP, SFP28."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        media_config: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MediaConfigurationType)  # coded byte, specifying the active front port: CFP4, QSFP28, CXP, SFP28.
+    class SetDataAttr(RequestBodyStruct):
+        media_config: MediaConfigurationType = field(XmpByte())
+        """coded byte, specifying the active front port: CFP4, QSFP28, CXP, SFP28."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the media type of the test module.
 
         :return: the media type of the test module
         :rtype: M_MEDIA.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, media_config: MediaConfigurationType) -> "Token":
+    def set(self, media_config: MediaConfigurationType) -> Token[None]:
         """Set the media type of the test module.
 
         :param media_config: the media type of the test module
         :type media_config: MediaType
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, media_config=media_config))
 
 
 @register_command
 @dataclass
 class M_CLOCKSYNCSTATUS:
     """
     Get module's clock sync status.
     """
 
     code: typing.ClassVar[int] = 370
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        m_clock_diff: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, module clock diff
-        m_correction: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, module correction
-        m_tune_is_increase: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, whether module tune is increased
-        m_tune_value: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, module tune value
-        m_is_steady_state: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, whether module is in steady state
+    class GetDataAttr(ResponseBodyStruct):
+        m_clock_diff: int = field(XmpLong())
+        """long integer, module clock diff"""
+        m_correction: int = field(XmpLong())
+        """long integer, module correction"""
+        m_tune_is_increase: int = field(XmpLong())
+        """long integer, whether module tune is increased"""
+        m_tune_value: int = field(XmpLong())
+        """long integer, module tune value"""
+        m_is_steady_state: int = field(XmpLong())
+        """long integer, whether module is in steady state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the test module's clock sync status.
 
         :return: the test module's clock sync status
         :rtype: M_CLOCKSYNCSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LICENSE_DEMO_INFO:
     """
     Returns info about the demo status of the module. Only applicable to L47 test module.
     """
 
     code: typing.ClassVar[int] = 400
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        demo: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=HasDemo)  # coded byte, specifies if this is a demo module or not.
-        valid: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsValid)  # coded byte, if this is a demo module, specifies if the demo license is valid.
-        permanent: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=IsPermanent
-        )  # coded byte, if this is a demo module and the demo license is valid, specifies if the demo license is permanent.
-        expiration: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, if this is a demo module and the demo license is valid and not permanent, specifies the expiration date of the demo license - in seconds since Jan 1, 1970.
+    class GetDataAttr(ResponseBodyStruct):
+        demo: HasDemo = field(XmpByte())
+        """coded byte, specifies if this is a demo module or not."""
+        valid: IsValid = field(XmpByte())
+        """coded byte, if this is a demo module, specifies if the demo license is valid."""
+        permanent: IsPermanent = field(XmpByte())
+        """coded byte, if this is a demo module and the demo license is valid, specifies if the demo license is permanent."""
+        expiration: int = field(XmpLong())
+        """long integer, if this is a demo module and the demo license is valid and not permanent,
+        specifies the expiration date of the demo license - in seconds since Jan 1, 1970.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get info of the demo status of the test module. Only applicable to L47 test module.
 
         :return: info of the demo status of the test module.
         :rtype: M_LICENSE_DEMO_INFO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LICENSE_MAINTENANCE_INFO:
     """
     Returns info about the maintenance license status for the module. Only applicable to L47 test module.
     """
 
     code: typing.ClassVar[int] = 401
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        valid: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsValid)  # coded byte, specifies if the maintenance license is valid.
-        permanent: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=IsPermanent
-        )  # coded byte, if the maintenance license is valid, specifies if the maintenance license is permanent.
-        expiration: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, if the maintenance license is valid and not permanent, specifies the expiration date of the maintenance license - in seconds since Jan 1, 1970.
+    class GetDataAttr(ResponseBodyStruct):
+        valid: IsValid = field(XmpByte())
+        """coded byte, specifies if the maintenance license is valid."""
+        permanent: IsPermanent = field(XmpByte())
+        """coded byte, if the maintenance license is valid, specifies if the maintenance license is permanent."""
+        expiration: int = field(XmpLong())
+        """long integer, if the maintenance license is valid and not permanent, specifies the expiration date of the maintenance license - in seconds since Jan 1, 1970."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the info about the maintenance license status for the module. Only applicable to L47 test module.
 
         :return: the info about the maintenance license status for the test module
         :rtype: M_LICENSE_MAINTENANCE_INFO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LICENSE_CWB_DETECTED:
     """
@@ -1106,27 +1201,28 @@
     clock-windback, set the system time correct (via the M4_SYSTEM_TIME command) and
     perform a license update (via the M_LICENSE_UPDATE command). Only applicable to L47 test module.
     """
 
     code: typing.ClassVar[int] = 402
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        detected: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifies if clock-windback is detected.
+    class GetDataAttr(ResponseBodyStruct):
+        detected: YesNo = field(XmpByte())
+        """coded byte, specifies if clock-windback is detected."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether clock-windback is detected.
 
         :return: whether clock-windback is detected
         :rtype: M_LICENSE_CWB_DETECTED.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LICENSE_UPDATE:
     """
@@ -1138,86 +1234,86 @@
     response (bin file) has a lifetime of one day (24 hours). The result of the
     license update operation can be retrieved by M_LICENSE_UPDATE_STATUS.
     """
 
     code: typing.ClassVar[int] = 403
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Start license update
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LICENSE_UPDATE_STATUS:
     """
     Returns the status of the latest license update operations.
     """
 
     code: typing.ClassVar[int] = 404
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        update_state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=UpdateState)  # coded byte, specifies the state of the license update procedure
-        last_update: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, time for the last update request - in seconds since Jan 1, 1979
-        last_success: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, time for the last successful update - in seconds since Jan 1, 1979
-        last_fail: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, time for the last failed update - in seconds since Jan 1, 1979
-        Info: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, info about the last license update operation - reason for failed update.
+    class GetDataAttr(ResponseBodyStruct):
+        update_state: UpdateState = field(XmpByte())
+        """coded byte, specifies the state of the license update procedure"""
+        last_update: int = field(XmpLong())
+        """long integer, time for the last update request - in seconds since Jan 1, 1979"""
+        last_success: int = field(XmpLong())
+        """long integer, time for the last successful update - in seconds since Jan 1, 1979"""
+        last_fail: int = field(XmpLong())
+        """long integer, time for the last failed update - in seconds since Jan 1, 1979"""
+        info: str = field(XmpStr())
+        """string, info about the last license update operation - reason for failed update."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of the latest license update operation.
 
         :return: the status of the latest license update operation
         :rtype: M_LICENSE_UPDATE_STATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LICENSE_LIST_BSON:
     """
     Returns a list of locally stored licenses - formatted as a BSON document.
     """
 
     code: typing.ClassVar[int] = 405
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        bson: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, bson document containing the list of locally stored licenses
+    class GetDataAttr(ResponseBodyStruct):
+        bson: Hex = field(XmpHex())
+        """list of hex bytes, bson document containing the list of locally stored licenses"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the a list of locally stored licenses - formatted as a BSON document.
 
         :return: a list of locally stored licenses - formatted as a BSON document.
         :rtype: M_LICENSE_LIST_BSON.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LICENSE_ONLINE:
     """
@@ -1227,44 +1323,47 @@
     access to the Internet. In offline mode the license update procedure can be
     performed without access to the Internet.
     """
 
     code: typing.ClassVar[int] = 406
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsOnline)  # coded byte, chassis online/offline mode.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: IsOnline = field(XmpByte())
+        """coded byte, chassis online/offline mode."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsOnline)  # coded byte, chassis online/offline mode.
+    class SetDataAttr(RequestBodyStruct):
+        mode: IsOnline = field(XmpByte())
+        """coded byte, chassis online/offline mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the current online/offline mode of the L47 tester.
 
         :return: the current online/offline mode of the L47 tester
         :rtype: M_LICENSE_ONLINE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, mode: IsOnline) -> "Token":
+    def set(self, mode: IsOnline) -> Token[None]:
         """Set the current online/offline mode of the L47 tester.
 
         :param mode: the current online/offline mode of the L47 tester
         :type mode: IsOnline
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, mode=mode))
 
     set_offline = functools.partialmethod(set, IsOnline.OFFLINE)
     """Set the L47 tester to offline mode.
     """
+
     set_online = functools.partialmethod(set, IsOnline.ONLINE)
     """Set the L47 tester to online mode.
     """
 
 
 @register_command
 @dataclass
@@ -1273,68 +1372,79 @@
     For test modules with advanced timing features, select what clock drives the port TX
     rates.
     """
 
     code: typing.ClassVar[int] = 410
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        tx_clock: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TXClockSource)  # coded byte, specifying what drives the port TX rates.
+    class GetDataAttr(ResponseBodyStruct):
+        tx_clock: TXClockSource = field(XmpByte())
+        """coded byte, specifying what drives the port TX rates."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        tx_clock: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TXClockSource)  # coded byte, specifying what drives the port TX rates.
+    class SetDataAttr(RequestBodyStruct):
+        tx_clock: TXClockSource = field(XmpByte())
+        """coded byte, specifying what drives the port TX rates."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the test module's TX clock source settings.
 
         :return: the test module's TX clock source settings.
         :rtype: M_TXCLOCKSOURCE_NEW.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, tx_clock: TXClockSource) -> "Token":
+    def set(self, tx_clock: TXClockSource) -> Token[None]:
         """Set the test module's TX clock source settings.
 
         :param tx_clock: the test module's TX clock source settings
         :type tx_clock: TXClockSource
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, tx_clock=tx_clock))
 
     set_modulelocalclock = functools.partialmethod(set, TXClockSource.MODULELOCALCLOCK)
     """Set the test module's TX clock source to Module Local Clock
     """
+
     set_smainput = functools.partialmethod(set, TXClockSource.SMAINPUT)
     """Set the test module's TX clock source to SMA Input
     """
+
     set_p0rxclk = functools.partialmethod(set, TXClockSource.P0RXCLK)
     """Set the test module's TX clock source to Port 0 RX Clock
     """
+
     set_p1rxclk = functools.partialmethod(set, TXClockSource.P1RXCLK)
     """Set the test module's TX clock source to Port 1 RX Clock
     """
+
     set_p2rxclk = functools.partialmethod(set, TXClockSource.P2RXCLK)
     """Set the test module's TX clock source to Port 2 RX Clock
     """
+
     set_p3rxclk = functools.partialmethod(set, TXClockSource.P3RXCLK)
     """Set the test module's TX clock source to Port 3 RX Clock
     """
+
     set_p4rxclk = functools.partialmethod(set, TXClockSource.P4RXCLK)
     """Set the test module's TX clock source to Port 4 RX Clock
     """
+
     set_p5rxclk = functools.partialmethod(set, TXClockSource.P5RXCLK)
     """Set the test module's TX clock source to Port 5 RX Clock
     """
+
     set_p6rxclk = functools.partialmethod(set, TXClockSource.P6RXCLK)
     """Set the test module's TX clock source to Port 6 RX Clock
     """
+
     set_p7rxclk = functools.partialmethod(set, TXClockSource.P7RXCLK)
     """Set the test module's TX clock source to Port 7 RX Clock
     """
 
 
 @register_command
 @dataclass
@@ -1343,80 +1453,87 @@
     For test modules with advanced timing features, check whether a valid clock is
     present.
     """
 
     code: typing.ClassVar[int] = 411
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TXClockStatus)  # coded byte, specifying the status of the TX clock.
+    class GetDataAttr(ResponseBodyStruct):
+        status: TXClockStatus = field(XmpByte())
+        """coded byte, specifying the status of the TX clock."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of whether a valid clock is present for the test module.
 
         :return: the status of whether a valid clock is present for the test module.
         :rtype: M_TXCLOCKSTATUS_NEW.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_TXCLOCKFILTER_NEW:
     """
     For test modules with advanced timing features, the loop bandwidth on the TX
     clock filter.
     """
 
     code: typing.ClassVar[int] = 412
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filter_bandwidth: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LoopBandwidth)  # coded byte, the loop bandwidth on the TX clock filter.
+    class GetDataAttr(ResponseBodyStruct):
+        filter_bandwidth: LoopBandwidth = field(XmpByte())
+        """coded byte, the loop bandwidth on the TX clock filter."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        filter_bandwidth: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LoopBandwidth)  # coded byte, the loop bandwidth on the TX clock filter.
+    class SetDataAttr(RequestBodyStruct):
+        filter_bandwidth: LoopBandwidth = field(XmpByte())
+        """coded byte, the loop bandwidth on the TX clock filter."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the setting of the loop bandwidth on the TX clock filter.
 
         :return: the setting of the loop bandwidth on the TX clock filter.
         :rtype: M_TXCLOCKFILTER_NEW.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, filter_bandwidth: LoopBandwidth) -> "Token":
+    def set(self, filter_bandwidth: LoopBandwidth) -> Token[None]:
         """Set the setting of the loop bandwidth on the TX clock filter.
 
         :param filter_bandwidth: the setting of the loop bandwidth on the TX clock filter
         :type filter_bandwidth: LoopBandwidth
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, filter_bandwidth=filter_bandwidth))
 
     set_bw103hz = functools.partialmethod(set, LoopBandwidth.BW103HZ)
     """Set the loop bandwidth on the TX clock filter to BW = 103 Hz.
     """
+
     set_bw207hz = functools.partialmethod(set, LoopBandwidth.BW207HZ)
     """Set the loop bandwidth on the TX clock filter to BW = 207 Hz.
     """
+
     set_bw416hz = functools.partialmethod(set, LoopBandwidth.BW416HZ)
     """Set the loop bandwidth on the TX clock filter to BW = 416 Hz.
     """
+
     set_bw1683hz = functools.partialmethod(set, LoopBandwidth.BW1683HZ)
     """Set the loop bandwidth on the TX clock filter to BW = 1683 Hz.
     """
+
     set_bw7019hz = functools.partialmethod(set, LoopBandwidth.BW7019HZ)
     """Set the loop bandwidth on the TX clock filter to BW = 7019 Hz.
     """
 
 
 @register_command
 @dataclass
@@ -1428,61 +1545,77 @@
 
     Note: The sweep is independent of the :class:`M_CLOCKPPB` parameter, i.e. the sweep uses the deviation set by :class:`M_CLOCKPPB` as its zero point.
     """
 
     code: typing.ClassVar[int] = 413
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=PPMSweepMode)  # coded byte, specifying the sweeping function: OFF or TRIANGLE
-        # integer >=0, the numeric clock adjustment in ppb per step of the sweep. If set to 0, the sweep will use as small steps as possible, creating a "linear" sweep of the clock rate.
-        ppb_step: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)
-        # integer >0 the delay in µs between each step in the sweep. If ppb_step is 0: The total time in µs to sweep linearly from 0 to max_ppb.
-        step_delay: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)
-        # integer != 0, the numeric maximum clock adjustment. The sign of max_ppb determines if the sweep will start with positive or negative offsets. When the next step would exceed the limit set by max_ppb, the sweep changes direction. I.e. the deviation will sweep from 0 to max_ppb, to (-max_ppb), and back to 0.
-        max_ppb: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)
-        loops: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer >=0, the number of full sweeps performed. 0 means "indefinitely".
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=PPMSweepMode)  # coded byte, specifying the sweeping function.
-        # integer >=0, the numeric clock adjustment in ppb per step of the sweep. If set to 0, the sweep will use as small steps as possible, creating a "linear" sweep of the clock rate.
-        ppb_step: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)
-        # integer >0 the delay in µs between each step in the sweep. If ppb_step is 0: The total time in µs to sweep linearly from 0 to max_ppb.
-        step_delay: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)
-        # integer != 0, the numeric maximum clock adjustment. The sign of max_ppb determines if the sweep will start with positive or negative offsets. When the next step would exceed the limit set by max_ppb, the sweep changes direction. I.e. the deviation will sweep from 0 to max_ppb, to (-max_ppb), and back to 0.
-        max_ppb: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)
-        loops: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer >=0, the number of full sweeps performed. 0 means "indefinitely".
+    class GetDataAttr(ResponseBodyStruct):
+        mode: PPMSweepMode = field(XmpInt())
+        """coded byte, specifying the sweeping function."""
+        ppb_step: int = field(XmpInt())
+        """integer >=0, the numeric clock adjustment in ppb per step of the sweep.
+        If set to 0, the sweep will use as small steps as possible, creating a "linear" sweep of the clock rate.
+        """
+        step_delay: int = field(XmpInt())
+        """integer >0 the delay in µs between each step in the sweep. If ppb_step is 0: The total time in µs to sweep linearly from 0 to max_ppb."""
+        max_ppb: int = field(XmpInt())
+        """integer != 0, the numeric maximum clock adjustment. The sign of max_ppb determines if the sweep will start with positive or negative offsets.
+        When the next step would exceed the limit set by max_ppb, the sweep changes direction. I.e. the deviation will sweep from 0 to max_ppb, to (-max_ppb), and back to 0.
+        """
+        loops: int = field(XmpInt())
+        """integer >=0, the number of full sweeps performed. 0 means "indefinitely"."""
+
+    class SetDataAttr(RequestBodyStruct):
+        mode: PPMSweepMode = field(XmpInt())
+        """coded byte, specifying the sweeping function: OFF or TRIANGLE"""
+        ppb_step: int = field(XmpInt())
+        """integer >=0, the numeric clock adjustment in ppb per step of the sweep.
+        If set to 0, the sweep will use as small steps as possible, creating a "linear" sweep of the clock rate.
+        """
+        step_delay: int = field(XmpInt())
+        """integer >0 the delay in µs between each step in the sweep. If ppb_step is 0: The total time in µs to sweep linearly from 0 to max_ppb."""
+        max_ppb: int = field(XmpInt())
+        """integer != 0, the numeric maximum clock adjustment. The sign of max_ppb determines if the sweep will start with positive or negative offsets.
+        When the next step would exceed the limit set by max_ppb, the sweep changes direction. I.e. the deviation will sweep from 0 to max_ppb, to (-max_ppb), and back to 0.
+        """
+        loops: int = field(XmpInt())
+        """integer >=0, the number of full sweeps performed. 0 means "indefinitely"."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the PPM sweep parameters from the module.
 
         :return: the PPM sweep parameters from the module.
         :rtype: M_CLOCKPPBSWEEP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, mode: PPMSweepMode, ppb_step: int, step_delay: int, max_ppb: int, loops: int) -> "Token":
+    def set(self, mode: PPMSweepMode, ppb_step: int, step_delay: int, max_ppb: int, loops: int) -> Token[None]:
         """Set the PPM sweep parameters of the module.
 
         :param mode: specifying the sweeping function: OFF or TRIANGLE.
         :type mode: PPMSweepMode
-        :param ppb_step: >=0, the numeric clock adjustment in ppb per step of the sweep. If set to 0, the sweep will use as small steps as possible, creating a "linear" sweep of the clock rate.
+        :param ppb_step: >=0, the numeric clock adjustment in ppb per step of the sweep.
+            If set to 0, the sweep will use as small steps as possible, creating a "linear" sweep of the clock rate.
         :type ppb_step: int
         :param step_delay: >0 the delay in µs between each step in the sweep. If ppb_step is 0: The total time in µs to sweep linearly from 0 to max_ppb.
         :type step_delay: int
-        :param max_ppb: != 0, the numeric maximum clock adjustment. The sign of max_ppb determines if the sweep will start with positive or negative offsets. When the next step would exceed the limit set by max_ppb, the sweep changes direction. I.e. the deviation will sweep from 0 to max_ppb, to (-max_ppb), and back to 0.
+        :param max_ppb: != 0, the numeric maximum clock adjustment.
+            The sign of max_ppb determines if the sweep will start with positive or negative offsets.
+            When the next step would exceed the limit set by max_ppb, the sweep changes direction.
+            I.e. the deviation will sweep from 0 to max_ppb, to (-max_ppb), and back to 0.
         :type max_ppb: int
         :param loops: >=0, the number of full sweeps performed. 0 means "indefinitely".
         :type loops: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, mode=mode, ppb_step=ppb_step, step_delay=step_delay, max_ppb=max_ppb, loops=loops))
 
 
 @register_command
 @dataclass
 class M_CLOCKSWEEPSTATUS:
     """
@@ -1491,81 +1624,88 @@
     Return the current status of the :class:`M_CLOCKPPBSWEEP` function.
 
     """
 
     code: typing.ClassVar[int] = 414
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PPMSweepStatus)  # coded byte, specifying if a sweep is active: OFF or SWEEPING
-
-        curr_sweep: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer >=0, the current full sweep number, counting from 0.
-        curr_step: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer >=0 the current step number inside the sweep, counting from 0.
-
-        # integer, >0, the total number of steps comprising a full sweep. For "linear" sweeps (ppb_step=0, see M_CLOCKPPBSWEEP) this number is determined by the chassis. In other cases, the number is implicitly given by the M_CLOCKPPBSWEEP parameters.
-        max_steps: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)
+    class GetDataAttr(ResponseBodyStruct):
+        state: PPMSweepStatus = field(XmpByte())
+        """coded byte, specifying if a sweep is active: OFF or SWEEPING"""
+        curr_sweep: int = field(XmpInt())
+        """integer >=0, the current full sweep number, counting from 0."""
+        curr_step: int = field(XmpInt())
+        """integer >=0 the current step number inside the sweep, counting from 0."""
+        max_steps: int = field(XmpInt())
+        """integer, >0, the total number of steps comprising a full sweep. For "linear" sweeps (ppb_step=0, see M_CLOCKPPBSWEEP)
+        this number is determined by the chassis. In other cases, the number is implicitly given by the M_CLOCKPPBSWEEP parameters.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the current status of the :class:`M_CLOCKPPBSWEEP` function.
 
         :return: the current status of the :class:`M_CLOCKPPBSWEEP` function.
         :rtype: M_CLOCKSWEEPSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
 
 @register_command
 @dataclass
 class M_LATENCYMODE:
     """
-    Configures the latency mode for Chimera module. In extended latency mode, the FPGA allows all latency parameters to be 10 times higher, at the cost of reduced latency precision.
+    Configures the latency mode for Chimera module. In extended latency mode, the FPGA allows all latency parameters to be 10 times higher,
+    at the cost of reduced latency precision.
 
     .. note::
 
         - When change the latency mode, all latency configurations are reset on all ports in chimera module.
 
     """
 
     code: typing.ClassVar[int] = 450
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ImpairmentLatencyMode)  # coded byte, specifying latency mode.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: ImpairmentLatencyMode = field(XmpByte())
+        """coded byte, specifying latency mode."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ImpairmentLatencyMode)  # coded byte, specifying latency mode.
+    class SetDataAttr(RequestBodyStruct):
+        mode: ImpairmentLatencyMode = field(XmpByte())
+        """coded byte, specifying latency mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the latency mode of the Chimera module.
 
         :return: the latency mode of the Chimera module.
         :rtype: M_LATENCYMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, mode: ImpairmentLatencyMode) -> "Token":
+    def set(self, mode: ImpairmentLatencyMode) -> Token[None]:
         """Set the latency mode of the Chimera module.
 
         :param mode: the bypass mode of the impairment emulator.
         :type mode: ImpairmentLatencyMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, mode=mode))
 
     set_normal = functools.partialmethod(set, ImpairmentLatencyMode.NORMAL)
     """Set the latency mode of the Chimera module to NORMAL
     """
+
     set_extended = functools.partialmethod(set, ImpairmentLatencyMode.EXTENDED)
     """Set the latency mode of the Chimera module to EXTENDED
     """
 
 
 @register_command
 @dataclass
@@ -1574,40 +1714,43 @@
     Set emulator bypass mode. Emulator bypass mode will bypass the entire emulator
     for minimum latency.
     """
 
     code: typing.ClassVar[int] = 454
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the emulator bypass is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the emulator bypass is enabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the emulator bypass is enabled.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the emulator bypass is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of bypass mode of the impairment emulator.
 
         :return: the status of bypass mode of the impairment emulator.
         :rtype: M_EMULBYPASS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the bypass mode of the impairment emulator.
 
         :param on_off: the bypass mode of the impairment emulator.
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the bypass mode of the impairment emulator.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the bypass mode of the impairment emulator.
     """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/p4_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/p4_commands.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,123 +1,157 @@
-#: L47 Port Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpLong,
+    XmpSequence,
+    XmpStr,
+    Hex,
+)
+from .enums import (
+    OnOff,
+    IsPermanent,
+    AutoOrManual,
+    L47TrafficState,
+    L47PortState,
+    L47PortSpeed,
+    IsPresent,
+    LicenseSpeed,
+)
 
 
 @register_command
 @dataclass
 class P4_TRAFFIC:
     """
     Gives a traffic state command to a L47 port.
     """
 
     code: typing.ClassVar[int] = 700
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        traffic_state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47TrafficState)  # coded byte, the traffic state command issued to the port.
+    class SetDataAttr(RequestBodyStruct):
+        traffic_state: L47TrafficState = field(XmpByte())
+        """coded byte, the traffic state command issued to the port."""
 
-    def set(self, traffic_state: L47TrafficState) -> "Token":
+    def set(self, traffic_state: L47TrafficState) -> Token[None]:
         """Set L47 port traffic state.
 
         :param traffic_state: the traffic state command issued to the port
         :type traffic_state: L47TrafficState
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, traffic_state=traffic_state))
 
     set_off = functools.partialmethod(set, L47TrafficState.OFF)
     """Set L47 port traffic state to Off."""
+
     set_on = functools.partialmethod(set, L47TrafficState.ON)
     """Set L47 port traffic state to On."""
+
     set_stop = functools.partialmethod(set, L47TrafficState.STOP)
     """Set L47 port traffic state to Stop."""
+
     set_prepare = functools.partialmethod(set, L47TrafficState.PREPARE)
     """Set L47 port traffic state to Prepare."""
+
     set_prerun = functools.partialmethod(set, L47TrafficState.PRERUN)
     """Set L47 port traffic state to Prerun."""
 
 
 @register_command
 @dataclass
 class P4_STATE:
     """
     Display the current state of the L47 port.
     """
 
     code: typing.ClassVar[int] = 701
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47PortState)  # coded byte, specifying the current state for this port.
+    class GetDataAttr(ResponseBodyStruct):
+        state: L47PortState = field(XmpByte())
+        """coded byte, specifying the current state for this port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the current state of the L47 port.
 
         :return: the current state of the L47 port
         :rtype: P4_STATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_CAPABILITIES:
     """
     Report the speeds supported by the L47 port.
     """
 
     code: typing.ClassVar[int] = 702
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        auto: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, autoneg supported
-        N100_mbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 100M speed supported
-        N1_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 1G speed supported
-        N2_5_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 2.5G speed supported
-        N5_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 5G speed supported
-        N10_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 10G speed supported
-        N25_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 25G speed supported
-        N40_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 40G speed supported
-        N50_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 50G speed supported
-        N100_gbps: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 100G speed supported
+    class GetDataAttr(ResponseBodyStruct):
+        auto: int = field(XmpByte())
+        """byte, autoneg supported"""
+        N100_mbps: int = field(XmpByte())
+        """byte, 100M speed supported"""
+        N1_gbps: int = field(XmpByte())
+        """byte, 1G speed supported"""
+        N2_5_gbps: int = field(XmpByte())
+        """byte, 2.5G speed supported"""
+        N5_gbps: int = field(XmpByte())
+        """byte, 5G speed supported"""
+        N10_gbps: int = field(XmpByte())
+        """byte, 10G speed supported"""
+        N25_gbps: int = field(XmpByte())
+        """byte, 25G speed supported"""
+        N40_gbps: int = field(XmpByte())
+        """byte, 40G speed supported"""
+        N50_gbps: int = field(XmpByte())
+        """byte, 50G speed supported"""
+        N100_gbps: int = field(XmpByte())
+        """byte, 100G speed supported"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the speeds supported by the L47 port.
 
         :return: the speeds supported by the L47 port
         :rtype: P4_CAPABILITIES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_STATE_STATUS:
     """
@@ -125,28 +159,29 @@
     PREPARE_FAIL, the status contains information about the reason for the fail.
     Currently the status will be "OK"in all other states.
     """
 
     code: typing.ClassVar[int] = 703
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, status for the last port state change
+    class GetDataAttr(ResponseBodyStruct):
+        status: str = field(XmpStr())
+        """string, status for the last port state change"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get status of the last port state change.
 
         :return: status of the last port state change
         :rtype: P4_STATE_STATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_VLAN_OFFLOAD:
     """
@@ -154,44 +189,47 @@
     device. If VLAN Offload is switched ON, VLAN tags will not be present in frames
     captured by the L47 Server.
     """
 
     code: typing.ClassVar[int] = 704
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        offload: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies if VLAN Offload is switched ON
+    class GetDataAttr(ResponseBodyStruct):
+        offload: OnOff = field(XmpByte())
+        """coded byte, specifies if VLAN Offload is switched ON"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        offload: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies if VLAN Offload is switched ON
+    class SetDataAttr(RequestBodyStruct):
+        offload: OnOff = field(XmpByte())
+        """coded byte, specifies if VLAN Offload is switched ON"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the VLAN offload status.
 
         :return: VLAN offload status
         :rtype: P4_VLAN_OFFLOAD.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, offload: OnOff) -> "Token":
+    def set(self, offload: OnOff) -> Token[None]:
         """Set the VLAN offload state.
 
         :param offload: specifies if VLAN Offload is enabled
         :type offload: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, offload=offload))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable VLAN offload."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable VLAN offload."""
 
 
 @register_command
 @dataclass
 class P4_ARP_CONFIG:
@@ -199,139 +237,154 @@
     Configure the value of the ARP request transmission rate, retransmission timeout
     and max. retries.
     """
 
     code: typing.ClassVar[int] = 705
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        rate: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ARP Request transmission rate (requests / sec) - must be larger than 0
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ARP Request retransmission timeout [ms] - must be larger than 0
-        retries: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum ARP Request retransmission retries
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        rate: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ARP Request transmission rate (requests / sec) - must be larger than 0
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ARP Request retransmission timeout [ms] - must be larger than 0
-        retries: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum ARP Request retransmission retries
+    class GetDataAttr(ResponseBodyStruct):
+        rate: int = field(XmpInt())
+        """integer, ARP Request transmission rate (requests / sec) - must be larger than 0"""
+        retrans_timeout: int = field(XmpInt())
+        """integer, ARP Request retransmission timeout [ms] - must be larger than 0"""
+        retries: int = field(XmpByte())
+        """byte, maximum ARP Request retransmission retries"""
+
+    class SetDataAttr(RequestBodyStruct):
+        rate: int = field(XmpInt())
+        """integer, ARP Request transmission rate (requests / sec) - must be larger than 0"""
+        retrans_timeout: int = field(XmpInt())
+        """integer, ARP Request retransmission timeout [ms] - must be larger than 0"""
+        retries: int = field(XmpByte())
+        """byte, maximum ARP Request retransmission retries"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the ARP configuration on the port.
 
         :return: the ARP configuration on the port
         :rtype: P4_ARP_CONFIG.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, rate: int, retrans_timeout: int, retries: int) -> "Token":
+    def set(self, rate: int, retrans_timeout: int, retries: int) -> Token[None]:
         """Set the ARP configuration on the port.
 
         :param rate: ARP Request transmission rate (requests/sec) - must be larger than 0
         :type rate: int
         :param retrans_timeout: ARP Request retransmission timeout [ms] - must be larger than 0
         :type retrans_timeout: int
         :param retries: maximum ARP Request retransmission retries
         :type retries: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, rate=rate, retrans_timeout=retrans_timeout, retries=retries))
 
 
 @register_command
 @dataclass
 class P4_NDP_CONFIG:
     """
     Configure the value of the NDP Neighbor Solicitation transmission rate,
     retransmission timeout and max. retries.
     """
 
     code: typing.ClassVar[int] = 706
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        rate: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, NDP Neighbor Solicitation transmission rate (requests / sec) - must be larger than 0
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, NDP Neighbor Solicitation retransmission timeout [ms] - must be larger than 0
-        retries: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, Max. NDP Neighbor Solicitation retransmission retries
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        rate: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, NDP Neighbor Solicitation transmission rate (requests / sec) - must be larger than 0
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, NDP Neighbor Solicitation retransmission timeout [ms] - must be larger than 0
-        retries: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, Max. NDP Neighbor Solicitation retransmission retries
+    class GetDataAttr(ResponseBodyStruct):
+        rate: int = field(XmpInt())
+        """integer, NDP Neighbor Solicitation transmission rate (requests / sec) - must be larger than 0"""
+        retrans_timeout: int = field(XmpInt())
+        """integer, NDP Neighbor Solicitation retransmission timeout [ms] - must be larger than 0"""
+        retries: int = field(XmpByte())
+        """byte, Max. NDP Neighbor Solicitation retransmission retries"""
+
+    class SetDataAttr(RequestBodyStruct):
+        rate: int = field(XmpInt())
+        """integer, NDP Neighbor Solicitation transmission rate (requests / sec) - must be larger than 0"""
+        retrans_timeout: int = field(XmpInt())
+        """integer, NDP Neighbor Solicitation retransmission timeout [ms] - must be larger than 0"""
+        retries: int = field(XmpByte())
+        """byte, Max. NDP Neighbor Solicitation retransmission retries"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the NDP configuration on the port.
 
         :return: the NDP configuration on the port
         :rtype: P4_NDP_CONFIG.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, rate: int, retrans_timeout: int, retries: int) -> "Token":
+    def set(self, rate: int, retrans_timeout: int, retries: int) -> Token[None]:
         """Set the NDP configuration on the port.
 
         :param rate: NDP Neighbor Solicitation transmission rate (requests/sec) - must be larger than 0
         :type rate: int
         :param retrans_timeout: NDP Neighbor Solicitation retransmission timeout [ms] - must be larger than 0
         :type retrans_timeout: int
         :param retries: maximum NDP Neighbor Solicitation retransmission retries
         :type retries: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, rate=rate, retrans_timeout=retrans_timeout, retries=retries))
 
 
 @register_command
 @dataclass
 class P4_CAPTURE:
     """
     Starts or stops packet capture on this port.
     """
 
     code: typing.ClassVar[int] = 707
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether to capture traffic on this port
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, specifying whether to capture traffic on this port"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether to capture traffic on this port
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, specifying whether to capture traffic on this port"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get packet capture state on this port.
 
         :return: packet capture state on this port
         :rtype: P4_CAPTURE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set packet capture state on this port.
 
         :param on_off: specifying whether to capture traffic on this port
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Stop packet capture on this port."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Start packet capture on this port."""
 
 
 @register_command
 @dataclass
 class P4_CAPTURE_GET_FIRST:
@@ -339,1365 +392,1559 @@
     Returns the first captured frame on the port. Command is only valid when port is
     in state STOPPED
     """
 
     code: typing.ClassVar[int] = 708
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        index: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, index of frame returned
-        second: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, second value of frame capture timestamp
-        microsecond: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, microsecond value of frame capture timestamp
-        capture_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, length of captured portion of the frame
-        frame_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, length of the frame
-        frame: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the captured frame (capture_len bytes)
+    class GetDataAttr(ResponseBodyStruct):
+        index: int = field(XmpInt())
+        """integer, index of frame returned"""
+        second: int = field(XmpInt())
+        """integer, second value of frame capture timestamp"""
+        microsecond: int = field(XmpInt())
+        """integer, microsecond value of frame capture timestamp"""
+        capture_length: int = field(XmpInt())
+        """integer, length of captured portion of the frame"""
+        frame_length: int = field(XmpInt())
+        """integer, length of the frame"""
+        frame: Hex = field(XmpHex())
+        """list of hex bytes, the captured frame (capture_len bytes)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the first captured frame on the port
 
         :return: the first captured frame on the port
         :rtype: P4_CAPTURE_GET_FIRST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_CAPTURE_GET_NEXT:
     """
     Returns the next captured frame on the port. Command is only valid when port is
     in state STOPPED
     """
 
     code: typing.ClassVar[int] = 709
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        index: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, index of frame returned
-        second: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, second value of frame capture timestamp
-        microsecond: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, microsecond value of frame capture timestamp
-        capture_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, length of captured portion of the frame
-        frame_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, length of the frame
-        frame: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # hex data, the captured frame (capture_len bytes)
+    class GetDataAttr(ResponseBodyStruct):
+        index: int = field(XmpInt())
+        """integer, index of frame returned"""
+        second: int = field(XmpInt())
+        """integer, second value of frame capture timestamp"""
+        microsecond: int = field(XmpInt())
+        """integer, microsecond value of frame capture timestamp"""
+        capture_length: int = field(XmpInt())
+        """integer, length of captured portion of the frame"""
+        frame_length: int = field(XmpInt())
+        """integer, length of the frame"""
+        frame: Hex = field(XmpHex())
+        """hex data, the captured frame (capture_len bytes)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the next captured frame on the port
 
         :return: the next captured frame on the port
         :rtype: P4_CAPTURE_GET_NEXT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ETH_TX_COUNTERS:
     """
     Return total port Ethernet transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 710
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        bits_per_sec: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, bit/second of (layer 2) bytes transmitted
-        packets_per_sec: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, packets/second of packets transmitted
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of (layer 2) bytes transmitted
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        bits_per_sec: int = field(XmpLong())
+        """long integer, bit/second of (layer 2) bytes transmitted"""
+        packets_per_sec: int = field(XmpLong())
+        """long integer, packets/second of packets transmitted"""
+        byte_count: int = field(XmpLong())
+        """long integer, total number of (layer 2) bytes transmitted"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of packets transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total port Ethernet transmit statistics since last clear.
 
         :return: total port Ethernet transmit statistics since last clear.
         :rtype: P4_ETH_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ETH_RX_COUNTERS:
     """
     Return total port Ethernet receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 711
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        bits_per_sec: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, bit/second of (layer 2) bytes received
-        packets_per_sec: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long, integer packets/second of received packets
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of (layer 2) bytes received
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        bits_per_sec: int = field(XmpLong())
+        """long integer, bit/second of (layer 2) bytes received"""
+        packets_per_sec: int = field(XmpLong())
+        """long, integer packets/second of received packets"""
+        byte_count: int = field(XmpLong())
+        """long integer, total number of (layer 2) bytes received"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of packets received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total port Ethernet receive statistics since last clear.
 
         :return: total port Ethernet receive statistics since last clear.
         :rtype: P4_ETH_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_PORT_TX_COUNTERS:
     """
     Return total port transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 712
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        vlan_packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of 802.1Q VLAN tagged packets transmitted
-        bits_per_sec: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, bit/second of (layer 1) bits transmitted.
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of (layer 1) bytes received.
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        vlan_packet_count: int = field(XmpLong())
+        """long integer, total number of 802.1Q VLAN tagged packets transmitted"""
+        bits_per_sec: int = field(XmpLong())
+        """long integer, bit/second of (layer 1) bits transmitted."""
+        byte_count: int = field(XmpLong())
+        """long integer, total number of (layer 1) bytes received."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total port transmit statistics since last clear.
 
         :return: total port transmit statistics since last clear.
         :rtype: P4_PORT_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_PORT_RX_COUNTERS:
     """
     Return total port receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 713
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        vlan_packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of 802.1Q VLAN tagged packets received
-        bits_per_sec: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, bit/second of (layer 1) bits received.
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of (layer 1) bytes received.
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        vlan_packet_count: int = field(XmpLong())
+        """long integer, total number of 802.1Q VLAN tagged packets received"""
+        bits_per_sec: int = field(XmpLong())
+        """long integer, bit/second of (layer 1) bits received."""
+        byte_count: int = field(XmpLong())
+        """long integer, total number of (layer 1) bytes received."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total port receive statistics since last clear.
 
         :return: total port receive statistics since last clear.
         :rtype: P4_PORT_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_PORT_COUNTERS:
     """
     Return total port transmit error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 714
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        invalid_eth_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of invalid (e.g. short) Ethernet packets received
-        unknown_eth_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of unknown or unsupported Ethernet packets received
-        mismatch_vlan_error_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets with mismatching vlan info received
-        pkt_rate_limit_count: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, number of times that number of packets transmitted has been limited by the maximum packet rate limiter.
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        invalid_eth_count: int = field(XmpLong())
+        """long integer, total number of invalid (e.g. short) Ethernet packets received"""
+        unknown_eth_count: int = field(XmpLong())
+        """long integer, total number of unknown or unsupported Ethernet packets received"""
+        mismatch_vlan_error_count: int = field(XmpLong())
+        """long integer, total number of packets with mismatching vlan info received"""
+        pkt_rate_limit_count: int = field(XmpLong())
+        """long integer, number of times that number of packets transmitted has been limited by the maximum packet rate limiter."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total port transmit error statistics since last clear.
 
         :return: total port transmit error statistics since last clear.
         :rtype: P4_PORT_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_TX_PACKET_SIZE:
     """
     Return histogram over transmitted (layer 2) packets sizes in 100 bytes intervals.
     """
 
     code: typing.ClassVar[int] = 715
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        bin_00: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_01: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_02: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_03: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_04: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_05: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_06: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_07: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_08: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_09: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_10: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_11: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_12: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_13: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_14: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_15: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        bin_00: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_01: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_02: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_03: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_04: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_05: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_06: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_07: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_08: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_09: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_10: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_11: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_12: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_13: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_14: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_15: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over transmitted (layer 2) packets sizes in 100 bytes intervals.
 
         :return: histogram over transmitted (layer 2) packets sizes in 100 bytes intervals.
         :rtype: P4_TX_PACKET_SIZE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_RX_PACKET_SIZE:
     """
     Return a histogram over received (layer 2) packets sizes in 100 bytes intervals.
     """
 
     code: typing.ClassVar[int] = 716
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        bin_00: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_01: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_02: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_03: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_04: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_05: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_06: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_07: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_08: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_09: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_10: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_11: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_12: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_13: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_14: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
-        bin_15: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets received with a (layer 2) size in the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        bin_00: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_01: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_02: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_03: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_04: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_05: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_06: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_07: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_08: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_09: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_10: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_11: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_12: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_13: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_14: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
+        bin_15: int = field(XmpLong())
+        """long integer, number of packets received with a (layer 2) size in the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over received (layer 2) packets sizes in 100 bytes intervals.
 
         :return: a histogram over received (layer 2) packets sizes in 100 bytes intervals.
         :rtype: P4_RX_PACKET_SIZE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_TX_MTU:
     """
     Return histogram over transmitted (layer 3) packets sizes in 1 byte intervals.
     Each bin represents a packet size in the interval [576..1500] bytes.
     """
 
     code: typing.ClassVar[int] = 717
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        bins: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # 925 x byte, '1' if any packets were transmitted with the specified layer 3 size, otherwise '0'.
+    class GetDataAttr(ResponseBodyStruct):
+        bins: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """925 x byte, '1' if any packets were transmitted with the specified layer 3 size, otherwise '0'."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get histogram over transmitted (layer 3) packets sizes in 1 byte intervals.
 
         :return: histogram over transmitted (layer 3) packets sizes in 1 byte intervals.
         :rtype: P4_TX_MTU.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_RX_MTU:
     """
     Return histogram over received (layer 3) packets sizes in 1 byte intervals. Each
     bin represents a packet size in the interval [576..1500] bytes.
     """
 
     code: typing.ClassVar[int] = 718
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        bins: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # 925 x byte, '1' if any packets were received with the specified layer 3 size, otherwise '0'.
+    class GetDataAttr(ResponseBodyStruct):
+        bins: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """925 x byte, '1' if any packets were received with the specified layer 3 size, otherwise '0'."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get histogram over received (layer 3) packets sizes in 1 byte intervals.
 
         :return: histogram over received (layer 3) packets sizes in 1 byte intervals.
         :rtype: P4_RX_MTU.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_IPV4_RX_COUNTERS:
     """
     Return total Port IPv4 protocol receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 719
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of IPv4 packets received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of IPv4 packets received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port IPv4 protocol receive statistics since last clear.
 
         :return: total Port IPv4 protocol receive statistics since last clear.
         :rtype: P4_IPV4_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_IPV4_TX_COUNTERS:
     """
     Return total Port IPv4 protocol transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 720
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of IPv4 packets transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of IPv4 packets transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port IPv4 protocol transmit statistics since last clear.
 
         :return: total Port IPv4 protocol transmit statistics since last clear.
         :rtype: P4_IPV4_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_IPV4_COUNTERS:
     """
     Return total Port IPv4 protocol error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 721
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        checksum_error_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of IPv4 packets which ip header checksum error
-        invalid_packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of IPv4 packets which are malformed
-        unknown_packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of IPv4 packets with unknown protocol
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        checksum_error_count: int = field(XmpLong())
+        """long integer, total number of IPv4 packets which ip header checksum error"""
+        invalid_packet_count: int = field(XmpLong())
+        """long integer, total number of IPv4 packets which are malformed"""
+        unknown_packet_count: int = field(XmpLong())
+        """long integer, total number of IPv4 packets with unknown protocol"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port IPv4 protocol error statistics since last clear.
 
         :return: total Port IPv4 protocol error statistics since last clear.
         :rtype: P4_IPV4_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_IPV6_RX_COUNTERS:
     """
     Return total Port IPv6 protocol receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 722
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of IPv6 packets received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of IPv6 packets received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port IPv6 protocol receive statistics since last clear.
 
         :return: total Port IPv6 protocol receive statistics since last clear.
         :rtype: P4_IPV6_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_IPV6_TX_COUNTERS:
     """
     Return total Port IPv6 protocol transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 723
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of IPv6 packets transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of IPv6 packets transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port IPv6 protocol transmit statistics since last clear.
 
         :return: total Port IPv6 protocol transmit statistics since last clear.
         :rtype: P4_IPV6_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_IPV6_COUNTERS:
     """
     Return total Port IPv6 protocol error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 724
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        invalid_packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ipv6 packets which are malformed
-        unknown_packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ipv6 packets with unknown protocol
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        invalid_packet_count: int = field(XmpLong())
+        """long integer, total number of ipv6 packets which are malformed"""
+        unknown_packet_count: int = field(XmpLong())
+        """long integer, total number of ipv6 packets with unknown protocol"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port IPv6 protocol error statistics since last clear.
 
         :return: total Port IPv6 protocol error statistics since last clear.
         :rtype: P4_IPV6_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ARP_RX_COUNTERS:
     """
     Return total Port ARP protocol receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 725
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        arp_request_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number ARP Requests received
-        arp_reply_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number ARP Replies received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        arp_request_count: int = field(XmpLong())
+        """long integer, total number ARP Requests received"""
+        arp_reply_count: int = field(XmpLong())
+        """long integer, total number ARP Replies received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port ARP protocol receive statistics since last clear.
 
         :return: total Port ARP protocol receive statistics since last clear.
         :rtype: P4_ARP_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ARP_TX_COUNTERS:
     """
     Return total Port ARP protocol transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 726
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        arp_request_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number ARP Requests transmitted
-        arp_reply_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number ARP Replies transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        arp_request_count: int = field(XmpLong())
+        """long integer, total number ARP Requests transmitted"""
+        arp_reply_count: int = field(XmpLong())
+        """long integer, total number ARP Replies transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port ARP protocol transmit statistics since last clear.
 
         :return: total Port ARP protocol transmit statistics since last clear.
         :rtype: P4_ARP_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ARP_COUNTERS:
     """
     Return total Port ARP protocol error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 727
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        invalid_arp_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of invalid ARP packets received
-        arp_request_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of ARP requests received that could not be resolved
-        arp_reply_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of ARP replies received that could not be resolved
-        arp_request_retrans_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of retransmitted ARP requests
-        arp_resolved_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of correct resolved IP addresses
-        arp_failed_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of IP address that was not resolved
-        arp_table_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of dest IP addresses not found in the ARP table
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        invalid_arp_count: int = field(XmpLong())
+        """long integer, total number of invalid ARP packets received"""
+        arp_request_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of ARP requests received that could not be resolved"""
+        arp_reply_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of ARP replies received that could not be resolved"""
+        arp_request_retrans_count: int = field(XmpLong())
+        """long integer, number of retransmitted ARP requests"""
+        arp_resolved_count: int = field(XmpLong())
+        """long integer, number of correct resolved IP addresses"""
+        arp_failed_count: int = field(XmpLong())
+        """long integer, number of IP address that was not resolved"""
+        arp_table_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of dest IP addresses not found in the ARP table"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port ARP protocol error statistics since last clear.
 
         :return: total Port ARP protocol error statistics since last clear.
         :rtype: P4_ARP_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_NDP_RX_COUNTERS:
     """
     Return total Port NDP protocol receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 728
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        ndp_request_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number NDP Requests received
-        ndp_reply_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number NDP Replies received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        ndp_request_count: int = field(XmpLong())
+        """long integer, total number NDP Requests received"""
+        ndp_reply_count: int = field(XmpLong())
+        """long integer, total number NDP Replies received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port NDP protocol receive statistics since last clear.
 
         :return: total Port NDP protocol receive statistics since last clear.
         :rtype: P4_NDP_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_NDP_TX_COUNTERS:
     """
     Return total Port NDP protocol transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 729
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        ndp_request_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number NDP Requests transmitted
-        ndp_reply_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number NDP Replies transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        ndp_request_count: int = field(XmpLong())
+        """long integer, total number NDP Requests transmitted"""
+        ndp_reply_count: int = field(XmpLong())
+        """long integer, total number NDP Replies transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port NDP protocol transmit statistics since last clear.
 
         :return: total Port NDP protocol transmit statistics since last clear.
         :rtype: P4_NDP_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_NDP_COUNTERS:
     """
     Return total Port NDP protocol error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 730
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        invalid_ndp_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of invalid NDP packets received
-        ndp_request_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of NDP requests received that could not be resolved
-        ndp_reply_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of NDP replies received that could not be resolved
-        ndp_request_retrans_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of retransmitted NDP requests
-        ndp_resolved_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of correct resolved IP addresses
-        ndp_failed_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of IP address that was not resolved
-        ndp_table_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of dest IP addresses not found in the NDP table
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        invalid_ndp_count: int = field(XmpLong())
+        """long integer, total number of invalid NDP packets received"""
+        ndp_request_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of NDP requests received that could not be resolved"""
+        ndp_reply_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of NDP replies received that could not be resolved"""
+        ndp_request_retrans_count: int = field(XmpLong())
+        """long integer, number of retransmitted NDP requests"""
+        ndp_resolved_count: int = field(XmpLong())
+        """long integer, number of correct resolved IP addresses"""
+        ndp_failed_count: int = field(XmpLong())
+        """long integer, number of IP address that was not resolved"""
+        ndp_table_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of dest IP addresses not found in the NDP table"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port NDP protocol error statistics since last clear.
 
         :return: total Port NDP protocol error statistics since last clear.
         :rtype: P4_NDP_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ICMP_RX_COUNTERS:
     """
     Return total Port ICMP protocol receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 731
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        icmp_echo_request_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Echo requests received
-        icmp_echo_reply_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Echo replies received
-        icmp_dest_unknown_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Destination unknown received
-        icmp_time_excessive_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Time exceeded received
-        icmpv6_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMPv6 packets received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        icmp_echo_request_count: int = field(XmpLong())
+        """long integer, total number of ICMP Echo requests received"""
+        icmp_echo_reply_count: int = field(XmpLong())
+        """long integer, total number of ICMP Echo replies received"""
+        icmp_dest_unknown_count: int = field(XmpLong())
+        """long integer, total number of ICMP Destination unknown received"""
+        icmp_time_excessive_count: int = field(XmpLong())
+        """long integer, total number of ICMP Time exceeded received"""
+        icmpv6_count: int = field(XmpLong())
+        """long integer, total number of ICMPv6 packets received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port ICMP protocol receive statistics since last clear.
 
         :return: total Port ICMP protocol receive statistics since last clear.
         :rtype: P4_ICMP_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ICMP_TX_COUNTERS:
     """
     Return total Port ICMP protocol transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 732
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        icmp_echo_request_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Echo requests transmitted
-        icmp_echo_reply_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Echo replies transmitted
-        icmp_dest_unknown_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Destination unknown transmitted
-        icmp_time_excessive_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMP Time exceeded transmitted
-        icmpv6_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of ICMPv6 packets transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        icmp_echo_request_count: int = field(XmpLong())
+        """long integer, total number of ICMP Echo requests transmitted"""
+        icmp_echo_reply_count: int = field(XmpLong())
+        """long integer, total number of ICMP Echo replies transmitted"""
+        icmp_dest_unknown_count: int = field(XmpLong())
+        """long integer, total number of ICMP Destination unknown transmitted"""
+        icmp_time_excessive_count: int = field(XmpLong())
+        """long integer, total number of ICMP Time exceeded transmitted"""
+        icmpv6_count: int = field(XmpLong())
+        """long integer, total number of ICMPv6 packets transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port ICMP protocol transmit statistics since last clear.
 
         :return: total Port ICMP protocol transmit statistics since last clear.
         :rtype: P4_ICMP_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ICMP_COUNTERS:
     """
     Return total Port ICMP protocol error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 733
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        invalid_icmp_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of unknown or invalid ICMP packets received
-        unknown_icmp_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of unknown or unsupported ICMP packets received
-        invalid_icmpv6_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of unknown or invalid ICMPv6 packets received
-        unknown_icmpv6_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of unknown or unsupported ICMPv6 packets received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        invalid_icmp_count: int = field(XmpLong())
+        """long integer, total number of unknown or invalid ICMP packets received"""
+        unknown_icmp_count: int = field(XmpLong())
+        """long integer, total number of unknown or unsupported ICMP packets received"""
+        invalid_icmpv6_count: int = field(XmpLong())
+        """long integer, total number of unknown or invalid ICMPv6 packets received"""
+        unknown_icmpv6_count: int = field(XmpLong())
+        """long integer, total number of unknown or unsupported ICMPv6 packets received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port ICMP protocol error statistics since last clear.
 
         :return: total Port ICMP protocol error statistics since last clear.
         :rtype: P4_ICMP_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_TCP_RX_COUNTERS:
     """
     Return total Port TCP protocol receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 734
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of TCP packets received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of TCP packets received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port TCP protocol receive statistics since last clear.
 
         :return: total Port TCP protocol receive statistics since last clear.
         :rtype: P4_TCP_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_TCP_TX_COUNTERS:
     """
     Return total Port TCP protocol transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 735
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of TCP packets transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of TCP packets transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port TCP protocol transmit statistics since last clear.
 
         :return: total Port TCP protocol transmit statistics since last clear.
         :rtype: P4_TCP_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_TCP_COUNTERS:
     """
     Return total Port TCP protocol error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 736
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        checksum_error_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of tcp packets which tcp header checksum error
-        invalid_tcp_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of TCP packets which are malformed
-        tcp_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP packets received that could not be resolved
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        checksum_error_count: int = field(XmpLong())
+        """long integer, total number of tcp packets which tcp header checksum error"""
+        invalid_tcp_count: int = field(XmpLong())
+        """long integer, total number of TCP packets which are malformed"""
+        tcp_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of TCP packets received that could not be resolved"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port TCP protocol error statistics since last clear.
 
         :return: total Port TCP protocol error statistics since last clear.
         :rtype: P4_TCP_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_UDP_RX_COUNTERS:
     """
     Return total Port UDP protocol receive statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 737
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of UDP packets received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of UDP packets received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port UDP protocol receive statistics since last clear.
 
         :return: total Port UDP protocol receive statistics since last clear.
         :rtype: P4_UDP_RX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_UDP_TX_COUNTERS:
     """
     Return total Port UDP protocol transmit statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 738
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of UDP packets transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, total number of UDP packets transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port UDP protocol transmit statistics since last clear.
 
         :return: total Port UDP protocol transmit statistics since last clear.
         :rtype: P4_UDP_TX_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_UDP_COUNTERS:
     """
     Return total Port UDP protocol error statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 739
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        checksum_error_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of udp packets which udp header checksum error
-        invalid_udp_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of UDP packets which are malformed
-        udp_lookup_failure_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP packets received that could not be resolved
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        checksum_error_count: int = field(XmpLong())
+        """long integer, total number of udp packets which udp header checksum error"""
+        invalid_udp_count: int = field(XmpLong())
+        """long integer, total number of UDP packets which are malformed"""
+        udp_lookup_failure_count: int = field(XmpLong())
+        """long integer, number of UDP packets received that could not be resolved"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total Port UDP protocol error statistics since last clear.
 
         :return: total Port UDP protocol error statistics since last clear.
         :rtype: P4_UDP_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_CLEAR_COUNTERS:
     """
     Clears all run-time port counters.
     """
 
     code: typing.ClassVar[int] = 740
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Clears all run-time port counters.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_ETH_COUNTERS:
     """
     Return total port Ethernet statistics since last clear.
     """
 
     code: typing.ClassVar[int] = 765
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        tx_error_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, TX errors
-        rx_error_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, RX errors
-        rx_packet_lost_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, packets lost by the Ethernet driver due to RX queue overflow
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        tx_error_count: int = field(XmpLong())
+        """long integer, TX errors"""
+        rx_error_count: int = field(XmpLong())
+        """long integer, RX errors"""
+        rx_packet_lost_count: int = field(XmpLong())
+        """long integer, packets lost by the Ethernet driver due to RX queue overflow"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get total port Ethernet statistics since last clear.
 
         :return: total port Ethernet statistics since last clear.
         :rtype: P4_ETH_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_CLEAR:
     """
     Set the Port State to OFF and delete all configured Connection Groups for the port.
     """
 
     code: typing.ClassVar[int] = 766
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Set the Port State to OFF and delete all configured Connection Groups for the port.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_SPEEDSELECTION:
     """
     Sets the port speed. The selected speed must be one of the speeds supported by
     the port, which can be retrieved with P4_CAPABILITIES.
     """
 
     code: typing.ClassVar[int] = 767
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        speed: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47PortSpeed)  # coded byte, specifies the speed of the port
+    class GetDataAttr(ResponseBodyStruct):
+        speed: L47PortSpeed = field(XmpByte())
+        """coded byte, specifies the speed of the port"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        speed: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47PortSpeed)  # coded byte, specifies the speed of the port
+    class SetDataAttr(RequestBodyStruct):
+        speed: L47PortSpeed = field(XmpByte())
+        """coded byte, specifies the speed of the port"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port speed mode.
 
         :return: the port speed mode.
         :rtype: P4_SPEEDSELECTION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, speed: L47PortSpeed) -> "Token":
+    def set(self, speed: L47PortSpeed) -> Token[None]:
         """Set the port speed mode.
 
         :param speed: specifies the speed mode of the port
         :type speed: L47PortSpeed
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, speed=speed))
 
     set_auto = functools.partialmethod(set, L47PortSpeed.AUTO)
     """Set the port speed mode to Auto."""
+
     set_f100m = functools.partialmethod(set, L47PortSpeed.F100M)
     """Set the port speed mode to 100 Mbit/s."""
+
     set_f1g = functools.partialmethod(set, L47PortSpeed.F1G)
     """Set the port speed mode to 1 Gbit/s."""
+
     set_f2_5g = functools.partialmethod(set, L47PortSpeed.F2_5G)
     """Set the port speed mode to 2.5 Gbit/s."""
+
     set_f5g = functools.partialmethod(set, L47PortSpeed.F5G)
     """Set the port speed mode to 5 Gbit/s."""
+
     set_f10g = functools.partialmethod(set, L47PortSpeed.F10G)
     """Set the port speed mode to 10 Gbit/s."""
+
     set_f25g = functools.partialmethod(set, L47PortSpeed.F25G)
     """Set the port speed mode to 25 Gbit/s."""
+
     set_f40g = functools.partialmethod(set, L47PortSpeed.F40G)
     """Set the port speed mode to 40 Gbit/s."""
+
     set_f50g = functools.partialmethod(set, L47PortSpeed.F50G)
     """Set the port speed mode to 50 Gbit/s."""
+
     set_f100g = functools.partialmethod(set, L47PortSpeed.F100G)
     """Set the port speed mode to 100 Gbit/s."""
 
 
 @register_command
 @dataclass
 class P4_MAX_PACKET_RATE:
     """
     Specifies the maximum number of packets per second allowed to be transmitted on the port.
     """
 
     code: typing.ClassVar[int] = 950
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=AutoOrManual)  # coded byte, specifies the mode of the max. pps mechanism
-        rate: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum number of packets per second to transmit on this port
-        time_window: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, time window [us] to measure the pps rate
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=AutoOrManual)  # coded byte, specifies the mode of the max. pps mechanism
-        rate: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum number of packets per second to transmit on this port
-        time_window: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, time window [us] to measure the pps rate
+    class GetDataAttr(ResponseBodyStruct):
+        mode: AutoOrManual = field(XmpByte())
+        """coded byte, specifies the mode of the max. pps mechanism"""
+        rate: int = field(XmpInt())
+        """integer, maximum number of packets per second to transmit on this port"""
+        time_window: int = field(XmpInt())
+        """integer, time window [us] to measure the pps rate"""
+
+    class SetDataAttr(RequestBodyStruct):
+        mode: AutoOrManual = field(XmpByte())
+        """coded byte, specifies the mode of the max. pps mechanism"""
+        rate: int = field(XmpInt())
+        """integer, maximum number of packets per second to transmit on this port"""
+        time_window: int = field(XmpInt())
+        """integer, time window [us] to measure the pps rate"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the maximum number of packets per second allowed to be transmitted on the port.
 
         :return: the maximum number of packets per second allowed to be transmitted on the port.
         :rtype: P4_MAX_PACKET_RATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: AutoOrManual, rate: int, time_window: int) -> "Token":
+    def set(self, mode: AutoOrManual, rate: int, time_window: int) -> Token[None]:
         """Set the maximum number of packets per second allowed to be transmitted on the port.
 
         :param mode: specifies the mode of the max. pps mechanism
         :type mode: AutoOrManual
         :param rate: maximum number of packets per second to transmit on this port
         :type rate: int
         :param time_window: time window [us] to measure the pps rate
         :type time_window: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode, rate=rate, time_window=time_window))
 
     set_automatic = functools.partialmethod(set, AutoOrManual.AUTOMATIC)
     """Set port max packet rate mode to Automatic."""
+
     set_manual = functools.partialmethod(set, AutoOrManual.MANUAL)
     """Set port max packet rate mode to Manual."""
 
 
 @register_command
 @dataclass
 class P4_PCI_INFO:
     """
     Report the port PCI info.
     """
 
     code: typing.ClassVar[int] = 960
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        vendor_id: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, PCI Vendor ID
-        device_id: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, PCI Device ID
-        sub_vendor_id: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, PCI Subsystem Vendor ID
-        sub_device_id: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, PCI Subsystem Device ID
-        rev: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, Revision
+    class GetDataAttr(ResponseBodyStruct):
+        vendor_id: Hex = field(XmpHex(size=4))
+        """four hex bytes, PCI Vendor ID"""
+        device_id: Hex = field(XmpHex(size=4))
+        """four hex bytes, PCI Device ID"""
+        sub_vendor_id: Hex = field(XmpHex(size=4))
+        """four hex bytes, PCI Subsystem Vendor ID"""
+        sub_device_id: Hex = field(XmpHex(size=4))
+        """four hex bytes, PCI Subsystem Device ID"""
+        rev: int = field(XmpInt())
+        """integer, Revision"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port PCI info.
 
         :return: the port PCI info
         :rtype: P4_PCI_INFO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_FW_VER:
     """
     Report the firmware version of the port (NIC).
     """
 
     code: typing.ClassVar[int] = 961
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        major: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, Major firmware version
-        minor: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, Minor firmware version
+    class GetDataAttr(ResponseBodyStruct):
+        major: int = field(XmpInt())
+        """integer, Major firmware version"""
+        minor: int = field(XmpInt())
+        """integer, Minor firmware version"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the firmware version of the port (NIC).
 
         :return: the firmware version of the port (NIC)
         :rtype: P4_FW_VER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_DEV_NAME:
     """
     Report the name of the device (NIC) on which the port is located.
     """
 
     code: typing.ClassVar[int] = 962
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, name of the device (NIC) on which the port is located
+    class GetDataAttr(ResponseBodyStruct):
+        name: str = field(XmpStr())
+        """string, name of the device (NIC) on which the port is located"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the name of the device (NIC) on which the port is located.
 
         :return: the name of the device (NIC) on which the port is located.
         :rtype: P4_DEV_NAME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_PORT_TYPE:
     """
     Report the port type. The different possible ports are divided into types.
     """
 
     code: typing.ClassVar[int] = 963
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        type_number: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, enumerated port type
-        type_string: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, textual representation of the port type
+    class GetDataAttr(ResponseBodyStruct):
+        type_number: int = field(XmpInt())
+        """integer, enumerated port type"""
+        type_string: str = field(XmpStr())
+        """string, textual representation of the port type"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the L47 port type.
 
         :return: the L47 port type
         :rtype: P4_PORT_TYPE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_LICENSE_INFO:
     """
     Returns the information on the license assigned to the port - if any.
     """
 
     code: typing.ClassVar[int] = 964
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        present: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsPresent)  # coded byte, specifies if a license is assigned to the port
-        speed: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LicenseSpeed)  # coded byte, if a license is assigned to the port, specifies the speed of the license
-        permanency: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsPermanent)  # coded byte, if a license is assigned to the port, specifies if the license is permanent
-        expiration: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, if a license is assigned to the port and it is not permanent, specifies the expiration date of the license - in seconds since Jan 1, 1970.
+    class GetDataAttr(ResponseBodyStruct):
+        present: IsPresent = field(XmpByte())
+        """coded byte, specifies if a license is assigned to the port"""
+        speed: LicenseSpeed = field(XmpByte())
+        """coded byte, if a license is assigned to the port, specifies the speed of the license"""
+        permanency: IsPermanent = field(XmpByte())
+        """coded byte, if a license is assigned to the port, specifies if the license is permanent"""
+        expiration: int = field(XmpLong())
+        """long integer, if a license is assigned to the port and it is not permanent, specifies the expiration date of the license - in seconds since Jan 1, 1970."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the information on the license assigned to the port.
 
         :return: the information on the license assigned to the port
         :rtype: P4_LICENSE_INFO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P4_APTITUDES:
     """
@@ -1744,22 +1991,23 @@
             }
         }
     """
 
     code: typing.ClassVar[int] = 1200
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        bson: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList)  # list of hex bytes, bson document containing the ports aptitudes
+    class GetDataAttr(ResponseBodyStruct):
+        bson: typing.List[int] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of hex bytes, bson document containing the ports aptitudes"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the ports aptitudes
 
         :return: the ports aptitudes in BSON format
         :rtype: P4_APTITUDES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/p4g_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/p4g_commands.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,481 +1,521 @@
-#: L47 Port Connection Group Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import ipaddress
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpIPv4Address,
+    XmpIPv6Address,
+    XmpLong,
+    XmpMacAddress,
+    XmpSequence,
+    XmpStr,
+    Hex,
+)
+from .enums import (
+    OnOff,
+    YesNo,
+    OnOffWithSuppress,
+    Role,
+    Timescale,
+    MSSType,
+    RTOType,
+    CongestionType,
+    IsEnabled,
+    AlgorithmMethod,
+    AutoOrManual,
+    EmbedIP,
+    ApplicationLayerBehavior,
+    TrafficScenario,
+    PayloadGenerationMethod,
+    InfiniteOrFinite,
+    WhoClose,
+    LifecycleMode,
+    L47IPVersion,
+    L47ProtocolType,
+    TLSVersion,
+)
 
 
 @register_command
 @dataclass
 class P4G_INDICES:
     """
     The full list of Connection Groups on this port. These are the sub-index that
     are used for the parameters that specify TCP connection behavior.
     """
 
     code: typing.ClassVar[int] = 600
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        group_identifiers: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, list of indices identifying Connection Groups.
+    class GetDataAttr(ResponseBodyStruct):
+        group_identifiers: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, list of indices identifying Connection Groups."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        group_identifiers: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, list of indices identifying Connection Groups.
+    class SetDataAttr(RequestBodyStruct):
+        group_identifiers: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, list of indices identifying Connection Groups."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get full list of Connection Groups on this port.
 
         :return: full list of Connection Groups on this port.
         :rtype: P4G_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, group_identifiers: typing.List[int]) -> "Token":
+    def set(self, group_identifiers: typing.List[int]) -> Token[None]:
         """Create Connection Groups with the indices on the port.
 
         :param group_identifiers: list of indices identifying Connection Groups.
         :type group_identifiers: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, group_identifiers=group_identifiers))
 
 
 @register_command
 @dataclass
 class P4G_CREATE:
     """
     Creates an empty Connection Group with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 601
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Creates an empty Connection Group with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._group_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_DELETE:
     """
     Deletes a Connection Group with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 602
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Deletes a Connection Group with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._group_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_ENABLE:
     """
     Enable/disable/suppress a previously created Connection Group with the specified
     sub-index value.
     """
 
     code: typing.ClassVar[int] = 603
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOffWithSuppress)  # coded byte, specifies the state of the Connection Group.
+    class GetDataAttr(ResponseBodyStruct):
+        status: OnOffWithSuppress = field(XmpByte())
+        """coded byte, specifies the state of the Connection Group."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOffWithSuppress)  # coded byte, specifies the state of the Connection Group.
+    class SetDataAttr(RequestBodyStruct):
+        status: OnOffWithSuppress = field(XmpByte())
+        """coded byte, specifies the state of the Connection Group."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the state of a Connection Group on a port.
 
         :return: the state of a Connection Group on a port.
         :rtype: P4G_ENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, status: OnOffWithSuppress) -> "Token":
+    def set(self, status: OnOffWithSuppress) -> Token[None]:
         """ Enable/disable/suppress a previously created Connection Group with the specified sub-index value.
 
         :param status: specifies the state of the Connection Group.
         :type status: OnOffWithSuppress
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], status=status))
 
     set_off = functools.partialmethod(set, OnOffWithSuppress.OFF)
     """Disable a Connection Group of with the specified index."""
+
     set_on = functools.partialmethod(set, OnOffWithSuppress.ON)
     """Enable a Connection Group of with the specified index."""
+
     set_suppress = functools.partialmethod(set, OnOffWithSuppress.SUPPRESS)
     """Suppress a Connection Group of with the specified index."""
 
 
 @register_command
 @dataclass
 class P4G_COMMENT:
     """
     The description of a Connection Group.
     """
 
     code: typing.ClassVar[int] = 604
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the description of the Connection Group.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the description of the Connection Group."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the description of the Connection Group.
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the description of the Connection Group."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the description of a Connection Group.
 
         :return: the description of a Connection Group.
         :rtype: P4G_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the description of a Connection Group.
 
         :param comment: the description of a Connection Group.
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], comment=comment))
 
 
 @register_command
 @dataclass
 class P4G_CLEAR_COUNTERS:
     """
     Clears all run-time statistics for the Connection Group.
     """
 
     code: typing.ClassVar[int] = 605
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Clears all run-time statistics for the Connection Group.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._group_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_ROLE:
     """
     Specifies the client or server role for this Connection Group. A server
     passively waits for the clients to establish connections.
     """
 
     code: typing.ClassVar[int] = 606
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        role: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=Role)  # coded byte, specifies the role of the Connection Group.
+    class GetDataAttr(ResponseBodyStruct):
+        role: Role = field(XmpByte())
+        """coded byte, specifies the role of the Connection Group."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        role: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=Role)  # coded byte, specifies the role of the Connection Group.
+    class SetDataAttr(RequestBodyStruct):
+        role: Role = field(XmpByte())
+        """coded byte, specifies the role of the Connection Group."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the role of the Connection Group.
 
         :return: the role of the Connection Group.
         :rtype: P4G_ROLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, role: Role) -> "Token":
+    def set(self, role: Role) -> Token[None]:
         """Set the role of the Connection Group.
 
         :param role: the role of the Connection Group.
         :type role: Role
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], role=role))
 
     set_client = functools.partialmethod(set, Role.CLIENT)
     """Set the role of the Connection Group to Client."""
+
     set_server = functools.partialmethod(set, Role.SERVER)
     """Set the role of the Connection Group to Server."""
 
 
 @register_command
 @dataclass
 class P4G_CLIENT_RANGE:
     """
     Specifies a number of client sockets (ip address, port number)
     """
 
     code: typing.ClassVar[int] = 607
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
-        max_address_count: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
-        max_address_count: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
+        max_address_count: int = field(XmpInt())
+        """integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE"""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
+        max_address_count: int = field(XmpInt())
+        """integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of client sockets (ip address, port number)
 
         :return: the number of client sockets (ip address, port number)
         :rtype: P4G_CLIENT_RANGE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ipv4_address: typing.Union[str, int, ipaddress.IPv4Address], address_count: int, start_port: int, port_count: int, max_address_count: int) -> "Token":
+    def set(self, ipv4_address: ipaddress.IPv4Address, address_count: int, start_port: int, port_count: int, max_address_count: int) -> Token[None]:
         """Set the number of client sockets (ip address, port number)
 
         :param ipv4_address: the start IP address of the address range
-        :type ipv4_address: typing.Union[str, int, ipaddress.IPv4Address]
+        :type ipv4_address: ipaddress.IPv4Address
         :param address_count: the number of IP addresses
         :type address_count: int
         :param start_port: the starting port number of the port range
         :type start_port: int
         :param port_count: the number of ports
         :type port_count: int
         :param max_address_count: the maximum number of IP addresses that this Connection Group will use, when connection incarnation is set to ``REINCARNATE``
         :type max_address_count: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._group_xindex],
                 ipv4_address=ipv4_address,
                 address_count=address_count,
                 start_port=start_port,
                 port_count=port_count,
-                max_address_count=max_address_count,
-            ),
+                max_address_count=max_address_count
+            )
         )
 
 
 @register_command
 @dataclass
 class P4G_SERVER_RANGE:
     """
     Specifies a number of server sockets (ip address, port number)
     """
 
     code: typing.ClassVar[int] = 608
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of server sockets (ip address, port number)
 
         :return: the number of server sockets (ip address, port number)
         :rtype: P4G_SERVER_RANGE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ipv4_address: typing.Union[str, int, ipaddress.IPv4Address], address_count: int, start_port: int, port_count: int) -> "Token":
+    def set(self, ipv4_address: ipaddress.IPv4Address, address_count: int, start_port: int, port_count: int) -> Token[None]:
         """Set the number of server sockets (ip address, port number)
 
         :param ipv4_address: the start IP address of the address range
-        :type ipv4_address: typing.Union[str, int, ipaddress.IPv4Address]
+        :type ipv4_address: ipaddress.IPv4Address
         :param address_count: the number of IP addresses
         :type address_count: int
         :param start_port: the starting port number of the port range
         :type start_port: int
         :param port_count: the number of ports
         :type port_count: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._group_xindex],
                 ipv4_address=ipv4_address,
                 address_count=address_count,
                 start_port=start_port,
-                port_count=port_count,
-            ),
+                port_count=port_count
+            )
         )
 
 
 @register_command
 @dataclass
 class P4G_LP_TIME_SCALE:
     """
     Specifies the time scale of the load profile.
     """
 
     code: typing.ClassVar[int] = 609
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        timescale: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=Timescale)  # coded byte, specifying the time scale.
+    class GetDataAttr(ResponseBodyStruct):
+        timescale: Timescale = field(XmpByte())
+        """coded byte, specifying the time scale."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        timescale: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=Timescale)  # coded byte, specifying the time scale.
+    class SetDataAttr(RequestBodyStruct):
+        timescale: Timescale = field(XmpByte())
+        """coded byte, specifying the time scale."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the time scale of the load profile.
 
         :return: the time scale of the load profile.
         :rtype: P4G_LP_TIME_SCALE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, timescale: Timescale) -> "Token":
+    def set(self, timescale: Timescale) -> Token[None]:
         """Set the time scale of the load profile.
 
         :param timescale: specifying the time scale.
         :type timescale: Timescale
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], timescale=timescale))
 
     set_msecs = functools.partialmethod(set, Timescale.MSECS)
     """Set the time scale of the load profile to Milliseconds."""
+
     set_seconds = functools.partialmethod(set, Timescale.SECONDS)
     """Set the time scale of the load profile to Seconds."""
+
     set_minutes = functools.partialmethod(set, Timescale.MINUTES)
     """Set the time scale of the load profile to Minutes."""
+
     set_hours = functools.partialmethod(set, Timescale.HOURS)
     """Set the time scale of the load profile to Hours."""
 
 
 @register_command
 @dataclass
 class P4G_LP_SHAPE:
@@ -483,109 +523,120 @@
     Specifies a load profile time duration. Time is measured from the beginning of
     the test when ``P€G_TRAFFIC`` is set to ``ON``.
     """
 
     code: typing.ClassVar[int] = 610
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        star_time: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ramp-up start time.
-        rampup_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ramp-up phase duration.
-        steady_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, steady phase duration.
-        rampdown_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ramp-down phase duration.
+    class GetDataAttr(ResponseBodyStruct):
+        star_time: int = field(XmpInt())
+        """integer, ramp-up start time."""
+        rampup_duration: int = field(XmpInt())
+        """integer, ramp-up phase duration."""
+        steady_duration: int = field(XmpInt())
+        """integer, steady phase duration."""
+        rampdown_duration: int = field(XmpInt())
+        """integer, ramp-down phase duration."""
+
+    class SetDataAttr(RequestBodyStruct):
+        star_time: int = field(XmpInt())
+        """integer, ramp-up start time."""
+        rampup_duration: int = field(XmpInt())
+        """integer, ramp-up phase duration."""
+        steady_duration: int = field(XmpInt())
+        """integer, steady phase duration."""
+        rampdown_duration: int = field(XmpInt())
+        """integer, ramp-down phase duration."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        star_time: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ramp-up start time.
-        rampup_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ramp-up phase duration.
-        steady_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, steady phase duration.
-        rampdown_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, ramp-down phase duration.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the load profile time duration.
 
         :return: the load profile time duration
         :rtype: P4G_LP_SHAPE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, star_time: int, rampup_duration: int, steady_duration: int, rampdown_duration: int) -> "Token":
+    def set(self, star_time: int, rampup_duration: int, steady_duration: int, rampdown_duration: int) -> Token[None]:
         """Set the load profile time duration.
 
         :param star_time: ramp-up start time
         :type star_time: int
         :param rampup_duration: ramp-up phase duration
         :type rampup_duration: int
         :param steady_duration: steady phase duration
         :type steady_duration: int
         :param rampdown_duration: ramp-down phase duration
         :type rampdown_duration: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._group_xindex],
                 star_time=star_time,
                 rampup_duration=rampup_duration,
                 steady_duration=steady_duration,
-                rampdown_duration=rampdown_duration,
-            ),
+                rampdown_duration=rampdown_duration
+            )
         )
 
 
 @register_command
 @dataclass
 class P4G_NAT:
     """
     Specify whether to support DUT Source NAT functionality. NAT should be enabled on both Client and Server ports that belong to the same Connection Group.
     """
 
     code: typing.ClassVar[int] = 611
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether to enable NAT
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, specifying whether to enable NAT"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether to enable NAT
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, specifying whether to enable NAT"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether to support DUT Source NAT functionality.
 
         :return: whether to support DUT Source NAT functionality.
         :rtype: P4G_NAT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether to support DUT Source NAT functionality.
 
         :param on_off: specifying whether to enable Source NAT support
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable source NAT support."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable source NAT support."""
 
 
 @register_command
 @dataclass
 class P4G_TCP_RTT_VALUE:
@@ -593,34 +644,40 @@
     Returns values that can be used to calculate the RTT value of all connections in
     a Connection Group.
     """
 
     code: typing.ClassVar[int] = 612
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        local_rtt_sum: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, accumulated RTT value (microsecond) in previous 200 milliseconds
-        local_rtt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of RTT value accumulated in local_rtt_sum
-        global_rtt_sum: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, accumulated RTT value (microsecond) since start of test
-        global_rtt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of RTT values accumulated in global_rtt_sum
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        local_rtt_sum: int = field(XmpLong())
+        """long integer, accumulated RTT value (microsecond) in previous 200 milliseconds"""
+        local_rtt_count: int = field(XmpLong())
+        """long integer, number of RTT value accumulated in local_rtt_sum"""
+        global_rtt_sum: int = field(XmpLong())
+        """long integer, accumulated RTT value (microsecond) since start of test"""
+        global_rtt_count: int = field(XmpLong())
+        """long integer, number of RTT values accumulated in global_rtt_sum"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get values that can be used to calculate the RTT value of all connections in a Connection Group.
 
         :return: values that can be used to calculate the RTT value of all connections in a Connection Group.
         :rtype: P4G_TCP_RTT_VALUE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_STATE_CURRENT:
     """
@@ -640,41 +697,54 @@
     * TIME_WAIT
 
     """
 
     code: typing.ClassVar[int] = 613
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        closed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        listen: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        syn_sent: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        syn_rcvd: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        established: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        fin_wait_1: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        fin_wait_2: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        close_wait: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        closing: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        last_ack: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        time_wait: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        closed: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        listen: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        syn_sent: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        syn_rcvd: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        established: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        fin_wait_1: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        fin_wait_2: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        close_wait: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        closing: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        last_ack: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        time_wait: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the current TCP state counters
 
         :return: a list of the current TCP state counters
         :rtype: P4G_TCP_STATE_CURRENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_STATE_TOTAL:
     """
@@ -694,41 +764,54 @@
     * TIME_WAIT
 
     """
 
     code: typing.ClassVar[int] = 614
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        closed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        listen: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        syn_sent: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        syn_rcvd: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        established: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        fin_wait_1: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        fin_wait_2: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        close_wait: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        closing: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        last_ack: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        time_wait: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        closed: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        listen: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        syn_sent: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        syn_rcvd: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        established: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        fin_wait_1: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        fin_wait_2: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        close_wait: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        closing: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        last_ack: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        time_wait: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the total TCP state counters.
 
         :return: a list of the total TCP state counters
         :rtype: P4G_TCP_STATE_TOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_STATE_RATE:
     """
@@ -748,268 +831,319 @@
     * TIME_WAIT
 
     """
 
     code: typing.ClassVar[int] = 615
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        closed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        listen: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        syn_sent: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        syn_rcvd: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        established: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        fin_wait_1: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        fin_wait_2: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        close_wait: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        closing: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        last_ack: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        time_wait: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        closed: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        listen: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        syn_sent: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        syn_rcvd: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        established: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        fin_wait_1: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        fin_wait_2: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        close_wait: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        closing: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        last_ack: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        time_wait: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TCP state rates measured in connections/second.
 
         :return: a list of the TCP state rates measured in connections/second
         :rtype: P4G_TCP_STATE_RATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_RX_PAYLOAD_COUNTERS:
     """
     Returns a list of the TCP Rx payload counters.
     """
 
     code: typing.ClassVar[int] = 616
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        total_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of total TCP payload bytes received
-        total_byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of total TCP payload bytes/second received
-        good_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of good TCP payload bytes received
-        good_byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of good TCP payload bytes/second received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        total_byte_count: int = field(XmpLong())
+        """long integer, number of total TCP payload bytes received"""
+        total_byte_per_second: int = field(XmpLong())
+        """long integer, number of total TCP payload bytes/second received"""
+        good_byte_count: int = field(XmpLong())
+        """long integer, number of good TCP payload bytes received"""
+        good_byte_per_second: int = field(XmpLong())
+        """long integer, number of good TCP payload bytes/second received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TCP Rx payload counters.
 
         :return: a list of the TCP Rx payload counters.
         :rtype: P4G_TCP_RX_PAYLOAD_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_TX_PAYLOAD_COUNTERS:
     """
     Returns a list of the TCP Tx payload counters.
     """
 
     code: typing.ClassVar[int] = 617
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        total_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of total TCP payload bytes transmitted
-        total_byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of total TCP payload bytes/second transmitted
-        good_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of good TCP payload bytes transmitted
-        good_byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of good TCP payload bytes/second transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        total_byte_count: int = field(XmpLong())
+        """long integer, number of total TCP payload bytes transmitted"""
+        total_byte_per_second: int = field(XmpLong())
+        """long integer, number of total TCP payload bytes/second transmitted"""
+        good_byte_count: int = field(XmpLong())
+        """long integer, number of good TCP payload bytes transmitted"""
+        good_byte_per_second: int = field(XmpLong())
+        """long integer, number of good TCP payload bytes/second transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TCP Tx payload counters.
 
         :return: a list of the TCP Tx payload counters.
         :rtype: P4G_TCP_TX_PAYLOAD_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_RETRANSMIT_COUNTERS:
     """
     Returns a list of TCP retransmission counters.
     """
 
     code: typing.ClassVar[int] = 618
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        rx_duplicate_ack_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of duplicate ACK received
-        rx_ooo_segment_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of out-of-order segments received
-        fast_retrans_event_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of fast-retransmit events occurred
-        fast_retrans_segment_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of segments retransmitted during fast-retransmit
-        rto_retrans_event_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of timer based retransmit events occurred
-        syn_retrans_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of SYN retransmitted
-        fin_retrans_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of FIN retransmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        rx_duplicate_ack_count: int = field(XmpLong())
+        """long integer, number of duplicate ACK received"""
+        rx_ooo_segment_count: int = field(XmpLong())
+        """long integer, number of out-of-order segments received"""
+        fast_retrans_event_count: int = field(XmpLong())
+        """long integer, number of fast-retransmit events occurred"""
+        fast_retrans_segment_count: int = field(XmpLong())
+        """long integer, number of segments retransmitted during fast-retransmit"""
+        rto_retrans_event_count: int = field(XmpLong())
+        """long integer, number of timer based retransmit events occurred"""
+        syn_retrans_count: int = field(XmpLong())
+        """long integer, number of SYN retransmitted"""
+        fin_retrans_count: int = field(XmpLong())
+        """long integer, number of FIN retransmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of TCP retransmission counters.
 
         :return: a list of TCP retransmission counters.
         :rtype: P4G_TCP_RETRANSMIT_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_ERROR_COUNTERS:
     """
     Returns a list of TCP error counters.
     """
 
     code: typing.ClassVar[int] = 619
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        rx_reset_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP RESET received
-        tx_reset_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP RESET transmitted
-        window_full_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP window full encountered
-        max_syn_retrans_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of connections reset due to maximum number of SYN retransmits
-        max_retrans_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of connections reset due to maximum number of RTO retransmits
-        local_reset_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of connections reset locally by transmitting a TCP RESET
-        peer_reset_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of connections reset by peer
-        seg_not_send_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP segments not send due to exhausted Tx resources
-        rx_zero_window_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of Zero Window ACKs received from the peer
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        rx_reset_count: int = field(XmpLong())
+        """long integer, number of TCP RESET received"""
+        tx_reset_count: int = field(XmpLong())
+        """long integer, number of TCP RESET transmitted"""
+        window_full_count: int = field(XmpLong())
+        """long integer, number of TCP window full encountered"""
+        max_syn_retrans_count: int = field(XmpLong())
+        """long integer, number of connections reset due to maximum number of SYN retransmits"""
+        max_retrans_count: int = field(XmpLong())
+        """long integer, number of connections reset due to maximum number of RTO retransmits"""
+        local_reset_count: int = field(XmpLong())
+        """long integer, number of connections reset locally by transmitting a TCP RESET"""
+        peer_reset_count: int = field(XmpLong())
+        """long integer, number of connections reset by peer"""
+        seg_not_send_count: int = field(XmpLong())
+        """long integer, number of TCP segments not send due to exhausted Tx resources"""
+        rx_zero_window_count: int = field(XmpLong())
+        """long integer, number of Zero Window ACKs received from the peer"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of TCP error counters.
 
         :return: a list of TCP error counters.
         :rtype: P4G_TCP_ERROR_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_IP_DS_TYPE:
     """
     Configure the mode of the DS field of the IP header of this Connection Group.
     """
 
     code: typing.ClassVar[int] = 620
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ds_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MSSType)  # coded byte, specifying how to fill out the DS field
+    class GetDataAttr(ResponseBodyStruct):
+        ds_type: MSSType = field(XmpByte())
+        """coded byte, specifying how to fill out the DS field"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ds_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MSSType)  # coded byte, specifying how to fill out the DS field
+    class SetDataAttr(RequestBodyStruct):
+        ds_type: MSSType = field(XmpByte())
+        """coded byte, specifying how to fill out the DS field"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value of the DS field of the IP header of this Connection Group.
 
         :return: the mode of the DS field
         :rtype: P4G_IP_DS_TYPE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ds_type: MSSType) -> "Token":
+    def set(self, ds_type: MSSType) -> Token[None]:
         """Set the value of the DS field of the IP header of this Connection Group.
 
         :param ds_type: specifying how to fill out the DS field
         :type ds_type: MSSType
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ds_type=ds_type))
 
     set_fixed = functools.partialmethod(set, MSSType.FIXED)
     """Use fixed value for DS."""
+
     set_increment = functools.partialmethod(set, MSSType.INCREMENT)
     """Use incrementing values for DS."""
+
     set_random = functools.partialmethod(set, MSSType.RANDOM)
     """Use pseudorandom values for DS."""
 
 
 @register_command
 @dataclass
 class P4G_IP_DS_VALUE:
     """
     Specify the (FIXED) value used for DS.
     """
 
     code: typing.ClassVar[int] = 621
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ds_value: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, the fixed DS value to be used
+    class GetDataAttr(ResponseBodyStruct):
+        ds_value: Hex = field(XmpHex(size=1))
+        """hex byte, the fixed DS value to be used"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ds_value: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, the fixed DS value to be used
+    class SetDataAttr(RequestBodyStruct):
+        ds_value: Hex = field(XmpHex(size=1))
+        """hex byte, the fixed DS value to be used"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the fixed DS value.
 
         :return: value of the DS field
         :rtype: P4G_IP_DS_VALUE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ds_value: str) -> "Token":
+    def set(self, ds_value: Hex) -> Token[None]:
         """Set the fixed DS value.
 
         :param ds_value: the fixed DS value to be used
-        :type ds_value: str
+        :type ds_value: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ds_value=ds_value))
 
 
 @register_command
 @dataclass
 class P4G_IP_DS_MASK:
     """
@@ -1018,127 +1152,135 @@
     DS will be calculated as follows: (fixed AND (NOT mask)) OR (curr AND mask) or
     in C syntax (fixed & (~mask)) | (curr & mask)
     """
 
     code: typing.ClassVar[int] = 622
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ds_mask: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, the DS mask to be used.
+    class GetDataAttr(ResponseBodyStruct):
+        ds_mask: Hex = field(XmpHex(size=1))
+        """hex byte, the DS mask to be used."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ds_mask: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, the DS mask to be used.
+    class SetDataAttr(RequestBodyStruct):
+        ds_mask: Hex = field(XmpHex(size=1))
+        """hex byte, the DS mask to be used."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the bit mask to be applied to the DS field.
 
         :return: the bit mask to be applied to the DS field
         :rtype: P4G_IP_DS_MASK.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ds_mask: str) -> "Token":
+    def set(self, ds_mask: Hex) -> Token[None]:
         """Set the bit mask to be applied to the DS field.
 
         :param ds_mask: the DS mask to be used.
-        :type ds_mask: str
+        :type ds_mask: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ds_mask=ds_mask))
 
 
 @register_command
 @dataclass
 class P4G_IP_DS_MINMAX:
     """
     Configure the min and max values of the range for the calculated part of the DS
     value. Both values are included in the range. Relevant when P4G_IP_DS_TYPE` is set to ``INCREMENT`` or ``RANDOM``.
     """
 
     code: typing.ClassVar[int] = 623
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ds_min: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, minimum value for the calculated part of DS
-        ds_max: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, maximum value for the calculated part of DS
+    class GetDataAttr(ResponseBodyStruct):
+        ds_min: Hex = field(XmpHex(size=1))
+        """hex byte, minimum value for the calculated part of DS"""
+        ds_max: Hex = field(XmpHex(size=1))
+        """hex byte, maximum value for the calculated part of DS"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ds_min: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, minimum value for the calculated part of DS
-        ds_max: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, maximum value for the calculated part of DS
+    class SetDataAttr(RequestBodyStruct):
+        ds_min: Hex = field(XmpHex(size=1))
+        """hex byte, minimum value for the calculated part of DS"""
+        ds_max: Hex = field(XmpHex(size=1))
+        """hex byte, maximum value for the calculated part of DS"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the min and max values of the range for the calculated part of the DS value.
 
         :return: the min and max values of the range for the calculated part of the DS value.
         :rtype: P4G_IP_DS_MINMAX.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ds_min: str, ds_max: str) -> "Token":
+    def set(self, ds_min: Hex, ds_max: Hex) -> Token[None]:
         """Set the min and max values of the range for the calculated part of the DS value.
 
         :param ds_min: minimum value for the calculated part of DS
-        :type ds_min: str
+        :type ds_min: Hex
         :param ds_max: maximum value for the calculated part of DS
-        :type ds_max: str
+        :type ds_max: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ds_min=ds_min, ds_max=ds_max))
 
 
 @register_command
 @dataclass
 class P4G_IP_DS_STEP:
     """
     Specifies the incrementing step size for the calculated part of the DS value.
     Relevant when P4G_IP_DS_TYPE` is set to ``INCREMENT``.
     """
 
     code: typing.ClassVar[int] = 624
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ds_step: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, the incrementing step size for DS.
+    class GetDataAttr(ResponseBodyStruct):
+        ds_step: Hex = field(XmpHex(size=1))
+        """hex byte, the incrementing step size for DS."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ds_step: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, the incrementing step size for DS.
+    class SetDataAttr(RequestBodyStruct):
+        ds_step: Hex = field(XmpHex(size=1))
+        """hex byte, the incrementing step size for DS."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the incrementing step size for the calculated part of the DS value.
 
         :return: the incrementing step size for the calculated part of the DS value.
         :rtype: P4G_IP_DS_STEP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ds_step: str) -> "Token":
+    def set(self, ds_step: Hex) -> Token[None]:
         """Set the incrementing step size for the calculated part of the DS value.
 
         :param ds_step: the incrementing step size for DS.
-        :type ds_step: str
+        :type ds_step: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ds_step=ds_step))
 
 
 @register_command
 @dataclass
 class P4G_TCP_MSS_TYPE:
     """
@@ -1149,47 +1291,51 @@
     P4G_TCP_MSS_MINMAX`
     command for information on how to configure min and max values.
     """
 
     code: typing.ClassVar[int] = 625
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mss_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MSSType)  # coded byte, specifying how MSS is set
+    class GetDataAttr(ResponseBodyStruct):
+        mss_type: MSSType = field(XmpByte())
+        """coded byte, specifying how MSS is set"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mss_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MSSType)  # coded byte, specifying how MSS is set
+    class SetDataAttr(RequestBodyStruct):
+        mss_type: MSSType = field(XmpByte())
+        """coded byte, specifying how MSS is set"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Maximum Segment size (MSS) type for a Connection Group.
 
         :return: the Maximum Segment size (MSS) type for a Connection Group
         :rtype: P4G_TCP_MSS_TYPE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mss_type: MSSType) -> "Token":
+    def set(self, mss_type: MSSType) -> Token[None]:
         """Set the Maximum Segment size (MSS) type for a Connection Group.
 
         :param mss_type: specifying how MSS is set
         :type mss_type: MSSType
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mss_type=mss_type))
 
     set_fixed = functools.partialmethod(set, MSSType.FIXED)
     """Use fixed value for TCP MSS."""
+
     set_increment = functools.partialmethod(set, MSSType.INCREMENT)
     """Use incrementing value for TCP MSS."""
+
     set_random = functools.partialmethod(set, MSSType.RANDOM)
     """Use pseudorandom value for TCP MSS."""
 
 
 @register_command
 @dataclass
 class P4G_TCP_MSS_MINMAX:
@@ -1198,286 +1344,317 @@
     included in the range. Relevant when P4G_TCP_MSS_TYPE is set to INCREMENT or
     RANDOM.
     """
 
     code: typing.ClassVar[int] = 626
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mss_min: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, minimum value of MSS
-        mss_max: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum value of MSS
+    class GetDataAttr(ResponseBodyStruct):
+        mss_min: int = field(XmpInt())
+        """integer, minimum value of MSS"""
+        mss_max: int = field(XmpInt())
+        """integer, maximum value of MSS"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mss_min: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, minimum value of MSS
-        mss_max: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum value of MSS
+    class SetDataAttr(RequestBodyStruct):
+        mss_min: int = field(XmpInt())
+        """integer, minimum value of MSS"""
+        mss_max: int = field(XmpInt())
+        """integer, maximum value of MSS"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the min and max values of the range for TCP MSS.
 
         :return: the min and max values of the range for TCP MSS
         :rtype: P4G_TCP_MSS_MINMAX.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mss_min: int, mss_max: int) -> "Token":
+    def set(self, mss_min: int, mss_max: int) -> Token[None]:
         """Set the min and max values of the range for TCP MSS.
 
         :param mss_min: minimum value of MSS
         :type mss_min: int
         :param mss_max: maximum value of MSS
         :type mss_max: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mss_min=mss_min, mss_max=mss_max))
 
 
 @register_command
 @dataclass
 class P4G_TCP_MSS_VALUE:
     """
     Configure the fixed MSS value. Relevant when P4G_TCP_MSS_TYPE is set to FIXED.
     """
 
     code: typing.ClassVar[int] = 627
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mss: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, fixed value of MSS
+    class GetDataAttr(ResponseBodyStruct):
+        mss: int = field(XmpInt())
+        """integer, fixed value of MSS"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mss: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, fixed value of MSS
+    class SetDataAttr(RequestBodyStruct):
+        mss: int = field(XmpInt())
+        """integer, fixed value of MSS"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the fixed MSS value of the Connection Group.
 
         :return: the fixed MSS value of the Connection Group.
         :rtype: P4G_TCP_MSS_VALUE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mss: int) -> "Token":
+    def set(self, mss: int) -> Token[None]:
         """Set the fixed MSS value of the Connection Group.
 
         :param mss: the fixed value of MSS (in bytes)
         :type mss: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mss=mss))
 
 
 @register_command
 @dataclass
 class P4G_TCP_WINDOW_SIZE:
     """
     Configure the value of the TCP RWND.
     """
 
     code: typing.ClassVar[int] = 628
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        window_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, window size in bytes
+    class GetDataAttr(ResponseBodyStruct):
+        window_size: int = field(XmpInt())
+        """integer, window size in bytes"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        window_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, window size in bytes
+    class SetDataAttr(RequestBodyStruct):
+        window_size: int = field(XmpInt())
+        """integer, window size in bytes"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value of the TCP RWND.
 
         :return: the value of the TCP RWND.
         :rtype: P4G_TCP_WINDOW_SIZE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, window_size: int) -> "Token":
+    def set(self, window_size: int) -> Token[None]:
         """Set the value of the TCP RWND.
 
         :param window_size: RWND size in bytes
         :type window_size: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], window_size=window_size))
 
 
 @register_command
 @dataclass
 class P4G_TCP_DUP_THRES:
     """
     Configure the value of the TCP duplicate ACK threshold.
     """
 
     code: typing.ClassVar[int] = 629
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        threshold: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, duplicate ACK threshold - must be larger than 0
+    class GetDataAttr(ResponseBodyStruct):
+        threshold: int = field(XmpByte())
+        """byte, duplicate ACK threshold - must be larger than 0"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        threshold: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, duplicate ACK threshold - must be larger than 0
+    class SetDataAttr(RequestBodyStruct):
+        threshold: int = field(XmpByte())
+        """byte, duplicate ACK threshold - must be larger than 0"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value of the TCP duplicate ACK threshold.
 
         :return: the value of the TCP duplicate ACK threshold.
         :rtype: P4G_TCP_DUP_THRES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, threshold: int) -> "Token":
+    def set(self, threshold: int) -> Token[None]:
         """Set the value of the TCP duplicate ACK threshold.
 
         :param threshold: duplicate ACK threshold - must be larger than 0
         :type threshold: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], threshold=threshold))
 
 
 @register_command
 @dataclass
 class P4G_TCP_SYN_RTO:
     """
     Configure the value of the TCP SYN retransmission timeout, max retries and max backoff.
     """
 
     code: typing.ClassVar[int] = 630
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, SYN retransmission timeout [milliseconds] - must be larger than 0
-        retry_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum SYN retransmission retries - must be larger than 0
-        backoff: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum SYN retransmission backoff
+    class GetDataAttr(ResponseBodyStruct):
+        retrans_timeout: int = field(XmpInt())
+        """integer, SYN retransmission timeout [milliseconds] - must be larger than 0"""
+        retry_count: int = field(XmpByte())
+        """byte, maximum SYN retransmission retries - must be larger than 0"""
+        backoff: int = field(XmpByte())
+        """byte, maximum SYN retransmission backoff"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, SYN retransmission timeout [milliseconds] - must be larger than 0
-        retry_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum SYN retransmission retries - must be larger than 0
-        backoff: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum SYN retransmission backoff
+    class SetDataAttr(RequestBodyStruct):
+        retrans_timeout: int = field(XmpInt())
+        """integer, SYN retransmission timeout [milliseconds] - must be larger than 0"""
+        retry_count: int = field(XmpByte())
+        """byte, maximum SYN retransmission retries - must be larger than 0"""
+        backoff: int = field(XmpByte())
+        """byte, maximum SYN retransmission backoff"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value of the TCP SYN retransmission timeout, max retries and max backoff.
 
         :return: the value of the TCP SYN retransmission timeout, max retries and max backoff.
         :rtype: P4G_TCP_SYN_RTO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, retrans_timeout: int, retry_count: int, backoff: int) -> "Token":
+    def set(self, retrans_timeout: int, retry_count: int, backoff: int) -> Token[None]:
         """Set the value of the TCP SYN retransmission timeout, max retries and max backoff.
 
         :param retrans_timeout: SYN retransmission timeout [milliseconds] - must be larger than 0
         :type retrans_timeout: int
         :param retry_count: maximum SYN retransmission retries - must be larger than 0
         :type retry_count: int
         :param backoff: maximum SYN retransmission backoff
         :type backoff: int
         """
+
         return Token(
             self._connection,
             build_set_request(
-                self, module=self._module, port=self._port, indices=[self._group_xindex], retrans_timeout=retrans_timeout, retry_count=retry_count, backoff=backoff
-            ),
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._group_xindex],
+                retrans_timeout=retrans_timeout,
+                retry_count=retry_count,
+                backoff=backoff
+            )
         )
 
 
 @register_command
 @dataclass
 class P4G_TCP_RTO:
     """
     Configure the value of the TCP retransmission timeout, max retries and max backoff.
     """
 
     code: typing.ClassVar[int] = 631
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        rto_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=RTOType)  # coded byte, specifying RTO type
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, retransmission timeout [milliseconds] - must be larger than 0
-        retry_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum retransmission retries - must be larger than 0
-        backoff: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum retransmission backoff
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=RTOType)  # coded byte, specifying RTO type
-        retrans_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, retransmission timeout [milliseconds] - must be larger than 0
-        retry_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum retransmission retries - must be larger than 0
-        backoff: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, maximum retransmission backoff
+    class GetDataAttr(ResponseBodyStruct):
+        type: RTOType = field(XmpByte())
+        """coded byte, specifying RTO type"""
+        retrans_timeout: int = field(XmpInt())
+        """integer, retransmission timeout [milliseconds] - must be larger than 0"""
+        retry_count: int = field(XmpByte())
+        """byte, maximum retransmission retries - must be larger than 0"""
+        backoff: int = field(XmpByte())
+        """byte, maximum retransmission backoff"""
+
+    class SetDataAttr(RequestBodyStruct):
+        rto_type: RTOType = field(XmpByte())
+        """coded byte, specifying RTO type"""
+        retrans_timeout: int = field(XmpInt())
+        """integer, retransmission timeout [milliseconds] - must be larger than 0"""
+        retry_count: int = field(XmpByte())
+        """byte, maximum retransmission retries - must be larger than 0"""
+        backoff: int = field(XmpByte())
+        """byte, maximum retransmission backoff"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value of the TCP retransmission timeout, max retries and max backoff.
 
         :return: the value of the TCP retransmission timeout, max retries and max backoff.
         :rtype: P4G_TCP_RTO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, rto_type: RTOType, retrans_timeout: int, retry_count: int, backoff: int) -> "Token":
+    def set(self, rto_type: RTOType, retrans_timeout: int, retry_count: int, backoff: int) -> Token[None]:
         """Set the value of the TCP retransmission timeout, max retries and max backoff.
 
         :param rto_type: specifying RTO type
         :type rto_type: RTOType
         :param retrans_timeout: retransmission timeout [milliseconds] - must be larger than 0
         :type retrans_timeout: int
         :param retry_count: maximum retransmission retries - must be larger than 0
         :type retry_count: int
         :param backoff: maximum retransmission backoff
         :type backoff: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._group_xindex],
                 rto_type=rto_type,
                 retrans_timeout=retrans_timeout,
                 retry_count=retry_count,
-                backoff=backoff,
-            ),
+                backoff=backoff
+            )
         )
 
     set_static = functools.partialmethod(set, RTOType.STATIC)
     """RTO is constant as configured"""
+
     set_dynamic = functools.partialmethod(set, RTOType.DYNAMIC)
     """RTO is dynamic and depending on round trip time (RTT)"""
 
 
 @register_command
 @dataclass
 class P4G_UDP_PACKET_SIZE_TYPE:
@@ -1488,47 +1665,51 @@
     always constant once the incrementing or random value has been created. Refer to
     P4G_UDP_PACKET_SIZE_MINMAX` command for information on how to configure min and max values.
     """
 
     code: typing.ClassVar[int] = 632
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        packet_size_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MSSType)  # coded byte, specifying how UDP packet size is set
+    class GetDataAttr(ResponseBodyStruct):
+        packet_size_type: MSSType = field(XmpByte())
+        """coded byte, specifying how UDP packet size is set"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        packet_size_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MSSType)  # coded byte, specifying how UDP packet size is set
+    class SetDataAttr(RequestBodyStruct):
+        packet_size_type: MSSType = field(XmpByte())
+        """coded byte, specifying how UDP packet size is set"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the UDP packet size type for the Connection Group.
 
         :return: the UDP packet size for the Connection Group.
         :rtype: P4G_UDP_PACKET_SIZE_TYPE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, packet_size_type: MSSType) -> "Token":
+    def set(self, packet_size_type: MSSType) -> Token[None]:
         """Set the UDP packet size type for the Connection Group.
 
         :param packet_size_type: specifying how UDP packet size is set
         :type packet_size_type: MSSType
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], packet_size_type=packet_size_type))
 
     set_fixed = functools.partialmethod(set, MSSType.FIXED)
     """Use fixed value for UDP packet size."""
+
     set_increment = functools.partialmethod(set, MSSType.INCREMENT)
     """Use incrementing value for UDP packet size."""
+
     set_random = functools.partialmethod(set, MSSType.RANDOM)
     """Use pseudorandom value for UDP packet size."""
 
 
 @register_command
 @dataclass
 class P4G_UDP_PACKET_SIZE_MINMAX:
@@ -1537,132 +1718,142 @@
     values are included in the range. Relevant when P4G_UDP_PACKET_SIZE_TYPE is set
     to INCREMENT or RANDOM.
     """
 
     code: typing.ClassVar[int] = 633
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        size_min: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, minimum value of UDP packet size
-        size_max: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum value of UDP packet size
+    class GetDataAttr(ResponseBodyStruct):
+        size_min: int = field(XmpInt())
+        """integer, minimum value of UDP packet size"""
+        size_max: int = field(XmpInt())
+        """integer, maximum value of UDP packet size"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        size_min: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, minimum value of UDP packet size
-        size_max: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum value of UDP packet size
+    class SetDataAttr(RequestBodyStruct):
+        size_min: int = field(XmpInt())
+        """integer, minimum value of UDP packet size"""
+        size_max: int = field(XmpInt())
+        """integer, maximum value of UDP packet size"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the minimum and maximum values of the range for UDP packet size.
 
         :return: the minimum and maximum values of the range for UDP packet size.
         :rtype: P4G_UDP_PACKET_SIZE_MINMAX.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, size_min: int, size_max: int) -> "Token":
+    def set(self, size_min: int, size_max: int) -> Token[None]:
         """Set the minimum and maximum values of the range for UDP packet size.
 
         :param size_min: the minimum value of UDP packet size
         :type size_min: int
         :param size_max: the maximum value of UDP packet size
         :type size_max: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], size_min=size_min, size_max=size_max))
 
 
 @register_command
 @dataclass
 class P4G_UDP_PACKET_SIZE_VALUE:
     """
     Configure the fixed UDP packet size value. Relevant when
     P4G_UDP_PACKET_SIZE_TYPE is set to FIXED.
     """
 
     code: typing.ClassVar[int] = 634
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, fixed value of UDP packet size
+    class GetDataAttr(ResponseBodyStruct):
+        size: int = field(XmpInt())
+        """integer, fixed value of UDP packet size"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, fixed value of UDP packet size
+    class SetDataAttr(RequestBodyStruct):
+        size: int = field(XmpInt())
+        """integer, fixed value of UDP packet size"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the fixed UDP packet size value.
 
         :return: the fixed UDP packet size value
         :rtype: P4G_UDP_PACKET_SIZE_VALUE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, size: int) -> "Token":
+    def set(self, size: int) -> Token[None]:
         """Set the fixed UDP packet size value.
 
         :param size: the fixed value of UDP packet size
         :type size: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], size=size))
 
 
 @register_command
 @dataclass
 class P4G_TCP_CONGESTION_MODE:
     """
     Configure the TCP congestion control algorithm.
     """
 
     code: typing.ClassVar[int] = 635
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        congestion_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=CongestionType)  # coded byte, specifying congestion algorithm type
+    class GetDataAttr(ResponseBodyStruct):
+        congestion_type: CongestionType = field(XmpByte())
+        """coded byte, specifying congestion algorithm type"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        congestion_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=CongestionType)  # coded byte, specifying congestion algorithm type
+    class SetDataAttr(RequestBodyStruct):
+        congestion_type: CongestionType = field(XmpByte())
+        """coded byte, specifying congestion algorithm type"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the TCP congestion control algorithm.
 
         :return: the TCP congestion control algorithm.
         :rtype: P4G_TCP_CONGESTION_MODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, congestion_type: CongestionType) -> "Token":
+    def set(self, congestion_type: CongestionType) -> Token[None]:
         """Set the TCP congestion control algorithm.
 
         :param congestion_type: specifying congestion algorithm type
         :type congestion_type: CongestionType
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], congestion_type=congestion_type))
 
     set_none = functools.partialmethod(set, CongestionType.NONE)
     """Disable congestion control."""
+
     set_reno = functools.partialmethod(set, CongestionType.RENO)
     """Enable RENO congestion control algorithm."""
+
     set_new_reno = functools.partialmethod(set, CongestionType.NEW_RENO)
     """Enable New RENO congestion control algorithm."""
 
 
 @register_command
 @dataclass
 class P4G_TCP_WINDOW_SCALING:
@@ -1670,49 +1861,54 @@
     Enable window scaling for the Connection Group. Note to use windows scaling it
     need to be enabled in both the client and server Connection Group. .
     """
 
     code: typing.ClassVar[int] = 636
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # code byte, specifying whether to enable window scaling or not
-        factor: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # integer, default value is 0 and maximum value is 14 - ignored if window scaling is not enabled
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """code byte, specifying whether to enable window scaling or not"""
+        factor: int = field(XmpByte())
+        """integer, default value is 0 and maximum value is 14 - ignored if window scaling is not enabled"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # code byte, specifying whether to enable window scaling or not
-        factor: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # integer, default value is 0 and maximum value is 14 - ignored if window scaling is not enabled
+    class SetDataAttr(RequestBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """code byte, specifying whether to enable window scaling or not"""
+        factor: int = field(XmpByte())
+        """integer, default value is 0 and maximum value is 14 - ignored if window scaling is not enabled"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get TCP window scaling settings for the Connection Group.
 
         :return: TCP window scaling settings for the Connection Group.
         :rtype: P4G_TCP_WINDOW_SCALING.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, on_off: YesNo, factor: int) -> "Token":
+    def set(self, on_off: YesNo, factor: int) -> Token[None]:
         """Set TCP window scaling settings for the Connection Group.
 
         :param on_off: specifying whether to enable window scaling or not
         :type on_off: YesNo
         :param factor: default value is 0 and maximum value is 14 - ignored if window scaling is not enabled
         :type factor: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], on_off=on_off, factor=factor))
 
     set_no = functools.partialmethod(set, YesNo.NO)
     """Disable TCP window scaling."""
+
     set_yes = functools.partialmethod(set, YesNo.YES)
     """Enable TCP window scaling."""
 
 
 @register_command
 @dataclass
 class P4G_TCP_RTO_MINMAX:
@@ -1721,45 +1917,49 @@
     is set to dynamic. If the calculated rto fall outside the interval, the value is
     clamped to the min or max value.
     """
 
     code: typing.ClassVar[int] = 637
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        rto_min: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, min retransmission timeout [us] - must be larger than 0 and less than max.
-        rto_max: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max retransmission timeout [us] - must be larger than 0 and greater than min.
+    class GetDataAttr(ResponseBodyStruct):
+        rto_min: int = field(XmpInt())
+        """integer, min retransmission timeout [us] - must be larger than 0 and less than max."""
+        rto_max: int = field(XmpInt())
+        """integer, max retransmission timeout [us] - must be larger than 0 and greater than min."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        rto_min: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, min retransmission timeout [us] - must be larger than 0 and less than max.
-        rto_max: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max retransmission timeout [us] - must be larger than 0 and greater than min.
+    class SetDataAttr(RequestBodyStruct):
+        rto_min: int = field(XmpInt())
+        """integer, min retransmission timeout [us] - must be larger than 0 and less than max."""
+        rto_max: int = field(XmpInt())
+        """integer, max retransmission timeout [us] - must be larger than 0 and greater than min."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the min and max values of the TCP retransmission timeout.
 
         :return: the min and max values of the TCP retransmission timeout
         :rtype: P4G_TCP_RTO_MINMAX.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, rto_min: int, rto_max: int) -> "Token":
+    def set(self, rto_min: int, rto_max: int) -> Token[None]:
         """Set the min and max values of the TCP retransmission timeout.
 
         :param rto_min: min retransmission timeout [us] - must be larger than 0 and less than max.
         :type rto_min: int
         :param rto_max: max retransmission timeout [us] - must be larger than 0 and greater than min.
         :type rto_max: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], rto_min=rto_min, rto_max=rto_max))
 
 
 @register_command
 @dataclass
 class P4G_TCP_RTO_PROLONGED_MODE:
     """
@@ -1767,243 +1967,255 @@
     exceeding max number of retransmission retries, continue trying retransmit until
     success, whereafter it will operate normally.
     """
 
     code: typing.ClassVar[int] = 638
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsEnabled)  # byte, specifying whether to enable/disable prolonged retransmission mode
-        timeout: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # retransmission timeout in milliseconds, when prolonged mode is enabled. when mode is set to 0, the value of the timeout is ignored, when mode is set to 1, the value of the timeout may not be 0
+    class GetDataAttr(ResponseBodyStruct):
+        mode: IsEnabled = field(XmpByte())
+        """byte, specifying whether to enable/disable prolonged retransmission mode"""
+        timeout: int = field(XmpInt())
+        """retransmission timeout in milliseconds, when prolonged mode is enabled.
+        When mode is set to 0, the value of the timeout is ignored, when mode is set to 1, the value of the timeout may not be 0"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IsEnabled)  # byte, specifying whether to enable/disable prolonged retransmission mode
-        timeout: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # retransmission timeout in milliseconds, when prolonged mode is enabled. when mode is set to 0, the value of the timeout is ignored, when mode is set to 1, the value of the timeout may not be 0
+    class SetDataAttr(RequestBodyStruct):
+        mode: IsEnabled = field(XmpByte())
+        """byte, specifying whether to enable/disable prolonged retransmission mode"""
+        timeout: int = field(XmpInt())
+        """retransmission timeout in milliseconds, when prolonged mode is enabled.
+        When mode is set to 0, the value of the timeout is ignored, when mode is set to 1, the value of the timeout may not be 0"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get TCP retransmission prolonged mode.
 
         :return: TCP retransmission prolonged mode
         :rtype: P4G_TCP_RTO_PROLONGED_MODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: IsEnabled, timeout: int) -> "Token":
+    def set(self, mode: IsEnabled, timeout: int) -> Token[None]:
         """Set TCP retransmission prolonged mode.
 
         :param mode: specifying whether to enable/disable prolonged retransmission mode
         :type mode: IsEnabled
-        :param timeout: retransmission timeout in milliseconds, when prolonged mode is enabled. When ``mode`` is set to 0, the value of the timeout is ignored. When ``mode`` is set to 1, the value of the timeout may not be 0.
+        :param timeout: retransmission timeout in milliseconds, when prolonged mode is enabled.
+            When ``mode`` is set to 0, the value of the timeout is ignored. When ``mode`` is set to 1, the value of the timeout may not be 0.
         :type timeout: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, timeout=timeout))
 
     set_disable = functools.partialmethod(set, IsEnabled.DISABLE)
     """Disable TCP retransmission prolonged mode."""
+
     set_enable = functools.partialmethod(set, IsEnabled.ENABLE)
     """Enable TCP retransmission prolonged mode."""
 
 
 @register_command
 @dataclass
 class P4G_TCP_ICWND_CALC_METHOD:
     """
     Select the algorithm to calculate the TCP initial congestion window (ICWND).
     """
 
     code: typing.ClassVar[int] = 639
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        method: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=AlgorithmMethod)  # coded byte, specifying the algorithm
-        factor: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, factor to multiply the senders MSS with, when method is set to 'FIXED_FACTOR'. Otherwise the value is ignored.
+    class GetDataAttr(ResponseBodyStruct):
+        method: AlgorithmMethod = field(XmpByte())
+        """coded byte, specifying the algorithm"""
+        factor: int = field(XmpInt())
+        """integer, factor to multiply the senders MSS with, when method is set to 'FIXED_FACTOR'. Otherwise the value is ignored."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        method: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=AlgorithmMethod)  # coded byte, specifying the algorithm
-        factor: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, factor to multiply the senders MSS with, when method is set to 'FIXED_FACTOR'. Otherwise the value is ignored.
+    class SetDataAttr(RequestBodyStruct):
+        method: AlgorithmMethod = field(XmpByte())
+        """coded byte, specifying the algorithm"""
+        factor: int = field(XmpInt())
+        """integer, factor to multiply the senders MSS with, when method is set to 'FIXED_FACTOR'. Otherwise the value is ignored."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the algorithm to calculate the TCP initial congestion window (ICWND).
 
         :return: the algorithm to calculate the TCP initial congestion window (ICWND).
         :rtype: P4G_TCP_ICWND_CALC_METHOD.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, method: AlgorithmMethod, factor: int) -> "Token":
+    def set(self, method: AlgorithmMethod, factor: int) -> Token[None]:
         """Set the algorithm to calculate the TCP initial congestion window (ICWND).
 
         :param method: specifying the algorithm
         :type method: AlgorithmMethod
         :param factor: factor to multiply the senders MSS with, when method is set to ``FIXED_FACTOR``. Otherwise the value is ignored.
         :type factor: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], method=method, factor=factor))
 
     set_rfc5681 = functools.partialmethod(set, AlgorithmMethod.RFC5681)
     """ICWND is set according to RFC5681."""
+
     set_rfc2581 = functools.partialmethod(set, AlgorithmMethod.RFC2581)
     """ICWND is set according to RFC2581"""
+
     set_fixed_factor = functools.partialmethod(set, AlgorithmMethod.FIXED_FACTOR)
     """ICWND is set to a FACTOR * SMSS (Sender's MSS)"""
 
 
 @register_command
 @dataclass
 class P4G_TCP_ISSTHRESH:
     """
     Configure the TCP initial slow start threshold (ISSTHRESH).
     """
 
     code: typing.ClassVar[int] = 640
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=AutoOrManual)  # coded byte, specifying TCP initial slow start mode
-        threshold: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of bytes, value ignored when mode is set to MANUAL
+    class GetDataAttr(ResponseBodyStruct):
+        mode: AutoOrManual = field(XmpByte())
+        """coded byte, specifying TCP initial slow start mode"""
+        threshold: int = field(XmpInt())
+        """integer, number of bytes, value ignored when mode is set to MANUAL"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=AutoOrManual)  # coded byte, specifying TCP initial slow start mode
-        threshold: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of bytes, value ignored when mode is set to MANUAL
+    class SetDataAttr(RequestBodyStruct):
+        mode: AutoOrManual = field(XmpByte())
+        """coded byte, specifying TCP initial slow start mode"""
+        threshold: int = field(XmpInt())
+        """integer, number of bytes, value ignored when mode is set to MANUAL"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the TCP initial slow start threshold (ISSTHRESH).
 
         :return: the TCP initial slow start threshold (ISSTHRESH).
         :rtype: P4G_TCP_ISSTHRESH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: AutoOrManual, threshold: int) -> "Token":
+    def set(self, mode: AutoOrManual, threshold: int) -> Token[None]:
         """Set the TCP initial slow start threshold (ISSTHRESH).
 
         :param mode: specifying TCP initial slow start mode
         :type mode: AutoOrManual
         :param threshold: number of bytes, value ignored when mode is set to ``MANUAL``
         :type threshold: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, threshold=threshold))
 
     set_automatic = functools.partialmethod(set, AutoOrManual.AUTOMATIC)
     """TCP initial slow start mode set to Automatic"""
+
     set_manual = functools.partialmethod(set, AutoOrManual.MANUAL)
     """TCP initial slow start mode set to Manual"""
 
 
 @register_command
 @dataclass
 class P4G_TCP_ACK_FREQUENCY:
     """
     Number of received packets before a pure-ACK is sent.
     """
 
     code: typing.ClassVar[int] = 641
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        packets_before_ack: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, number of received packets before an ACK is sent, range between 1 and 255, default 1. When set to 1, every packet is ACKed
+    class GetDataAttr(ResponseBodyStruct):
+        packets_before_ack: int = field(XmpInt())
+        """integer, number of received packets before an ACK is sent, range between 1 and 255, default 1. When set to 1, every packet is ACKed"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        packets_before_ack: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, number of received packets before an ACK is sent, range between 1 and 255, default 1. When set to 1, every packet is ACKed
+    class SetDataAttr(RequestBodyStruct):
+        packets_before_ack: int = field(XmpInt())
+        """integer, number of received packets before an ACK is sent, range between 1 and 255, default 1. When set to 1, every packet is ACKed"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of the number of received packets before a pure-ACK is sent.
 
         :return: the configuration of the number of received packets before a pure-ACK is sent.
         :rtype: P4G_TCP_ACK_FREQUENCY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, packets_before_ack: int) -> "Token":
+    def set(self, packets_before_ack: int) -> Token[None]:
         """Set the configuration of the number of received packets before a pure-ACK is sent.
 
         :param packets_before_ack: number of received packets before an ACK is sent, range between 1 and 255, default 1. When set to 1, every packet is ACKed.
         :type packets_before_ack: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], packets_before_ack=packets_before_ack))
 
 
 @register_command
 @dataclass
 class P4G_TCP_ACK_TIMEOUT:
     """
     Delayed ACK timeout in microsecondsA pure ACK for the last RX packet will be
-    sent after P4G_TCP_ACK_TIMEOUT` microseconds in case it cannot be sent by other means, ie. a number of packets received since last ACK is less than P4G_TCP_ACK_FREQUENCY` and there is no TX packets to sent (to piggy-back an ACK)
+    sent after P4G_TCP_ACK_TIMEOUT` microseconds in case it cannot be sent by other means,
+    ie. a number of packets received since last ACK is less than P4G_TCP_ACK_FREQUENCY` and there is no TX packets to sent (to piggy-back an ACK)
     """
 
     code: typing.ClassVar[int] = 642
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ack_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, timeout value in microseconds, default 200000.
+    class GetDataAttr(ResponseBodyStruct):
+        ack_timeout: int = field(XmpInt())
+        """integer, timeout value in microseconds, default 200000."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ack_timeout: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, timeout value in microseconds, default 200000.
+    class SetDataAttr(RequestBodyStruct):
+        ack_timeout: int = field(XmpInt())
+        """integer, timeout value in microseconds, default 200000."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Delayed ACK timeout.
 
         :return: the Delayed ACK timeout
         :rtype: P4G_TCP_ACK_TIMEOUT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ack_timeout: int) -> "Token":
+    def set(self, ack_timeout: int) -> Token[None]:
         """Set the Delayed ACK timeout.
 
         :param ack_timeout: timeout value in microseconds, default 200000.
         :type ack_timeout: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ack_timeout=ack_timeout))
 
 
 @register_command
 @dataclass
 class P4G_L2_CLIENT_MAC:
     """
@@ -2011,49 +2223,54 @@
     address or an embedding of the four byte IPv4 address into the lower 4 bytes of
     the 6 byte MAC address.
     """
 
     code: typing.ClassVar[int] = 644
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address specified as hexadecimal
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=EmbedIP)  # coded byte, whether to embed the IP address or not
+    class GetDataAttr(ResponseBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address specified as hexadecimal"""
+        mode: EmbedIP = field(XmpByte())
+        """coded byte, whether to embed the IP address or not"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address specified as hexadecimal
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=EmbedIP)  # coded byte, whether to embed the IP address or not
+    class SetDataAttr(RequestBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address specified as hexadecimal"""
+        mode: EmbedIP = field(XmpByte())
+        """coded byte, whether to embed the IP address or not"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the client MAC address.
 
         :return: the client MAC address
         :rtype: P4G_L2_CLIENT_MAC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mac_address: str, mode: EmbedIP) -> "Token":
+    def set(self, mac_address: Hex, mode: EmbedIP) -> Token[None]:
         """Set the client MAC address.
 
         :param mac_address: the MAC address specified as hexadecimal
-        :type mac_address: str
+        :type mac_address: Hex
         :param mode: whether to embed the IP address in MAC
         :type mode: EmbedIP
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mac_address=mac_address, mode=mode))
 
     set_dont_embed_ip = functools.partialmethod(set, mode=EmbedIP.DONT_EMBED_IP)
     """Not embed IP address in MAC address."""
+
     set_embed_ip = functools.partialmethod(set, mode=EmbedIP.EMBED_IP)
     """Embed IP address in MAC address."""
 
 
 @register_command
 @dataclass
 class P4G_L2_SERVER_MAC:
@@ -2062,49 +2279,54 @@
     address or an embedding of the four byte IPv4 address into the lower 4 bytes of
     the 6 byte MAC address.
     """
 
     code: typing.ClassVar[int] = 645
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address specified as hexadecimal
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=EmbedIP)  # coded byte, whether to embed the ip address or not
+    class GetDataAttr(ResponseBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address specified as hexadecimal"""
+        mode: EmbedIP = field(XmpByte())
+        """coded byte, whether to embed the ip address or not"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address specified as hexadecimal
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=EmbedIP)  # coded byte, whether to embed the ip address or not
+    class SetDataAttr(RequestBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address specified as hexadecimal"""
+        mode: EmbedIP = field(XmpByte())
+        """coded byte, whether to embed the ip address or not"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the server MAC address.
 
         :return: the server MAC address
         :rtype: P4G_L2_SERVER_MAC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mac_address: str, mode: EmbedIP) -> "Token":
+    def set(self, mac_address: Hex, mode: EmbedIP) -> Token[None]:
         """Set the server MAC address.
 
         :param mac_address: the MAC address specified as hexadecimal
-        :type mac_address: str
+        :type mac_address: Hex
         :param mode: whether to embed the IP address in MAC
         :type mode: EmbedIP
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mac_address=mac_address, mode=mode))
 
     set_dont_embed_ip = functools.partialmethod(set, mode=EmbedIP.DONT_EMBED_IP)
     """Not embed IP address in MAC address."""
+
     set_embed_ip = functools.partialmethod(set, mode=EmbedIP.EMBED_IP)
     """Embed IP address in MAC address."""
 
 
 @register_command
 @dataclass
 class P4G_L2_USE_ADDRESS_RES:
@@ -2112,183 +2334,199 @@
     Specify whether to use ARP and NDP to resolve hardware (MAC) addresses in the
     ``pre_run`` phase.
     """
 
     code: typing.ClassVar[int] = 646
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        is_enabled: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifying whether to use ARP and NDP or not
+    class GetDataAttr(ResponseBodyStruct):
+        is_enabled: YesNo = field(XmpByte())
+        """coded byte, specifying whether to use ARP and NDP or not"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        is_enabled: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifying whether to use ARP and NDP or not
+    class SetDataAttr(RequestBodyStruct):
+        is_enabled: YesNo = field(XmpByte())
+        """coded byte, specifying whether to use ARP and NDP or not"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of using ARP and NDP to resolve hardware (MAC) addresses.
 
         :return: specifying whether to use ARP and NDP to resolve hardware (MAC) addresses.
         :rtype: P4G_L2_USE_ADDRESS_RES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, is_enabled: YesNo) -> "Token":
+    def set(self, is_enabled: YesNo) -> Token[None]:
         """Set the status of using ARP and NDP to resolve hardware (MAC) addresses.
 
         :param is_enabled: specifying whether to use ARP and NDP to resolve hardware (MAC) addresses.
         :type is_enabled: YesNo
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], is_enabled=is_enabled))
 
     set_no = functools.partialmethod(set, YesNo.NO)
     """Disable using ARP and NDP to resolve hardware (MAC) addresses."""
+
     set_yes = functools.partialmethod(set, YesNo.YES)
     """Enable using ARP and NDP to resolve hardware (MAC) addresses."""
 
 
 @register_command
 @dataclass
 class P4G_L2_USE_GW:
     """
     Specify whether to use the resolved default gateway's MAC address as the destination MAC address in the packets.
     """
 
     code: typing.ClassVar[int] = 647
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        is_enabled: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifying whether to use gateway MAC or not
+    class GetDataAttr(ResponseBodyStruct):
+        is_enabled: YesNo = field(XmpByte())
+        """coded byte, specifying whether to use gateway MAC or not"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        is_enabled: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifying whether to use gateway MAC or not
+    class SetDataAttr(RequestBodyStruct):
+        is_enabled: YesNo = field(XmpByte())
+        """coded byte, specifying whether to use gateway MAC or not"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of using the resolved default gateway's MAC address as the destination MAC address in the packets.
 
         :return: the status of using the resolved default gateway's MAC address as the destination MAC address in the packets
         :rtype: P4G_L2_USE_GW.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, is_enabled: YesNo) -> "Token":
+    def set(self, is_enabled: YesNo) -> Token[None]:
         """Set the status of using the resolved default gateway's MAC address as the destination MAC address in the packets.
 
         :param is_enabled: specifying whether to use gateway's MAC address as the destination MAC address in the packets.
         :type is_enabled: YesNo
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], is_enabled=is_enabled))
 
     set_no = functools.partialmethod(set, YesNo.NO)
     """Disable using gateway's MAC address as the destination MAC address."""
+
     set_yes = functools.partialmethod(set, YesNo.YES)
     """Enable using gateway's MAC address as the destination MAC address."""
 
 
 @register_command
 @dataclass
 class P4G_L2_GW:
     """
     Specify a default gateway for IPv4.
     """
 
     code: typing.ClassVar[int] = 648
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, ip address of gateway
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address of the gateway
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, ip address of gateway"""
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address of the gateway"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, ip address of gateway
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address of the gateway
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, ip address of gateway"""
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address of the gateway"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the settings of the default gateway for IPv4.
 
         :return: IPv4 address and MAC address of the default gateway for IPv4.
         :rtype: P4G_L2_GW.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ipv4_address: typing.Union[str, int, ipaddress.IPv4Address], mac_address: str) -> "Token":
+    def set(self, ipv4_address: ipaddress.IPv4Address, mac_address: Hex) -> Token[None]:
         """Set a default gateway for IPv4.
 
         :param ipv4_address: IPv5 address of the gateway
-        :type ipv4_address: typing.Union[str, int, ipaddress.IPv4Address]
+        :type ipv4_address: ipaddress.IPv4Address
         :param mac_address: the MAC address of the gateway
-        :type mac_address: str
+        :type mac_address: Hex
         """
+
         return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ipv4_address=ipv4_address, mac_address=mac_address)
+            self._connection,
+            build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ipv4_address=ipv4_address, mac_address=mac_address)
         )
 
 
 @register_command
 @dataclass
 class P4G_L2_IPV6_GW:
     """
     Specify a default gateway for IPv6.
     """
 
     code: typing.ClassVar[int] = 649
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, the 16 bytes of IPv6 address of gateway
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address of the gateway
+    class GetDataAttr(ResponseBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, the 16 bytes of IPv6 address of gateway"""
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address of the gateway"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, the 16 bytes of IPv6 address of gateway
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, the MAC address of the gateway
+    class SetDataAttr(RequestBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, the 16 bytes of IPv6 address of gateway"""
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, the MAC address of the gateway"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the settings of the default gateway for IPv6.
 
         :return: IPv6 address and MAC address of the default gateway for IPv6.
         :rtype: P4G_L2_IPV6_GW.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ipv6_address: typing.Union[str, int, ipaddress.IPv6Address], mac_address: str) -> "Token":
+    def set(self, ipv6_address: ipaddress.IPv6Address, mac_address: Hex) -> Token[None]:
         """Set the default gateway for IPv6.
 
         :param ipv6_address: the 16 bytes of IPv6 address of gateway
-        :type ipv6_address: typing.Union[str, int, ipaddress.IPv6Address]
+        :type ipv6_address: ipaddress.IPv6Address
         :param mac_address: the MAC address of the gateway
-        :type mac_address: str
+        :type mac_address: Hex
         """
+
         return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ipv6_address=ipv6_address, mac_address=mac_address)
+            self._connection,
+            build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ipv6_address=ipv6_address, mac_address=mac_address)
         )
 
 
 @register_command
 @dataclass
 class P4G_TEST_APPLICATION:
     """
@@ -2301,194 +2539,213 @@
     * ``REPLAY`` refers to PCAP replay.
 
     """
 
     code: typing.ClassVar[int] = 650
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        behavior: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ApplicationLayerBehavior)  # coded byte, application behavior
+    class GetDataAttr(ResponseBodyStruct):
+        behavior: ApplicationLayerBehavior = field(XmpByte())
+        """coded byte, application behavior"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        behavior: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=ApplicationLayerBehavior)  # coded byte, application behavior
+    class SetDataAttr(RequestBodyStruct):
+        behavior: ApplicationLayerBehavior = field(XmpByte())
+        """coded byte, application behavior"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the application layer mode.
 
         :return: the application layer mode
         :rtype: P4G_TEST_APPLICATION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, behavior: ApplicationLayerBehavior) -> "Token":
+    def set(self, behavior: ApplicationLayerBehavior) -> Token[None]:
         """Set he application layer mode.
 
         :param behavior: the application layer mode
         :type behavior: ApplicationLayerBehavior
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], behavior=behavior))
 
     set_none = functools.partialmethod(set, ApplicationLayerBehavior.NONE)
     """Application layer is set to connection-only."""
+
     set_raw = functools.partialmethod(set, ApplicationLayerBehavior.RAW)
     """Application layer is set to connection + payload."""
+
     set_replay = functools.partialmethod(set, ApplicationLayerBehavior.REPLAY)
     """Application layer is set to pcap replay."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_TEST_SCENARIO:
     """
     Configure the traffic direction scenario for RAW mode.
     """
 
     code: typing.ClassVar[int] = 651
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        scenario: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TrafficScenario)  # coded byte, traffic scenario
+    class GetDataAttr(ResponseBodyStruct):
+        scenario: TrafficScenario = field(XmpByte())
+        """coded byte, traffic scenario"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        scenario: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TrafficScenario)  # coded byte, traffic scenario
+    class SetDataAttr(RequestBodyStruct):
+        scenario: TrafficScenario = field(XmpByte())
+        """coded byte, traffic scenario"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the traffic scenario for RAW mode.
 
         :return: the traffic scenario for RAW mode.
         :rtype: P4G_RAW_TEST_SCENARIO.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, scenario: TrafficScenario) -> "Token":
+    def set(self, scenario: TrafficScenario) -> Token[None]:
         """Set the traffic scenario for RAW mode.
 
         :param scenario: traffic scenario
         :type scenario: TrafficScenario
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], scenario=scenario))
 
     set_download = functools.partialmethod(set, TrafficScenario.DOWNLOAD)
     """Server transmits payload to client."""
+
     set_upload = functools.partialmethod(set, TrafficScenario.UPLOAD)
     """Client transmits payload to server."""
+
     set_both = functools.partialmethod(set, TrafficScenario.BOTH)
     """Payload is transmitted in both directions."""
+
     set_echo = functools.partialmethod(set, TrafficScenario.ECHO)
     """Client transmits payload to server, server echoes the payload back"""
 
 
 @register_command
 @dataclass
 class P4G_RAW_PAYLOAD_TYPE:
     """
     Specify the payload generation method.
     """
 
     code: typing.ClassVar[int] = 652
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        gen_method: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PayloadGenerationMethod)  # coded byte, payload generation method
+    class GetDataAttr(ResponseBodyStruct):
+        gen_method: PayloadGenerationMethod = field(XmpByte())
+        """coded byte, payload generation method"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        gen_method: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PayloadGenerationMethod)  # coded byte, payload generation method
+    class SetDataAttr(RequestBodyStruct):
+        gen_method: PayloadGenerationMethod = field(XmpByte())
+        """coded byte, payload generation method"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the payload generation method.
 
         :return: payload generation method
         :rtype: P4G_RAW_PAYLOAD_TYPE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, gen_method: PayloadGenerationMethod) -> "Token":
+    def set(self, gen_method: PayloadGenerationMethod) -> Token[None]:
         """Set the payload generation method.
 
         :param gen_method: payload generation method
         :type gen_method: PayloadGenerationMethod
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], gen_method=gen_method))
 
     set_fixed = functools.partialmethod(set, PayloadGenerationMethod.FIXED)
     """Payload has a fixed value - as specified by the P4G_RAW_PAYLOAD` command."""
+
     set_increment = functools.partialmethod(set, PayloadGenerationMethod.INCREMENT)
     """Payload consist of incrementing bytes."""
+
     set_random = functools.partialmethod(set, PayloadGenerationMethod.RANDOM)
     """Payload consists of pseudo random bytes with a repeat cycle of 1 MB."""
+
     set_longrandom = functools.partialmethod(set, PayloadGenerationMethod.LONGRANDOM)
     """Payload consists of pseudo random bytes with a repeat cycle of 4 GB."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_PAYLOAD_TOTAL_LEN:
     """
     Configure the total amount of payload to transmit on one connection.
     """
 
     code: typing.ClassVar[int] = 653
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, generation mode.
-        length: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, size of the payload
+    class GetDataAttr(ResponseBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, generation mode."""
+        length: int = field(XmpLong())
+        """long integer, size of the payload"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, generation mode.
-        length: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, size of the payload
+    class SetDataAttr(RequestBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, generation mode."""
+        length: int = field(XmpLong())
+        """long integer, size of the payload"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the total amount of payload to transmit on one connection.
 
         :return: the total amount of payload to transmit on one connection
         :rtype: P4G_RAW_PAYLOAD_TOTAL_LEN.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: InfiniteOrFinite, length: int) -> "Token":
+    def set(self, mode: InfiniteOrFinite, length: int) -> Token[None]:
         """Set the total amount of payload to transmit on one connection.
 
         :param mode: generation mode.
         :type mode: InfiniteOrFinite
         :param length: size of the payload
         :type length: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, length=length))
 
     set_infinite = functools.partialmethod(set, InfiniteOrFinite.INFINITE)
     """Generates payload as long as test is running."""
+
     set_finite = functools.partialmethod(set, InfiniteOrFinite.FINITE)
     """Stop generating payload after length bytes are transmitted."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_PAYLOAD:
@@ -2496,93 +2753,99 @@
     Specify raw payload as hex bytes. This command can be called several times to build
     a custom payload.
     """
 
     code: typing.ClassVar[int] = 654
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the offset in the payload buffer where data is to be written
-        length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of bytes to write
-        content: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, specifying the payload
+    class GetDataAttr(ResponseBodyStruct):
+        offset: int = field(XmpInt())
+        """integer, the offset in the payload buffer where data is to be written"""
+        length: int = field(XmpInt())
+        """integer, number of bytes to write"""
+        content: Hex = field(XmpHex())
+        """list of hex bytes, specifying the payload"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the offset in the payload buffer where data is to be written
-        length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of bytes to write
-        content: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, specifying the payload
+    class SetDataAttr(RequestBodyStruct):
+        offset: int = field(XmpInt())
+        """integer, the offset in the payload buffer where data is to be written"""
+        length: int = field(XmpInt())
+        """integer, number of bytes to write"""
+        content: Hex = field(XmpHex())
+        """list of hex bytes, specifying the payload"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the payload as hex bytes.
 
         :return: the payload as hex bytes
         :rtype: P4G_RAW_PAYLOAD.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, offset: int, length: int, content: str) -> "Token":
+    def set(self, offset: int, length: int, content: Hex) -> Token[None]:
         """Set the payload as hex bytes.
 
         :param offset: the offset in the payload buffer where data is to be written
         :type offset: int
         :param length: number of bytes to write
         :type length: int
         :param content: specifying the payload
-        :type content: str
+        :type content: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], offset=offset, length=length, content=content)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], offset=offset, length=length, content=content))
 
 
 @register_command
 @dataclass
 class P4G_RAW_PAYLOAD_REPEAT_LEN:
     """
     Specify the length of the raw payload, which is defined by one or more P4G_RAW_PAYLOAD` commands, to repeat.
 
     P4G_RAW_PAYLOAD_REPEAT_LEN` number of bytes will be repeated until P4G_RAW_PAYLOAD_TOTAL_LEN` bytes are transmitted on the connection.
     """
 
     code: typing.ClassVar[int] = 655
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the repeat length of the custom payload
+    class GetDataAttr(ResponseBodyStruct):
+        length: int = field(XmpInt())
+        """integer, specifying the length of the custom payload"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the length of the custom payload
+    class SetDataAttr(RequestBodyStruct):
+        length: int = field(XmpInt())
+        """integer, specifying the repeat length of the custom payload"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the length of the raw payload to repeat.
 
         :return: the length of the raw payload to repeat
         :rtype: P4G_RAW_PAYLOAD_REPEAT_LEN.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, length: int) -> "Token":
+    def set(self, length: int) -> Token[None]:
         """Set the length of the raw payload to repeat.
 
         :param length: the length of the raw payload to repeat
         :type length: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], length=length))
 
 
 @register_command
 @dataclass
 class P4G_RAW_HAS_DOWNLOAD_REQ:
     """
@@ -2593,107 +2856,116 @@
         This parameter is N/A when P4G_L4_PROTOCOL` is configured as UDP.
 
     """
 
     code: typing.ClassVar[int] = 656
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, expect request before sending payload or not
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """coded byte, expect request before sending payload or not"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, expect request before sending payload or not
+    class SetDataAttr(RequestBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """coded byte, expect request before sending payload or not"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the server waits for a request from the client before it starts transmitting.
 
         :return: whether the server waits for a request from the client before it starts transmitting.
         :rtype: P4G_RAW_HAS_DOWNLOAD_REQ.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, on_off: YesNo) -> "Token":
+    def set(self, on_off: YesNo) -> Token[None]:
         """Set whether the server waits for a request from the client before it starts transmitting.
 
         :param on_off: whether the server waits for a request from the client before it starts transmitting.
         :type on_off: YesNo
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], on_off=on_off))
 
     set_no = functools.partialmethod(set, YesNo.NO)
     """The server does not wait for a request from the client before it starts transmitting."""
+
     set_yes = functools.partialmethod(set, YesNo.YES)
     """The server waits for a request from the client before it starts transmitting."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_CLOSE_CONN:
     """
     Specify how to close TCP connection when all payload has been transmitted.
 
     In raw test scenario ``DOWNLOAD``, the server can close the connection, when all payload has been transmitted.
 
-    In raw test scenario ``UPLOAD``, the client can close the connection, when all payload has been transmitted. In any case, both server and client Connection Groups must be configured with the same value of this parameter.
+    In raw test scenario ``UPLOAD``, the client can close the connection, when all payload has been transmitted.
+    In any case, both server and client Connection Groups must be configured with the same value of this parameter.
 
     In raw test scenario ``BOTH`` (bidirectional), this parameter is N/A and will be ignored.
 
     In a transaction scenario, where P4G_RAW_HAS_DOWNLOAD_REQ` is set to ``YES``, both client and server can close the connection, when the last transaction has been completed.
 
-    When P4G_RAW_CONN_INCARNATION` is set to ``IMMORTAL`` or ``REINCARNATE``, and this command is set to ``NONE``, connections will be closed after 'connection lifetime', set by P4G_RAW_CONN_LIFETIME`.
+    When P4G_RAW_CONN_INCARNATION` is set to ``IMMORTAL`` or ``REINCARNATE``, and this command is set to ``NONE``,
+    connections will be closed after 'connection lifetime', set by P4G_RAW_CONN_LIFETIME`.
 
     .. note::
 
         This parameter is N/A when P4G_L4_PROTOCOL` is configured as UDP.
 
     """
 
     code: typing.ClassVar[int] = 657
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        who_close: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=WhoClose)  # coded byte, specifying who closes the connection
+    class GetDataAttr(ResponseBodyStruct):
+        who_close: WhoClose = field(XmpByte())
+        """coded byte, specifying who closes the connection"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        who_close: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=WhoClose)  # coded byte, specifying who closes the connection
+    class SetDataAttr(RequestBodyStruct):
+        who_close: WhoClose = field(XmpByte())
+        """coded byte, specifying who closes the connection"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get how to close TCP connection when all payload has been transmitted.
 
         :return: how to close TCP connection when all payload has been transmitted
         :rtype: P4G_RAW_CLOSE_CONN.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, who_close: WhoClose) -> "Token":
+    def set(self, who_close: WhoClose) -> Token[None]:
         """Set how to close TCP connection when all payload has been transmitted.
 
         :param who_close: specifying how to close TCP connection
         :type who_close: WhoClose
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], who_close=who_close))
 
     set_none = functools.partialmethod(set, WhoClose.NONE)
     """Keep the connection open after last byte is transmitted."""
+
     set_client = functools.partialmethod(set, WhoClose.CLIENT)
     """Client closes the connection after last byte is receiver/transmitted."""
+
     set_server = functools.partialmethod(set, WhoClose.SERVER)
     """Server closes the connection after last byte is transmitted."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_UTILIZATION:
@@ -2701,41 +2973,43 @@
     Specify the link layer bandwidth utilization for all the generated traffic from
     the specified Raw Connection Group.
     """
 
     code: typing.ClassVar[int] = 658
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        utilization: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, utilization specified in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        utilization: int = field(XmpInt())
+        """integer, utilization specified in ppm."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        utilization: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, utilization specified in ppm.
+    class SetDataAttr(RequestBodyStruct):
+        utilization: int = field(XmpInt())
+        """integer, utilization specified in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the link layer bandwidth utilization for all the generated traffic from the specified Raw Connection Group.
 
         :return: the link layer bandwidth utilization for all the generated traffic from the specified Raw Connection Group.
         :rtype: P4G_RAW_UTILIZATION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, utilization: int) -> "Token":
+    def set(self, utilization: int) -> Token[None]:
         """Set the link layer bandwidth utilization for all the generated traffic from the specified Raw Connection Group.
 
         :param utilization: utilization specified in ppm.
         :type utilization: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], utilization=utilization))
 
 
 @register_command
 @dataclass
 class P4G_RAW_DOWNLOAD_REQUEST:
     """
@@ -2746,45 +3020,49 @@
         This parameter is N/A when P4G_L4_PROTOCOL is configured as UDP.
 
     """
 
     code: typing.ClassVar[int] = 659
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the number of bytes to write. Maximum request length is 1024 bytes.
-        content: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, specifying the request content.
+    class GetDataAttr(ResponseBodyStruct):
+        length: int = field(XmpInt())
+        """integer, specifying the number of bytes to write. Maximum request length is 1024 bytes."""
+        content: Hex = field(XmpHex())
+        """list of hex bytes, specifying the request content."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the number of bytes to write. Maximum request length is 1024 bytes.
-        content: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, specifying the request content.
+    class SetDataAttr(RequestBodyStruct):
+        length: int = field(XmpInt())
+        """integer, specifying the number of bytes to write. Maximum request length is 1024 bytes."""
+        content: Hex = field(XmpHex())
+        """list of hex bytes, specifying the request content."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the content of the download request sent by the client and expected by the server as hex bytes.
 
         :return: the content of the download request sent by the client and expected by the server as hex bytes.
         :rtype: P4G_RAW_DOWNLOAD_REQUEST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, length: int, content: str) -> "Token":
+    def set(self, length: int, content: Hex) -> Token[None]:
         """Set the content of the download request sent by the client and expected by the server as hex bytes.
 
         :param length: specifying the number of bytes to write. Maximum request length is 1024 bytes.
         :type length: int
         :param content: specifying the request content.
-        :type content: str
+        :type content: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], length=length, content=content))
 
 
 @register_command
 @dataclass
 class P4G_RAW_TX_DURING_RAMP:
     """
@@ -2795,469 +3073,502 @@
         For UDP connections payload transmission will always take place during ramp-up and ramp-down, and this parameter is therefore N/A.
 
     """
 
     code: typing.ClassVar[int] = 660
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        should_close_conn_ramp_up: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, whether TCP payload transmission should take place during ramp up.
-        should_close_conn_ramp_down: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, whether TCP payload transmission should take place during ramp down.
+    class GetDataAttr(ResponseBodyStruct):
+        should_close_conn_ramp_up: YesNo = field(XmpByte())
+        """coded byte, whether TCP payload transmission should take place during ramp up."""
+        should_close_conn_ramp_down: YesNo = field(XmpByte())
+        """coded byte, whether TCP payload transmission should take place during ramp down."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        should_close_conn_ramp_up: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, whether TCP payload transmission should take place during ramp up.
-        should_close_conn_ramp_down: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, whether TCP payload transmission should take place during ramp down.
+    class SetDataAttr(RequestBodyStruct):
+        should_close_conn_ramp_up: YesNo = field(XmpByte())
+        """coded byte, whether TCP payload transmission should take place during ramp up."""
+        should_close_conn_ramp_down: YesNo = field(XmpByte())
+        """coded byte, whether TCP payload transmission should take place during ramp down."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether TCP payload transmission should take place during ramp-up and ramp-down.
 
         :return: whether TCP payload transmission should take place during ramp-up and ramp-down.
         :rtype: P4G_RAW_TX_DURING_RAMP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, should_close_conn_ramp_up: YesNo, should_close_conn_ramp_down: YesNo) -> "Token":
+    def set(self, should_close_conn_ramp_up: YesNo, should_close_conn_ramp_down: YesNo) -> Token[None]:
         """Set whether TCP payload transmission should take place during ramp-up and ramp-down.
 
         :param should_close_conn_ramp_up: whether TCP payload transmission should take place during ramp-up.
         :type should_close_conn_ramp_up: YesNo
         :param should_close_conn_ramp_down: whether TCP payload transmission should take place during ramp-down.
         :type should_close_conn_ramp_down: YesNo
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._group_xindex],
                 should_close_conn_ramp_up=should_close_conn_ramp_up,
-                should_close_conn_ramp_down=should_close_conn_ramp_down,
-            ),
+                should_close_conn_ramp_down=should_close_conn_ramp_down
+            )
         )
 
 
 @register_command
 @dataclass
 class P4G_RAW_TX_TIME_OFFSET:
     """
     Specify a time offset to the transmit start and stop time, if P4G_TX_DURING_RAMP` is set to ``NO`` for ramp-up and ramp-down respectively.
     """
 
     code: typing.ClassVar[int] = 661
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        start_offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specify time in milliseconds from ramp-up has completed to start of payload transmit.
-        stop_offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specify time in milliseconds from stop of payload transmit to start of ramp-down.
+    class GetDataAttr(ResponseBodyStruct):
+        start_offset: int = field(XmpInt())
+        """integer, specify time in milliseconds from ramp-up has completed to start of payload transmit."""
+        stop_offset: int = field(XmpInt())
+        """integer, specify time in milliseconds from stop of payload transmit to start of ramp-down."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        start_offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specify time in milliseconds from ramp-up has completed to start of payload transmit.
-        stop_offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specify time in milliseconds from stop of payload transmit to start of ramp-down.
+    class SetDataAttr(RequestBodyStruct):
+        start_offset: int = field(XmpInt())
+        """integer, specify time in milliseconds from ramp-up has completed to start of payload transmit."""
+        stop_offset: int = field(XmpInt())
+        """integer, specify time in milliseconds from stop of payload transmit to start of ramp-down."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the time offset to the transmit start and stop time.
 
         :return: the time offset to the transmit start and stop time
         :rtype: P4G_RAW_TX_TIME_OFFSET.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, start_offset: int, stop_offset: int) -> "Token":
+    def set(self, start_offset: int, stop_offset: int) -> Token[None]:
         """Set the time offset to the transmit start and stop time.
 
         :param start_offset: specify time in milliseconds from ramp-up has completed to start of payload transmit.
         :type start_offset: int
         :param stop_offset: specify time in milliseconds from stop of payload transmit to start of ramp-down.
         :type stop_offset: int
         """
+
         return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], start_offset=start_offset, stop_offset=stop_offset)
+            self._connection,
+            build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], start_offset=start_offset, stop_offset=stop_offset)
         )
 
 
 @register_command
 @dataclass
 class P4G_RAW_BURSTY_TX:
     """
     Enables or disables bursty transmission.
     """
 
     code: typing.ClassVar[int] = 662
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        bursty: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether bursty transmission is on or off.
+    class GetDataAttr(ResponseBodyStruct):
+        bursty: OnOff = field(XmpByte())
+        """coded byte, whether bursty transmission is on or off."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        bursty: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether bursty transmission is on or off.
+    class SetDataAttr(RequestBodyStruct):
+        bursty: OnOff = field(XmpByte())
+        """coded byte, whether bursty transmission is on or off."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether to use bursty transmission.
 
         :return: whether to use bursty transmission.
         :rtype: P4G_RAW_BURSTY_TX.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, bursty: OnOff) -> "Token":
+    def set(self, bursty: OnOff) -> Token[None]:
         """Set whether to use bursty transmission.
 
         :param bursty: whether bursty transmission is on or off.
         :type bursty: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], bursty=bursty))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable bursty transmission."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable bursty transmission."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_BURSTY_CONF:
     """
     Specifies active and inactive periods of bursty transmission in milliseconds. The burst period starts with the active part.
     """
 
     code: typing.ClassVar[int] = 663
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        active_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the duration in milliseconds of the active part of the burst period.
-        inactive_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the duration in milliseconds of the inactive part of the burst period.
+    class GetDataAttr(ResponseBodyStruct):
+        active_duration: int = field(XmpInt())
+        """integer, specifies the duration in milliseconds of the active part of the burst period."""
+        inactive_duration: int = field(XmpInt())
+        """integer, specifies the duration in milliseconds of the inactive part of the burst period."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        active_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the duration in milliseconds of the active part of the burst period.
-        inactive_duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the duration in milliseconds of the inactive part of the burst period.
+    class SetDataAttr(RequestBodyStruct):
+        active_duration: int = field(XmpInt())
+        """integer, specifies the duration in milliseconds of the active part of the burst period."""
+        inactive_duration: int = field(XmpInt())
+        """integer, specifies the duration in milliseconds of the inactive part of the burst period."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get active and inactive periods of bursty transmission in milliseconds.
 
         :return: active and inactive period of bursty transmission in milliseconds.
         :rtype: P4G_RAW_BURSTY_CONF.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, active_duration: int, inactive_duration: int) -> "Token":
+    def set(self, active_duration: int, inactive_duration: int) -> Token[None]:
         """Set active and inactive periods of bursty transmission in milliseconds.
 
         :param active_duration: specifies the duration in milliseconds of the active part of the burst period.
         :type active_duration: int
         :param inactive_duration: specifies the duration in milliseconds of the inactive part of the burst period.
         :type inactive_duration: int
         """
+
         return Token(
             self._connection,
-            build_set_request(
-                self, module=self._module, port=self._port, indices=[self._group_xindex], active_duration=active_duration, inactive_duration=inactive_duration
-            ),
+            build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], active_duration=active_duration, inactive_duration=inactive_duration)
         )
 
 
 @register_command
 @dataclass
 class P4G_VLAN_ENABLE:
     """
     Specify whether to insert a VLAN tag header upon transmit.
     """
 
     code: typing.ClassVar[int] = 664
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifying whether to enable VLAN tag
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """coded byte, specifying whether to enable VLAN tag"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifying whether to enable VLAN tag
+    class SetDataAttr(RequestBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """coded byte, specifying whether to enable VLAN tag"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether to insert a VLAN tag header upon transmit.
 
         :return: whether to insert a VLAN tag header upon transmit.
         :rtype: P4G_VLAN_ENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether to insert a VLAN tag header upon transmit.
 
         :param on_off: specifying whether to enable VLAN tag
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable VLAN tag insertion upon transmit."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable VLAN tag insertion upon transmit."""
 
 
 @register_command
 @dataclass
 class P4G_VLAN_TCI:
     """
     Specify the VLAN TCI.
     """
 
     code: typing.ClassVar[int] = 665
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        tci: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes, specifying the 16 bit TCI
+    class GetDataAttr(ResponseBodyStruct):
+        tci: Hex = field(XmpHex(size=2))
+        """two hex bytes, specifying the 16 bit TCI"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        tci: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes, specifying the 16 bit TCI
+    class SetDataAttr(RequestBodyStruct):
+        tci: Hex = field(XmpHex(size=2))
+        """two hex bytes, specifying the 16 bit TCI"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the VLAN TCI value.
 
         :return: the VLAN TCI value.
         :rtype: P4G_VLAN_TCI.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, tci: str) -> "Token":
+    def set(self, tci: Hex) -> Token[None]:
         """Set the VLAN TCI value.
 
         :param tci: specifying the 16 bit TCI
-        :type tci: str
+        :type tci: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], tci=tci))
 
 
 @register_command
 @dataclass
 class P4G_TIME_HIST_CONF:
     """
     Sets the start value and the interval size for the time histograms (P4G_TCP_ESTABLISH_HIST` and P4G_TCP_CLOSE_HIST`).
     """
 
     code: typing.ClassVar[int] = 666
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in us
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in us
+    class GetDataAttr(ResponseBodyStruct):
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in us"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in us"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in us
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in us
+    class SetDataAttr(RequestBodyStruct):
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in us"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in us"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the start value and the interval size for the time histograms.
 
         :return: the start value and the interval size for the time histograms.
         :rtype: P4G_TIME_HIST_CONF.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, start: int, interval: int) -> "Token":
+    def set(self, start: int, interval: int) -> Token[None]:
         """Set the start value and the interval size for the time histograms.
 
         :param start: start value of first histogram interval in microseconds
         :type start: int
         :param interval: histogram interval size in microseconds
         :type interval: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], start=start, interval=interval))
 
 
 @register_command
 @dataclass
 class P4G_PAYLOAD_HIST_CONF:
     """
     Sets the start value and the interval size for the payload histograms.
     """
 
     code: typing.ClassVar[int] = 667
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
+    class GetDataAttr(ResponseBodyStruct):
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
+    class SetDataAttr(RequestBodyStruct):
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the start value and the interval size for the payload histograms.
 
         :return: the start value and the interval size for the payload histograms.
         :rtype: P4G_PAYLOAD_HIST_CONF.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, start: int, interval: int) -> "Token":
+    def set(self, start: int, interval: int) -> Token[None]:
         """Set the start value and the interval size for the payload histograms.
 
         :param start: start value of first histogram interval in bytes
         :type start: int
         :param interval: histogram interval size in bytes
         :type interval: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], start=start, interval=interval))
 
 
 @register_command
 @dataclass
 class P4G_TRANSACTION_HIST_CONF:
     """
     Sets the start value and the interval size for the transaction histogram (P4G_APP_TRANSACTION_HIST`).
     """
 
     code: typing.ClassVar[int] = 668
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size
+    class GetDataAttr(ResponseBodyStruct):
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size
+    class SetDataAttr(RequestBodyStruct):
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the start value and the interval size for the transaction histogram.
 
         :return: the start value and the interval size for the transaction histogram
         :rtype: P4G_TRANSACTION_HIST_CONF.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, start: int, interval: int) -> "Token":
+    def set(self, start: int, interval: int) -> Token[None]:
         """Set the start value and the interval size for the transaction histogram.
 
         :param start: tart value of first histogram interval
         :type start: int
         :param interval: histogram interval size
         :type interval: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], start=start, interval=interval))
 
 
 @register_command
 @dataclass
 class P4G_RAW_RX_PAYLOAD_LEN:
     """
-    Specify the length of the payload the Client should expect to receive before sending the next download request to the Server. Should be configured identical to the P4G_RAW_PAYLOAD_TOTAL_LEN` for the Server. If mode is set to INFINITE, effectively no request/response repetitions will be performed.
+    Specify the length of the payload the Client should expect to receive before sending the next download request to the Server.
+    Should be configured identical to the P4G_RAW_PAYLOAD_TOTAL_LEN` for the Server. If mode is set to INFINITE, effectively no request/response repetitions will be performed.
 
     .. note::
 
         This parameter is N/A when P4G_L4_PROTOCOL` is configured as UDP.
 
     """
 
     code: typing.ClassVar[int] = 669
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, specifying the payload length mode
-        length: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, number of payload bytes the client should receive before sending the next request, if mode is FINITE.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, specifying the payload length mode"""
+        length: int = field(XmpLong())
+        """long integer, number of payload bytes the client should receive before sending the next request, if mode is FINITE."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, specifying the payload length mode
-        length: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, number of payload bytes the client should receive before sending the next request, if mode is FINITE.
+    class SetDataAttr(RequestBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, specifying the payload length mode"""
+        length: int = field(XmpLong())
+        """long integer, number of payload bytes the client should receive before sending the next request, if mode is FINITE."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the length of the payload the Client should expect to receive before sending the next download request to the Server.
 
         :return: the length of the payload the Client should expect to receive before sending the next download request to the Server.
         :rtype: P4G_RAW_RX_PAYLOAD_LEN.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: InfiniteOrFinite, length: int) -> "Token":
+    def set(self, mode: InfiniteOrFinite, length: int) -> Token[None]:
         """Set the length of the payload the Client should expect to receive before sending the next download request to the Server.
 
         :param mode: specifying the payload length mode
         :type mode: InfiniteOrFinite
         :param length: number of payload bytes the client should receive before sending the next request, if mode is ``FINITE``.
         :type length: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, length=length))
 
     set_infinite = functools.partialmethod(set, InfiniteOrFinite.INFINITE)
     """Expects payload as long as test is running."""
+
     set_finite = functools.partialmethod(set, InfiniteOrFinite.FINITE)
     """Expects a number of bytes of payload defined by the command."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_REQUEST_REPEAT:
@@ -3269,1027 +3580,1351 @@
         This parameter is N/A when P4G_L4_PROTOCOL` is configured as UDP.
 
     """
 
     code: typing.ClassVar[int] = 670
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, specifying the transaction mode.
-        repeat: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of request/response transactions to perform , if mode is FINITE.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, specifying the transaction mode."""
+        repeat: int = field(XmpInt())
+        """integer, number of request/response transactions to perform , if mode is FINITE."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, specifying the transaction mode.
-        repeat: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of request/response transactions to perform , if mode is FINITE.
+    class SetDataAttr(RequestBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, specifying the transaction mode."""
+        repeat: int = field(XmpInt())
+        """integer, number of request/response transactions to perform , if mode is FINITE."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of request/response transactions to perform.
 
         :return: the number of request/response transactions to perform
         :rtype: P4G_RAW_REQUEST_REPEAT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: InfiniteOrFinite, repeat: int) -> "Token":
+    def set(self, mode: InfiniteOrFinite, repeat: int) -> Token[None]:
         """Set the number of request/response transactions to perform.
 
         :param mode: specifying the transaction mode.
         :type mode: InfiniteOrFinite
         :param repeat: number of request/response transactions to perform , if mode is ``FINITE``.
         :type repeat: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, repeat=repeat))
 
     set_infinite = functools.partialmethod(set, InfiniteOrFinite.INFINITE)
     """Repeats request/response transactions as long as test is running."""
+
     set_finite = functools.partialmethod(set, InfiniteOrFinite.FINITE)
     """Stop generating request/response transactions after a number of cycles"""
 
 
 @register_command
 @dataclass
 class P4G_RAW_CONN_INCARNATION:
     """
     Defines the lifecycle of a connection and how new connections should be established as old connections are closed.
     """
 
     code: typing.ClassVar[int] = 671
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LifecycleMode)  # coded byte, defines the lifecycle of connections
+    class GetDataAttr(ResponseBodyStruct):
+        mode: LifecycleMode = field(XmpByte())
+        """coded byte, defines the lifecycle of connections"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LifecycleMode)  # coded byte, defines the lifecycle of connections
+    class SetDataAttr(RequestBodyStruct):
+        mode: LifecycleMode = field(XmpByte())
+        """coded byte, defines the lifecycle of connections"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the lifecycle of a connection and how new connections should be established.
 
         :return: the lifecycle of a connection and how new connections should be established.
         :rtype: P4G_RAW_CONN_INCARNATION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: LifecycleMode) -> "Token":
+    def set(self, mode: LifecycleMode) -> Token[None]:
         """Set the lifecycle of a connection and how new connections should be established.
 
         :param mode: connection lifecycle mode
         :type mode: LifecycleMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode))
 
     set_once = functools.partialmethod(set, LifecycleMode.ONCE)
     """Connections are established during the ramp-up phase and not closed until the ramp-down phase of the load profile. That is, each configured connection only exists once."""
+
     set_immortal = functools.partialmethod(set, LifecycleMode.IMMORTAL)
-    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by P4G_RAW_CONN_LIFETIME`). As connections close, new connections are established, attempting to keep the concurrent number of established connections constant. A new connection will have the same IP address as the connection it replaces, but will have a new TCP port number. This will simulate that the user (defined by the client IP address) is living on, and creates new connections as old connections close."""
+    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by P4G_RAW_CONN_LIFETIME`).
+    As connections close, new connections are established, attempting to keep the concurrent number of established connections constant.
+    A new connection will have the same IP address as the connection it replaces, but will have a new TCP port number.
+    This will simulate that the user (defined by the client IP address) is living on, and creates new connections as old connections close.
+    """
+
     set_reincarnate = functools.partialmethod(set, LifecycleMode.REINCARNATE)
-    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by P4G_RAW_CONN_LIFETIME`). As connections close, new connections are established, attempting to keep the concurrent number of established connections constant. A new connection will have the same TCP port number as the connection it replaces, but will have a new IP address. This will simulate that the user (defined by the client IP address) ceases to exist, and new users appear as old users die."""
+    """Connections are established during the ramp-up phase of the load profile, and are closed after the configured lifetime (configured by P4G_RAW_CONN_LIFETIME`).
+    As connections close, new connections are established, attempting to keep the concurrent number of established connections constant.
+    A new connection will have the same TCP port number as the connection it replaces, but will have a new IP address.
+    This will simulate that the user (defined by the client IP address) ceases to exist, and new users appear as old users die.
+    """
 
 
 @register_command
 @dataclass
 class P4G_RAW_CONN_REPETITIONS:
     """
     Defines how many times a new connection should be created, after an old
     connection has been closed, when P4G_RAW_CONN_INCARNATION` is set to ``IMMORTAL`` or
     ``REINCARNATE``.
     """
 
     code: typing.ClassVar[int] = 672
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, repetition mode.
-        repetition_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of repetitions
+    class GetDataAttr(ResponseBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, repetition mode."""
+        repetition_count: int = field(XmpInt())
+        """integer, number of repetitions"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, repetition mode.
-        repetition_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of repetitions
+    class SetDataAttr(RequestBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, repetition mode."""
+        repetition_count: int = field(XmpInt())
+        """integer, number of repetitions"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get how many times a new connection should be created after an old connection is closed.
 
         :return: how many times a new connection should be created after an old connection is closed.
         :rtype: P4G_RAW_CONN_REPETITIONS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: InfiniteOrFinite, repetition_count: int) -> "Token":
+    def set(self, mode: InfiniteOrFinite, repetition_count: int) -> Token[None]:
         """Set how many times a new connection should be created after an old connection is closed.
 
         :param mode: repetition mode.
         :type mode: InfiniteOrFinite
         :param repetition_count:  number of repetitions
         :type repetition_count: int
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, repetition_count=repetition_count)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, repetition_count=repetition_count))
 
     set_infinite = functools.partialmethod(set, InfiniteOrFinite.INFINITE)
     """New connections are generated as long as the load profile allows."""
+
     set_finite = functools.partialmethod(set, InfiniteOrFinite.FINITE)
     """Each configured connection is closed and re-established repetitions number of times."""
 
 
 @register_command
 @dataclass
 class P4G_RAW_CONN_LIFETIME:
     """
     Defines the lifetime of a connection, when P4G_RAW_CONN_INCARNATION` is set to ``IMMORTAL`` or ``REINCARNATE``.
     """
 
     code: typing.ClassVar[int] = 673
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        timescale: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=Timescale)  # coded byte, specifying the time scale
-        lifetime: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, time from a connection is established until it will be closed.
+    class GetDataAttr(ResponseBodyStruct):
+        timescale: Timescale = field(XmpByte())
+        """coded byte, specifying the time scale"""
+        lifetime: int = field(XmpInt())
+        """integer, time from a connection is established until it will be closed."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        timescale: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=Timescale)  # coded byte, specifying the time scale
-        lifetime: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, time from a connection is established until it will be closed.
+    class SetDataAttr(RequestBodyStruct):
+        timescale: Timescale = field(XmpByte())
+        """coded byte, specifying the time scale"""
+        lifetime: int = field(XmpInt())
+        """integer, time from a connection is established until it will be closed."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the lifetime of a connection.
 
         :return: the lifetime of a connection
         :rtype: P4G_RAW_CONN_LIFETIME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, timescale: Timescale, lifetime: int) -> "Token":
+    def set(self, timescale: Timescale, lifetime: int) -> Token[None]:
         """Set the lifetime of a connection.
 
         :param timescale: specifying the time scale
         :type timescale: Timescale
         :param lifetime: time from a connection is established until it will be closed.
         :type lifetime: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], timescale=timescale, lifetime=lifetime))
 
     set_msecs = functools.partialmethod(set, Timescale.MSECS)
     """Set the time scale of a connection lifetime to milliseconds."""
+
     set_seconds = functools.partialmethod(set, Timescale.SECONDS)
     """Set the time scale of a connection lifetime to seconds."""
+
     set_minutes = functools.partialmethod(set, Timescale.MINUTES)
     """Set the time scale of a connection lifetime to minutes."""
+
     set_hours = functools.partialmethod(set, Timescale.HOURS)
     """Set the time scale of a connection lifetime to hours."""
 
 
 @register_command
 @dataclass
 class P4G_IP_VERSION:
     """
     Specifies either IPv4 or IPv6.
     """
 
     code: typing.ClassVar[int] = 684
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        version_number: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47IPVersion)  # coded byte, IP version
+    class GetDataAttr(ResponseBodyStruct):
+        version_number: L47IPVersion = field(XmpByte())
+        """coded byte, IP version"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        version_number: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47IPVersion)  # coded byte, IP version
+    class SetDataAttr(RequestBodyStruct):
+        version_number: L47IPVersion = field(XmpByte())
+        """coded byte, IP version"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IP version of a Connection Group.
 
         :return: the IP version of a Connection Group.
         :rtype: P4G_IP_VERSION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, version_number: L47IPVersion) -> "Token":
+    def set(self, version_number: L47IPVersion) -> Token[None]:
         """Set the IP version of a Connection Group.
 
         :param version_number: IP version
         :type version_number: L47IPVersion
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], version_number=version_number))
 
     set_ipv4 = functools.partialmethod(set, L47IPVersion.IPV4)
     """Set IP version to IPv4."""
+
     set_ipv6 = functools.partialmethod(set, L47IPVersion.IPV6)
     """Set IP version to IPv6."""
 
 
 @register_command
 @dataclass
 class P4G_IPV6_CLIENT_RANGE:
     """
     Specifies the number of client sockets (IPv6 address, port number).
     """
 
     code: typing.ClassVar[int] = 685
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
-        max_address_count: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
-        max_address_count: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE
+    class GetDataAttr(ResponseBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
+        max_address_count: int = field(XmpLong())
+        """long integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE"""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
+        max_address_count: int = field(XmpLong())
+        """long integer, the maximum number of ip addresses that this Connection Group will use, when connection incarnation is set to REINCARNATE"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of client sockets (IPv6 address, port number).
 
         :return: the number of client sockets (IPv6 address, port number).
         :rtype: P4G_IPV6_CLIENT_RANGE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ipv6_address: typing.Union[str, int, ipaddress.IPv6Address], address_count: int, start_port: int, port_count: int, max_address_count: int) -> "Token":
+    def set(self, ipv6_address: ipaddress.IPv6Address, address_count: int, start_port: int, port_count: int, max_address_count: int) -> Token[None]:
         """Set the number of client sockets (IPv6 address, port number).
 
         :param ipv6_address: the start ip address of the address range
-        :type ipv6_address: typing.Union[str, int, ipaddress.IPv6Address]
+        :type ipv6_address: ipaddress.IPv6Address
         :param address_count: the number of IPv6 addresses
         :type address_count: int
         :param start_port: the start port number of the port range
         :type start_port: int
         :param port_count: the number of ports
         :type port_count: int
         :param max_address_count: the maximum number of IPv6 addresses that this Connection Group will use, when connection incarnation is set to ``REINCARNATE``
         :type max_address_count: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._group_xindex],
                 ipv6_address=ipv6_address,
                 address_count=address_count,
                 start_port=start_port,
                 port_count=port_count,
-                max_address_count=max_address_count,
-            ),
+                max_address_count=max_address_count
+            )
         )
 
 
 @register_command
 @dataclass
 class P4G_IPV6_SERVER_RANGE:
     """
     Specifies the number of server sockets (IPv6 address, port number)
     """
 
     code: typing.ClassVar[int] = 686
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # hex bytes, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # hex bytes, the start ip address of the address range
-        address_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ip addresses
-        start_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the start port number, of the port range
-        port_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of ports
+    class GetDataAttr(ResponseBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """hex bytes, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """hex bytes, the start ip address of the address range"""
+        address_count: int = field(XmpInt())
+        """integer, the number of ip addresses"""
+        start_port: int = field(XmpInt())
+        """integer, the start port number, of the port range"""
+        port_count: int = field(XmpInt())
+        """integer, the number of ports"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of server sockets (IPv6 address, port number).
 
         :return: the number of server sockets (IPv6 address, port number)
         :rtype: P4G_IPV6_SERVER_RANGE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ipv6_address: typing.Union[str, int, ipaddress.IPv6Address], address_count: int, start_port: int, port_count: int) -> "Token":
+    def set(self, ipv6_address: ipaddress.IPv6Address, address_count: int, start_port: int, port_count: int) -> Token[None]:
         """Set the number of server sockets (IPv6 address, port number).
 
         :param ipv6_address: the start IPv6 address of the address range
-        :type ipv6_address: typing.Union[str, int, ipaddress.IPv6Address]
+        :type ipv6_address: ipaddress.IPv6Address
         :param address_count: the number of IPv6 addresses
         :type address_count: int
         :param start_port: the start port number of the port range
         :type start_port: int
         :param port_count: the number of ports
         :type port_count: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._group_xindex],
                 ipv6_address=ipv6_address,
                 address_count=address_count,
                 start_port=start_port,
-                port_count=port_count,
-            ),
+                port_count=port_count
+            )
         )
 
 
 @register_command
 @dataclass
 class P4G_IPV6_TRAFFIC_CLASS:
     """
     Configure the value of the traffic class field of the IPv6 header.
     """
 
     code: typing.ClassVar[int] = 687
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        traffic_class: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, value of the traffic class field
+    class GetDataAttr(ResponseBodyStruct):
+        traffic_class: Hex = field(XmpHex(size=1))
+        """hex byte, value of the traffic class field"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        traffic_class: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, value of the traffic class field
+    class SetDataAttr(RequestBodyStruct):
+        traffic_class: Hex = field(XmpHex(size=1))
+        """hex byte, value of the traffic class field"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value of the traffic class field of the IPv6 header.
 
         :return: the value of the traffic class field of the IPv6 header.
         :rtype: P4G_IPV6_TRAFFIC_CLASS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, traffic_class: str) -> "Token":
+    def set(self, traffic_class: Hex) -> Token[None]:
         """Set the value of the traffic class field of the IPv6 header.
 
         :param traffic_class: value of the traffic class field
-        :type traffic_class: str
+        :type traffic_class: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], traffic_class=traffic_class))
 
 
 @register_command
 @dataclass
 class P4G_IPV6_FLOW_LABEL:
     """
     Configure the value of the flow label field of the IPv6 header.
     """
 
     code: typing.ClassVar[int] = 688
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        flow_label: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # 4 hex bytes, value of the traffic class field (only lowest 20 bits are valid)
+    class GetDataAttr(ResponseBodyStruct):
+        flow_label: Hex = field(XmpHex(size=4))
+        """4 hex bytes, value of the traffic class field (only lowest 20 bits are valid)"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        flow_label: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # 4 hex bytes, value of the traffic class field (only lowest 20 bits are valid)
+    class SetDataAttr(RequestBodyStruct):
+        flow_label: Hex = field(XmpHex(size=4))
+        """4 hex bytes, value of the traffic class field (only lowest 20 bits are valid)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value of the flow label field of the IPv6 header.
 
         :return: the value of the flow label field of the IPv6 header.
         :rtype: P4G_IPV6_FLOW_LABEL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, flow_label: str) -> "Token":
+    def set(self, flow_label: Hex) -> Token[None]:
         """Set the value of the flow label field of the IPv6 header.
 
         :param flow_label: value of the traffic class field (only lowest 20 bits are valid)
-        :type flow_label: str
+        :type flow_label: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], flow_label=flow_label))
 
 
 @register_command
 @dataclass
 class P4G_L4_PROTOCOL:
     """
     Specifies either TCP or UDP as Layer 4 protocol.
     """
 
     code: typing.ClassVar[int] = 689
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        protocol_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47ProtocolType)  # coded byte, layer 4 protocol.
+    class GetDataAttr(ResponseBodyStruct):
+        protocol_type: L47ProtocolType = field(XmpByte())
+        """coded byte, layer 4 protocol."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        protocol_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L47ProtocolType)  # coded byte, layer 4 protocol.
+    class SetDataAttr(RequestBodyStruct):
+        protocol_type: L47ProtocolType = field(XmpByte())
+        """coded byte, layer 4 protocol."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Layer 4 protocol used by the Connection Group.
 
         :return: the Layer 4 protocol used by the Connection Group.
         :rtype: P4G_L4_PROTOCOL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, protocol_type: L47ProtocolType) -> "Token":
+    def set(self, protocol_type: L47ProtocolType) -> Token[None]:
         """Set the Layer 4 protocol used by the Connection Group.
 
         :param protocol_type: the Layer 4 protocol
         :type protocol_type: L47ProtocolType
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], protocol_type=protocol_type))
 
     set_tcp = functools.partialmethod(set, L47ProtocolType.TCP)
     """Use TCP as the Layer 4 protocol of the Connection Group."""
+
     set_udp = functools.partialmethod(set, L47ProtocolType.UDP)
     """Use UDP as the Layer 4 protocol of the Connection Group."""
 
 
 @register_command
 @dataclass
 class P4G_TCP_ESTABLISH_HIST:
     """
     Returns a histogram over TCP connection establish times, with start and interval values as configured by P4G_TIME_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 741
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections established.
-        min_connection_estab_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum connection establish time in us.
-        max_connection_estab_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum connection establish time in us.
-        avg_connection_estab_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average connection establish time in us.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in us
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in us
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with establish time within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections established."""
+        min_connection_estab_time: int = field(XmpLong())
+        """long integer, minimum connection establish time in us."""
+        max_connection_estab_time: int = field(XmpLong())
+        """long integer, maximum connection establish time in us."""
+        avg_connection_estab_time: int = field(XmpLong())
+        """long integer, average connection establish time in us."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in us"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in us"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections with establish time within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over TCP connection establish times.
 
         :return: a histogram over TCP connection establish times
         :rtype: P4G_TCP_ESTABLISH_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_CLOSE_HIST:
     """
     Returns a histogram over TCP connection close times, with start and interval values as configured by P4G_TIME_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 742
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections closed.
-        min_connection_close_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum connection close time in us.
-        max_connection_close_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum connection close time in us.
-        avg_connection_close_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average connection close time in us.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in us
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in us
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with close time within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer, number of connections closed."""
+        min_connection_close_time: int = field(XmpLong())
+        """long integer, minimum connection close time in us."""
+        max_connection_close_time: int = field(XmpLong())
+        """long integer, maximum connection close time in us."""
+        avg_connection_close_time: int = field(XmpLong())
+        """long integer, average connection close time in us."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in us"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in us"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections with close time within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over TCP connection close times.
 
         :return: a histogram over TCP connection close times
         :rtype: P4G_TCP_CLOSE_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_RX_TOTAL_BYTES_HIST:
     """
     Returns a histogram over number of total TCP bytes received, with start and interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 743
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum total TCP bytes received on a connection.
-        max_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum total TCP bytes received on a connection.
-        avg_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average total TCP bytes received on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received total TCP bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections."""
+        min_byte_count: int = field(XmpLong())
+        """long integer, minimum total TCP bytes received on a connection."""
+        max_byte_count: int = field(XmpLong())
+        """long integer, maximum total TCP bytes received on a connection."""
+        avg_byte_count: int = field(XmpLong())
+        """long integer, average total TCP bytes received on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has received total TCP bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of total TCP bytes received.
 
         :return: a histogram over number of total TCP bytes received
         :rtype: P4G_TCP_RX_TOTAL_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_RX_GOOD_BYTES_HIST:
     """
     Returns a histogram over number of good TCP bytes received, with start and interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 744
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum good TCP bytes received on a connection.
-        max_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum good TCP bytes received on a connection.
-        avg: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average good TCP bytes received on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received good TCP bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections."""
+        min_byte_count: int = field(XmpLong())
+        """long integer, minimum good TCP bytes received on a connection."""
+        max_byte_count: int = field(XmpLong())
+        """long integer, maximum good TCP bytes received on a connection."""
+        avg: int = field(XmpLong())
+        """long integer, average good TCP bytes received on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has received good TCP bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of good TCP bytes received.
 
         :return: a histogram over number of good TCP bytes received
         :rtype: P4G_TCP_RX_GOOD_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_TX_TOTAL_BYTES_HIST:
     """
     Returns a histogram over number of total TCP bytes transmitted, with start and interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 745
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum total TCP bytes transmitted on a connection.
-        max_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum total TCP bytes transmitted on a connection.
-        avg_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average total TCP bytes transmitted on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted total TCP bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections."""
+        min_byte_count: int = field(XmpLong())
+        """long integer, minimum total TCP bytes transmitted on a connection."""
+        max_byte_count: int = field(XmpLong())
+        """long integer, maximum total TCP bytes transmitted on a connection."""
+        avg_byte_count: int = field(XmpLong())
+        """long integer, average total TCP bytes transmitted on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has transmitted total TCP bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of total TCP bytes transmitted.
 
         :return: a histogram over number of total TCP bytes transmitted
         :rtype: P4G_TCP_TX_TOTAL_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_TX_GOOD_BYTES_HIST:
     """
     Returns a histogram over number of good TCP bytes transmitted, with start and interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 746
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        conn: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum good TCP bytes transmitted on a connection.
-        max: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum good TCP bytes transmitted on a connection.
-        average: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average good TCP bytes transmitted on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted good TCP bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        conn: int = field(XmpInt())
+        """integer,number of connections."""
+        min: int = field(XmpLong())
+        """long integer, minimum good TCP bytes transmitted on a connection."""
+        max: int = field(XmpLong())
+        """long integer, maximum good TCP bytes transmitted on a connection."""
+        average: int = field(XmpLong())
+        """long integer, average good TCP bytes transmitted on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has transmitted good TCP bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of good TCP bytes transmitted.
 
         :return: a histogram over number of good TCP bytes transmitted
         :rtype: P4G_TCP_TX_GOOD_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_APP_REPLAY_COUNTERS:
     """
     Returns NAT collisions of a replay application.
     """
 
     code: typing.ClassVar[int] = 747
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        nat_collision_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of NAT collisions
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        nat_collision_count: int = field(XmpLong())
+        """long integer, number of NAT collisions"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get NAT collisions of a replay application.
 
         :return: NAT collisions of a replay application.
         :rtype: P4G_APP_REPLAY_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_APP_TRANSACTION_COUNTERS:
     """
     Returns request/response transaction statistics.
     """
 
     code: typing.ClassVar[int] = 753
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        transaction_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of completed request/response transactions
-        transaction_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of completed transactions/second
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        transaction_count: int = field(XmpLong())
+        """long integer, number of completed request/response transactions"""
+        transaction_per_second: int = field(XmpLong())
+        """long integer, number of completed transactions/second"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get request/response transaction statistics.
 
         :return: request/response transaction statistics.
         :rtype: P4G_APP_TRANSACTION_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_APP_TRANSACTION_HIST:
     """
     Returns a histogram over completed request/response transactions per connection,
     with start and interval values as configured by P4G_TRANSACTION_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 754
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections.
-        min_transaction_per_con: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum number of transactions per connection.
-        max_transaction_per_con: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum number of transactions per connection.
-        avg_transaction_per_con: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average number of transactions per connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with number of transactions within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer, number of connections."""
+        min_transaction_per_con: int = field(XmpLong())
+        """long integer, minimum number of transactions per connection."""
+        max_transaction_per_con: int = field(XmpLong())
+        """long integer, maximum number of transactions per connection."""
+        avg_transaction_per_con: int = field(XmpLong())
+        """long integer, average number of transactions per connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections with number of transactions within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over completed request/response transactions per connection.
 
         :return: a histogram over completed request/response transactions per connection
         :rtype: P4G_APP_TRANSACTION_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_STATE_CURRENT:
     """
@@ -4303,33 +4938,38 @@
     * ``ACTIVE``. The connection is actively transmitting data.
 
     """
 
     code: typing.ClassVar[int] = 756
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        closed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        opened: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        active: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        closed: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        opened: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        active: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the current UDP state counters.
 
         :return: a list of the current UDP state counters
         :rtype: P4G_UDP_STATE_CURRENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_STATE_TOTAL:
     """
@@ -4343,33 +4983,38 @@
     * ``ACTIVE`` The connection is actively transmitting data.
 
     """
 
     code: typing.ClassVar[int] = 757
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        closed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        opened: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        active: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        closed: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        opened: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        active: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the total UDP state counters.
 
         :return: a list of the total UDP state counters.
         :rtype: P4G_UDP_STATE_TOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_STATE_RATE:
     """
@@ -4383,512 +5028,589 @@
     * ``ACTIVE`` The connection is actively transmitting data.
 
     """
 
     code: typing.ClassVar[int] = 758
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        closed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        open: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        active: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        closed: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        open: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        active: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the UDP state rates measured in connections/second.
 
         :return: a list of the UDP state rates measured in connections/second.
         :rtype: P4G_UDP_STATE_RATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_RX_PAYLOAD_COUNTERS:
     """
     Returns a list of the UDP RX payload counters.
     """
 
     code: typing.ClassVar[int] = 759
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP payload bytes received
-        byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP payload bytes/second received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        byte_count: int = field(XmpLong())
+        """long integer, number of UDP payload bytes received"""
+        byte_per_second: int = field(XmpLong())
+        """long integer, number of UDP payload bytes/second received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the UDP RX payload counters.
 
         :return: a list of the UDP RX payload counters.
         :rtype: P4G_UDP_RX_PAYLOAD_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_TX_PAYLOAD_COUNTERS:
     """
     Returns a list of the UDP TX payload counters.
     """
 
     code: typing.ClassVar[int] = 760
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP payload bytes transmitted
-        byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP payload bytes/second transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        byte_count: int = field(XmpLong())
+        """long integer, number of UDP payload bytes transmitted"""
+        byte_per_second: int = field(XmpLong())
+        """long integer, number of UDP payload bytes/second transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the UDP TX payload counters.
 
         :return: a list of the UDP TX payload counters.
         :rtype: P4G_UDP_TX_PAYLOAD_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_RX_BYTES_HIST:
     """
     Returns a histogram over number of UDP bytes received, with start and interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 761
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum UDP bytes received on a connection.
-        max_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum UDP bytes received on a connection.
-        avg_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average UDP bytes received on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received UDP bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections."""
+        min_byte_count: int = field(XmpLong())
+        """long integer, minimum UDP bytes received on a connection."""
+        max_byte_count: int = field(XmpLong())
+        """long integer, maximum UDP bytes received on a connection."""
+        avg_byte_count: int = field(XmpLong())
+        """long integer, average UDP bytes received on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has received UDP bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of UDP bytes received.
 
         :return: a histogram over number of UDP bytes received
         :rtype: P4G_UDP_RX_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_TX_BYTES_HIST:
     """
     Returns a histogram over number of UDP bytes transmitted, with start and interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 762
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum UDP bytes transmitted on a connection.
-        max_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum UDP bytes transmitted on a connection.
-        avg_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average UDP bytes transmitted on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted UDP bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections."""
+        min_byte_count: int = field(XmpLong())
+        """long integer, minimum UDP bytes transmitted on a connection."""
+        max_byte_count: int = field(XmpLong())
+        """long integer, maximum UDP bytes transmitted on a connection."""
+        avg_byte_count: int = field(XmpLong())
+        """long integer, average UDP bytes transmitted on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has transmitted UDP bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of UDP bytes transmitted.
 
         :return: a histogram over number of UDP bytes transmitted
         :rtype: P4G_UDP_TX_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_RX_PACKET_COUNTERS:
     """
     Returns a list of the TCP RX packet counters.
     """
 
     code: typing.ClassVar[int] = 770
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP packets received
-        packet_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP packets/second received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, number of TCP packets received"""
+        packet_per_second: int = field(XmpLong())
+        """long integer, number of TCP packets/second received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TCP RX packet counters.
 
         :return: a list of the TCP RX packet counters.
         :rtype: P4G_TCP_RX_PACKET_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TCP_TX_PACKET_COUNTERS:
     """
     Returns a list of the TCP TX packet counters.
     """
 
     code: typing.ClassVar[int] = 771
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP packets transmitted
-        packet_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TCP packets/second transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, number of TCP packets transmitted"""
+        packet_per_second: int = field(XmpLong())
+        """long integer, number of TCP packets/second transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TCP TX packet counters.
 
         :return: a list of the TCP TX packet counters.
         :rtype: P4G_TCP_TX_PACKET_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_RX_PACKET_COUNTERS:
     """
     Returns a list of the UDP RX packet counters.
     """
 
     code: typing.ClassVar[int] = 772
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP packets received
-        packet_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP packets/second received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, number of UDP packets received"""
+        packet_per_second: int = field(XmpLong())
+        """long integer, number of UDP packets/second received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the UDP RX packet counters.
 
         :return: a list of the UDP RX packet counters.
         :rtype: P4G_UDP_RX_PACKET_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_UDP_TX_PACKET_COUNTERS:
     """
     Returns a list of the UDP TX packet counters.
     """
 
     code: typing.ClassVar[int] = 773
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        packet_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP packets transmitted
-        packet_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of UDP packets/second transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        packet_count: int = field(XmpLong())
+        """long integer, number of UDP packets transmitted"""
+        packet_per_second: int = field(XmpLong())
+        """long integer, number of UDP packets/second transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the UDP TX packet counters.
 
         :return: a list of the UDP TX packet counters.
         :rtype: P4G_UDP_TX_PACKET_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_CLEAR_POST_STAT:
     """
     Clears all TCP Connection Group post-test statistics.
     """
 
     code: typing.ClassVar[int] = 790
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Clears all TCP Connection Group post-test statistics.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._group_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_RECALC_TIME_HIST:
     """
-    Recalculates connection time histograms (retrieved with: P4G_TCP_ESTABLISH_HIST` and P4G_TCP_CLOSE_HIST`). Used in case time histogram configuration has been changed (using P4G_TIME_HIST_CONF`).
+    Recalculates connection time histograms (retrieved with: P4G_TCP_ESTABLISH_HIST` and P4G_TCP_CLOSE_HIST`).
+    Used in case time histogram configuration has been changed (using P4G_TIME_HIST_CONF`).
     """
 
     code: typing.ClassVar[int] = 791
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Recalculates connection time histograms
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._group_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_RECALC_PAYLOAD_HIST:
     """
-    Recalculates connection payload histograms (retrieved with: P4G_TCP_RX_TOTAL_BYTES_HIST`, P4G_TCP_RX_GOOD_BYTES_HIST`, P4G_TCP_TX_TOTAL_BYTES_HIST` and P4G_TCP_TX_GOOD_BYTES_HIST`). Used in case
-    payload histogram configuration has been changed (using P4G_PAYLOAD_HIST_CONF`)
+    Recalculates connection payload histograms (retrieved with:
+    P4G_TCP_RX_TOTAL_BYTES_HIST`, P4G_TCP_RX_GOOD_BYTES_HIST`, P4G_TCP_TX_TOTAL_BYTES_HIST` and P4G_TCP_TX_GOOD_BYTES_HIST`).
+    Used in case payload histogram configuration has been changed (using P4G_PAYLOAD_HIST_CONF`)
     """
 
     code: typing.ClassVar[int] = 792
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Recalculates connection payload histograms.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._group_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_RECALC_TRANSACTION_HIST:
     """
     Recalculates transaction histograms (retrieved with: P4G_APP_TRANSACTION_HIST`).
     Used in case transaction histogram configuration has been changed (using P4G_TRANSACTION_HIST_CONF`)
     """
 
     code: typing.ClassVar[int] = 793
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Recalculates transaction histograms.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._group_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_REPLAY_FILE_INDICES:
     """
     Returns an index list of configured Replay Files for this Connection Group.
-    These are the Replay File Index that are used for P4G_REPLAY_FILE_NAME` and P4G_REPLAY_FILE_CLEAR` commands.  More than one Replay File can be configured for a Connection Group. When configuring a Replay File for a Connection Group, it must have an index.
+    These are the Replay File Index that are used for P4G_REPLAY_FILE_NAME` and P4G_REPLAY_FILE_CLEAR` commands.
+    More than one Replay File can be configured for a Connection Group. When configuring a Replay File for a Connection Group, it must have an index.
     """
 
     code: typing.ClassVar[int] = 900
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        replay_file_indices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, indices of configured replay files
+    class GetDataAttr(ResponseBodyStruct):
+        replay_file_indices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, indices of configured replay files"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get an index list of configured Replay Files for this Connection Group.
 
         :return: an index list of configured Replay Files for this Connection Group.
         :rtype: P4G_REPLAY_FILE_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_REPLAY_FILE_NAME:
     """
@@ -4896,216 +5618,229 @@
     configuring a Replay File for a Connection Group, it must have an index. The
     indices at which Replay Files are configured does not have to be continuous.
     """
 
     code: typing.ClassVar[int] = 901
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
     _replay_file_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        file_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, file name (including relative path and excluding the '.bson' extension).
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        file_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, file name (including relative path and excluding the '.bson' extension).
+    class GetDataAttr(ResponseBodyStruct):
+        file_name: str = field(XmpStr())
+        """string, file name (including relative path and excluding the '.bson' extension)."""
+
+    class SetDataAttr(RequestBodyStruct):
+        file_name: str = field(XmpStr())
+        """string, file name (including relative path and excluding the '.bson' extension)."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the name of a replay file configured for the Connection Group.
 
         :return: the name of a replay file configured for the Connection Group.
         :rtype: P4G_REPLAY_FILE_NAME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex, self._replay_file_xindex]))
 
-    def set(self, file_name: str) -> "Token":
+    def set(self, file_name: str) -> Token[None]:
         """Set the name of a replay file configured for the Connection Group.
 
         :param file_name: file name (including relative path and excluding the ``.bson`` extension).
         :type file_name: str
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex, self._replay_file_xindex], file_name=file_name)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex, self._replay_file_xindex], file_name=file_name))
 
 
 @register_command
 @dataclass
 class P4G_REPLAY_FILE_CLEAR:
     """
     Clears a Replay File index, so no Replay File is configured for that index.
     """
 
     code: typing.ClassVar[int] = 902
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _replay_file_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Clears a Replay File index.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._replay_file_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._replay_file_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_REPLAY_UTILIZATION:
     """
     Specify the link layer bandwidth utilization for all the generated traffic from
     the specified Replay Connection Group.
     """
 
     code: typing.ClassVar[int] = 903
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        utilization: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, utilization specified in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        utilization: int = field(XmpInt())
+        """integer, utilization specified in ppm."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        utilization: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, utilization specified in ppm.
+    class SetDataAttr(RequestBodyStruct):
+        utilization: int = field(XmpInt())
+        """integer, utilization specified in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the link layer bandwidth utilization for all the generated traffic from the specified Replay Connection Group.
 
         :return: the link layer bandwidth utilization for all the generated traffic from the specified Replay Connection Group.
         :rtype: P4G_REPLAY_UTILIZATION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, utilization: int) -> "Token":
+    def set(self, utilization: int) -> Token[None]:
         """Set the link layer bandwidth utilization for all the generated traffic from the specified Replay Connection Group.
 
         :param utilization: utilization specified in ppm.
         :type utilization: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], utilization=utilization))
 
 
 @register_command
 @dataclass
 class P4G_REPLAY_USER_INCARNATION:
     """
     Defines the lifecycle mode of a user and its connections, and how new users should be
     established as old connections are closed.
     """
 
     code: typing.ClassVar[int] = 904
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LifecycleMode)  # coded byte, defines the lifecycle mode of connections.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: LifecycleMode = field(XmpByte())
+        """coded byte, defines the lifecycle mode of connections."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LifecycleMode)  # coded byte, defines the lifecycle mode of connections.
+    class SetDataAttr(RequestBodyStruct):
+        mode: LifecycleMode = field(XmpByte())
+        """coded byte, defines the lifecycle mode of connections."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the lifecycle mode of a user and its connections.
 
         :return: the lifecycle mode of a user and its connections
         :rtype: P4G_REPLAY_USER_INCARNATION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: LifecycleMode) -> "Token":
+    def set(self, mode: LifecycleMode) -> Token[None]:
         """Set the lifecycle mode of a user and its connections.
 
         :param mode: defines the lifecycle mode of connections.
         :type mode: LifecycleMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode))
 
     set_once = functools.partialmethod(set, LifecycleMode.ONCE)
-    """Users are created and its connections are established during the ramp-up phase and not closed until the ramp-down phase of the load profile. That is, each configured user only exists once."""
+    """Users are created and its connections are established during the ramp-up phase and not closed until the ramp-down phase of the load profile.
+    That is, each configured user only exists once.
+    """
+
     set_immortal = functools.partialmethod(set, LifecycleMode.IMMORTAL)
-    """Users are created and its connections are established during the ramp-up phase of the load profile. Each connection is closed when all payload in the Replay File for that connection has been transmitted. A user is destroyed when all its connections are closed. As users are destroyed, new users are created, attempting to keep the concurrent number of users constant. A new user will have the same IP address as the user he replaces, but the new connections will have new TCP/UDP port numbers. This will simulate that the user is living on, and creates new connections as old connections close."""
+    """Users are created and its connections are established during the ramp-up phase of the load profile.
+    Each connection is closed when all payload in the Replay File for that connection has been transmitted.
+    A user is destroyed when all its connections are closed. As users are destroyed, new users are created, attempting to keep the concurrent number of users constant.
+    A new user will have the same IP address as the user he replaces, but the new connections will have new TCP/UDP port numbers.
+    This will simulate that the user is living on, and creates new connections as old connections close.
+    """
+
     set_reincarnate = functools.partialmethod(set, LifecycleMode.REINCARNATE)
-    """Users are created and its connections are established during the ramp-up phase of the load profile. Each connection is closed when all payload in the Replay File for that connection has been transmitted. A user is destroyed when all its connections are closed. As users are destroyed, new users are created, attempting to keep the concurrent number of users constant. A new user will have a different IP address than the user it replaces, but its connection will have the same TCP/UDP port numbers. This will simulate that the user ceases to exist, and new users appear as old users die."""
+    """Users are created and its connections are established during the ramp-up phase of the load profile.
+    Each connection is closed when all payload in the Replay File for that connection has been transmitted. A user is destroyed when all its
+    connections are closed. As users are destroyed, new users are created, attempting to keep the concurrent number of users constant.
+    A new user will have a different IP address than the user it replaces, but its connection will have the same TCP/UDP port numbers.
+    This will simulate that the user ceases to exist, and new users appear as old users die.
+    """
 
 
 @register_command
 @dataclass
 class P4G_REPLAY_USER_REPETITIONS:
     """
     Defines how many times a new user should be created after an old user has been destroyed, when P4G_REPLAY_USER_INCARNATION` is set to ``IMMORTAL`` or ``REINCARNATE``.
     """
 
     code: typing.ClassVar[int] = 905
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, repetition mode.
-        repetition_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of repetitions
+    class GetDataAttr(ResponseBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, repetition mode."""
+        repetition_count: int = field(XmpInt())
+        """integer, number of repetitions"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfiniteOrFinite)  # coded byte, repetition mode.
-        repetition_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of repetitions
+    class SetDataAttr(RequestBodyStruct):
+        mode: InfiniteOrFinite = field(XmpByte())
+        """coded byte, repetition mode."""
+        repetition_count: int = field(XmpInt())
+        """integer, number of repetitions"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get how many times a new user should be created, after an old user has been destroyed.
 
         :return: how many times a new user should be created, after an old user has been destroyed
         :rtype: P4G_REPLAY_USER_REPETITIONS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, mode: InfiniteOrFinite, repetition_count: int) -> "Token":
+    def set(self, mode: InfiniteOrFinite, repetition_count: int) -> Token[None]:
         """Set how many times a new user should be created, after an old user has been destroyed.
 
         :param mode: the repetition mode
         :type mode: InfiniteOrFinite
         :param repetition_count: number of repetitions
         :type repetition_count: int
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, repetition_count=repetition_count)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], mode=mode, repetition_count=repetition_count))
 
     set_infinite = functools.partialmethod(set, InfiniteOrFinite.INFINITE)
     """New users are generated as long as the load profile allows."""
+
     set_finite = functools.partialmethod(set, InfiniteOrFinite.FINITE)
     """Each configured user is destroyed and re-created repetitions number of times."""
 
 
 @register_command
 @dataclass
 class P4G_USER_STATE_CURRENT:
@@ -5124,36 +5859,44 @@
 
     * ``INACTIVE`` All the users connection is closed, but the user has not been destroyed yet.
     """
 
     code: typing.ClassVar[int] = 910
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        init: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users currently in this state
-        active: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users currently in this state
-        success: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users currently in this state
-        failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users currently in this state
-        stopped: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users currently in this state
-        inactive: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users currently in this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        init: int = field(XmpLong())
+        """long integer, the number of users currently in this state"""
+        active: int = field(XmpLong())
+        """long integer, the number of users currently in this state"""
+        success: int = field(XmpLong())
+        """long integer, the number of users currently in this state"""
+        failed: int = field(XmpLong())
+        """long integer, the number of users currently in this state"""
+        stopped: int = field(XmpLong())
+        """long integer, the number of users currently in this state"""
+        inactive: int = field(XmpLong())
+        """long integer, the number of users currently in this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the current user state counters.
 
         :return: a list of the current user state counters.
         :rtype: P4G_USER_STATE_CURRENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_USER_STATE_TOTAL:
     """
@@ -5173,36 +5916,44 @@
 
     * ``INACTIVE`` All the users connection is closed, but the user has not been destroyed yet.
     """
 
     code: typing.ClassVar[int] = 911
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        init: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of users that has entered this state
-        active: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of users that has entered this state
-        success: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of users that has entered this state
-        failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of users that has entered this state
-        stopped: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of users that has entered this state
-        inactive: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of users that has entered this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        init: int = field(XmpLong())
+        """long integer, the total number of users that has entered this state"""
+        active: int = field(XmpLong())
+        """long integer, the total number of users that has entered this state"""
+        success: int = field(XmpLong())
+        """long integer, the total number of users that has entered this state"""
+        failed: int = field(XmpLong())
+        """long integer, the total number of users that has entered this state"""
+        stopped: int = field(XmpLong())
+        """long integer, the total number of users that has entered this state"""
+        inactive: int = field(XmpLong())
+        """long integer, the total number of users that has entered this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the total user state counters.
 
         :return: a list of the total user state counters.
         :rtype: P4G_USER_STATE_TOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_USER_STATE_RATE:
     """
@@ -5223,289 +5974,310 @@
     * ``INACTIVE`` All the users connection is closed, but the user has not been destroyed yet.
 
     """
 
     code: typing.ClassVar[int] = 912
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        stats: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users/second entering this state
-        init: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users/second entering this state
-        active: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users/second entering this state
-        success: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users/second entering this state
-        failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users/second entering this state
-        stopped: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of users/second entering this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        stats: int = field(XmpLong())
+        """long integer, the number of users/second entering this state"""
+        init: int = field(XmpLong())
+        """long integer, the number of users/second entering this state"""
+        active: int = field(XmpLong())
+        """long integer, the number of users/second entering this state"""
+        success: int = field(XmpLong())
+        """long integer, the number of users/second entering this state"""
+        failed: int = field(XmpLong())
+        """long integer, the number of users/second entering this state"""
+        stopped: int = field(XmpLong())
+        """long integer, the number of users/second entering this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the user state rates measured in users/second.
 
         :return: a list of the user state rates measured in users/second.
         :rtype: P4G_USER_STATE_RATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_ENABLE:
     """
     Enable/Disable TLS.
     """
 
     code: typing.ClassVar[int] = 1100
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # code byte, specifying whether to enable TLS
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """code byte, specifying whether to enable TLS"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # code byte, specifying whether to enable TLS
+    class SetDataAttr(RequestBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """code byte, specifying whether to enable TLS"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether TLS is enabled.
 
         :return: whether TLS is enabled.
         :rtype: P4G_TLS_ENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, on_off: YesNo) -> "Token":
+    def set(self, on_off: YesNo) -> Token[None]:
         """Set whether TLS is enabled.
 
         :param on_off: specifying whether to enable TLS
         :type on_off: YesNo
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], on_off=on_off))
 
     set_no = functools.partialmethod(set, YesNo.NO)
     """Disable TLS."""
+
     set_yes = functools.partialmethod(set, YesNo.YES)
     """Enable TLS."""
 
 
 @register_command
 @dataclass
 class P4G_TLS_CIPHER_SUITES:
     """
     Configure the list of ciphers to announce in order of priorities.
     """
 
     code: typing.ClassVar[int] = 1101
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ciphers: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, sequence of ciphers identified by theirs IANA number in order of priority.
+    class GetDataAttr(ResponseBodyStruct):
+        ciphers: Hex = field(XmpHex())
+        """list of hex bytes, sequence of ciphers identified by theirs IANA number in order of priority."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ciphers: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, sequence of ciphers identified by theirs IANA number in order of priority.
+    class SetDataAttr(RequestBodyStruct):
+        ciphers: Hex = field(XmpHex())
+        """list of hex bytes, sequence of ciphers identified by theirs IANA number in order of priority."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the list of ciphers to announce in order of priorities.
 
         :return: the list of ciphers to announce in order of priorities.
         :rtype: P4G_TLS_CIPHER_SUITES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, ciphers: str) -> "Token":
+    def set(self, ciphers: Hex) -> Token[None]:
         """Set the list of ciphers to announce in order of priorities.
 
         :param ciphers: sequence of ciphers identified by theirs IANA number in order of priority.
-        :type ciphers: str
+        :type ciphers: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], ciphers=ciphers))
 
 
 @register_command
 @dataclass
 class P4G_TLS_MAX_RECORD_SIZE:
     """
     Configure the maximum outgoing TLS record size.
     """
 
     code: typing.ClassVar[int] = 1102
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum outgoing record size in the interval ]0;16384], default value 8087.
+    class GetDataAttr(ResponseBodyStruct):
+        size: int = field(XmpInt())
+        """integer, maximum outgoing record size in the interval ]0;16384], default value 8087."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, maximum outgoing record size in the interval ]0;16384], default value 8087.
+    class SetDataAttr(RequestBodyStruct):
+        size: int = field(XmpInt())
+        """integer, maximum outgoing record size in the interval ]0;16384], default value 8087."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the maximum outgoing TLS record size.
 
         :return: the maximum outgoing TLS record size.
         :rtype: P4G_TLS_MAX_RECORD_SIZE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, size: int) -> "Token":
+    def set(self, size: int) -> Token[None]:
         """Set the maximum outgoing TLS record size.
 
         :param size: maximum outgoing record size in the interval (0, 16384], default value 8087.
         :type size: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], size=size))
 
 
 @register_command
 @dataclass
 class P4G_TLS_CERTIFICATE_FILENAME:
     """
     Configure the TLS certificate.
     """
 
     code: typing.ClassVar[int] = 1103
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filename: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the filename of the certificate relative to the ftp tls folder
+    class SetDataAttr(RequestBodyStruct):
+        filename: str = field(XmpStr())
+        """string, the filename of the certificate relative to the ftp tls folder"""
 
-    def set(self, filename: str) -> "Token":
+    def set(self, filename: str) -> Token[None]:
         """Set the TLS certificate.
 
         :param filename: the filename of the certificate relative to the FTP TLS folder on the tester.
         :type filename: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], filename=filename))
 
 
 @register_command
 @dataclass
 class P4G_TLS_PRIVATE_KEY_FILENAME:
     """
     Configure the private key matching the TLS certificate.
     """
 
     code: typing.ClassVar[int] = 1104
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filename: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the filename of the private key relative to the ftp tls folder
+    class SetDataAttr(RequestBodyStruct):
+        filename: str = field(XmpStr())
+        """string, the filename of the private key relative to the ftp tls folder"""
 
-    def set(self, filename: str) -> "Token":
+    def set(self, filename: str) -> Token[None]:
         """Set the private key matching the TLS certificate.
 
         :param filename: the filename of the private key relative to the FTP TLS folder on the tester.
         :type filename: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], filename=filename))
 
 
 @register_command
 @dataclass
 class P4G_TLS_DHPARAMS_FILENAME:
     """
     Configure TLS DH parameters, if not set a default set will be used.
     """
 
     code: typing.ClassVar[int] = 1105
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filename: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the filename of the dhparams relative to the ftp tls folder
+    class SetDataAttr(RequestBodyStruct):
+        filename: str = field(XmpStr())
+        """string, the filename of the dhparams relative to the ftp tls folder"""
 
-    def set(self, filename: str) -> "Token":
+    def set(self, filename: str) -> Token[None]:
         """Set TLS DH parameters.
 
         :param filename: the filename of the TLS DH parameters relative to the FTP TLS folder on the tester.
         :type filename: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], filename=filename))
 
 
 @register_command
 @dataclass
 class P4G_TLS_CLOSE_NOTIFY:
     """
     Enable/Disable TLS sending close notify alert on connection tear-down.
     """
 
     code: typing.ClassVar[int] = 1106
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # code byte, specifying whether to send close notify on connection tear down
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """code byte, specifying whether to send close notify on connection tear down"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # code byte, specifying whether to send close notify on connection tear down
+    class SetDataAttr(RequestBodyStruct):
+        on_off: YesNo = field(XmpByte())
+        """code byte, specifying whether to send close notify on connection tear down"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether TLS sends close notify alert on connection tear-down.
 
         :return: whether TLS sends close notify alert on connection tear-down.
         :rtype: P4G_TLS_CLOSE_NOTIFY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, on_off: YesNo) -> "Token":
+    def set(self, on_off: YesNo) -> Token[None]:
         """Set whether TLS sends close notify alert on connection tear-down.
 
         :param on_off: whether TLS sends close notify alert on connection tear-down.
         :type on_off: YesNo
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], on_off=on_off))
 
     set_no = functools.partialmethod(set, YesNo.NO)
     """TLS does not send close notify alert on connection tear-down."""
+
     set_yes = functools.partialmethod(set, YesNo.YES)
     """TLS sends close notify alert on connection tear-down."""
 
 
 @register_command
 @dataclass
 class P4G_TLS_ALERT_WARNING_COUNTERS:
@@ -5537,53 +6309,78 @@
     * unsupported_extension
     * unknown.
     """
 
     code: typing.ClassVar[int] = 1107
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        close_notify: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        unexpected_message: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        bad_record_mac: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        record_overflow: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        decompression_failure: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        handshake_failure: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        bad_certificate: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        unsupported_certificate: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        certificate_revoked: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        certificate_expired: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        certificate_unknown: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        illegal_parameter: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        unknown_ca: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        access_denied: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        decode_error: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        decrypt_error: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        protocol_version: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        insufficient_security: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        internal_error: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        user_canceled: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        no_renegotiation: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        unsupported_extension: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
-        unknown: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this warning received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        close_notify: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        unexpected_message: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        bad_record_mac: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        record_overflow: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        decompression_failure: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        handshake_failure: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        bad_certificate: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        unsupported_certificate: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        certificate_revoked: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        certificate_expired: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        certificate_unknown: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        illegal_parameter: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        unknown_ca: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        access_denied: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        decode_error: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        decrypt_error: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        protocol_version: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        insufficient_security: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        internal_error: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        user_canceled: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        no_renegotiation: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        unsupported_extension: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
+        unknown: int = field(XmpLong())
+        """long integer, the total number of this warning received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of TLS warning counters.
 
         :return: a list of TLS warning counters
         :rtype: P4G_TLS_ALERT_WARNING_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_ALERT_FATAL_COUNTERS:
     """
@@ -5614,53 +6411,78 @@
     * unsupported_extension
     * unknown.
     """
 
     code: typing.ClassVar[int] = 1108
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        stats: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        unexpected_message: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        bad_record_mac: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        record_overflow: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        decompression_failure: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        handshake_failure: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        bad_certificate: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        unsupported_certificate: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        certificate_revoked: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        certificate_expired: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        certificate_unknown: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        illegal_parameter: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        unknown_ca: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        access_denied: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        decode_error: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        decrypt_error: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        protocol_version: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        insufficient_security: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        internal_error: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        user_canceled: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        no_renegotiation: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        unsupported_extension: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
-        unknown: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of this error received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        stats: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        unexpected_message: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        bad_record_mac: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        record_overflow: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        decompression_failure: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        handshake_failure: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        bad_certificate: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        unsupported_certificate: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        certificate_revoked: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        certificate_expired: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        certificate_unknown: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        illegal_parameter: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        unknown_ca: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        access_denied: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        decode_error: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        decrypt_error: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        protocol_version: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        insufficient_security: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        internal_error: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        user_canceled: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        no_renegotiation: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        unsupported_extension: int = field(XmpLong())
+        """long integer, the total number of this error received"""
+        unknown: int = field(XmpLong())
+        """long integer, the total number of this error received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of TLS error counters.
 
         :return: a list of TLS error counters
         :rtype: P4G_TLS_ALERT_FATAL_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_STATE_CURRENT:
     """
@@ -5676,38 +6498,48 @@
     * TLS_CLOSE_NOTIFY
     * TLS_DONE
     """
 
     code: typing.ClassVar[int] = 1109
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        tls_inactive: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        tls_handshaking: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        tls_handshake_done: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        tls_handshake_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        tls_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        tls_internal_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        tls_close_notify: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
-        tls_done: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections currently in this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        tls_inactive: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        tls_handshaking: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        tls_handshake_done: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        tls_handshake_failed: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        tls_failed: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        tls_internal_failed: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        tls_close_notify: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
+        tls_done: int = field(XmpLong())
+        """long integer, the number of connections currently in this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the current TLS state counters.
 
         :return: a list of the current TLS state counters
         :rtype: P4G_TLS_STATE_CURRENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_STATE_TOTAL:
     """
@@ -5723,38 +6555,48 @@
     * TLS_CLOSE_NOTIFY
     * TLS_DONE
     """
 
     code: typing.ClassVar[int] = 1110
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        tls_inactive: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        tls_handshaking: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        tls_handshake_done: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        tls_handshake_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        tls_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        tls_internal_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        tls_close_notify: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
-        tls_done: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the total number of connections that has entered this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        tls_inactive: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        tls_handshaking: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        tls_handshake_done: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        tls_handshake_failed: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        tls_failed: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        tls_internal_failed: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        tls_close_notify: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
+        tls_done: int = field(XmpLong())
+        """long integer, the total number of connections that has entered this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the total TLS state counters.
 
         :return: a list of the total TLS state counters
         :rtype: P4G_TLS_STATE_TOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_STATE_RATE:
     """
@@ -5770,298 +6612,430 @@
     * TLS_CLOSE_NOTIFY
     * TLS_DONE
     """
 
     code: typing.ClassVar[int] = 1111
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        tls_inactive: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        tls_handshaking: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        tls_handshake_done: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        tls_handshake_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        tls_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        tls_internal_failed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        tls_close_notify: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
-        tls_done: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of connections/second entering this state
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        tls_inactive: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        tls_handshaking: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        tls_handshake_done: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        tls_handshake_failed: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        tls_failed: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        tls_internal_failed: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        tls_close_notify: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
+        tls_done: int = field(XmpLong())
+        """long integer, the number of connections/second entering this state"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TLS state rates measured in per second.
 
         :return: a list of the TLS state rates measured in per second
         :rtype: P4G_TLS_STATE_RATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_RX_PAYLOAD_COUNTERS:
     """
     Returns a list of the TLS Rx payload counters.
     """
 
     code: typing.ClassVar[int] = 1112
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TLS payload bytes received
-        byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TLS payload bytes/second received
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        byte_count: int = field(XmpLong())
+        """long integer, number of TLS payload bytes received"""
+        byte_per_second: int = field(XmpLong())
+        """long integer, number of TLS payload bytes/second received"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TLS Rx payload counters.
 
         :return: a list of the TLS Rx payload counters.
         :rtype: P4G_TLS_RX_PAYLOAD_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_TX_PAYLOAD_COUNTERS:
     """
     Returns a list of the TLS Tx payload counters.
     """
 
     code: typing.ClassVar[int] = 1113
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        current_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the current time (mSec since module restart)
-        ref_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, reference time (mSec for P4_TRAFFIC on)
-        byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TLS payload bytes transmitted
-        byte_per_second: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of TLS payload bytes/second transmitted
+    class GetDataAttr(ResponseBodyStruct):
+        current_time: int = field(XmpLong())
+        """long integer, the current time (mSec since module restart)"""
+        ref_time: int = field(XmpLong())
+        """long integer, reference time (mSec for P4_TRAFFIC on)"""
+        byte_count: int = field(XmpLong())
+        """long integer, number of TLS payload bytes transmitted"""
+        byte_per_second: int = field(XmpLong())
+        """long integer, number of TLS payload bytes/second transmitted"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the TLS Tx payload counters.
 
         :return: a list of the TLS Tx payload counters.
         :rtype: P4G_TLS_TX_PAYLOAD_COUNTERS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_RX_PAYLOAD_BYTES_HIST:
     """
     Returns a histogram over number of TLS Payload bytes received, with start and
     interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 1114
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum TLS Payload bytes received on a connection.
-        max_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum TLS Payload bytes received on a connection.
-        avg_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average TLS Payload bytes received on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has received TLS Payload bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections."""
+        min_byte_count: int = field(XmpLong())
+        """long integer, minimum TLS Payload bytes received on a connection."""
+        max_byte_count: int = field(XmpLong())
+        """long integer, maximum TLS Payload bytes received on a connection."""
+        avg_byte_count: int = field(XmpLong())
+        """long integer, average TLS Payload bytes received on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has received TLS Payload bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of TLS Payload bytes received.
 
         :return: a histogram over number of TLS Payload bytes received
         :rtype: P4G_TLS_RX_PAYLOAD_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_TX_PAYLOAD_BYTES_HIST:
     """
     Returns a histogram over number of TLS Payload bytes transmitted, with start and
     interval values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 1115
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections.
-        min_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum TLS Payload bytes transmitted on a connection.
-        max_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum TLS Payload bytes transmitted on a connection.
-        avg_byte_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average TLS Payload bytes transmitted on a connection.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in bytes
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in bytes
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections that has transmitted TLS Payload bytes within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections."""
+        min_byte_count: int = field(XmpLong())
+        """long integer, minimum TLS Payload bytes transmitted on a connection."""
+        max_byte_count: int = field(XmpLong())
+        """long integer, maximum TLS Payload bytes transmitted on a connection."""
+        avg_byte_count: int = field(XmpLong())
+        """long integer, average TLS Payload bytes transmitted on a connection."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in bytes"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in bytes"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections that has transmitted TLS Payload bytes within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over number of TLS Payload bytes transmitted.
 
         :return: a histogram over number of TLS Payload bytes transmitted
         :rtype: P4G_TLS_TX_PAYLOAD_BYTES_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_HANDSHAKE_HIST:
     """
     Returns a histogram over TLS connection handshake times, with start and interval
     values as configured by P4G_PAYLOAD_HIST_CONF`.
     """
 
     code: typing.ClassVar[int] = 1116
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        connection_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,number of connections established.
-        min_connection_handshake_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum connection handshake time in us.
-        max_connection_handshake_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum connection handshake time in us.
-        avg_connection_handshake_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, average connection handshake time in us.
-        start: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, start value of first histogram interval in us
-        interval: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, histogram interval size in us
-        bin_00: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_01: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_02: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_03: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_04: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_05: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_06: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_07: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_08: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_09: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_10: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_11: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_12: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_13: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_14: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_15: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_16: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_17: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_18: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_19: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_20: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_21: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_22: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_23: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_24: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_25: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_26: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_27: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_28: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_29: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_30: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
-        bin_31: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of connections with handshake time within the given interval.
+    class GetDataAttr(ResponseBodyStruct):
+        connection_count: int = field(XmpInt())
+        """integer,number of connections established."""
+        min_connection_handshake_time: int = field(XmpLong())
+        """long integer, minimum connection handshake time in us."""
+        max_connection_handshake_time: int = field(XmpLong())
+        """long integer, maximum connection handshake time in us."""
+        avg_connection_handshake_time: int = field(XmpLong())
+        """long integer, average connection handshake time in us."""
+        start: int = field(XmpLong())
+        """long integer, start value of first histogram interval in us"""
+        interval: int = field(XmpLong())
+        """long integer, histogram interval size in us"""
+        bin_00: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_01: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_02: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_03: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_04: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_05: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_06: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_07: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_08: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_09: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_10: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_11: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_12: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_13: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_14: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_15: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_16: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_17: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_18: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_19: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_20: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_21: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_22: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_23: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_24: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_25: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_26: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_27: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_28: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_29: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_30: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
+        bin_31: int = field(XmpInt())
+        """integer, number of connections with handshake time within the given interval."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a histogram over TLS connection handshake times.
 
         :return: a histogram over TLS connection handshake times
         :rtype: P4G_TLS_HANDSHAKE_HIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
 
 @register_command
 @dataclass
 class P4G_TLS_SERVER_NAME:
     """
@@ -6071,41 +7045,43 @@
     message. If server name is not configured (or configured blank), the SNI
     extension will not be inserted in the Client Hello message.
     """
 
     code: typing.ClassVar[int] = 1117
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        server_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, server name inserted in the SNI TLS extension
+    class GetDataAttr(ResponseBodyStruct):
+        server_name: str = field(XmpStr())
+        """string, server name inserted in the SNI TLS extension"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        server_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, server name inserted in the SNI TLS extension
+    class SetDataAttr(RequestBodyStruct):
+        server_name: str = field(XmpStr())
+        """string, server name inserted in the SNI TLS extension"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the server name advertised by the client in the TLS SNI.
 
         :return: the server name advertised by the client in the TLS SNI
         :rtype: P4G_TLS_SERVER_NAME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, server_name: str) -> "Token":
+    def set(self, server_name: str) -> Token[None]:
         """Set the server name advertised by the client in the TLS SNI.
 
         :param server_name: server name inserted in the SNI TLS extension
         :type server_name: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], server_name=server_name))
 
 
 @register_command
 @dataclass
 class P4G_TLS_PROTOCOL_VER:
     """
@@ -6115,49 +7091,54 @@
     protocol_version in the Client Hello message is higher than the highest protocol
     version accepted by the server, the TLS Handshake will fail.
     """
 
     code: typing.ClassVar[int] = 1118
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        tls_version: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TLSVersion)  # coded byte, maximum supported TLS protocol version
+    class GetDataAttr(ResponseBodyStruct):
+        tls_version: TLSVersion = field(XmpByte())
+        """coded byte, maximum supported TLS protocol version"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        tls_version: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TLSVersion)  # coded byte, maximum supported TLS protocol version
+    class SetDataAttr(RequestBodyStruct):
+        tls_version: TLSVersion = field(XmpByte())
+        """coded byte, maximum supported TLS protocol version"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the highest supported TLS protocol version.
 
         :return: the highest supported TLS protocol version
         :rtype: P4G_TLS_PROTOCOL_VER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
 
-    def set(self, tls_version: TLSVersion) -> "Token":
+    def set(self, tls_version: TLSVersion) -> Token[None]:
         """Set the highest supported TLS protocol version.
 
         :param tls_version:  the highest supported TLS protocol version
         :type tls_version: TLSVersion
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._group_xindex], tls_version=tls_version))
 
     set_sslv3 = functools.partialmethod(set, TLSVersion.SSLV3)
     """The highest supported TLS protocol version is set to SSLv3."""
+
     set_tls10 = functools.partialmethod(set, TLSVersion.TLS10)
     """The highest supported TLS protocol version is set to TLS 1.0."""
+
     set_tls11 = functools.partialmethod(set, TLSVersion.TLS11)
     """The highest supported TLS protocol version is set to TLS 1.1."""
+
     set_tls12 = functools.partialmethod(set, TLSVersion.TLS12)
     """The highest supported TLS protocol version is set to TLS 1.2."""
 
 
 @register_command
 @dataclass
 class P4G_TLS_MIN_REQ_PROTOCOL_VER:
@@ -6168,23 +7149,24 @@
     for a list of cipher suites is the lowest minimum required TLS protocol version
     of all the cipher suites in the list.
     """
 
     code: typing.ClassVar[int] = 1119
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _group_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        tls_version: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TLSVersion)  # coded byte, minimum required TLS protocol version
+    class GetDataAttr(ResponseBodyStruct):
+        tls_version: TLSVersion = field(XmpByte())
+        """coded byte, minimum required TLS protocol version"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the minimum TLS protocol version required by the configured list of cipher suites.
 
         :return: the minimum TLS protocol version required by the configured list of cipher suites.
         :rtype: P4G_TLS_MIN_REQ_PROTOCOL_VER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._group_xindex]))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/p_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/p_commands.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,72 @@
-#: L23 Port Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import ipaddress
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
-from . import subtypes
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpIPv4Address,
+    XmpIPv6Address,
+    XmpLong,
+    XmpShort,
+    XmpMacAddress,
+    XmpSequence,
+    XmpStr,
+    Hex,
+)
+from .subtypes import (
+    ArpChunk,
+    NdpChunk,
+)
+from .enums import (
+    ReservedStatus,
+    ReservedAction,
+    OnOff,
+    YesNo,
+    PortSpeedMode,
+    SyncStatus,
+    LoopbackMode,
+    TrafficOnOff,
+    StartOrStop,
+    LatencyMode,
+    MDIXMode,
+    MulticastOperation,
+    MulticastExtOperation,
+    IGMPVersion,
+    TXMode,
+    PayloadMode,
+    BRRMode,
+    TXHState,
+    RXHState,
+    TXCState,
+    RXCState,
+    LinkState,
+    FaultSignaling,
+    LocalFaultStatus,
+    RemoteFaultStatus,
+    TPLDMode,
+    MulticastHeaderFormat,
+    TrafficError,
+    TrafficEngine,
+    ReconciliationSublayerSupport,
+)
 
 
 @register_command
 @dataclass
 class P_RESERVATION:
     """
     You set this command to reserve, release, or relinquish a port. The port must
@@ -28,52 +75,59 @@
     specified. Reservation will fail if the chassis or module is reserved to other
     users.
     """
 
     code: typing.ClassVar[int] = 102
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        operation: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=ReservedAction
-        )  # coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get. When set, it contains the operation to perform. When get, it contains the status.
+    class GetDataAttr(ResponseBodyStruct):
+        status: ReservedStatus = field(XmpByte())
+        """coded byte, containing the operation to perform.
+        The reservation parameters are asymmetric with respect to set/get.
+        When set, it contains the operation to perform. When get, it contains the status.
+        """
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=ReservedStatus
-        )  # coded byte, containing the operation to perform. The reservation parameters are asymmetric with respect to set/get. When set, it contains the operation to perform. When get, it contains the status.
+    class SetDataAttr(RequestBodyStruct):
+        operation: ReservedAction = field(XmpByte())
+        """coded byte, containing the operation to perform.
+        The reservation parameters are asymmetric with respect to set/get.
+        When set, it contains the operation to perform.
+        When get, it contains the status.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the reservation status of the test port.
 
         :return: the reservation status of the test port.
         :rtype: ReservedStatus
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, operation: ReservedAction) -> "Token":
+    def set(self, operation: ReservedAction) -> Token[None]:
         """Set the reservation of the test port, i.e., reserve, release, or relinquish.
 
         :param operation: the reservation of the test port, i.e., reserve, release, or relinquish.
         :type operation: ReservedAction
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, operation=operation))
 
     set_release = functools.partialmethod(set, ReservedAction.RELEASE)
     """Release the port from your ownership.
     """
+
     set_reserve = functools.partialmethod(set, ReservedAction.RESERVE)
     """Reserve the port.
     """
+
     set_relinquish = functools.partialmethod(set, ReservedAction.RELINQUISH)
     """Release the port from others' ownership.
     """
 
 
 @register_command
 @dataclass
@@ -86,191 +140,272 @@
     The port is reserved to this connection only if P_RESERVATION returns
     RESERVED_BY_YOU.
     """
 
     code: typing.ClassVar[int] = 103
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        username: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the name of the current owner of the port.
+    class GetDataAttr(ResponseBodyStruct):
+        username: str = field(XmpStr())
+        """string, containing the name of the current owner of the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the username of the user who has the port reserved.
 
         :return: the username of the user who has the port reserved.
         :rtype: P_RESERVEDBY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_RESET:
     """
     Reset port-level parameters to standard values, and delete all streams, filters,
     capture, and dataset definitions.
     """
 
     code: typing.ClassVar[int] = 104
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Reset the port to its default configuration.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_CAPABILITIES:
     """
     A series of integer values specifying various internal limits of a port.
     integer: integer, internally defined limit values.
     """
 
     code: typing.ClassVar[int] = 106
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        max_speed: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max wire speed in Mbps, for fastest transceiver and mode
-        max_speed_reduction: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max ppm value of speed reduction
-        min_interframe_gap: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, min bytes between frames
-        max_interframe_gap: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max explicit bytes between frames
-        max_preamble: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max preamble bytes included in frame
-        max_streams_per_port: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max streams per port
-        max_percent: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max input rate in percent
-        max_pps: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer,  max input rate in pps
-        max_mbps: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max input rate in mbps
-        max_seed: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max random seed
-        max_tx_packet_limit: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max stop-after-n-packet limitation
-        max_burst_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max packets per burst
-        min_packet_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, min bytes in total packet
-        max_packet_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max bytes in total packet
-        max_header_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max bytes in auto-generated packet header
-        max_protocol_segments: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max number of protocol segments
-        max_pattern_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max bytes in repeating payload pattern
-        max_modifiers: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max 16-bit modifiers per stream
-        max_modifier_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max bytes in modified field
-        max_repeat: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max packet repeats for modifier
-        max_tpid: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max test payload id
-        max_manual_packets: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max manual packets
-        max_match_terms: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max filter match terms per port
-        max_length_terms: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max filter length terms per port
-        max_ors: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max or-terms per filter
-        max_nots: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max or-terms with nots per filter
-        max_filters: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max filters per port
-        max_captured_packets: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max captured packets at one time
-        max_tpld_stats: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max number of different tplds for rx statistics
-        max_histogram: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max number of sampled histograms
-        max_32bit_modifiers: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max 32-bit modifiers per stream
-        can_set_autoneg: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports auto negotiation
-        can_tcp_checksum: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports TCP with valid checksum
-        can_udp_checksum: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports UDP with valid checksum
-        can_eee: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports EEE
-        can_hw_reg_access: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports hardware register access
-        can_tcvr_mii_reg_access: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports transceiver MII access
-        can_adv_phy_man: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports advanced PHY management
-        can_micro_tpld: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports micro TPLD
-        can_mdi_mdix: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports MDI/MDIX
-        can_payload_mode: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports payload mode
-        can_custom_data_fields: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports custom data fields
-        can_ext_payload: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports extended payload
-        can_dyn_traffic_change: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports dynamic traffic change
-        can_sync_traffic_start: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports synchronized traffic start
-        can_pfc: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports Priority Flow Control
-        can_pcs_pma_config: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether this port can provide PCS/PMA configuration and status
-        can_fec: XmpField[xt.XmpUnsignedInt] = XmpField(xt.XmpUnsignedInt)  # bit map encoded, [0] = KR FEC, [1] = KP FEC, [2] = FC FEC, [31] = Mandatory (If this bit is set, you have to have FEC mode turned on in either of the supported mode, but you cannot turn FEC off.)
-        can_fec_stats: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # bit map encoded, can this port provide advanced FEC stats of type x? [0] = symbol error distribution
-        can_tx_eq: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports TX EQ settings
-        can_rx_retune: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether supports RX retuning
-        prbs_types_supported: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # bit map encoded, [0] = lane-based, [1] = PHY-based, [2-31] = reserved
-        prbs_inversions_supported: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # bit map encoded, [0] = lane-based supports inv, [1] = PHY-based supports inv, [2-31] = reserved
-        prbs_polys_supported: XmpField[xt.XmpIntList5] = XmpField(
-            xt.XmpIntList5
-        )  # 5 integers, bit map for each PRBS type (above). [0] = PRBS7, [1] = PRBS9, [2] = PRBS11, [3] = PRBS15, [4] = PRBS23, [5] = PRBS31, [6] = PRBS58, [7] = PRBS49, [8] = PRBS10, [9] = PRBS20, [10] = PRBS13
-        serdes_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of physical serdes on line-side
-        lane_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of lanes (virtual)
-        tx_eq_tap_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of TXEQ taps
-        tx_eq_tap_max_val: XmpField[xt.XmpIntList10] = XmpField(xt.XmpIntList10)  # 10 integers, max-value of individual TXEQ taps
-        tx_eq_tap_min_val: XmpField[xt.XmpIntList10] = XmpField(xt.XmpIntList10)  # 10 integers, min-value of individual TXEQ taps
-        max_fec_correctable_symbol_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, max number of symbols correctable by the current FEC
-        max_xmit_one_packet_length: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, maximum size (in bytes) of packets, which can be sent using xmitone (replay/streaming interface)
-        tx_runt_packet_min_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, minimum TX packet size supported by runt block. Zero = not supported
-        rx_runt_packet_min_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, minimum RX packet size supported by runt block. Zero = not supported
-        can_manipulate_preamble: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether this port can manipulate the preamble
-        can_set_link_train: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether this port can set link training
-        can_link_flap: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether this port supports link flap
-        can_auto_neg_base_r: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether the port currently can perform BASE-R auto-negotiation (as opposed to RJ45 BASE-T)
-        can_pma_error_pulse: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether this port supports 'PMA pulse error injection'
-        is_chimera: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether this is a Chimera port
-        has_p2p_loop_partner: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, whether this port currently has a port-to-port loop partner
-        p2p_loop_partner: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, The port-to-port loop partner for the port. N/A = -1.
-        traffic_engine: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=TrafficEngine)  # integer, Enabled traffic engine on port. 0x01 = TGA, 0x02 = uTGA.
-        reconc_sublayer: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=ReconciliationSublayerSupport)  # integer, Reconciliation Sublayer support, bitmask, 0 = fault signalling not support; 1 = fault signalling supported (XMP: P_FAULTSTATUS/P_FAULTSIGNALING)
+    class GetDataAttr(ResponseBodyStruct):
+        max_speed: int = field(XmpInt())
+        """integer, max wire speed in Mbps, for fastest transceiver and mode"""
+        max_speed_reduction: int = field(XmpInt())
+        """integer, max ppm value of speed reduction"""
+        min_interframe_gap: int = field(XmpInt())
+        """integer, min bytes between frames"""
+        max_interframe_gap: int = field(XmpInt())
+        """integer, max explicit bytes between frames"""
+        max_preamble: int = field(XmpInt())
+        """integer, max preamble bytes included in frame"""
+        max_streams_per_port: int = field(XmpInt())
+        """integer, max streams per port"""
+        max_percent: int = field(XmpInt())
+        """integer, max input rate in percent"""
+        max_pps: int = field(XmpInt())
+        """integer,  max input rate in pps"""
+        max_mbps: int = field(XmpInt())
+        """integer, max input rate in mbps"""
+        max_seed: int = field(XmpInt())
+        """integer, max random seed"""
+        max_tx_packet_limit: int = field(XmpInt())
+        """integer, max stop-after-n-packet limitation"""
+        max_burst_size: int = field(XmpInt())
+        """integer, max packets per burst"""
+        min_packet_length: int = field(XmpInt())
+        """integer, min bytes in total packet"""
+        max_packet_length: int = field(XmpInt())
+        """integer, max bytes in total packet"""
+        max_header_length: int = field(XmpInt())
+        """integer, max bytes in auto-generated packet header"""
+        max_protocol_segments: int = field(XmpInt())
+        """integer, max number of protocol segments"""
+        max_pattern_length: int = field(XmpInt())
+        """integer, max bytes in repeating payload pattern"""
+        max_modifiers: int = field(XmpInt())
+        """integer, max 16-bit modifiers per stream"""
+        max_modifier_bytes: int = field(XmpInt())
+        """integer, max bytes in modified field"""
+        max_repeat: int = field(XmpInt())
+        """integer, max packet repeats for modifier"""
+        max_tpid: int = field(XmpInt())
+        """integer, max test payload id"""
+        max_manual_packets: int = field(XmpInt())
+        """integer, max manual packets"""
+        max_match_terms: int = field(XmpInt())
+        """integer, max filter match terms per port"""
+        max_length_terms: int = field(XmpInt())
+        """integer, max filter length terms per port"""
+        max_ors: int = field(XmpInt())
+        """integer, max or-terms per filter"""
+        max_nots: int = field(XmpInt())
+        """integer, max or-terms with nots per filter"""
+        max_filters: int = field(XmpInt())
+        """integer, max filters per port"""
+        max_captured_packets: int = field(XmpInt())
+        """integer, max captured packets at one time"""
+        max_tpld_stats: int = field(XmpInt())
+        """integer, max number of different tplds for rx statistics"""
+        max_histogram: int = field(XmpInt())
+        """integer, max number of sampled histograms"""
+        max_32bit_modifiers: int = field(XmpInt())
+        """integer, max 32-bit modifiers per stream"""
+        can_set_autoneg: int = field(XmpInt())
+        """integer, whether supports auto negotiation"""
+        can_tcp_checksum: int = field(XmpInt())
+        """integer, whether supports TCP with valid checksum"""
+        can_udp_checksum: int = field(XmpInt())
+        """integer, whether supports UDP with valid checksum"""
+        can_eee: int = field(XmpInt())
+        """integer, whether supports EEE"""
+        can_hw_reg_access: int = field(XmpInt())
+        """integer, whether supports hardware register access"""
+        can_tcvr_mii_reg_access: int = field(XmpInt())
+        """integer, whether supports transceiver MII access"""
+        can_adv_phy_man: int = field(XmpInt())
+        """integer, whether supports advanced PHY management"""
+        can_micro_tpld: int = field(XmpInt())
+        """integer, whether supports micro TPLD"""
+        can_mdi_mdix: int = field(XmpInt())
+        """integer, whether supports MDI/MDIX"""
+        can_payload_mode: int = field(XmpInt())
+        """integer, whether supports payload mode"""
+        can_custom_data_fields: int = field(XmpInt())
+        """integer, whether supports custom data fields"""
+        can_ext_payload: int = field(XmpInt())
+        """integer, whether supports extended payload"""
+        can_dyn_traffic_change: int = field(XmpInt())
+        """integer, whether supports dynamic traffic change"""
+        can_sync_traffic_start: int = field(XmpInt())
+        """integer, whether supports synchronized traffic start"""
+        can_pfc: int = field(XmpInt())
+        """integer, whether supports Priority Flow Control"""
+        can_pcs_pma_config: int = field(XmpInt())
+        """integer, whether this port can provide PCS/PMA configuration and status"""
+        can_fec: int = field(XmpInt(signed=False))
+        """bit map encoded,
+            [0] = KR FEC,
+            [1] = KP FEC,
+            [2] = FC FEC,
+            [31] = Mandatory (If this bit is set, you have to have FEC mode turned on in either of the supported mode, but you cannot turn FEC off.)
+        """
+        can_fec_stats: int = field(XmpInt())
+        """bit map encoded, can this port provide advanced FEC stats of type x? [0] = symbol error distribution"""
+        can_tx_eq: int = field(XmpInt())
+        """integer, whether supports TX EQ settings"""
+        can_rx_retune: int = field(XmpInt())
+        """integer, whether supports RX retuning"""
+        prbs_types_supported: int = field(XmpInt())
+        """bit map encoded, [0] = lane-based, [1] = PHY-based, [2-31] = reserved"""
+        prbs_inversions_supported: int = field(XmpInt())
+        """bit map encoded, [0] = lane-based supports inv, [1] = PHY-based supports inv, [2-31] = reserved"""
+        prbs_polys_supported: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()], length=5))
+        """5 integers, bit map for each PRBS type (above).
+            [0] = PRBS7,
+            [1] = PRBS9,
+            [2] = PRBS11,
+            [3] = PRBS15,
+            [4] = PRBS23,
+            [5] = PRBS31,
+            [6] = PRBS58,
+            [7] = PRBS49,
+            [8] = PRBS10,
+            [9] = PRBS20,
+            [10] = PRBS13
+        """
+        serdes_count: int = field(XmpInt())
+        """integer, number of physical serdes on line-side"""
+        lane_count: int = field(XmpInt())
+        """integer, number of lanes (virtual)"""
+        tx_eq_tap_count: int = field(XmpInt())
+        """integer, number of TXEQ taps"""
+        tx_eq_tap_max_val: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()], length=10))
+        """10 integers, max-value of individual TXEQ taps"""
+        tx_eq_tap_min_val: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()], length=10))
+        """10 integers, min-value of individual TXEQ taps"""
+        max_fec_correctable_symbol_count: int = field(XmpInt())
+        """integer, max number of symbols correctable by the current FEC"""
+        max_xmit_one_packet_length: int = field(XmpInt())
+        """integer, maximum size (in bytes) of packets, which can be sent using xmitone (replay/streaming interface)"""
+        tx_runt_packet_min_length: int = field(XmpInt())
+        """integer, minimum TX packet size supported by runt block. Zero = not supported"""
+        rx_runt_packet_min_length: int = field(XmpInt())
+        """integer, minimum RX packet size supported by runt block. Zero = not supported"""
+        can_manipulate_preamble: int = field(XmpInt())
+        """integer, whether this port can manipulate the preamble"""
+        can_set_link_train: int = field(XmpInt())
+        """integer, whether this port can set link training"""
+        can_link_flap: int = field(XmpInt())
+        """integer, whether this port supports link flap"""
+        can_auto_neg_base_r: int = field(XmpInt())
+        """integer, whether the port currently can perform BASE-R auto-negotiation (as opposed to RJ45 BASE-T)"""
+        can_pma_error_pulse: int = field(XmpInt())
+        """integer, whether this port supports 'PMA pulse error injection'"""
+        is_chimera: int = field(XmpInt())
+        """integer, whether this is a Chimera port"""
+        has_p2p_loop_partner: int = field(XmpInt())
+        """integer, whether this port currently has a port-to-port loop partner"""
+        p2p_loop_partner: int = field(XmpInt())
+        """integer, The port-to-port loop partner for the port. N/A = -1."""
+        traffic_engine: TrafficEngine = field(XmpInt(), min_version=456)
+        """integer, Enabled traffic engine on port. 0x01 = TGA, 0x02 = uTGA."""
+        reconc_sublayer: ReconciliationSublayerSupport = field(XmpInt(), min_version=456)
+        """integer, Reconciliation Sublayer support, bitmask, 0 = fault signalling not support; 1 = fault signalling supported (XMP: P_FAULTSTATUS/P_FAULTSIGNALING)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the internal limits, aka. capabilities, of the port.
 
         :return: the internal limits, aka. capabilities, of the port.
         :rtype: P_CAPABILITIES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_INTERFACE:
     """
     Obtains the name of the physical interface type of a port.
     """
 
     code: typing.ClassVar[int] = 107
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        interface: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, describing the interface type.
+    class GetDataAttr(ResponseBodyStruct):
+        interface: str = field(XmpStr())
+        """string, describing the interface type."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the name of the physical interface type of a port.
 
         :return: the name of the physical interface type of a port.
         :rtype: P_INTERFACE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_SPEEDSELECTION:
     """
@@ -281,87 +416,104 @@
         This is only a settable command when speed is selected at the port level. Use the M_CFPCONFIGEXT` command when speed is selected at the module level.
 
     """
 
     code: typing.ClassVar[int] = 109
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PortSpeedMode)  # coded byte, containing the speed mode for the port.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: PortSpeedMode = field(XmpByte())
+        """coded byte, containing the speed mode for the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PortSpeedMode)  # coded byte, containing the speed mode for the port.
+    class SetDataAttr(RequestBodyStruct):
+        mode: PortSpeedMode = field(XmpByte())
+        """coded byte, containing the speed mode for the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the speed mode of the port with an interface type supporting multiple speeds.
 
         :return: the speed mode of the port with an interface type supporting multiple speeds.
         :rtype: P_SPEEDSELECTION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: PortSpeedMode) -> "Token":
+    def set(self, mode: PortSpeedMode) -> Token[None]:
         """Set the speed mode of the port with an interface type supporting multiple speeds.
 
         :param mode: the speed mode of the port with an interface type supporting multiple speeds
         :type mode: PortSpeedMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_auto = functools.partialmethod(set, PortSpeedMode.AUTO)
     """Set the speed mode to auto (all speeds used in auto negotiation).
     """
+
     set_f10m = functools.partialmethod(set, PortSpeedMode.F10M)
     """Set the speed mode to 10 Mbit/s.
     """
+
     set_f100m = functools.partialmethod(set, PortSpeedMode.F100M)
     """Set the speed mode to 100 Mbit/s.
     """
+
     set_f1g = functools.partialmethod(set, PortSpeedMode.F1G)
     """Set the speed mode to 1 Gbit/s.
     """
+
     set_f10g = functools.partialmethod(set, PortSpeedMode.F10G)
     """Set the speed mode to 10 Gbit/s.
     """
+
     set_f40g = functools.partialmethod(set, PortSpeedMode.F40G)
     """Set the speed mode to 40 Gbit/s.
     """
+
     set_f100g = functools.partialmethod(set, PortSpeedMode.F100G)
     """Set the speed mode to 100 Gbit/s.
     """
+
     set_f10mhdx = functools.partialmethod(set, PortSpeedMode.F10MHDX)
     """Set the speed mode to 10 Mbit/s Half Duplex.
     """
+
     set_f100mhdx = functools.partialmethod(set, PortSpeedMode.F100MHDX)
     """Set the speed mode to 100 Mbit/s Half Duplex.
     """
+
     set_f10m100m = functools.partialmethod(set, PortSpeedMode.F10M100M)
     """Set the speed mode to 10/100 Mbit/s.
     """
+
     set_f100m1g = functools.partialmethod(set, PortSpeedMode.F100M1G)
     """Set the speed mode to 100 Mbit/s / 1 Gbit/s.
     """
+
     set_f100m1g10g = functools.partialmethod(set, PortSpeedMode.F100M1G10G)
     """Set the speed mode to 100 Mbit/s / 1 Gbit/s / 10 Gbit/s.
     """
+
     set_f2500m = functools.partialmethod(set, PortSpeedMode.F2500M)
     """Set the speed mode to 2500 Mbit/s.
     """
+
     set_f5g = functools.partialmethod(set, PortSpeedMode.F5G)
     """Set the speed mode to 5 Gbit/s.
     """
+
     set_f100m1g2500m = functools.partialmethod(set, PortSpeedMode.F100M1G2500M)
     """Set the speed mode to 100 Mbit/s / 1 Gbit/s / 2500 Mbit/s.
     """
+
     set_unknown = functools.partialmethod(set, PortSpeedMode.UNKNOWN)
     """Set the speed mode to unknown.
     """
 
 
 @register_command
 @dataclass
@@ -369,94 +521,98 @@
     """
     Obtains the current physical speed of a port's interface.
     """
 
     code: typing.ClassVar[int] = 110
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_speed: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, current speed in units of Mbps.
+    class GetDataAttr(ResponseBodyStruct):
+        port_speed: int = field(XmpInt())
+        """integer, current speed in units of Mbps."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the current physical speed of the port's interface.
 
         :return: the current physical speed of the port's interface.
         :rtype: P_SPEED.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_RECEIVESYNC:
     """
     Obtains the current in-sync status of a port's receive interface.
     """
 
     code: typing.ClassVar[int] = 111
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        sync_status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=SyncStatus)  # coded byte, describing the current sync status of the port.
+    class GetDataAttr(ResponseBodyStruct):
+        sync_status: SyncStatus = field(XmpByte())
+        """coded byte, describing the current sync status of the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the current in-sync status for a port's receive interface.
 
         :return: the current in-sync status for a port's receive interface.
         :rtype: P_RECEIVESYNC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_COMMENT:
     """
     The description of a port.
     """
 
     code: typing.ClassVar[int] = 112
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the description of the port.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, containing the description of the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the description of the port.
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, containing the description of the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the description of the port.
 
         :return: the description of the port
         :rtype: P_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the description of the port.
 
         :param comment: the description of the port
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, comment=comment))
 
 
 @register_command
 @dataclass
 class P_SPEEDREDUCTION:
     """
@@ -466,80 +622,84 @@
     generated traffic pattern to consume part of the port's physical bandwidth. The
     port's clock speed is not altered.
     """
 
     code: typing.ClassVar[int] = 113
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ppm: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the speed reduction in units of parts-per-million.
+    class GetDataAttr(ResponseBodyStruct):
+        ppm: int = field(XmpInt())
+        """integer, specifying the speed reduction in units of parts-per-million."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ppm: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the speed reduction in units of parts-per-million.
+    class SetDataAttr(RequestBodyStruct):
+        ppm: int = field(XmpInt())
+        """integer, specifying the speed reduction in units of parts-per-million."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the speed reduction ppm value of the test port.
 
         :return: the speed reduction ppm value of the test port.
         :rtype: P_SPEEDREDUCTION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, ppm: int) -> "Token":
+    def set(self, ppm: int) -> Token[None]:
         """Set the speed reduction ppm value of the test port.
 
         :param ppm: the speed reduction ppm value of the test port
         :type ppm: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, ppm=ppm))
 
 
 @register_command
 @dataclass
 class P_INTERFRAMEGAP:
     """
     The minimum gap between packets in the traffic generated for a port. The gap
     includes the Ethernet preamble.
     """
 
     code: typing.ClassVar[int] = 114
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        min_byte_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the minimum number of byte-times between generated packets.
+    class GetDataAttr(ResponseBodyStruct):
+        min_byte_count: int = field(XmpInt())
+        """integer, specifying the minimum number of byte-times between generated packets."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        min_byte_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the minimum number of byte-times between generated packets.
+    class SetDataAttr(RequestBodyStruct):
+        min_byte_count: int = field(XmpInt())
+        """integer, specifying the minimum number of byte-times between generated packets."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the minimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble.
 
         :return: the minimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble.
         :rtype: P_INTERFRAMEGAP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, min_byte_count: int) -> "Token":
+    def set(self, min_byte_count: int) -> Token[None]:
         """Set the minimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble.
 
         :param min_byte_count: the minimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble.
         :type min_byte_count: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, min_byte_count=min_byte_count))
 
 
 @register_command
 @dataclass
 class P_MACADDRESS:
     """
@@ -547,40 +707,42 @@
     default source MAC field in the header of generated traffic for the port, and is
     also used for support of the ARP protocol.
     """
 
     code: typing.ClassVar[int] = 116
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, specifying the six bytes of the MAC address.
+    class GetDataAttr(ResponseBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, specifying the six bytes of the MAC address."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, specifying the six bytes of the MAC address.
+    class SetDataAttr(RequestBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, specifying the six bytes of the MAC address."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the MAC address of the port.
 
         :return: the MAC address of the port.
         :rtype: P_MACADDRESS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mac_address: str) -> "Token":
+    def set(self, mac_address: Hex) -> Token[None]:
         """Set the MAC address of the port.
 
         :param mac_address: the MAC address of the port
-        :type mac_address: str
+        :type mac_address: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mac_address=mac_address))
 
 
 @register_command
 @dataclass
 class P_IPADDRESS:
     """
@@ -588,60 +750,63 @@
     default source address field in the IP header of generated traffic, and the
     configuration is also used for support of the ARP and PING protocols.
     """
 
     code: typing.ClassVar[int] = 117
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the IP address of the port.
-        subnet_mask: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the subnet mask of the local network segment for the port.
-        gateway: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the gateway of the local network segment for the port.
-        wild: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, wildcards used for ARP and PING replies, must be 255 or 0.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_address: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the IP address of the port.
-        subnet_mask: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the subnet mask of the local network segment for the port.
-        gateway: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the gateway of the local network segment for the port.
-        wild: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, wildcards used for ARP and PING replies, and each byte must be 255 (0xFF) or 0 (0x00).
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the IP address of the port."""
+        subnet_mask: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the subnet mask of the local network segment for the port."""
+        gateway: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the gateway of the local network segment for the port."""
+        wild: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, wildcards used for ARP and PING replies, and each byte must be 255 (0xFF) or 0 (0x00)."""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_address: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the IP address of the port."""
+        subnet_mask: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the subnet mask of the local network segment for the port."""
+        gateway: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the gateway of the local network segment for the port."""
+        wild: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, wildcards used for ARP and PING replies, must be 255 or 0."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IPv4 address, subnet mask, gateway address and wildcard used for ARP and PING replies of the port.
 
         :return: the IPv4 address, subnet mask, gateway address and wildcard used for ARP and PING replies of the port
         :rtype: P_IPADDRESS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(
-        self,
-        ipv4_address: typing.Union[str, int, ipaddress.IPv4Address],
-        subnet_mask: typing.Union[str, int, ipaddress.IPv4Address],
-        gateway: typing.Union[str, int, ipaddress.IPv4Address],
-        wild: typing.Union[str, int, ipaddress.IPv4Address],
-    ) -> "Token":
+    def set(self, ipv4_address: ipaddress.IPv4Address, subnet_mask: ipaddress.IPv4Address, gateway: ipaddress.IPv4Address, wild: ipaddress.IPv4Address) -> Token[None]:
         """Set the IPv4 address, subnet mask, gateway address and wildcard used for ARP and PING replies of the port.
 
         :param ipv4_address: the IPv4 address of the port
         :type ipv4_address: Union[str, int, ipaddress.IPv4Address]
         :param subnet_mask: the subnet mask of the local network segment for the port
         :type subnet_mask: Union[str, int, ipaddress.IPv4Address]
         :param gateway: he gateway of the local network segment for the port
         :type gateway: Union[str, int, ipaddress.IPv4Address]
         :param wild: wildcards used for ARP and PING replies, and each byte must be 255 (0xFF) or 0 (0x00)
         :type wild: Union[str, int, ipaddress.IPv4Address]
         """
+
         return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, ipv4_address=ipv4_address, subnet_mask=subnet_mask, gateway=gateway, wild=wild)
+            self._connection,
+            build_set_request(self, module=self._module, port=self._port, ipv4_address=ipv4_address, subnet_mask=subnet_mask, gateway=gateway, wild=wild)
         )
 
 
 @register_command
 @dataclass
 class P_ARPREPLY:
     """
@@ -650,45 +815,48 @@
     the port to the MAC address specified for the port. ARP/NDP reply generation is
     independent of whether traffic and capture is on for the port.
     """
 
     code: typing.ClassVar[int] = 118
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to ARP requests.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to ARP requests."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to ARP requests.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to ARP requests."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of whether the port replies to ARP requests.
 
         :return: the status of whether the port replies to ARP requests
         :rtype: P_ARPREPLY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the status of whether the port replies to ARP requests.
 
         :param on_off: whether the port replies to ARP requests
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the port from replying to incoming ARP requests.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the port to reply to incoming ARP requests.
     """
 
 
 @register_command
 @dataclass
@@ -699,45 +867,48 @@
     reply generation is independent of whether traffic and capture is on for the
     port.
     """
 
     code: typing.ClassVar[int] = 119
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to PING requests.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to PING requests."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to PING requests.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to PING requests."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of whether the port replies to IPv4/IPv6 PING requests.
 
         :return: the status of whether the port replies to IPv4/IPv6 PING requests
         :rtype: P_PINGREPLY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the status of whether the port replies to IPv4/IPv6 PING requests.
 
         :param on_off: whether the port replies to IPv4/IPv6 PING requests
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Enable IPv4/IPv6 PING reply on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable IPv4/IPv6 PING reply on the port.
     """
 
 
 @register_command
 @dataclass
@@ -745,45 +916,48 @@
     """
     Whether a port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.
     """
 
     code: typing.ClassVar[int] = 120
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether PAUSE response is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether PAUSE response is enabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether PAUSE response is enabled.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether PAUSE response is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.
 
         :return: the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.
         :rtype: P_PAUSE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.
 
         :param on_off: the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the port to respond to incoming Ethernet PAUSE frames.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the port to respond to incoming Ethernet PAUSE frames.
     """
 
 
 @register_command
 @dataclass
@@ -797,44 +971,42 @@
     variation by using a new time-based seed value each time traffic generation is
     restarted.
     """
 
     code: typing.ClassVar[int] = 121
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        seed: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, specifying a fixed seed value for the pseudo-random number generator. -1 = new random sequence for each start.
+    class GetDataAttr(ResponseBodyStruct):
+        seed: int = field(XmpInt())
+        """integer, specifying a fixed seed value for the pseudo-random number generator. -1 = new random sequence for each start."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        seed: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, specifying a fixed seed value for the pseudo-random number generator. -1 = new random sequence for each start.
+    class SetDataAttr(RequestBodyStruct):
+        seed: int = field(XmpInt())
+        """integer, specifying a fixed seed value for the pseudo-random number generator. -1 = new random sequence for each start."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the seed value specified for the port.
 
         :return: the seed value specified for the port.
         :rtype: P_RANDOMSEED.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, seed: int) -> "Token":
+    def set(self, seed: int) -> Token[None]:
         """Set the seed value for the port.
 
         :param seed: the seed value for the port
         :type seed: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, seed=seed))
 
 
 @register_command
 @dataclass
 class P_LOOPBACK:
     """
@@ -846,60 +1018,68 @@
     useful for testing the generated traffic patterns before actual use.
 
     """
 
     code: typing.ClassVar[int] = 122
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LoopbackMode)  # coded byte, specifying the loopback mode of the port.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: LoopbackMode = field(XmpByte())
+        """coded byte, specifying the loopback mode of the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LoopbackMode)  # coded byte, specifying the loopback mode of the port.
+    class SetDataAttr(RequestBodyStruct):
+        mode: LoopbackMode = field(XmpByte())
+        """coded byte, specifying the loopback mode of the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the loop back mode of the port.
 
         :return: the loop back mode of the port.
         :rtype: P_LOOPBACK.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: LoopbackMode) -> "Token":
+    def set(self, mode: LoopbackMode) -> Token[None]:
         """Set the loop back mode of the port.
 
         :param mode: the loop back mode of the port
         :type mode: LoopbackMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_none = functools.partialmethod(set, LoopbackMode.NONE)
     """Set the port loop back mode to non-looped.
     """
+
     set_l1rx2tx = functools.partialmethod(set, LoopbackMode.L1RX2TX)
     """Set the port loop back mode to L1RX2TX, transmit byte-by-byte copy of the incoming packet.
     """
+
     set_l2rx2tx = functools.partialmethod(set, LoopbackMode.L2RX2TX)
     """Set the port loop back mode to L2RX2TX, swap source and destination MAC addresses.
     """
+
     set_l3rx2tx = functools.partialmethod(set, LoopbackMode.L3RX2TX)
     """Set the port loop back mode to L3RX2TX, swap source and destination MAC addresses and swap source and destination IP addresses.
     """
+
     set_txon2rx = functools.partialmethod(set, LoopbackMode.TXON2RX)
     """Set the port loop back mode to TXON2RX, packet is also transmitted from the port.
     """
+
     set_txoff2rx = functools.partialmethod(set, LoopbackMode.TXOFF2RX)
     """Set the port loop back mode to TXOFF2RX, port transmitter is off.
     """
+
     set_port2port = functools.partialmethod(set, LoopbackMode.PORT2PORT)
     """Set the port loop back mode to PORT2PORT, packets received on one port is sent out again on the neighbor port for inline monitoring.
     """
 
 
 @register_command
 @dataclass
@@ -909,45 +1089,48 @@
     interval. This is helpful when you need to identify a specific port within a
     chassis.
     """
 
     code: typing.ClassVar[int] = 123
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the test port LED is blinking.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the test port LED is blinking."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the test port LED is blinking.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the test port LED is blinking."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of the LED flashing status of the port.
 
         :return: the status of the LED flashing status of the port.
         :rtype: P_FLASH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the status of the LED flashing status of the port.
 
         :param on_off: the status of the LED flashing status of the port.
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable port LED from flashing.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable port LED to flash.
     """
 
 
 @register_command
 @dataclass
@@ -955,52 +1138,56 @@
     """
     Whether a port is transmitting packets. When on, the port generates a sequence
     of packets with contributions from each stream that is enabled. The streams are
     configured using the PS_xxx parameters.
 
     .. note::
 
-        From Release 57.1, if any of the specified packet sizes cannot fit into the packet generator, this command will return FAILED and not start the traffic. While traffic is on the streams for this port cannot be enabled or disabled, and the configuration of those streams that are enabled cannot be changed.
+        From Release 57.1, if any of the specified packet sizes cannot fit into the packet generator, this command will return FAILED and not start the traffic.
+        While traffic is on the streams for this port cannot be enabled or disabled, and the configuration of those streams that are enabled cannot be changed.
 
     """
 
     code: typing.ClassVar[int] = 124
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=StartOrStop)  # coded byte, determines whether to start or stop traffic generation on this port.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: TrafficOnOff = field(XmpByte())
+        """coded byte, determines whether to start or stop traffic generation on this port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TrafficOnOff)  # coded byte, determines whether to start or stop traffic generation on this port.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: StartOrStop = field(XmpByte())
+        """coded byte, determines whether to start or stop traffic generation on this port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the traffic generation status of the port.
 
         :return: the traffic generation status of the port
         :rtype: P_TRAFFIC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: StartOrStop) -> "Token":
+    def set(self, on_off: StartOrStop) -> Token[None]:
         """Set the traffic generation status of the port.
 
         :param on_off: the traffic generation status of the port.
         :type on_off: StartOrStop
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_stop = functools.partialmethod(set, StartOrStop.STOP)
     """Stop the traffic generation of the port.
     """
+
     set_start = functools.partialmethod(set, StartOrStop.START)
     """Start the traffic generation of the port.
     """
 
 
 @register_command
 @dataclass
@@ -1011,45 +1198,48 @@
     configured using the PC_xxx parameters. While capture is on the capture
     parameters cannot be changed.
     """
 
     code: typing.ClassVar[int] = 125
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=StartOrStop)  # coded byte, whether capture is active for this port.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether capture is active for this port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether capture is active for this port.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: StartOrStop = field(XmpByte())
+        """coded byte, whether capture is active for this port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the port is capturing packets.
 
         :return: whether the port is capturing packets.
         :rtype: P_CAPTURE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: StartOrStop) -> "Token":
+    def set(self, on_off: StartOrStop) -> Token[None]:
         """Set whether the port is capturing packets.
 
         :param on_off: whether the port is capturing packets.
         :type on_off: StartOrStop
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_stop = functools.partialmethod(set, StartOrStop.STOP)
     """Stop packet capturing on the port.
     """
+
     set_start = functools.partialmethod(set, StartOrStop.START)
     """Start packet capturing on the port.
     """
 
 
 @register_command
 @dataclass
@@ -1059,28 +1249,30 @@
     and independent of whether traffic is on. A valid Frame Check Sum is written
     into the final four bytes.
     """
 
     code: typing.ClassVar[int] = 126
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the data content of the packet to be transmitted.
+    class SetDataAttr(RequestBodyStruct):
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, the data content of the packet to be transmitted."""
 
-    def set(self, hex_data: str) -> "Token":
-        """Transmits a single packet from a port, independent of the stream definitions, and independent of whether traffic is on. A valid Frame Check Sum is written into the final four bytes.
+    def set(self, hex_data: Hex) -> Token[None]:
+        """Transmits a single packet from a port, independent of the stream definitions, and independent of whether traffic is on.
+        A valid Frame Check Sum is written into the final four bytes.
 
         :param hex_data: raw bytes of the packet in hex to transmit
-        :rtype: List[str]
+        :rtype: typing.List[str]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, hex_data=hex_data))
 
 
 @register_command
 @dataclass
 class P_LATENCYOFFSET:
     """
@@ -1088,40 +1280,42 @@
     containing test payloads. This value affects the minimum, average, and maximum
     latency values obtained through the PR_TPLDLATENCY command.
     """
 
     code: typing.ClassVar[int] = 127
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the offset for the latency measurements.
+    class GetDataAttr(ResponseBodyStruct):
+        offset: int = field(XmpInt())
+        """integer, specifying the offset for the latency measurements."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the offset for the latency measurements.
+    class SetDataAttr(RequestBodyStruct):
+        offset: int = field(XmpInt())
+        """integer, specifying the offset for the latency measurements."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port latency offset value in nanoseconds.
 
         :return: the port latency offset value in nanoseconds
         :rtype: P_LATENCYOFFSET.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, offset: int) -> "Token":
+    def set(self, offset: int) -> Token[None]:
         """Set the port latency offset value in nanoseconds.
 
         :param offset: the port latency offset value in nanoseconds
         :type offset: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, offset=offset))
 
 
 @register_command
 @dataclass
 class P_LATENCYMODE:
     """
@@ -1142,53 +1336,61 @@
             port and the receiving port; otherwise invalid measurements will occur.
 
     """
 
     code: typing.ClassVar[int] = 128
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LatencyMode)  # coded byte, which calculation mode to use.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: LatencyMode = field(XmpByte())
+        """coded byte, which calculation mode to use."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LatencyMode)  # coded byte, which calculation mode to use.
+    class SetDataAttr(RequestBodyStruct):
+        mode: LatencyMode = field(XmpByte())
+        """coded byte, which calculation mode to use."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the latency measurement mode of the port.
 
         :return: the latency measurement mode of the port
         :rtype: P_LATENCYMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: LatencyMode) -> "Token":
+    def set(self, mode: LatencyMode) -> Token[None]:
         """Set the latency measurement mode of the port.
 
         :param mode: the latency measurement mode of the port
         :type mode: LatencyMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_last2last = functools.partialmethod(set, LatencyMode.LAST2LAST)
     """Set the port latency mode to LAST2LAST (Last-bit-out to last-bit-in, which measures basic bit-transit time, independent of packet length).
     """
+
     set_first2last = functools.partialmethod(set, LatencyMode.FIRST2LAST)
     """Set the port latency mode to FIRST2LAST (First-bit-out to last-bit-in, which adds the time taken to transmit the packet itself).
     """
+
     set_last2first = functools.partialmethod(set, LatencyMode.LAST2FIRST)
-    """Set the port latency mode to LAST2FIRST (Last-bit-out to first-bit-in, which subtracts the time taken to transmit the packet itself. The same latency mode must be configured for the transmitting port and the receiving port; otherwise invalid measurements will occur).
+    """Set the port latency mode to LAST2FIRST (Last-bit-out to first-bit-in, which subtracts the time taken to transmit the packet itself.
+    The same latency mode must be configured for the transmitting port and the receiving port; otherwise invalid measurements will occur).
     """
+
     set_first2first = functools.partialmethod(set, LatencyMode.FIRST2FIRST)
-    """Set the port latency mode to FIRST2FIRST (First-bit-out to first-bit-in, which adds the time taken to transmit the packet itself, and subtracts the time taken to transmit the packet itself. The same latency mode must be configured for the transmitting port and the receiving port; otherwise invalid measurements will occur).
+    """Set the port latency mode to FIRST2FIRST
+    (First-bit-out to first-bit-in, which adds the time taken to transmit the packet itself, and subtracts the time taken to transmit the packet itself.
+    The same latency mode must be configured for the transmitting port and the receiving port; otherwise invalid measurements will occur).
     """
 
 
 @register_command
 @dataclass
 class P_AUTOTRAIN:
     """
@@ -1201,93 +1403,98 @@
     the port to send switch training packets, independent of whether the port is
     transmitting test traffic.
     """
 
     code: typing.ClassVar[int] = 129
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        interval: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the number of seconds between training packets. 0, disable training packets.
+    class GetDataAttr(ResponseBodyStruct):
+        interval: int = field(XmpInt())
+        """integer, specifying the number of seconds between training packets. 0, disable training packets."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        interval: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the number of seconds between training packets. 0, disable training packets.
+    class SetDataAttr(RequestBodyStruct):
+        interval: int = field(XmpInt())
+        """integer, specifying the number of seconds between training packets. 0, disable training packets."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the interval between sending out training packets of the port in seconds.
 
         :return: the interval between sending out training packets of the port.
         :rtype: P_AUTOTRAIN.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, interval: int) -> "Token":
+    def set(self, interval: int) -> Token[None]:
         """Set the interval between sending out training packets of the port in seconds.
 
         :param interval: the interval between sending out training packets of the port
         :type interval: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, interval=interval))
 
 
 @register_command
 @dataclass
 class P_UAT_MODE:
     """
     This command defines if a port is currently used by test suite Valkyrie1564, which
     means that UAT (UnAvailable Time) will be detected for the port.
     """
 
     code: typing.ClassVar[int] = 138
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # specifies the state of the affected stream counters
-        delay: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, time in milliseconds to wait before detection of UAT is started. Default value: 500. This parameter is ignored when state is set to OFF.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: OnOff = field(XmpByte())
+        """specifies the state of the affected stream counters"""
+        delay: int = field(XmpInt())
+        """integer,time in milliseconds to wait before detection of UAT is started. Default value: 500. This parameter is ignored when state is set to OFF."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # specifies the state of the affected stream counters
-        delay: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer,time in milliseconds to wait before detection of UAT is started. Default value: 500. This parameter is ignored when state is set to OFF.
+    class SetDataAttr(RequestBodyStruct):
+        mode: OnOff = field(XmpByte())
+        """specifies the state of the affected stream counters"""
+        delay: int = field(XmpInt())
+        """integer, time in milliseconds to wait before detection of UAT is started. Default value: 500. This parameter is ignored when state is set to OFF."""
 
-    def get(self) -> "Token[GetDataAttr]":
-        """Get the state of the affected stream counters and time in milliseconds to wait before detection of UAT is started. Default value: 500. This command is ignored when state is set to OFF.
+    def get(self) -> Token[GetDataAttr]:
+        """Get the state of the affected stream counters and time in milliseconds to wait before detection of UAT is started. Default value: 500.
+        This command is ignored when state is set to OFF.
 
-        :return: the state of the affected stream counters and time in milliseconds to wait before detection of UAT is started. Default value: 500. This command is ignored when state is set to OFF.
+        :return: the state of the affected stream counters and time in milliseconds to wait before detection of UAT is started. Default value: 500.
+            This command is ignored when state is set to OFF.
         :rtype: P_UAT_MODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: OnOff, delay: int) -> "Token":
+    def set(self, mode: OnOff, delay: int) -> Token[None]:
         """Set the UAT mode of the port.
 
         :param mode: the state of the affected stream counters
         :type mode: OnOff
         :param delay: time in milliseconds to wait before detection of UAT is started. Default value: 500. This command is ignored when state is set to OFF
         :type delay: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode, delay=delay))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable UAT on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable UAT on the port.
     """
 
 
 @register_command
 @dataclass
@@ -1297,42 +1504,42 @@
     declared as a Severely Errored Second (SES). In Valkyrie1564 UnAvailable Time
     (UAT) is declared after 10 consecutive SES has been detected
     """
 
     code: typing.ClassVar[int] = 139
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        frame_loss_ratio: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, Frame Loss Ratio specified as a number times 1/100, 0..100
+    class GetDataAttr(ResponseBodyStruct):
+        frame_loss_ratio: int = field(XmpByte())
+        """byte, specifies the Frame Loss Ratio threshold for SES as a fraction of 1 * 100 (i.e. if the threshold is 0.50, value is 50)"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        frame_loss_ratio: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte
-        )  # byte, specifies the Frame Loss Ratio threshold for SES as a fraction of 1 * 100 (i.e. if the threshold is 0.50, value is 50)
+    class SetDataAttr(RequestBodyStruct):
+        frame_loss_ratio: int = field(XmpByte())
+        """byte, Frame Loss Ratio specified as a number times 1/100, 0..100"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the the threshold for the Frame Loss Ratio, where a second is declared as a Severely Errored Second (SES).
 
         :return: specifies the Frame Loss Ratio threshold for SES as a fraction of 1 * 100 (i.e. if the threshold is 0.50, value is 50)
         :rtype: P_UAT_FLR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, frame_loss_ratio: int) -> "Token":
+    def set(self, frame_loss_ratio: int) -> Token[None]:
         """Set the the threshold for the Frame Loss Ratio, where a second is declared as a Severely Errored Second (SES).
 
         :param frame_loss_ratio: Frame Loss Ratio specified as a number times 1/100, 0..100
         :type frame_loss_ratio: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, frame_loss_ratio=frame_loss_ratio))
 
 
 @register_command
 @dataclass
 class P_MIXWEIGHTS:
     """
@@ -1348,66 +1555,97 @@
         This command requires Xena server version 375 or higher.
 
     """
 
     code: typing.ClassVar[int] = 192
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        weight_56_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 56-byte frame sizes.
-        weight_60_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 60-byte frame sizes.
-        weight_64_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 64-byte frame sizes.
-        weight_70_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 70-byte frame sizes.
-        weight_78_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 78-byte frame sizes.
-        weight_92_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 92-byte frame sizes.
-        weight_256_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 256-byte frame sizes.
-        weight_496_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 496-byte frame sizes.
-        weight_512_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 512-byte frame sizes.
-        weight_570_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 570-byte frame sizes.
-        weight_576_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 576-byte frame sizes.
-        weight_594_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 594-byte frame sizes.
-        weight_1438_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 1438-byte frame sizes.
-        weight_1518_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 1518-byte frame sizes.
-        weight_9216_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 9216-byte frame sizes.
-        weight_16360_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 16360-byte frame sizes.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        weight_56_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 56-byte frame sizes.
-        weight_60_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 60-byte frame sizes.
-        weight_64_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 64-byte frame sizes.
-        weight_70_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 70-byte frame sizes.
-        weight_78_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 78-byte frame sizes.
-        weight_92_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 92-byte frame sizes.
-        weight_256_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 256-byte frame sizes.
-        weight_496_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 496-byte frame sizes.
-        weight_512_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 512-byte frame sizes.
-        weight_570_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 570-byte frame sizes.
-        weight_576_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 576-byte frame sizes.
-        weight_594_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 594-byte frame sizes.
-        weight_1438_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 1438-byte frame sizes.
-        weight_1518_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 1518-byte frame sizes.
-        weight_9216_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 9216-byte frame sizes.
-        weight_16360_bytes: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the percentage of 16360-byte frame sizes.
+    class GetDataAttr(ResponseBodyStruct):
+        weight_56_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 56-byte frame sizes."""
+        weight_60_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 60-byte frame sizes."""
+        weight_64_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 64-byte frame sizes."""
+        weight_70_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 70-byte frame sizes."""
+        weight_78_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 78-byte frame sizes."""
+        weight_92_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 92-byte frame sizes."""
+        weight_256_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 256-byte frame sizes."""
+        weight_496_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 496-byte frame sizes."""
+        weight_512_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 512-byte frame sizes."""
+        weight_570_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 570-byte frame sizes."""
+        weight_576_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 576-byte frame sizes."""
+        weight_594_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 594-byte frame sizes."""
+        weight_1438_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 1438-byte frame sizes."""
+        weight_1518_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 1518-byte frame sizes."""
+        weight_9216_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 9216-byte frame sizes."""
+        weight_16360_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 16360-byte frame sizes."""
+
+    class SetDataAttr(RequestBodyStruct):
+        weight_56_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 56-byte frame sizes."""
+        weight_60_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 60-byte frame sizes."""
+        weight_64_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 64-byte frame sizes."""
+        weight_70_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 70-byte frame sizes."""
+        weight_78_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 78-byte frame sizes."""
+        weight_92_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 92-byte frame sizes."""
+        weight_256_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 256-byte frame sizes."""
+        weight_496_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 496-byte frame sizes."""
+        weight_512_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 512-byte frame sizes."""
+        weight_570_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 570-byte frame sizes."""
+        weight_576_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 576-byte frame sizes."""
+        weight_594_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 594-byte frame sizes."""
+        weight_1438_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 1438-byte frame sizes."""
+        weight_1518_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 1518-byte frame sizes."""
+        weight_9216_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 9216-byte frame sizes."""
+        weight_16360_bytes: int = field(XmpInt())
+        """integer, specifying the percentage of 16360-byte frame sizes."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the percentage of each of the
         16 possible frame sizes used in the MIX. The sum of the percentage values specified must
         be 100. The command will affect the mix-distribution for all streams on the port.
         The possible 16 frame sizes are: 56 (not valid for 40G and above), 60, 64, 70, 78, 92,
         256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360.
 
         :return: the percentage of each of the 16 possible frame sizes used in the MIX.
         :rtype: P_MIXWEIGHTS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
     def set(
         self,
         weight_56_bytes: int,
         weight_60_bytes: int,
         weight_64_bytes: int,
@@ -1419,16 +1657,16 @@
         weight_512_bytes: int,
         weight_570_bytes: int,
         weight_576_bytes: int,
         weight_594_bytes: int,
         weight_1438_bytes: int,
         weight_1518_bytes: int,
         weight_9216_bytes: int,
-        weight_16360_bytes: int,
-    ) -> "Token":
+        weight_16360_bytes: int
+    ) -> Token[None]:
         """Set the percentage of each of the
         16 possible frame sizes used in the MIX. The sum of the percentage values specified must
         be 100. The command will affect the mix-distribution for all streams on the port.
         The possible 16 frame sizes are: 56 (not valid for 40G and above), 60, 64, 70, 78, 92,
         256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360.
 
         :param weight_56_bytes: specifying the percentage of 56-byte frame sizes
@@ -1460,14 +1698,15 @@
         :param weight_1518_bytes: specifying the percentage of 1518-byte frame sizes
         :type weight_1518_bytes: int
         :param weight_9216_bytes: specifying the percentage of 9216-byte frame sizes
         :type weight_9216_bytes: int
         :param weight_16360_bytes: specifying the percentage of 16360-byte frame sizes
         :type weight_16360_bytes: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 weight_56_bytes=weight_56_bytes,
@@ -1481,64 +1720,68 @@
                 weight_512_bytes=weight_512_bytes,
                 weight_570_bytes=weight_570_bytes,
                 weight_576_bytes=weight_576_bytes,
                 weight_594_bytes=weight_594_bytes,
                 weight_1438_bytes=weight_1438_bytes,
                 weight_1518_bytes=weight_1518_bytes,
                 weight_9216_bytes=weight_9216_bytes,
-                weight_16360_bytes=weight_16360_bytes,
-            ),
+                weight_16360_bytes=weight_16360_bytes
+            )
         )
 
 
 @register_command
 @dataclass
 class P_MDIXMODE:
     """
     Selects the MDI/MDIX behavior of copper interfaces (Currently supported on
     M6SFP and M2SFPT).
     """
 
     code: typing.ClassVar[int] = 194
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MDIXMode)  # coded byte, containing the MDI/MDIX mode for the port.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: MDIXMode = field(XmpByte())
+        """coded byte, containing the MDI/MDIX mode for the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MDIXMode)  # coded byte, containing the MDI/MDIX mode for the port.
+    class SetDataAttr(RequestBodyStruct):
+        mode: MDIXMode = field(XmpByte())
+        """coded byte, containing the MDI/MDIX mode for the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the MDI/MDIX mode of the port.
 
         :return: the MDI/MDIX mode of the port.
         :rtype: P_MDIXMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: MDIXMode) -> "Token":
+    def set(self, mode: MDIXMode) -> Token[None]:
         """Set the MDI/MDIX mode of the port.
 
         :param mode: the MDI/MDIX mode of the port.
         :type mode: MDIXMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_auto = functools.partialmethod(set, MDIXMode.AUTO)
     """Set the MDI/MDIX mode of the port to Auto.
     """
+
     set_mdi = functools.partialmethod(set, MDIXMode.MDI)
     """Set the MDI/MDIX mode of the port to MDI.
     """
+
     set_mdix = functools.partialmethod(set, MDIXMode.MDIX)
     """Set the MDI/MDIX mode of the port to MDIX.
     """
 
 
 @register_command
 @dataclass
@@ -1547,28 +1790,29 @@
     Obtain the traffic error which has occurred in the last ``*_TRAFFIC`` or ``C_TRAFFICSYNC`` command.
 
     """
 
     code: typing.ClassVar[int] = 198
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        error: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=TrafficError)  # coded byte, specifies the port traffic error.
+    class GetDataAttr(ResponseBodyStruct):
+        error: TrafficError = field(XmpInt())
+        """coded byte, specifies the port traffic error."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get traffic error which has occurred in the last ``*_TRAFFIC`` or ``C_TRAFFICSYNC`` command.
 
         :return: traffic error which has occurred in the last ``*_TRAFFIC`` or ``C_TRAFFICSYNC`` command
         :rtype: P_TRAFFICERR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_GAPMONITOR:
     """
@@ -1577,47 +1821,47 @@
     gaps between them. Once a gap event is encountered it requires a certain number
     of consecutive packets below the threshold to end the event.
     """
 
     code: typing.ClassVar[int] = 301
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        start: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the maximum allowed gap between packets, in microseconds. (0 to 134.000 microseconds) 0 = disable gap monitor.
-        stop: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minimum number of good packets required. (0 to 1024 packets) 0 = disable gap monitor.
+    class GetDataAttr(ResponseBodyStruct):
+        start: int = field(XmpInt())
+        """integer, the maximum allowed gap between packets, in microseconds. (0 to 134.000 microseconds) 0 = disable gap monitor."""
+        stop: int = field(XmpInt())
+        """integer, the minimum number of good packets required. (0 to 1024 packets) 0 = disable gap monitor."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        start: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the maximum allowed gap between packets, in microseconds. (0 to 134.000 microseconds) 0 = disable gap monitor.
-        stop: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minimum number of good packets required. (0 to 1024 packets) 0 = disable gap monitor.
+    class SetDataAttr(RequestBodyStruct):
+        start: int = field(XmpInt())
+        """integer, the maximum allowed gap between packets, in microseconds. (0 to 134.000 microseconds) 0 = disable gap monitor."""
+        stop: int = field(XmpInt())
+        """integer, the minimum number of good packets required. (0 to 1024 packets) 0 = disable gap monitor."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the gap-start and gap-stop criteria for the port's gap monitor.
 
         :return: the gap-start and gap-stop criteria for the port's gap monitor
         :rtype: P_GAPMONITOR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, start: int, stop: int) -> "Token":
+    def set(self, start: int, stop: int) -> Token[None]:
         """Set the gap-start and gap-stop criteria for the port's gap monitor.
         :param start: the maximum allowed gap between packets, in microseconds. (0 to 134.000 microseconds) 0 = disable gap monitor
         :type start: int
         :param stop: the minimum number of good packets required. (0 to 1024 packets) 0 = disable gap monitor
         :type stop: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, start=start, stop=stop))
 
 
 @register_command
 @dataclass
 class P_CHECKSUM:
     """
@@ -1626,46 +1870,62 @@
     modifications to the protocol fields (which should therefore not have modifiers
     on them).
     """
 
     code: typing.ClassVar[int] = 302
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        offset: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable. Valid enable range is [8 .. 127]. Please observe that ON equals the value 14. Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
+    class GetDataAttr(ResponseBodyStruct):
+        offset: int = field(XmpByte())
+        """byte, the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable.
+        Valid enable range is [8 .. 127, ON].
+        Please observe that ON equals the value 14.
+        Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
+        """
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        offset: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable. Valid enable range is [8 .. 127, ON]. Please observe that ON equals the value 14. Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
+    class SetDataAttr(RequestBodyStruct):
+        offset: int = field(XmpByte())
+        """byte, the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable.
+        Valid enable range is [8 .. 127].
+        Please observe that ON equals the value 14.
+        Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
-        """Get the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable. Valid enable range is [8 .. 127, ON]. Please observe that ON equals the value 14. Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
+    def get(self) -> Token[GetDataAttr]:
+        """Get the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable.
+        Valid enable range is [8 .. 127, ON].
+        Please observe that ON equals the value 14.
+        Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
 
         :return: the offset in the packet where the calculation of the extra checksum is started from
         :rtype: P_CHECKSUM.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, offset: int) -> "Token":
-        """Set the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable. Valid enable range is [8 .. 127, ON].
-        Please observe that ON equals the value 14. Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
+    def set(self, offset: int) -> Token[None]:
+        """Set the offset in the packet where the calculation of the extra checksum is started from.
+        Set to OFF or 0 to disable. Valid enable range is [8 .. 127, ON].
+        Please observe that ON equals the value 14.
+        Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).
 
         :param offset:  the offset in the packet where the calculation of the extra checksum is started from
         :type offset: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, offset=offset))
 
     set_off = functools.partialmethod(set, 0)
     """Set port's payload checksum off (offset = 0).
     """
+
     set_on = functools.partialmethod(set, 14)
     """Set port's payload checksum on (offset = 14).
     """
 
 
 @register_command
 @dataclass
@@ -1673,71 +1933,75 @@
     """
     Get the received signal level for optical ports.
     """
 
     code: typing.ClassVar[int] = 303
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        optical_power: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, received signal level for optical ports, in nanowatts, -1 when not available.
+    class GetDataAttr(ResponseBodyStruct):
+        optical_power: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, received signal level for optical ports, in nanowatts, -1 when not available."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the received signal level for optical ports, in nanowatts, -1 when not available.
 
         :return: the received signal level for optical ports, in nanowatts, -1 when not available
         :rtype: P_STATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_AUTONEGSELECTION:
     """
     Whether the port responds to incoming auto-negotiation requests. Only applicable
     to electrical ports (RJ45).
     """
 
     code: typing.ClassVar[int] = 304
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to auto-neg requests.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to auto-neg requests."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to auto-neg requests.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to auto-neg requests."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the port responds to incoming auto-negotiation requests.
 
         :return: whether the port responds to incoming auto-negotiation requests
         :rtype: P_AUTONEGSELECTION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether the port responds to incoming auto-negotiation requests.
 
         :param on_off: whether the port responds to incoming auto-negotiation requests
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
+
     set_on = functools.partialmethod(set, OnOff.ON)
 
 
 @register_command
 @dataclass
 class P_MIXLENGTH:
     """
@@ -1754,201 +2018,217 @@
         This command requires release 84 or higher.
 
     """
 
     code: typing.ClassVar[int] = 305
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
-    position_xindex: int
+    _position_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        frame_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, frame size of the position
+    class GetDataAttr(ResponseBodyStruct):
+        frame_size: int = field(XmpInt())
+        """integer, frame size of the position"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        frame_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, frame size of the position
+    class SetDataAttr(RequestBodyStruct):
+        frame_size: int = field(XmpInt())
+        """integer, frame size of the position"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get frame sizes defined for each position of the P_MIXWEIGHTS command.
         By default, the 16 frame sizes are: 56 (not valid for 40G/100G), 60,
         64, 70, 78, 92, 256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360.
 
         :return: frame sizes defined for each position of the P_MIXWEIGHTS command
         :rtype: P_MIXLENGTH.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self.position_xindex]))
 
-    def set(self, frame_size: int) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._position_xindex]))
+
+    def set(self, frame_size: int) -> Token[None]:
         """Set the frame size defined for positions 0, 1, 14 and 15 (default values 56, 60, 9216 and 16360), in bytes.
 
         :param frame_size: the frame size for the position.
         :type frame_size: int
         """
-        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self.position_xindex], frame_size=frame_size))
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._position_xindex], frame_size=frame_size))
 
 
 @register_command
 @dataclass
 class P_ARPRXTABLE:
     """
     Port ARP table used to reply to incoming ARP requests.
     """
 
     code: typing.ClassVar[int] = 308
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        chunks: XmpField[subtypes.ArpChunkList] = XmpField(subtypes.ArpChunkList)
+    class GetDataAttr(ResponseBodyStruct):
+        chunks: typing.List[ArpChunk] = field(XmpSequence(types_chunk=[XmpIPv4Address(), XmpShort(), XmpByte(), XmpMacAddress()]))
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        chunks: XmpField[subtypes.ArpChunkList] = XmpField(subtypes.ArpChunkList)
+    class SetDataAttr(RequestBodyStruct):
+        chunks: typing.List[ArpChunk] = field(XmpSequence(types_chunk=[XmpIPv4Address(), XmpShort(), XmpByte(), XmpMacAddress()]))
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's ARP table used to reply to incoming ARP requests.
 
         :return: the port's ARP table used to reply to incoming ARP requests.
             * IP address to match to the Target IP address in the ARP requests,
             * The prefix used for address matching,
             * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix,
             * The target MAC address to return in the ARP reply
         :rtype: P_ARPRXTABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, chunks: typing.List[subtypes.ArpChunk]) -> "Token":
+    def set(self, chunks: typing.List[ArpChunk]) -> Token[None]:
         """Set the port's ARP table used to reply to incoming ARP requests.
 
         :param chunks:
             * IP address to match to the Target IP address in the ARP requests
             * The prefix used for address matching
             * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix
             * The target MAC address to return in the ARP reply
-        :type chunks: List[subtypes.ArpChunkList]
+        :type chunks: typing.List[subtypes.ArpChunkList]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, chunks=chunks))
 
 
 @register_command
 @dataclass
 class P_NDPRXTABLE:
     """
     Port NDP table used to reply to incoming NDP Neighbor Solicitation.
     """
 
     code: typing.ClassVar[int] = 309
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        chunks: XmpField[subtypes.NdpChunkList] = XmpField(subtypes.NdpChunkList)
+    class GetDataAttr(ResponseBodyStruct):
+        chunks: typing.List[NdpChunk] = field(XmpSequence(types_chunk=[XmpIPv6Address(), XmpShort(), XmpByte(), XmpMacAddress()]))
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        chunks: XmpField[subtypes.NdpChunkList] = XmpField(subtypes.NdpChunkList)
+    class SetDataAttr(RequestBodyStruct):
+        chunks: typing.List[NdpChunk] = field(XmpSequence(types_chunk=[XmpIPv6Address(), XmpShort(), XmpByte(), XmpMacAddress()]))
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's NDP table used to reply to incoming NDP Neighbor Solicitation.
 
         :return: the port's NDP table used to reply to incoming NDP Neighbor Solicitation.
             * IP address to match to the Target IP address in the NDP Neighbor Solicitation
             * The prefix used for address matching
             * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix
             * The target MAC address to return in the NDP Neighbor Advertisement
         :rtype: P_NDPRXTABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, chunks: typing.List[subtypes.NdpChunk]) -> "Token":
+    def set(self, chunks: typing.List[NdpChunk]) -> Token[None]:
         """Set the port's NDP table used to reply to incoming NDP Neighbor Solicitation.
 
         :param chunks:
             * IP address to match to the Target IP address in the NDP Neighbor Solicitation
             * The prefix used for address matching
             * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix
             * The target MAC address to return in the NDP Neighbor Advertisement
-        :type chunks: List[subtypes.NdpChunkList]
+        :type chunks: typing.List[subtypes.NdpChunkList]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, chunks=chunks))
 
 
 @register_command
 @dataclass
 class P_MULTICAST:
     """
     A multicast mode for a port. Ports can use the IGMPv2 protocol to join or leave
     multicast groups, either on an on-off basis or repeatedly.
     """
 
     code: typing.ClassVar[int] = 311
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_multicast_addresses: XmpField[xt.XmpIPV4AddressListStopToKeep4] = XmpField(xt.XmpIPV4AddressListStopToKeep4)  # a multicast group address to join or leave
-        operation: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MulticastOperation)  # coded byte, specifying the operation.
-        second_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # the interval between repeated joins in seconds.
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address] = field(XmpSequence(types_chunk=[XmpIPv4Address()]))
+        """a multicast group address to join or leave"""
+        operation: MulticastOperation = field(XmpByte())
+        """coded byte, specifying the operation."""
+        second_count: int = field(XmpByte())
+        """the interval between repeated joins in seconds."""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address] = field(XmpSequence(types_chunk=[XmpIPv4Address()]))
+        """a multicast group address to join or leave"""
+        operation: MulticastOperation = field(XmpByte())
+        """coded byte, specifying the operation."""
+        second_count: int = field(XmpByte())
+        """the interval between repeated joins in seconds."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_multicast_addresses: XmpField[xt.XmpIPV4AddressListStopToKeep4] = XmpField(xt.XmpIPV4AddressListStopToKeep4)  # a multicast group address to join or leave
-        operation: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MulticastOperation)  # coded byte, specifying the operation.
-        second_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # the interval between repeated joins in seconds.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's multicast information (IGMPv2).
 
         :return: the port's multicast information (IGMPv2)
         :rtype: P_MULTICAST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address], operation: MulticastOperation, second_count: int) -> "Token":
+    def set(self, ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address], operation: MulticastOperation, second_count: int) -> Token[None]:
         """Set the port's multicast information (IGMPv2).
 
         :param ipv4_multicast_addresses: a multicast group address to join or leave
-        :type ipv4_multicast_addresses: List[ipaddress.IPv4Address]
+        :type ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address]
         :param operation: the operation
         :type operation: MulticastOperation
         :param second_count: the interval between repeated joins in seconds.
         :type second_count: int
         """
+
         return Token(
             self._connection,
             build_set_request(
-                self, module=self._module, port=self._port, ipv4_multicast_addresses=ipv4_multicast_addresses, operation=operation, second_count=second_count
-            ),
+                self,
+                module=self._module,
+                port=self._port,
+                ipv4_multicast_addresses=ipv4_multicast_addresses,
+                operation=operation,
+                second_count=second_count
+            )
         )
 
     set_off = functools.partialmethod(set, operation=MulticastOperation.OFF)
     """Set port's multicast operation to Off.
     """
+
     set_on = functools.partialmethod(set, operation=MulticastOperation.ON)
     """Set port's multicast operation to On.
     """
+
     set_join = functools.partialmethod(set, operation=MulticastOperation.JOIN)
     """Set port's multicast operation to Join.
     """
+
     set_leave = functools.partialmethod(set, operation=MulticastOperation.LEAVE)
     """Set port's multicast operation to Join.
     """
 
 
 @register_command
 @dataclass
@@ -1958,111 +2238,113 @@
     leave multicast groups, either on an on-off basis or repeatedly. ** Requires
     software release 83.2 or higher
     """
 
     code: typing.ClassVar[int] = 312
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_multicast_addresses: XmpField[xt.XmpIPV4AddressListStopToKeep4] = XmpField(
-            xt.XmpIPV4AddressListStopToKeep4
-        )  # list of addresses, up to 8 multicast group addresses to receive an operation
-        operation: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MulticastExtOperation)  # coded byte, specifying the operation.
-        second_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, the interval between repeated joins/excludes in seconds.
-        igmp_version: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IGMPVersion)  # coded byte, specifying the IGMP version.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_multicast_addresses: XmpField[xt.XmpIPV4AddressListStopToKeep4] = XmpField(
-            xt.XmpIPV4AddressListStopToKeep4
-        )  # list of addresses, up to 8 multicast group addresses to receive an operation
-        operation: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MulticastExtOperation)  # coded byte, specifying the operation.
-        second_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, the interval between repeated joins/excludes in seconds.
-        igmp_version: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=IGMPVersion)  # coded byte, specifying the IGMP version.
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address] = field(XmpSequence(types_chunk=[XmpIPv4Address()]))
+        """list of addresses, up to 8 multicast group addresses to receive an operation"""
+        operation: MulticastExtOperation = field(XmpByte())
+        """coded byte, specifying the operation."""
+        second_count: int = field(XmpByte())
+        """byte, the interval between repeated joins/excludes in seconds."""
+        igmp_version: IGMPVersion = field(XmpByte())
+        """coded byte, specifying the IGMP version."""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address] = field(XmpSequence(types_chunk=[XmpIPv4Address()]))
+        """list of addresses, up to 8 multicast group addresses to receive an operation"""
+        operation: MulticastExtOperation = field(XmpByte())
+        """coded byte, specifying the operation."""
+        second_count: int = field(XmpByte())
+        """byte, the interval between repeated joins/excludes in seconds."""
+        igmp_version: IGMPVersion = field(XmpByte())
+        """coded byte, specifying the IGMP version."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's multicast information (IGMPv2/IGMPv3).
 
         :return: the port's multicast information (IGMPv2/IGMPv3)
         :rtype: P_MULTICASTEXT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address], operation: MulticastExtOperation, second_count: int, igmp_version: IGMPVersion) -> "Token":
+    def set(self, ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address], operation: MulticastExtOperation, second_count: int, igmp_version: IGMPVersion) -> Token[None]:
         """Set the port's multicast information (IGMPv2/IGMPv3).
 
         :param ipv4_multicast_addresses: a multicast group address to join or leave
-        :type ipv4_multicast_addresses: List[ipaddress.IPv4Address]
+        :type ipv4_multicast_addresses: typing.List[ipaddress.IPv4Address]
         :param operation: the operation
         :type operation: MulticastExtOperation
         :param second_count: the interval between repeated joins in seconds.
         :type second_count: int
         :param igmp_version: IGMP version
         :type igmp_version: IGMPVersion
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 ipv4_multicast_addresses=ipv4_multicast_addresses,
                 operation=operation,
                 second_count=second_count,
-                igmp_version=igmp_version,
-            ),
+                igmp_version=igmp_version
+            )
         )
 
 
 @register_command
 @dataclass
 class P_MCSRCLIST:
     """
     Multicast source list of the port. Only valid if the IGMP protocol version is
     IGMPv3 set by P_MULTICASTEXT.
     """
 
     code: typing.ClassVar[int] = 313
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv4_addresses: XmpField[xt.XmpIPV4AddressList] = XmpField(
-            xt.XmpIPV4AddressList
-        )  # list of addresses, multicast source list addresses (max 8) in Group Record field of the IGMPv3 membership report packet.
+    class GetDataAttr(ResponseBodyStruct):
+        ipv4_addresses: typing.List[ipaddress.IPv4Address] = field(XmpSequence(types_chunk=[XmpIPv4Address()]))
+        """list of addresses, multicast source list addresses (max 8) in Group Record field of the IGMPv3 membership report packet."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv4_addresses: XmpField[xt.XmpIPV4AddressList] = XmpField(
-            xt.XmpIPV4AddressList
-        )  # list of addresses, multicast source list addresses (max 8) in Group Record field of the IGMPv3 membership report packet.
+    class SetDataAttr(RequestBodyStruct):
+        ipv4_addresses: typing.List[ipaddress.IPv4Address] = field(XmpSequence(types_chunk=[XmpIPv4Address()]))
+        """list of addresses, multicast source list addresses (max 8) in Group Record field of the IGMPv3 membership report packet."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the multicast source list of the port. Only valid if the IGMP protocol version is IGMPv3 set by P_MULTICASTEXT.
 
         :return: the multicast source list of the port
         :rtype: P_MCSRCLIST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, ipv4_addresses: typing.List[ipaddress.IPv4Address]) -> "Token":
+    def set(self, ipv4_addresses: typing.List[ipaddress.IPv4Address]) -> Token[None]:
         """Set the multicast source list of the port.
 
         :param ipv4_addresses: the multicast source list of the port
-        :type ipv4_addresses: List[ipaddress.IPv4Address]
+        :type ipv4_addresses: typing.List[ipaddress.IPv4Address]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, ipv4_addresses=ipv4_addresses))
 
 
 @register_command
 @dataclass
 class P_TXMODE:
     """
@@ -2087,55 +2369,74 @@
     the number of packets in a burst is defined by the PS_BURST command, while the Inter
     Packet Gap and the Inter Burst Gap are defined by the PS_BURSTGAP command.
     """
 
     code: typing.ClassVar[int] = 320
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=TXMode
-        )  # coded byte, containing the loopback mode for the port: NORMAL (interleaved packet scheduling), STRICTUNIFORM (strict uniform mode), SEQUENTIAL (sequential packet scheduling), BURST (burst mode).
+    class GetDataAttr(ResponseBodyStruct):
+        mode: TXMode = field(XmpByte())
+        """coded byte, containing the loopback mode for the port:
+            NORMAL (interleaved packet scheduling),
+            STRICTUNIFORM (strict uniform mode),
+            SEQUENTIAL (sequential packet scheduling),
+            BURST (burst mode).
+        """
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=TXMode
-        )  # coded byte, containing the loopback mode for the port: NORMAL (interleaved packet scheduling), STRICTUNIFORM (strict uniform mode), SEQUENTIAL (sequential packet scheduling), BURST (burst mode).
+    class SetDataAttr(RequestBodyStruct):
+        mode: TXMode = field(XmpByte())
+        """coded byte, containing the loopback mode for the port:
+        NORMAL (interleaved packet scheduling),
+        STRICTUNIFORM (strict uniform mode),
+        SEQUENTIAL (sequential packet scheduling),
+        BURST (burst mode).
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the scheduling mode for outgoing traffic from the port.
 
-        :return: the scheduling mode for outgoing traffic from the port, containing the loopback mode for the port: NORMAL (interleaved packet scheduling), STRICTUNIFORM (strict uniform mode), SEQUENTIAL (sequential packet scheduling), BURST (burst mode).
+        :return: the scheduling mode for outgoing traffic from the port, containing the loopback mode for the port:
+            NORMAL (interleaved packet scheduling),
+            STRICTUNIFORM (strict uniform mode),
+            SEQUENTIAL (sequential packet scheduling),
+            BURST (burst mode).
         :rtype: P_TXMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: TXMode) -> "Token":
+    def set(self, mode: TXMode) -> Token[None]:
         """Set the the scheduling mode for outgoing traffic from the port.
 
-        :param mode: the scheduling mode for outgoing traffic from the port, containing the loopback mode for the port: NORMAL (interleaved packet scheduling), STRICTUNIFORM (strict uniform mode), SEQUENTIAL (sequential packet scheduling), BURST (burst mode).
+        :param mode: the scheduling mode for outgoing traffic from the port, containing the loopback mode for the port:
+            NORMAL (interleaved packet scheduling),
+            STRICTUNIFORM (strict uniform mode),
+            SEQUENTIAL (sequential packet scheduling),
+            BURST (burst mode).
         :type mode: TXMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_normal = functools.partialmethod(set, TXMode.NORMAL)
     """Set the port scheduling mode to Normal.
     """
+
     set_strictuniform = functools.partialmethod(set, TXMode.STRICTUNIFORM)
     """Set the port scheduling mode to Strict Uniform.
     """
+
     set_sequential = functools.partialmethod(set, TXMode.SEQUENTIAL)
     """Set the port scheduling mode to Sequential.
     """
+
     set_burst = functools.partialmethod(set, TXMode.BURST)
     """Set the port scheduling mode to Burst.
     """
 
 
 @register_command
 @dataclass
@@ -2144,59 +2445,78 @@
     Allows addition of a VLAN tag to IGMPv2 and IGPMv3 packets. This command
     requires software release 83.2 or higher.
     """
 
     code: typing.ClassVar[int] = 314
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        header_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, number of additional headers. Currently only 0 or 1 supported.
-        header_format: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MulticastHeaderFormat)  # byte, indicates the header format. 0 = no header, 1 = VLAN
-        tag: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, VLAN tag (VID)
-        pcp: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, VLAN Priority code point
-        dei: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # byte, drop-eligible indicator.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        header_count: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, number of additional headers. Currently only 0 or 1 supported.
-        header_format: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=MulticastHeaderFormat)  # byte, indicates the header format. 0 = no header, 1 = VLAN
-        tag: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, VLAN tag (VID)
-        pcp: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, VLAN Priority code point
-        dei: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # byte, drop-eligible indicator
+    class GetDataAttr(ResponseBodyStruct):
+        header_count: int = field(XmpByte())
+        """byte, number of additional headers. Currently only 0 or 1 supported."""
+        header_format: MulticastHeaderFormat = field(XmpByte())
+        """byte, indicates the header format. 0 = no header, 1 = VLAN"""
+        tag: int = field(XmpInt())
+        """integer, VLAN tag (VID)"""
+        pcp: int = field(XmpByte())
+        """byte, VLAN Priority code point"""
+        dei: OnOff = field(XmpByte())
+        """byte, drop-eligible indicator"""
+
+    class SetDataAttr(RequestBodyStruct):
+        header_count: int = field(XmpByte())
+        """byte, number of additional headers. Currently only 0 or 1 supported."""
+        header_format: MulticastHeaderFormat = field(XmpByte())
+        """byte, indicates the header format. 0 = no header, 1 = VLAN"""
+        tag: int = field(XmpInt())
+        """integer, VLAN tag (VID)"""
+        pcp: int = field(XmpByte())
+        """byte, VLAN Priority code point"""
+        dei: OnOff = field(XmpByte())
+        """byte, drop-eligible indicator."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the VLAN tag to the IGMPv2 and IGMPv3 packets of the port.
 
         :return: the VLAN tag to the IGMPv2 and IGMPv3 packets of the port
         :rtype: P_MULTICASTHDR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, header_count: int, header_format: MulticastHeaderFormat, tag: int, pcp: int, dei: OnOff) -> "Token":
+    def set(self, header_count: int, header_format: MulticastHeaderFormat, tag: int, pcp: int, dei: OnOff) -> Token[None]:
         """Set the VLAN tag to the IGMPv2 and IGMPv3 packets of the port.
 
         :param header_count: number of additional headers. Currently only 0 or 1 supported
         :type header_count: int
         :param header_format: indicates the header format
         :type header_format: MulticastHeaderFormat
         :param tag: VLAN tag (VID)
         :type tag: int
         :param pcp: VLAN Priority code point
         :type pcp: int
         :param dei: drop-eligible indicator
         :type dei: OnOff
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, header_count=header_count, header_format=header_format, tag=tag, pcp=pcp, dei=dei),
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                header_count=header_count,
+                header_format=header_format,
+                tag=tag,
+                pcp=pcp,
+                dei=dei
+            )
         )
 
 
 @register_command
 @dataclass
 class P_RATEFRACTION:
     """
@@ -2205,40 +2525,42 @@
     consumption includes the inter-frame gaps, and does not depend on the length of
     the packets for the streams.
     """
 
     code: typing.ClassVar[int] = 321
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        port_rate_ppm: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, port rate expressed as a value between 0 and 1,000,000.
+    class GetDataAttr(ResponseBodyStruct):
+        port_rate_ppm: int = field(XmpInt())
+        """integer, port rate expressed as a value between 0 and 1,000,000."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_rate_ppm: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, port rate expressed as a value between 0 and 1,000,000.
+    class SetDataAttr(RequestBodyStruct):
+        port_rate_ppm: int = field(XmpInt())
+        """integer, port rate expressed as a value between 0 and 1,000,000."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port.
 
         :return: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port.
         :rtype: P_RATEFRACTION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, port_rate_ppm: int) -> "Token":
+    def set(self, port_rate_ppm: int) -> Token[None]:
         """Set the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port.
 
         :param port_rate_ppm: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port
         :type port_rate_ppm: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, port_rate_ppm=port_rate_ppm))
 
 
 @register_command
 @dataclass
 class P_RATEPPS:
     """
@@ -2247,40 +2569,42 @@
     on the length of the packets generated for the streams, and also on the inter-
     frame gap for the port.
     """
 
     code: typing.ClassVar[int] = 322
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        port_rate_pps: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, port rate expressed as packets per second.
+    class GetDataAttr(ResponseBodyStruct):
+        port_rate_pps: int = field(XmpInt())
+        """integer, port rate expressed as packets per second."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_rate_pps: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, port rate expressed as packets per second.
+    class SetDataAttr(RequestBodyStruct):
+        port_rate_pps: int = field(XmpInt())
+        """integer, port rate expressed as packets per second."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second.
 
         :return: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second
         :rtype: P_RATEPPS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, port_rate_pps: int) -> "Token":
+    def set(self, port_rate_pps: int) -> Token[None]:
         """Set the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second.
 
         :param port_rate_pps: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second
         :type port_rate_pps: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, port_rate_pps=port_rate_pps))
 
 
 @register_command
 @dataclass
 class P_RATEL2BPS:
     """
@@ -2290,40 +2614,46 @@
     dependent on the length of the packets generated for the stream, and also on the
     inter-frame gap for the port.
     """
 
     code: typing.ClassVar[int] = 323
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        port_rate_bps: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, port rate expressed as bits-per-second.
+    class GetDataAttr(ResponseBodyStruct):
+        port_rate_bps: int = field(XmpLong())
+        """long integer, port rate expressed as bits-per-second."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        port_rate_bps: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, port rate expressed as bits-per-second.
+    class SetDataAttr(RequestBodyStruct):
+        port_rate_bps: int = field(XmpLong())
+        """long integer, port rate expressed as bits-per-second."""
 
-    def get(self) -> "Token[GetDataAttr]":
-        """Get the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap.
+    def get(self) -> Token[GetDataAttr]:
+        """Get the port-level rate of the traffic transmitted for a port in sequential tx mode,
+        expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap.
 
-        :return: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap
+        :return: the port-level rate of the traffic transmitted for a port in sequential tx mode,
+            expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap
         :rtype: P_RATEL2BPS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, port_rate_bps: int) -> "Token":
-        """Set the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap.
+    def set(self, port_rate_bps: int) -> Token[None]:
+        """Set the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2,
+        thus including the Ethernet header but excluding the inter-frame gap.
 
-        :param port_rate_bps: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap
+        :param port_rate_bps: the port-level rate of the traffic transmitted for a port in sequential tx mode,
+            expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap
         :type port_rate_bps: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, port_rate_bps=port_rate_bps))
 
 
 @register_command
 @dataclass
 class P_PAYLOADMODE:
     """
@@ -2335,94 +2665,103 @@
     then be used in a round robin fashion when packets are sent based on the stream
     definition.
     """
 
     code: typing.ClassVar[int] = 324
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PayloadMode)  # coded byte, which is the payload mode the port should be set.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: PayloadMode = field(XmpByte())
+        """coded byte, which is the payload mode the port should be set."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PayloadMode)  # coded byte, which is the payload mode the port should be set.
+    class SetDataAttr(RequestBodyStruct):
+        mode: PayloadMode = field(XmpByte())
+        """coded byte, which is the payload mode the port should be set."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port.
 
         :return: the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port.
         :rtype: P_PAYLOADMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: PayloadMode) -> "Token":
+    def set(self, mode: PayloadMode) -> Token[None]:
         """Set the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port.
 
         :param mode: the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port
         :type mode: PayloadMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_normal = functools.partialmethod(set, PayloadMode.NORMAL)
     """Set the port's payload mode to Normal.
     """
+
     set_extpl = functools.partialmethod(set, PayloadMode.EXTPL)
     """Set the port's payload mode to Extend Payload.
     """
+
     set_cdf = functools.partialmethod(set, PayloadMode.CDF)
     """Set the port's payload mode to Custom Payload Field.
     """
 
 
 @register_command
 @dataclass
 class P_BRRMODE:
     """
-    Selects the Master/Slave setting of 100 Mbit/s (requires Valkyrie release 76.1 or higher) and 1000 Mbit/s (requires Valkyrie release 76.2 or higher) BroadR-Reach copper interfaces.
+    Selects the Master/Slave setting of
+    100 Mbit/s (requires Valkyrie release 76.1 or higher),
+    1000 Mbit/s (requires Valkyrie release 76.2 or higher) BroadR-Reach copper interfaces.
     """
 
     code: typing.ClassVar[int] = 326
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=BRRMode)  # coded byte, containing the Master/Slave mode for the port.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: BRRMode = field(XmpByte())
+        """coded byte, containing the Master/Slave mode for the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=BRRMode)  # coded byte, containing the Master/Slave mode for the port.
+    class SetDataAttr(RequestBodyStruct):
+        mode: BRRMode = field(XmpByte())
+        """coded byte, containing the Master/Slave mode for the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's BroadR-Reach mode.
 
         :return: the port's BroadR-Reach mode
         :rtype: P_BRRMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: BRRMode) -> "Token":
+    def set(self, mode: BRRMode) -> Token[None]:
         """Set the port's BroadR-Reach mode.
 
         :param mode: the port's BroadR-Reach mode
         :type mode: BRRMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_slave = functools.partialmethod(set, BRRMode.SLAVE)
     """Set the port's BRR mode to Slave.
     """
+
     set_master = functools.partialmethod(set, BRRMode.MASTER)
     """Set the port's BRR mode to Master.
     """
 
 
 @register_command
 @dataclass
@@ -2430,45 +2769,48 @@
     """
     Whether a port should enable its transmitter, or keep the outgoing link down.
     """
 
     code: typing.ClassVar[int] = 327
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the transmitter is enabled or disabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the transmitter is enabled or disabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the transmitter is enabled or disabled.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the transmitter is enabled or disabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's transmitter status.
 
         :return: the port's transmitter status
         :rtype: P_TXENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the the port's transmitter status.
 
         :param on_off: the port's transmitter status
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the port's transmitter and keep the outgoing link down.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the port's transmitter.
     """
 
 
 @register_command
 @dataclass
@@ -2481,40 +2823,42 @@
     are available for the port. Possible values: 128 (default), 256, 512, 1024,
     2048.
     """
 
     code: typing.ClassVar[int] = 328
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        max_header_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the maximum number of header bytes.
+    class GetDataAttr(ResponseBodyStruct):
+        max_header_length: int = field(XmpInt())
+        """integer, specifying the maximum number of header bytes."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        max_header_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the maximum number of header bytes.
+    class SetDataAttr(RequestBodyStruct):
+        max_header_length: int = field(XmpInt())
+        """integer, specifying the maximum number of header bytes."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the maximum number of header content bytes that can be freely specified for each generated stream on the port.
 
         :return: the maximum number of header content bytes that can be freely specified for each generated stream on the port
         :rtype: P_MAXHEADERLENGTH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, max_header_length: int) -> "Token":
+    def set(self, max_header_length: int) -> Token[None]:
         """Set the maximum number of header content bytes that can be freely specified for each generated stream on the port. Possible values: 128 (default), 256, 512, 1024, 2048.
 
         :param max_header_length: the maximum number of header content bytes that can be freely specified for each generated stream on the port
         :type max_header_length: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, max_header_length=max_header_length))
 
 
 @register_command
 @dataclass
 class P_TXTIMELIMIT:
     """
@@ -2522,96 +2866,100 @@
     the elapsed time traffic must be stopped and restarted. This complements the
     stream-level PS_PACKETLIMIT function.
     """
 
     code: typing.ClassVar[int] = 329
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        microseconds: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, time limit after which the port stops transmitting.
+    class GetDataAttr(ResponseBodyStruct):
+        microseconds: int = field(XmpLong())
+        """long integer, time limit after which the port stops transmitting."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        microseconds: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, time limit after which the port stops transmitting.
+    class SetDataAttr(RequestBodyStruct):
+        microseconds: int = field(XmpLong())
+        """long integer, time limit after which the port stops transmitting."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port-level time-limit on how long it keeps transmitting when started in microseconds.
 
         :return: port-level time-limit on how long it keeps transmitting when started in microseconds.
         :rtype: P_TXTIMELIMIT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, microseconds: int) -> "Token":
+    def set(self, microseconds: int) -> Token[None]:
         """Set the port-level time-limit on how long it keeps transmitting when started in microseconds. Maximum can be 2^63.
 
         :param microseconds: the port-level time-limit on how long it keeps transmitting when started in microseconds. Maximum can be 2^63
         :type microseconds: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, microseconds=microseconds))
 
 
 @register_command
 @dataclass
 class P_TXTIME:
     """
     How long the port has been transmitting, the elapsed time since traffic was
     started.
     """
 
     code: typing.ClassVar[int] = 330
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        microseconds: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, elapsed time since traffic was started.
+    class GetDataAttr(ResponseBodyStruct):
+        microseconds: int = field(XmpLong())
+        """long integer, elapsed time since traffic was started."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get how long the port has been transmitting, the elapsed time since traffic was started in microseconds.
 
         :return: how long the port has been transmitting, the elapsed time since traffic was started in microseconds
         :rtype: P_TXTIME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_XMITONETIME:
     """
     The time at which the latest packet was transmitted using the P_XMITONE command.
     The time reference is the same used by the time stamps of captured packets.
     """
 
     code: typing.ClassVar[int] = 331
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        nanoseconds: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the time at which packet was transmitted.
+    class GetDataAttr(ResponseBodyStruct):
+        nanoseconds: int = field(XmpLong())
+        """long integer, the time at which packet was transmitted."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the time at which the latest packet was transmitted using the P_XMITONE command in nanoseconds.
 
         :return: the time at which the latest packet was transmitted using the P_XMITONE command in nanoseconds
         :rtype: P_XMITONETIME.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_IPV6ADDRESS:
     """
@@ -2619,63 +2967,71 @@
     default source address field in the IP header of generated traffic, and the
     configuration is also used for support of the NDP and PINGv6 protocols.
     """
 
     code: typing.ClassVar[int] = 332
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # address, the IPv6 address of the port.
-        gateway: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # address, the gateway of the local network segment for the port.
-        subnet_prefix: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, the subnet prefix of the local network segment for the port.
-        wildcard_prefix: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, a prefix that makes the port replies to NDP/PING for the masked addresses, valid value 0-255
+    class GetDataAttr(ResponseBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """address, the IPv6 address of the port."""
+        gateway: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """address, the gateway of the local network segment for the port."""
+        subnet_prefix: int = field(XmpByte())
+        """byte, the subnet prefix of the local network segment for the port."""
+        wildcard_prefix: int = field(XmpByte())
+        """byte, a prefix that makes the port replies to NDP/PING for the masked addresses, valid value 0-255"""
+
+    class SetDataAttr(RequestBodyStruct):
+        ipv6_address: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """address, the IPv6 address of the port."""
+        gateway: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """address, the gateway of the local network segment for the port."""
+        subnet_prefix: int = field(XmpByte())
+        """byte, the subnet prefix of the local network segment for the port."""
+        wildcard_prefix: int = field(XmpByte())
+        """byte, a prefix that makes the port replies to NDP/PING for the masked addresses, valid value 0-255"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ipv6_address: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # address, the IPv6 address of the port.
-        gateway: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # address, the gateway of the local network segment for the port.
-        subnet_prefix: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, the subnet prefix of the local network segment for the port.
-        wildcard_prefix: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, a prefix that makes the port replies to NDP/PING for the masked addresses, valid value 0-255
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the port's IPv6 address settings.
 
         :return: the port's IPv6 address settings
         :rtype: P_IPV6ADDRESS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(
-        self,
-        ipv6_address: typing.Union[str, int, ipaddress.IPv6Address],
-        gateway: typing.Union[str, int, ipaddress.IPv6Address],
-        subnet_prefix: int,
-        wildcard_prefix: int,
-    ) -> "Token":
+    def set(self, ipv6_address: ipaddress.IPv6Address, gateway: ipaddress.IPv6Address, subnet_prefix: int, wildcard_prefix: int) -> Token[None]:
         """Set the port's IPv6 settings.
 
         :param ipv6_address: the IPv6 address of the port
         :type ipv6_address: Union[str, int, ipaddress.IPv6Address]
         :param gateway: the gateway of the local network segment for the port
         :type gateway: Union[str, int, ipaddress.IPv6Address]
         :param subnet_prefix: the subnet prefix of the local network segment for the port
         :type subnet_prefix: int
         :param wildcard_prefix: a prefix that makes the port replies to NDP/PING for the masked addresses, valid value 0-255
         :type wildcard_prefix: int
         """
+
         return Token(
             self._connection,
             build_set_request(
-                self, module=self._module, port=self._port, ipv6_address=ipv6_address, gateway=gateway, subnet_prefix=subnet_prefix, wildcard_prefix=wildcard_prefix
-            ),
+                self,
+                module=self._module,
+                port=self._port,
+                ipv6_address=ipv6_address,
+                gateway=gateway,
+                subnet_prefix=subnet_prefix,
+                wildcard_prefix=wildcard_prefix
+            )
         )
 
 
 @register_command
 @dataclass
 class P_ARPV6REPLY:
     """
@@ -2684,45 +3040,48 @@
     specified for the port to the MAC address specified for the port. NDP reply
     generation is independent of whether traffic and capture is on for the port.
     """
 
     code: typing.ClassVar[int] = 333
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to NDP Neighbor Solicitations.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to NDP Neighbor Solicitations."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to NDP Neighbor Solicitations.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to NDP Neighbor Solicitations."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the port replies to NDP Neighbor Solicitations.
 
         :return: whether the port replies to NDP Neighbor Solicitations.
         :rtype: P_ARPV6REPLY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether the port replies to NDP Neighbor Solicitations.
 
         :param on_off: whether the port replies to NDP Neighbor Solicitations.
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the port from replying to NDP Neighbor Solicitations.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the port to reply to NDP Neighbor Solicitations.
     """
 
 
 @register_command
 @dataclass
@@ -2733,45 +3092,48 @@
     specified for the port. PINGv6 reply generation is independent of whether
     traffic and capture is on for the port.
     """
 
     code: typing.ClassVar[int] = 334
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to PINGv6 requests.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to PINGv6 requests."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the port replies to PINGv6 requests.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the port replies to PINGv6 requests."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the port replies to incoming PINGv6.
 
         :return: whether the port replies to incoming PINGv6
         :rtype: P_PINGV6REPLY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether the port replies to incoming PINGv6.
 
         :param on_off: whether the port replies to incoming PINGv6.
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the port from replying to PINGv6.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the port to reply to PINGv6.
     """
 
 
 @register_command
 @dataclass
@@ -2785,60 +3147,54 @@
         FCS errors are included, which will typically lead to double-counting of lost packets.
 
     """
 
     code: typing.ClassVar[int] = 335
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        error_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # list of long integers, the total number of errors across all streams, and including FCS errors.
+    class GetDataAttr(ResponseBodyStruct):
+        error_count: int = field(XmpLong())
+        """list of long integers, the total number of errors across all streams, and including FCS errors."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the total number of errors detected across all streams on the port, including lost packets, misorder events, and payload errors.
 
         :return: the total number of errors detected across all streams on the port, including lost packets, misorder events, and payload errors
         :rtype: P_ERRORS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_TXPREPARE:
     """
     Prepare port for transmission
     """
 
     code: typing.ClassVar[int] = 336
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Set the port to prepare for packet transmission.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_TXDELAY:
     """
     Sets a variable delay from a traffic start command received by the port until
@@ -2850,84 +3206,89 @@
         You must use C_TRAFFIC instead of P_TRAFFIC to start traffic for P_TXDELAY to take effect.
 
     """
 
     code: typing.ClassVar[int] = 337
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        delay_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, TX delay in multiples of 64 microseconds. (TX delay = delay_val * 64 microseconds).
+    class GetDataAttr(ResponseBodyStruct):
+        delay_val: int = field(XmpInt())
+        """integer, TX delay in multiples of 64 microseconds. (TX delay = delay_val * 64 microseconds)."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        delay_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, TX delay in multiples of 64 microseconds. (TX delay = delay_val * 64 microseconds).
+    class SetDataAttr(RequestBodyStruct):
+        delay_val: int = field(XmpInt())
+        """integer, TX delay in multiples of 64 microseconds. (TX delay = delay_val * 64 microseconds)."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the delay from a traffic start command received by the port until the port starts transmitting packets, in microseconds.
 
         :return: the delay from a traffic start command received by the port until the port starts transmitting packets, in microseconds.
         :rtype: P_TXDELAY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, delay_val: int) -> "Token":
+    def set(self, delay_val: int) -> Token[None]:
         """Set the delay from a traffic start command received by the port until the port starts transmitting packets, in microseconds.
 
         :param delay_val: the delay specified in multiples of 64 microseconds.
         :type delay_val: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, delay_val=delay_val))
 
 
 @register_command
 @dataclass
 class P_LPENABLE:
     """
     Enables/disables Energy Efficient Ethernet (EEE) on the port.
     """
 
     code: typing.ClassVar[int] = 340
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the EEE feature is activated or not.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the EEE feature is activated or not."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the EEE feature is activated or not.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the EEE feature is activated or not."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether Energy Efficient Ethernet (EEE) is enabled on the port.
 
         :return: whether Energy Efficient Ethernet (EEE) is enabled on the port
         :rtype: P_LPENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether Energy Efficient Ethernet (EEE) is enabled on the port.
 
         :param on_off: whether Energy Efficient Ethernet (EEE) is enabled on the port
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable Energy Efficient Ethernet (EEE) on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable Energy Efficient Ethernet (EEE) on the port.
     """
 
 
 @register_command
 @dataclass
@@ -2939,45 +3300,48 @@
     transmitted if the Link Partner (receiving port) has advertised EEE capability
     for the selected port speed during EEE auto-negotiation.
     """
 
     code: typing.ClassVar[int] = 341
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether low power idles will be transmitted or not. OFF (0) ON (1)
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether low power idles will be transmitted or not. OFF (0) ON (1)"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether low power idles will be transmitted or not. OFF (0) ON (1)
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether low power idles will be transmitted or not. OFF (0) ON (1)"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the transmission of Low Power Idles (LPIs) is enabled on the port.
 
         :return: whether the transmission of Low Power Idles (LPIs) is enabled on the port
         :rtype: P_LPTXMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether the transmission of Low Power Idles (LPIs) is enabled on the port.
 
         :param on_off: whether the transmission of Low Power Idles (LPIs) is enabled on the port
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the transmission of Low Power Idles (LPIs) on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the transmission of Low Power Idles (LPIs) on the port.
     """
 
 
 @register_command
 @dataclass
@@ -2985,149 +3349,164 @@
     """
     Displays the Energy Efficient Ethernet (EEE) status as reported by the PHY.
     """
 
     code: typing.ClassVar[int] = 343
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        txh: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=TXHState
-        )  # coded bytes, shows if there has been any recent change in the EEE state on the transmission side (either going into low power mode or leaving low power mode.
-        rxh: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte, choices=RXHState
-        )  # shows if there has been any recent change in the EEE state on the receiver side (either going into low power mode or leaving low power mode.
-        txc: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TXCState)  # shows the current EEE state of the transmitter (in low power or active)
-        rxc: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=RXCState)  # shows the current EEE state of the receiver (in low power or active).
-        link_up: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LinkState)  # shows if the link is up (seen from perspective of the the PHY's PCS).
+    class GetDataAttr(ResponseBodyStruct):
+        txh: TXHState = field(XmpByte())
+        """coded bytes, shows if there has been any recent change in the EEE state on the transmission side (either going into low power mode or leaving low power mode."""
+        rxh: RXHState = field(XmpByte())
+        """shows if there has been any recent change in the EEE state on the receiver side (either going into low power mode or leaving low power mode."""
+        txc: TXCState = field(XmpByte())
+        """shows the current EEE state of the transmitter (in low power or active)"""
+        rxc: RXCState = field(XmpByte())
+        """shows the current EEE state of the receiver (in low power or active)."""
+        link_up: LinkState = field(XmpByte())
+        """shows if the link is up (seen from perspective of the the PHY's PCS)."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the the Energy Efficient Ethernet (EEE) status as reported by the PHY.
             * if there has been any recent change in the EEE state on the transmission side
             * if there has been any recent change in the EEE state on the receiver side
             * the current EEE state of the transmitter
             * the current EEE state of the receiver
             * if the link is up
 
         :return: the the Energy Efficient Ethernet (EEE) status
         :rtype: P_LPSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_LPPARTNERAUTONEG:
     """
     Displays the EEE capabilities advertised during auto-negotiation by the far side
     (link partner).
     """
 
     code: typing.ClassVar[int] = 345
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        cap_100base_tx: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, specifying whether the link partner is capable of 100BASE-TX.
-        cap_1000base_t: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte. specifying whether the link partner is capable of 1000BASE-T.
-        cap_10gbase_t: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte. specifying whether the link partner is capable of 10GBASE-T.
-        cap_100base_kx: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte. specifying whether the link partner is capable of 100BASE-KX.
-        cap_10gbase_kx4: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte. specifying whether the link partner is capable of 10GBASE-KX4.
-        cap_10gbase_kr: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte. specifying whether the link partner is capable of 10GBASE-KR.
+    class GetDataAttr(ResponseBodyStruct):
+        cap_100base_tx: YesNo = field(XmpByte())
+        """coded byte, specifying whether the link partner is capable of 100BASE-TX."""
+        cap_1000base_t: YesNo = field(XmpByte())
+        """coded byte. specifying whether the link partner is capable of 1000BASE-T."""
+        cap_10gbase_t: YesNo = field(XmpByte())
+        """coded byte. specifying whether the link partner is capable of 10GBASE-T."""
+        cap_100base_kx: YesNo = field(XmpByte())
+        """coded byte. specifying whether the link partner is capable of 100BASE-KX."""
+        cap_10gbase_kx4: YesNo = field(XmpByte())
+        """coded byte. specifying whether the link partner is capable of 10GBASE-KX4."""
+        cap_10gbase_kr: YesNo = field(XmpByte())
+        """coded byte. specifying whether the link partner is capable of 10GBASE-KR."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the the Energy Efficient Ethernet (EEE) capabilities advertised during auto-negotiation by the far side (link partner).
             * whether the link partner is capable of 100BASE-TX
             * whether the link partner is capable of 1000BASE-T
             * whether the link partner is capable of 10GBASE-T
             * whether the link partner is capable of 100BASE-KX
             * whether the link partner is capable of 10GBASE-KX4
             * whether the link partner is capable of 10GBASE-KR
 
         :return: the the Energy Efficient Ethernet (EEE) capabilities advertised during auto-negotiation by the far side (link partner)
         :rtype: P_LPPARTNERAUTONEG.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_LPSNRMARGIN:
     """
     Displays the SNR margin on the four link channels (Channel A-D) as reported by
     the PHY. It is displayed in units of 0.1dB.
     """
 
     code: typing.ClassVar[int] = 346
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        channel_a: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the SNR margin on link channel A.
-        channel_b: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the SNR margin on link channel B.
-        channel_c: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the SNR margin on link channel C.
-        channel_d: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the SNR margin on link channel D.
+    class GetDataAttr(ResponseBodyStruct):
+        channel_a: int = field(XmpInt())
+        """integer, the SNR margin on link channel A."""
+        channel_b: int = field(XmpInt())
+        """integer, the SNR margin on link channel B."""
+        channel_c: int = field(XmpInt())
+        """integer, the SNR margin on link channel C."""
+        channel_d: int = field(XmpInt())
+        """integer, the SNR margin on link channel D."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the SNR margin on the four link channels (Channel A-D) as reported by the PHY. It is displayed in units of 0.1dB.
             * the SNR margin on link channel A
             * the SNR margin on link channel B
             * the SNR margin on link channel C
             * the SNR margin on link channel D
 
         :return: the SNR margin on the four link channels (Channel A-D) as reported by the PHY. It is displayed in units of 0.1dB
         :rtype: P_LPSNRMARGIN.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_LPRXPOWER:
     """
     Obtain the RX power recorded during training for the four channels.
     """
 
     code: typing.ClassVar[int] = 347
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        channel_a: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the RX power on link channel A.
-        channel_b: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the RX power on link channel B.
-        channel_c: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the RX power on link channel C.
-        channel_d: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the RX power on link channel D.
+    class GetDataAttr(ResponseBodyStruct):
+        channel_a: int = field(XmpInt())
+        """integer, the RX power on link channel A."""
+        channel_b: int = field(XmpInt())
+        """integer, the RX power on link channel B."""
+        channel_c: int = field(XmpInt())
+        """integer, the RX power on link channel C."""
+        channel_d: int = field(XmpInt())
+        """integer, the RX power on link channel D."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the the RX power recorded during training for the four channels.
 
         :return: the the RX power recorded during training for the four channels
             * the RX power on link channel A
             * the RX power on link channel B
             * the RX power on link channel C
             * the RX power on link channel D
         :rtype: P_LPRXPOWER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_FAULTSIGNALING:
     """
@@ -3137,51 +3516,56 @@
     output and when receiving a "Remote Fault indication"from the far-side it will
     transmit IDLE sequences.
     """
 
     code: typing.ClassVar[int] = 348
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        fault_signaling: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FaultSignaling)  # coded byte, specifying remote/local fault signaling behavior of the port.
+    class GetDataAttr(ResponseBodyStruct):
+        fault_signaling: FaultSignaling = field(XmpByte())
+        """coded byte, specifying remote/local fault signaling behavior of the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        fault_signaling: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FaultSignaling)  # coded byte, specifying remote/local fault signaling behavior of the port.
+    class SetDataAttr(RequestBodyStruct):
+        fault_signaling: FaultSignaling = field(XmpByte())
+        """coded byte, specifying remote/local fault signaling behavior of the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the remote/local fault signaling behavior of the port (performed by the Reconciliation Sub-layer).
 
         :return: remote/local fault signaling behavior of the port
         :rtype: P_FAULTSIGNALING.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, fault_signaling: FaultSignaling) -> "Token":
+    def set(self, fault_signaling: FaultSignaling) -> Token[None]:
         """Set the remote/local fault signaling behavior of the port (performed by the Reconciliation Sub-layer).
 
         :param fault_signaling: remote/local fault signaling behavior of the port
         :type fault_signaling: FaultSignaling
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, fault_signaling=fault_signaling))
 
     set_normal = functools.partialmethod(set, FaultSignaling.NORMAL)
     """Set the remote/local fault signaling behavior of the port to Normal.
     """
+
     set_force_local = functools.partialmethod(set, FaultSignaling.FORCE_LOCAL)
     """Set the remote/local fault signaling behavior of the port to Forced Local.
     """
+
     set_force_remote = functools.partialmethod(set, FaultSignaling.FORCE_REMOTE)
     """Set the remote/local fault signaling behavior of the port to Forced Remote.
     """
+
     set_disabled = functools.partialmethod(set, FaultSignaling.DISABLED)
     """Disable the remote/local fault signaling behavior of the port.
     """
 
 
 @register_command
 @dataclass
@@ -3195,31 +3579,33 @@
         Currently only available on M1CFP100, M2CFP40, M2QSFP+ and M1CFP4QSFP28CXP.
 
     """
 
     code: typing.ClassVar[int] = 349
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        local_fault_status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LocalFaultStatus)  # coded byte, specifying the local fault.
-        remote_fault_status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=RemoteFaultStatus)  # coded byte, specifying the remote fault.
+    class GetDataAttr(ResponseBodyStruct):
+        local_fault_status: LocalFaultStatus = field(XmpByte())
+        """coded byte, specifying the local fault."""
+        remote_fault_status: RemoteFaultStatus = field(XmpByte())
+        """coded byte, specifying the remote fault."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether a local or remote fault is currently being detected by the Reconciliation Sub-layer of the port.
 
         :return: whether a local or remote fault is currently being detected.
             * specifying the local fault
             * specifying the remote fault
         :rtype: P_FAULTSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_TPLDMODE:
     """
@@ -3237,45 +3623,48 @@
     Currently not available on M6SFP, M2SFPT, M6RJ45+/M2RJ45+, M2CFP40, M1CFP100,
     M2SFP+4SFP
     """
 
     code: typing.ClassVar[int] = 350
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TPLDMode)  # coded byte, specifying TPLD's mode.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: TPLDMode = field(XmpByte())
+        """coded byte, specifying TPLD's mode."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TPLDMode)  # coded byte, specifying TPLD's mode.
+    class SetDataAttr(RequestBodyStruct):
+        mode: TPLDMode = field(XmpByte())
+        """coded byte, specifying TPLD's mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Test Payload mode of the port.
 
         :return: the Test Payload mode of the port
         :rtype: P_TPLDMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: TPLDMode) -> "Token":
+    def set(self, mode: TPLDMode) -> Token[None]:
         """Set the Test Payload mode of the port.
 
         :param mode: the Test Payload mode of the port.
         :type mode: TPLDMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_normal = functools.partialmethod(set, TPLDMode.NORMAL)
     """Set the Test Payload mode of the port to Normal.
     """
+
     set_micro = functools.partialmethod(set, TPLDMode.MICRO)
     """Set the Test Payload mode of the port to Micro.
     """
 
 
 @register_command
 @dataclass
@@ -3284,28 +3673,29 @@
     Read EEE capabilities of the port (variable size, one for each supported speed,
     returns 0s if no EEE).
     """
 
     code: typing.ClassVar[int] = 351
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        eee_capabilities: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers,EEE capabilities of the port.
+    class GetDataAttr(ResponseBodyStruct):
+        eee_capabilities: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers,EEE capabilities of the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the EEE capabilities of the port (variable size, one for each supported speed, returns 0s if no EEE).
 
         :return: the EEE capabilities of the port (variable size, one for each supported speed, returns 0s if no EEE).
         :rtype: P_LPSUPPORT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_TXPACKETLIMIT:
     """
@@ -3314,118 +3704,127 @@
     Traffic from the streams on the port can however also be set to stop after
     transmitting a number of packets.
     """
 
     code: typing.ClassVar[int] = 352
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        packet_count_limit: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of packets that will be transmitted by the port.
+    class GetDataAttr(ResponseBodyStruct):
+        packet_count_limit: int = field(XmpInt())
+        """integer, number of packets that will be transmitted by the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        packet_count_limit: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, number of packets that will be transmitted by the port.
+    class SetDataAttr(RequestBodyStruct):
+        packet_count_limit: int = field(XmpInt())
+        """integer, number of packets that will be transmitted by the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of packets that will be transmitted from the port when traffic is started on the port.
 
         :return: the number of packets that will be transmitted from the port when traffic is started on the port.
         :rtype: P_TXPACKETLIMIT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, packet_count_limit: int) -> "Token":
+    def set(self, packet_count_limit: int) -> Token[None]:
         """Set the number of packets that will be transmitted from the port when traffic is started on the port.
             A value of 0 or -1 makes the port transmit continuously.
             Traffic from the streams on the port can however also be set to stop after transmitting a number of packets.
 
         :param packet_count_limit: the number of packets that will be transmitted from the port when traffic is started on the port
         :type packet_count_limit: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, packet_count_limit=packet_count_limit))
 
 
 @register_command
 @dataclass
 class P_TCVRSTATUS:
     """
     Get various tcvr status information. RX loss status of the individual RX optical
     lanes (only 4 lanes are supported currently).
     """
 
     code: typing.ClassVar[int] = 357
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        rx_loss_lane_0: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # RX loss of lane 0
-        rx_loss_lane_1: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # RX loss of lane 1
-        rx_loss_lane_2: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # RX loss of lane 2
-        rx_loss_lane_3: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # RX loss of lane 3
+    class GetDataAttr(ResponseBodyStruct):
+        rx_loss_lane_0: int = field(XmpByte())
+        """RX loss of lane 0"""
+        rx_loss_lane_1: int = field(XmpByte())
+        """RX loss of lane 1"""
+        rx_loss_lane_2: int = field(XmpByte())
+        """RX loss of lane 2"""
+        rx_loss_lane_3: int = field(XmpByte())
+        """RX loss of lane 3"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get various transceiver status information.
 
         :return: various tcvr status information. RX loss status of the individual RX optical lanes (only 4 lanes are supported currently).
         :rtype: P_TCVRSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_DYNAMIC:
     """
     Controls if a >10G port supports dynamic changes when the traffic is
     running. This command is only supported by ports >10G.
     """
 
     code: typing.ClassVar[int] = 368
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether dynamic traffic change is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether dynamic traffic change is enabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether dynamic traffic change is enabled.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether dynamic traffic change is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the port should support dynamic changes when the traffic is running.
 
         :return: whether the port should support dynamic changes when the traffic is running.
         :rtype: P_DYNAMIC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether the port should support dynamic changes when the traffic is running.
 
         :param on_off: whether the port should support dynamic changes when the traffic is running
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable dynamic traffic change on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable dynamic traffic change on the port.
     """
 
 
 @register_command
 @dataclass
@@ -3434,49 +3833,64 @@
     This setting control whether a port responds to incoming Ethernet Priority Flow
     Control (PFC) frames, by holding back outgoing traffic for that priority.
     """
 
     code: typing.ClassVar[int] = 373
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        cos_0: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 0.
-        cos_1: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 1.
-        cos_2: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 2.
-        cos_3: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 3.
-        cos_4: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 4.
-        cos_5: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 5.
-        cos_6: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 6.
-        cos_7: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 7.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        cos_0: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 0.
-        cos_1: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 1.
-        cos_2: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 2.
-        cos_3: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 3.
-        cos_4: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 4.
-        cos_5: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 5.
-        cos_6: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 6.
-        cos_7: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded bytes, indicating whether PFC response is enabled for that CoS 7.
+    class GetDataAttr(ResponseBodyStruct):
+        cos_0: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 0."""
+        cos_1: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 1."""
+        cos_2: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 2."""
+        cos_3: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 3."""
+        cos_4: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 4."""
+        cos_5: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 5."""
+        cos_6: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 6."""
+        cos_7: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 7."""
+
+    class SetDataAttr(RequestBodyStruct):
+        cos_0: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 0."""
+        cos_1: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 1."""
+        cos_2: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 2."""
+        cos_3: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 3."""
+        cos_4: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 4."""
+        cos_5: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 5."""
+        cos_6: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 6."""
+        cos_7: OnOff = field(XmpByte())
+        """coded bytes, indicating whether PFC response is enabled for that CoS 7."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the port responds to incoming Ethernet Priority Flow Control (PFC) frames.
 
         :return: whether PFC response is enabled for CoS 0, Cos 1, Cos 2, Cos 3, Cos 4, Cos 5, Cos 6, and Cos 7
         :rtype: P_PFCENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, cos_0: OnOff, cos_1: OnOff, cos_2: OnOff, cos_3: OnOff, cos_4: OnOff, cos_5: OnOff, cos_6: OnOff, cos_7: OnOff) -> "Token":
+    def set(self, cos_0: OnOff, cos_1: OnOff, cos_2: OnOff, cos_3: OnOff, cos_4: OnOff, cos_5: OnOff, cos_6: OnOff, cos_7: OnOff) -> Token[None]:
         """Set whether the port responds to incoming Ethernet Priority Flow Control (PFC) frames.
 
         :param cos_0: whether PFC response is enabled for CoS 0
         :type cos_0: OnOff
         :param cos_1: whether PFC response is enabled for CoS 1
         :type cos_1: OnOff
         :param cos_2: whether PFC response is enabled for CoS 2
@@ -3488,19 +3902,30 @@
         :param cos_5: whether PFC response is enabled for CoS 5
         :type cos_5: OnOff
         :param cos_6: whether PFC response is enabled for CoS 6
         :type cos_6: OnOff
         :param cos_7: whether PFC response is enabled for CoS 7
         :type cos_7: OnOff
         """
+
         return Token(
             self._connection,
             build_set_request(
-                self, module=self._module, port=self._port, cos_0=cos_0, cos_1=cos_1, cos_2=cos_2, cos_3=cos_3, cos_4=cos_4, cos_5=cos_5, cos_6=cos_6, cos_7=cos_7
-            ),
+                self,
+                module=self._module,
+                port=self._port,
+                cos_0=cos_0,
+                cos_1=cos_1,
+                cos_2=cos_2,
+                cos_3=cos_3,
+                cos_4=cos_4,
+                cos_5=cos_5,
+                cos_6=cos_6,
+                cos_7=cos_7
+            )
         )
 
 
 @register_command
 @dataclass
 class P_TXBURSTPERIOD:
     """
@@ -3508,194 +3933,201 @@
     bursts (from a number of streams) to the start of next sequence of bursts. NB:
     Only used when Port TX Mode is "BURST".
     """
 
     code: typing.ClassVar[int] = 377
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        burst_period: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # integer, burst period expressed in microseconds.
+    class GetDataAttr(ResponseBodyStruct):
+        burst_period: int = field(XmpLong())
+        """integer, burst period expressed in microseconds."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        burst_period: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # integer, burst period expressed in microseconds.
+    class SetDataAttr(RequestBodyStruct):
+        burst_period: int = field(XmpLong())
+        """integer, burst period expressed in microseconds."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts in Burst TX mode.
 
         :return: the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts
         :rtype: P_TXBURSTPERIOD.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, burst_period: int) -> "Token":
+    def set(self, burst_period: int) -> Token[None]:
         """Set the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts in Burst TX mode.
 
-        :param burst_period: the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts in Burst TX mode
+        :param burst_period: the duration in microseconds from the start of one sequence of bursts
+            (from a number of streams) to the start of next sequence of bursts in Burst TX mode
         :type burst_period: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, burst_period=burst_period))
 
 
 @register_command
 @dataclass
 class P_TXRUNTLENGTH:
     """
     Enable TX runt feature to cut all packets to a number of bytes.
     """
 
     code: typing.ClassVar[int] = 390
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        runt_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, enable TX runt feature to cut all packets to I bytes. Set to -1 to disable.
+    class GetDataAttr(ResponseBodyStruct):
+        runt_length: int = field(XmpInt())
+        """integer, enable TX runt feature to cut all packets to I bytes. Set to -1 to disable."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        runt_length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, enable TX runt feature to cut all packets to I bytes. Set to -1 to disable.
+    class SetDataAttr(RequestBodyStruct):
+        runt_length: int = field(XmpInt())
+        """integer, enable TX runt feature to cut all packets to I bytes. Set to -1 to disable."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the TX runt feature to cut all packets to I bytes. -1 means disabled.
 
         :return: the TX runt feature to cut all packets to I bytes
         :rtype: P_TXRUNTLENGTH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, runt_length: int) -> "Token":
+    def set(self, runt_length: int) -> Token[None]:
         """Set TX runt feature to cut all packets to I bytes. Set to -1 to disable.
 
         :param runt_length: enable TX runt feature to cut all packets to I bytes. Set to -1 to disable.
         :type runt_length: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, runt_length=runt_length))
 
 
 @register_command
 @dataclass
 class P_RXRUNTLENGTH:
     """
     Enable RX runt length detection to flag if packets are seen with length not
     being I bytes.
     """
 
     code: typing.ClassVar[int] = 391
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        runt_length: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, enable RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled.
+    class GetDataAttr(ResponseBodyStruct):
+        runt_length: int = field(XmpInt())
+        """integer, enable RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        runt_length: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, enable RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled.
+    class SetDataAttr(RequestBodyStruct):
+        runt_length: int = field(XmpInt())
+        """integer, enable RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get RX runt length detection to flag if packets are seen with length not being I bytes. -1 means disabled.
 
         :return: RX runt length detection to flag if packets are seen with length not being I bytes. -1 means disabled
         :rtype: P_RXRUNTLENGTH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, runt_length: int) -> "Token":
+    def set(self, runt_length: int) -> Token[None]:
         """Set RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled.
 
         :param runt_length: RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled.
         :type runt_length: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, runt_length=runt_length))
 
 
 @register_command
 @dataclass
 class P_RXRUNTLEN_ERRS:
     """
     Sticky clear on read: Have packets with wrong runt length been detected since last read?
     """
 
     code: typing.ClassVar[int] = 392
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        status: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=YesNo)  # coded integer, have packets with wrong runt length been detected since last read?
+    class GetDataAttr(ResponseBodyStruct):
+        status: YesNo = field(XmpInt())
+        """coded integer, have packets with wrong runt length been detected since last read?"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Have packets with wrong runt length been detected since last read?
 
         :return: whether packets with wrong runt length been detected since last read
         :rtype: P_RXRUNTLEN_ERRS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_TXPREAMBLE_REMOVE:
     """
     Remove preamble from outgoing frames.
     """
 
     code: typing.ClassVar[int] = 393
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, remove preamble from outgoing frames.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, remove preamble from outgoing frames."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, remove preamble from outgoing frames.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, remove preamble from outgoing frames."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the preambles from outgoing frames are to be removed by the port.
 
         :return: whether the preambles from outgoing frames are to be removed by the port
         :rtype: P_TXPREAMBLE_REMOVE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether the preambles from outgoing frames are to be removed by the port.
 
         :param on_off: whether the preambles from outgoing frames are to be removed by the port
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable frame preamble removal on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable frame preamble removal on the port.
     """
 
 
 @register_command
 @dataclass
@@ -3703,45 +4135,48 @@
     """
     Insert preambles to the incoming frames.
     """
 
     code: typing.ClassVar[int] = 394
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, insert preamble to incoming frames.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, insert preamble to incoming frames."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, insert preamble to incoming frames.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, insert preamble to incoming frames."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the port should insert preambles to the incoming frames.
 
         :return: whether the port should insert preambles to the incoming frames
         :rtype: P_RXPREAMBLE_INSERT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether the port should insert preambles to the incoming frames.
 
         :param on_off: whether the port should insert preambles to the incoming frames
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable frame preamble insertion on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable frame preamble insertion on the port.
     """
 
 
 @register_command
 @dataclass
@@ -3749,45 +4184,48 @@
     """
     The action determines if config load mode is enabled or disabled for the Chimera port.
     """
 
     code: typing.ClassVar[int] = 395
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether the config load function is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, specifying whether the config load function is enabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether the config load function is enabled.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, specifying whether the config load function is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of config load mode of the Chimera port.
 
         :return: the status of config load mode on the Chimera port
         :rtype: P_LOADMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the status of config load mode of the Chimera port.
 
         :param on_off: whether config load is enabled on the Chimera port
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable config load on the Chimera port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable config load on the Chimera port.
     """
 
 
 @register_command
 @dataclass
@@ -3802,88 +4240,112 @@
         Ports can support zero (in case of e.g. empty cage), one, or multiple speeds.
 
     """
 
     code: typing.ClassVar[int] = 396
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        auto: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # auto-negotiated speed, the actual speed depends on the negotiation result.
-        f10M: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 10 Mbps.
-        f100M: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 100 Mbps.
-        f1G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 1 Gbps.
-        f10G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 10 Gbps.
-        f40G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 40 Gbps.
-        f100G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 100 Gbps.
-        f10MHDX: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 10 Mbps half duplex.
-        f100MHDX: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 100 Mbps half duplex.
-        f10M100M: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 10/100 Mbps.
-        f100M1G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 100/1000 Mbps.
-        f100M1G10G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 100/1000/10000 Mbps.
-        f2500M: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 2500 Mbps.
-        f5G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 5 Gbps.
-        f100M1G2500M: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 100/1000/2500 Mbps.
-        f25G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 25 Gbps.
-        f50G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 50 Gbps.
-        f200G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 200 Gbps.
-        f400G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 400 Gbps.
-        f800G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 800 Gbps.
-        f1600G: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # 1600 Gbps.
+    class GetDataAttr(ResponseBodyStruct):
+        auto: int = field(XmpByte())
+        """auto-negotiated speed, the actual speed depends on the negotiation result."""
+        f10M: int = field(XmpByte())
+        """10 Mbps."""
+        f100M: int = field(XmpByte())
+        """100 Mbps."""
+        f1G: int = field(XmpByte())
+        """1 Gbps."""
+        f10G: int = field(XmpByte())
+        """10 Gbps."""
+        f40G: int = field(XmpByte())
+        """40 Gbps."""
+        f100G: int = field(XmpByte())
+        """100 Gbps."""
+        f10MHDX: int = field(XmpByte())
+        """10 Mbps half duplex."""
+        f100MHDX: int = field(XmpByte())
+        """100 Mbps half duplex."""
+        f10M100M: int = field(XmpByte())
+        """10/100 Mbps."""
+        f100M1G: int = field(XmpByte())
+        """100/1000 Mbps."""
+        f100M1G10G: int = field(XmpByte())
+        """100/1000/10000 Mbps."""
+        f2500M: int = field(XmpByte())
+        """2500 Mbps."""
+        f5G: int = field(XmpByte())
+        """5 Gbps."""
+        f100M1G2500M: int = field(XmpByte())
+        """100/1000/2500 Mbps."""
+        f25G: int = field(XmpByte())
+        """25 Gbps."""
+        f50G: int = field(XmpByte())
+        """50 Gbps."""
+        f200G: int = field(XmpByte())
+        """200 Gbps."""
+        f400G: int = field(XmpByte())
+        """400 Gbps."""
+        f800G: int = field(XmpByte())
+        """800 Gbps."""
+        f1600G: int = field(XmpByte())
+        """1600 Gbps."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the speeds supported by the port.
 
         :return: the speeds supported by the port
         :rtype: P_SPEEDS_SUPPORTED.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class P_EMULATE:
     """
     The action determines if emulation functionality is enabled or disabled
     """
 
     code: typing.ClassVar[int] = 1600
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether the emulate function is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        action: OnOff = field(XmpByte())
+        """coded byte, specifying whether the emulate function is enabled."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether the emulate function is enabled.
+    class SetDataAttr(RequestBodyStruct):
+        action: OnOff = field(XmpByte())
+        """coded byte, specifying whether the emulate function is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether the Chimera port's emulation functionality is enabled.
 
         :return: whether the Chimera port's emulation functionality is enabled
         :rtype: P_EMULATE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, action: OnOff) -> "Token":
+    def set(self, action: OnOff) -> Token[None]:
         """Set whether the Chimera port's emulation functionality is enabled.
 
         :param action: whether the Chimera port's emulation functionality is enabled
         :type action: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, action=action))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the Chimera port's emulation functionality.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the Chimera port's emulation functionality.
     """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pc_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pc_commands.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,23 +1,34 @@
-#: L23 Port Capture Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpHex,
+    XmpInt,
+    XmpLong,
+    XmpSequence,
+    Hex,
+)
+from .enums import (
+    StartTrigger,
+    StopTrigger,
+    PacketType,
+)
 
 
 @register_command
 @dataclass
 class PC_TRIGGER:
     """
     The criteria for when to start and stop the capture process for a port. Even
@@ -30,75 +41,72 @@
     discarded),  and otherwise, the earliest packets are retained (and the later
     ones discarded).
     """
 
     code: typing.ClassVar[int] = 221
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        start_criteria: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=StartTrigger)  # coded integer, the criteria for starting the actual packet capture
-        start_criteria_filter: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the index of a particular filter for the start criteria.
-        stop_criteria: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=StopTrigger)  # coded integer, the criteria for stopping the actual packet capture
-        stop_criteria_filter: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the index of a particular filter for the stop criteria.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        """
-        Class of the get data.
-        """
-
-        start_criteria: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=StartTrigger)  # coded integer, the criteria for starting the actual packet capture
+    class GetDataAttr(ResponseBodyStruct):
+        start_criteria: StartTrigger = field(XmpInt())
         """The criteria for starting the actual packet capture.
 
         :type: StartTrigger
         """
-
-        start_criteria_filter: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the index of a particular filter for the start criteria.
+        start_criteria_filter: int = field(XmpInt())
         """The index of a particular filter for the start criteria.
 
         :type: int
         """
-
-        stop_criteria: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=StopTrigger)  # coded integer, the criteria for stopping the actual packet capture
+        stop_criteria: StopTrigger = field(XmpInt())
         """The criteria for stopping the actual packet capture.
 
         :type: StopTrigger
         """
-
-        stop_criteria_filter: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the index of a particular filter for the stop criteria.
+        stop_criteria_filter: int = field(XmpInt())
         """The index of a particular filter for the stop criteria.
 
         :type: int
         """
 
-    def get(self) -> "Token[GetDataAttr]":
+    class SetDataAttr(RequestBodyStruct):
+        start_criteria: StartTrigger = field(XmpInt())
+        """coded integer, the criteria for starting the actual packet capture"""
+        start_criteria_filter: int = field(XmpInt())
+        """integer, the index of a particular filter for the start criteria."""
+        stop_criteria: StopTrigger = field(XmpInt())
+        """coded integer, the criteria for stopping the actual packet capture"""
+        stop_criteria_filter: int = field(XmpInt())
+        """integer, the index of a particular filter for the stop criteria."""
+
+    def get(self) -> Token[GetDataAttr]:
         """Get the capture criteria configurations.
 
         :return: capture criteria configuration.
         :rtype: ~PC_TRIGGER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, start_criteria: StartTrigger, start_criteria_filter: int, stop_criteria: StopTrigger, stop_criteria_filter: int) -> "Token":
+    def set(self, start_criteria: StartTrigger, start_criteria_filter: int, stop_criteria: StopTrigger, stop_criteria_filter: int) -> Token[None]:
         """Set the capture criteria configurations.
 
         :param start_criteria: the criteria for starting the actual packet capture
         :type start_criteria: StartTrigger
         :param start_criteria_filter: the index of a particular filter for the start criteria
         :type start_criteria_filter: int
         :param stop_criteria: the criteria for stopping the actual packet capture
         :type stop_criteria: StopTrigger
         :param stop_criteria_filter: the index of a particular filter for the stop criteria
         :type stop_criteria_filter: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 start_criteria=start_criteria,
@@ -117,82 +125,85 @@
     Also how big a portion of each packet to retain, saving space for more packets
     in the capture buffer.
     """
 
     code: typing.ClassVar[int] = 222
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        kind: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=PacketType)  # coded integer, which general kind of packets to keep
-        index: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, test payload id or filter index for which packets to keep.
-        byte_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, how many bytes to keep in the buffer for of each packet. The value -1 means no limit on packet size.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        """Class of the get data.
-        """
-
-        kind: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=PacketType)  # coded integer, which general kind of packets to keep
+    class GetDataAttr(ResponseBodyStruct):
+        kind: PacketType = field(XmpInt())
         """The type of packet to keep.
 
         :type: PacketType
         """
-
-        index: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, test payload id or filter index for which packets to keep.
+        index: int = field(XmpInt())
         """Test payload id or filter index for which packets to keep.
 
         :type: int
         """
-
-        byte_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, how many bytes to keep in the buffer for of each packet. The value -1 means no limit on packet size.
+        byte_count: int = field(XmpInt())
         """How many bytes to keep in the buffer for of each packet. The value -1 means no limit on packet size.
 
         :type: int
         """
 
-    def get(self) -> "Token[GetDataAttr]":
+    class SetDataAttr(RequestBodyStruct):
+        kind: PacketType = field(XmpInt())
+        """coded integer, which general kind of packets to keep"""
+        index: int = field(XmpInt())
+        """integer, test payload id or filter index for which packets to keep."""
+        byte_count: int = field(XmpInt())
+        """integer, how many bytes to keep in the buffer for of each packet. The value -1 means no limit on packet size."""
+
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of how to keep captured packets.
 
         :return: the configuration of how to keep captured packets
         :rtype: ~PC_KEEP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, kind: PacketType, index: int, byte_count: int) -> "Token":
+    def set(self, kind: PacketType, index: int, byte_count: int) -> Token[None]:
         """Set the configuration of how to keep captured packets.
 
         :param kind: which general kind of packets to keep
         :type kind: PacketType
         :param index: test payload id or filter index for which packets to keep
         :type index: int
         :param byte_count: how many bytes to keep in the buffer for of each packet. The value -1 means no limit on packet size.
         :type byte_count: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, kind=kind, index=index, byte_count=byte_count))
 
     set_all = functools.partialmethod(set, PacketType.ALL)
     """Keep all types of packets.
     """
+
     set_fcserr = functools.partialmethod(set, PacketType.FCSERR)
     """Only keep the packets with FCS errors.
     """
+
     set_notpld = functools.partialmethod(set, PacketType.NOTPLD)
     """Only keep the packets without test payload.
     """
+
     set_tpld = functools.partialmethod(set, PacketType.TPLD)
     """Only keep the packets with test payload.
     """
+
     set_filter = functools.partialmethod(set, PacketType.FILTER)
     """Only keep the packets that satisfy the given filter.
     """
+
     set_plderr = functools.partialmethod(set, PacketType.PLDERR)
     """Only keep the packets with payload error in.
     """
 
 
 @register_command
 @dataclass
@@ -201,47 +212,42 @@
     Obtains the number of packets currently in the capture buffer for a port. The
     count is reset to zero when capture is turned on.
     """
 
     code: typing.ClassVar[int] = 224
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        """Class of the get data.
-        """
-
-        status: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, 1 if capture has been stopped because of overflow, 0 if still running.
-        """Capture status, 1 if capture has been stopped because of overflow, 0 if still running. 
+    class GetDataAttr(ResponseBodyStruct):
+        status: int = field(XmpLong())
+        """Capture status, 1 if capture has been stopped because of overflow, 0 if still running.
 
         :type: int
         """
-
-        packets: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of packets in the buffer.
+        packets: int = field(XmpLong())
         """The number of packets in the buffer.
 
         :type: int
         """
-
-        start_time: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, time when capture was started, in nano-seconds since 2010-01-01.
+        start_time: int = field(XmpLong())
         """Time when capture was started, in **nanoseconds** since 2010-01-01.
 
         :type: int
         """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of packets currently in the capture buffer for a port. The count is reset to zero when capture is turned on.
 
         :return: status of the capture, number of packets in the buffer, and start time in nanoseconds since 2010-01-01.
         :rtype: ~PC_STATS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PC_EXTRA:
     """
@@ -250,92 +256,81 @@
     Latency is only valid for packets with test payloads and where the originating
     port is on the same module and therefore has the same clock.
     """
 
     code: typing.ClassVar[int] = 225
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
-    capture_packet_xindex: int
+    _capture_packet_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        """
-        Class of the returned data.
-        """
-
-        time_captured: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, time when packet was captured, in nanoseconds since 2010-01-01.
+    class GetDataAttr(ResponseBodyStruct):
+        time_captured: int = field(XmpLong())
         """
         Time of capture, in **nanoseconds** since 2010-01-01.
 
         :type: int
         """
-
-        latency: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of nanoseconds since the packet was transmitted.
+        latency: int = field(XmpLong())
         """
         The number of **nanoseconds** since the packet was transmitted.
 
         :type: int
         """
-
-        byte_time_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, the number of byte-times since previous packet.
+        byte_time_count: int = field(XmpLong())
         """
         The number of byte-times since previous packet.
 
         :type: int
         """
-
-        length: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the real length of the packet on the wire.
+        length: int = field(XmpInt())
         """
         The real length of the packet on the wire.
 
         :type: int
         """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get extra information about a captured packet for a port.
 
         :return: Extra information about a captured packet for a port.
-            
+
         :rtype: ~PC_EXTRA.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self.capture_packet_xindex]))
+
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._capture_packet_xindex]))
 
 
 @register_command
 @dataclass
 class PC_PACKET:
     """
     Obtains the raw bytes of a captured packet for a port. The packet data may be
     truncated if the :class:`PC_KEEP` command specified a limit on the number of bytes
     kept.
     """
 
     code: typing.ClassVar[int] = 226
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
-    capture_packet_xindex: int
+    _capture_packet_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        """
-        Class of the returned data.
-        """
-
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the raw bytes kept for the packet.
+    class GetDataAttr(ResponseBodyStruct):
+        hex_data: Hex = field(XmpHex())
         """The raw bytes kept for the packet.
 
         :type: list
         """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the raw bytes of a captured packet for a port.
 
         :return: the raw bytes of a captured packet
         :rtype: ~PC_PACKET.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self.capture_packet_xindex]))
+
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._capture_packet_xindex]))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pd_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pd_commands.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,128 +1,125 @@
-#: L23 Port Histogram Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpInt,
+    XmpLong,
+    XmpSequence,
+
+)
+from .enums import (
+    OnOff,
+    SourceType,
+    PacketDetailSelection,
+)
 
 
 @register_command
 @dataclass
 class PD_INDICES:
     """
     Obtain or configure histogram indices for each of N histograms.
     """
 
     code: typing.ClassVar[int] = 140
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        histogram_indices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, histogram indices
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        histogram_indices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, histogram indices
+    class GetDataAttr(ResponseBodyStruct):
+        histogram_indices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, histogram indices"""
+
+    class SetDataAttr(RequestBodyStruct):
+        histogram_indices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, histogram indices"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the histogram indices for each of N histograms.
 
         :return: the histogram indices for each of N histograms
         :rtype: PD_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, histogram_indices: typing.List[int]) -> "Token":
+    def set(self, histogram_indices: typing.List[int]) -> Token[None]:
         """Set the histogram indices for each of N histograms.
 
         :param histogram_indices: histogram indices
-        :type histogram_indices: List[int]
+        :type histogram_indices: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, histogram_indices=histogram_indices))
 
 
 @register_command
 @dataclass
 class PD_CREATE:
     """
     Creates a histogram definition with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 141
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _dataset_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Create a histogram definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._dataset_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex]))
 
 
 @register_command
 @dataclass
 class PD_DELETE:
     """
     Delete an existing histogram definition.
     """
 
     code: typing.ClassVar[int] = 142
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _dataset_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Delete an existing histogram definition.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._dataset_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex]))
 
 
 @register_command
 @dataclass
 class PD_ENABLE:
     """
     Whether a histogram is currently active on a port. When turned on, all the bucket
@@ -130,46 +127,49 @@
     criteria is counted into one of the buckets. While a histogram is enabled its
     parameters cannot be changed.
     """
 
     code: typing.ClassVar[int] = 143
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _dataset_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded integer, whether the histogram is enabled.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded integer, whether the histogram is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded integer, whether the histogram is enabled."""
+
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded integer, whether the histogram is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether a histogram is currently active on a port.
 
         :return: whether the histogram is enabled
         :rtype: OnOff
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex]))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether a histogram is currently active on a port.
 
         :param on_off: whether the histogram is enabled
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex], on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the histogram on the port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the histogram on the port.
     """
 
 
 @register_command
 @dataclass
@@ -178,54 +178,66 @@
     The source criteria specifying what is counted, and for which packets, by a
     histogram of a port.
     """
 
     code: typing.ClassVar[int] = 144
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _dataset_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        source_type: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=SourceType)  # coded integer, specifying what is counted and for which packets.
-        which_packets: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=PacketDetailSelection)  # coded integer, specifying a further detail on which packets to count.
-        identity: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, test payload id or filter id for the wanted packets.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        source_type: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=SourceType)  # coded integer, specifying what is counted and for which packets.
-        which_packets: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=PacketDetailSelection)  # coded integer, specifying a further detail on which packets to count.
-        identity: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, test payload id or filter id for the wanted packets.
+    class GetDataAttr(ResponseBodyStruct):
+        source_type: SourceType = field(XmpInt())
+        """coded integer, specifying what is counted and for which packets."""
+        which_packets: PacketDetailSelection = field(XmpInt())
+        """coded integer, specifying a further detail on which packets to count."""
+        identity: int = field(XmpInt())
+        """integer, test payload id or filter id for the wanted packets."""
+
+    class SetDataAttr(RequestBodyStruct):
+        source_type: SourceType = field(XmpInt())
+        """coded integer, specifying what is counted and for which packets."""
+        which_packets: PacketDetailSelection = field(XmpInt())
+        """coded integer, specifying a further detail on which packets to count."""
+        identity: int = field(XmpInt())
+        """integer, test payload id or filter id for the wanted packets."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the source criteria specifying what is counted, and for which packets, by a histogram of a port.
 
         :return: what is counted and for which packets, a further detail on which packets to count, test payload id or filter id for the wanted packets
         :rtype: PD_SOURCE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex]))
 
-    def set(self, source_type: SourceType, which_packets: PacketDetailSelection, identity: int) -> "Token":
+    def set(self, source_type: SourceType, which_packets: PacketDetailSelection, identity: int) -> Token[None]:
         """Set the source criteria specifying what is counted, and for which packets, by a histogram of a port.
 
         :param source_type: what is counted and for which packets
         :type source_type: SourceType
         :param which_packets: a further detail on which packets to count
         :type which_packets: PacketDetailSelection
         :param identity: test payload id or filter id for the wanted packets
         :type identity: int
         """
+
         return Token(
             self._connection,
             build_set_request(
-                self, module=self._module, port=self._port, indices=[self._dataset_xindex], source_type=source_type, which_packets=which_packets, identity=identity
-            ),
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._dataset_xindex],
+                source_type=source_type,
+                which_packets=which_packets,
+                identity=identity
+            )
         )
 
 
 @register_command
 @dataclass
 class PD_RANGE:
     """
@@ -238,63 +250,81 @@
     ranges of the middle buckets. The buckets are placed at a certain offset by
     specifying the first value that should be counted by the first middle bucket.
     """
 
     code: typing.ClassVar[int] = 145
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _dataset_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        start: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, first value going into the second bucket.
-        step: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the span of each middle bucket: (1) 1,2,4,8,16,32,64,128,256,512 (bytes, non-latency histograms). (2) 16,32,64,128,...,1048576,2097152 (nanoseconds, latency histograms).
-        bucket_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the total number of buckets.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        start: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, first value going into the second bucket.
-        step: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the span of each middle bucket: (1) 1,2,4,8,16,32,64,128,256,512 (bytes, non-latency histograms). (2) 16,32,64,128,...,1048576,2097152 (nanoseconds, latency histograms).
-        bucket_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the total number of buckets.
+    class GetDataAttr(ResponseBodyStruct):
+        start: int = field(XmpInt())
+        """integer, first value going into the second bucket."""
+        step: int = field(XmpInt())
+        """integer, the span of each middle bucket:
+            (1) 1,2,4,8,16,32,64,128,256,512 (bytes, non-latency histograms).
+            (2) 16,32,64,128,...,1048576,2097152 (nanoseconds, latency histograms).
+        """
+        bucket_count: int = field(XmpInt())
+        """integer, the total number of buckets."""
+
+    class SetDataAttr(RequestBodyStruct):
+        start: int = field(XmpInt())
+        """integer, first value going into the second bucket."""
+        step: int = field(XmpInt())
+        """integer, the span of each middle bucket:
+            (1) 1,2,4,8,16,32,64,128,256,512 (bytes, non-latency histograms).
+            (2) 16,32,64,128,...,1048576,2097152 (nanoseconds, latency histograms).
+        """
+        bucket_count: int = field(XmpInt())
+        """integer, the total number of buckets."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the bucket ranges used for classifying the packets counted by a histogram of a port.
 
         :return: first value going into the second bucket, the span of each middle bucket, the total number of buckets
         :rtype: PD_RANGE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex]))
 
-    def set(self, start: int, step: int, bucket_count: int) -> "Token":
+    def set(self, start: int, step: int, bucket_count: int) -> Token[None]:
         """Set the bucket ranges used for classifying the packets counted by a histogram of a port.
         The packets are either counted by length, measured in bytes, by inter-
         frame gap to the preceding packet,  also measured in bytes, or by latency in
         transmission measured in nanoseconds.  There are a fixed number of buckets, each
         middle bucket covering a fixed-size range of values which is a power of two.
         The first and last buckets count all the packets that do not fit within the
         ranges of the middle buckets. The buckets are placed at a certain offset by
         specifying the first value that should be counted by the first middle bucket.
 
         :param start: first value going into the second bucket
         :type start: int
-        :param step: the span of each middle bucket: (1) 1,2,4,8,16,32,64,128,256,512 (bytes, non-latency histograms). (2) 16,32,64,128,...,1048576,2097152 (nanoseconds, latency histograms)
+        :param step: the span of each middle bucket:
+            (1) 1,2,4,8,16,32,64,128,256,512 (bytes, non-latency histograms).
+            (2) 16,32,64,128,...,1048576,2097152 (nanoseconds, latency histograms)
         :type step: int
         :param bucket_count: the total number of buckets
         :type bucket_count: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex], start=start, step=step, bucket_count=bucket_count),
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._dataset_xindex],
+                start=start,
+                step=step,
+                bucket_count=bucket_count
+            )
         )
 
 
 @register_command
 @dataclass
 class PD_SAMPLES:
     """
@@ -302,23 +332,24 @@
     for each bucket, but any trailing zeros are left out. The list is empty if all
     counts are zero.
     """
 
     code: typing.ClassVar[int] = 146
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _dataset_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        packet_counts: XmpField[xt.XmpLongList] = XmpField(xt.XmpLongList)  # list of long integers, the number of packets counted for each bucket.
+    class GetDataAttr(ResponseBodyStruct):
+        packet_counts: typing.List[int] = field(XmpSequence(types_chunk=[XmpLong()]))
+        """list of long integers, the number of packets counted for each bucket."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get current set of counts collected by a histogram for a port.
 
         :return: the number of packets counted for each bucket
         :rtype: PD_SAMPLES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._dataset_xindex]))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pe_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pe_commands.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,66 +1,80 @@
-#: Impairment Port Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpInt,
+    XmpLong,
+    XmpStr
+)
+from .enums import (
+    OnOff,
+    TPLDMode,
+    CorruptionType,
+    PolicerMode,
+)
 
 
 @register_command
 @dataclass
 class PE_FCSDROP:
     """
     The action on packets with FCS errors on a port.
     """
 
     code: typing.ClassVar[int] = 1601
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, the action on packets with FCS errors on a port
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, the action on packets with FCS errors on a port"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, the action on packets with FCS errors on a port
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, the action on packets with FCS errors on a port"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of whether the action on packets with FCS errors on a port is enabled.
 
         :return: whether the action on packets with FCS errors on a port is enabled
         :rtype: PE_FCSDROP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set the status of whether the action on packets with FCS errors on a port is enabled.
 
         :param on_off:  whether the action on packets with FCS errors on a port is enabled
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable the action on packets with FCS errors on a port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable the action on packets with FCS errors on a port.
     """
 
 
 @register_command
 @dataclass
@@ -68,45 +82,48 @@
     """
     The action indicates the TPLD mode to be used per port.
     """
 
     code: typing.ClassVar[int] = 1602
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TPLDMode)  # coded byte, indicating the TPLD mode.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: TPLDMode = field(XmpByte())
+        """coded byte, indicating the TPLD mode."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=TPLDMode)  # coded byte, indicating the TPLD mode.
+    class SetDataAttr(RequestBodyStruct):
+        mode: TPLDMode = field(XmpByte())
+        """coded byte, indicating the TPLD mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the TPLD mode of the port.
 
         :return: indicating the TPLD mode
         :rtype: PE_TPLDMODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, mode: TPLDMode) -> "Token":
+    def set(self, mode: TPLDMode) -> Token[None]:
         """Set the TPLD mode of the port.
 
         :param mode: indicating the TPLD mode
         :type mode: TPLDMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, mode=mode))
 
     set_normal = functools.partialmethod(set, TPLDMode.NORMAL)
     """Set the TPLD mode to Normal.
     """
+
     set_micro = functools.partialmethod(set, TPLDMode.MICRO)
     """Set the TPLD mode to Micro.
     """
 
 
 @register_command
 @dataclass
@@ -114,104 +131,116 @@
     """
     Flow description.
     """
 
     code: typing.ClassVar[int] = 1605
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the description of the flow.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, containing the description of the flow."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, containing the description of the flow.
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, containing the description of the flow."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the flow description.
 
         :return: the description of the flow
         :rtype: PE_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the flow description.
 
         :param comment: the description of the flow
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex], comment=comment))
 
 
 @register_command
 @dataclass
 class PE_INDICES:
     """
     Get the flow indices. Currently the number of flows is 8.
     """
 
     code: typing.ClassVar[int] = 1608
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        flow0_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 0.
-        flow1_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 1.
-        flow2_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 2.
-        flow3_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 3.
-        flow4_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 4.
-        flow5_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 5.
-        flow6_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 6.
-        flow7_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, id of flow 7.
+    class GetDataAttr(ResponseBodyStruct):
+        flow0_id: int = field(XmpInt())
+        """integer, id of flow 0."""
+        flow1_id: int = field(XmpInt())
+        """integer, id of flow 1."""
+        flow2_id: int = field(XmpInt())
+        """integer, id of flow 2."""
+        flow3_id: int = field(XmpInt())
+        """integer, id of flow 3."""
+        flow4_id: int = field(XmpInt())
+        """integer, id of flow 4."""
+        flow5_id: int = field(XmpInt())
+        """integer, id of flow 5."""
+        flow6_id: int = field(XmpInt())
+        """integer, id of flow 6."""
+        flow7_id: int = field(XmpInt())
+        """integer, id of flow 7."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the flow indices of a port. Currently the number of flows is fixed to 8.
 
         :return: the flow indices of a port
         :rtype: PE_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_LATENCYRANGE:
     """
     Retrieve minimum and maximum configurable latency per flow in nanoseconds.
     """
 
     code: typing.ClassVar[int] = 1646
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        min: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, minimum configurable latency per flow in nanoseconds.
-        max: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, maximum configurable latency per flow in nanoseconds.
+    class GetDataAttr(ResponseBodyStruct):
+        min: int = field(XmpLong())
+        """long integer, minimum configurable latency per flow in nanoseconds."""
+        max: int = field(XmpLong())
+        """long integer, maximum configurable latency per flow in nanoseconds."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the minimum and maximum configurable latency per flow in nanoseconds.
 
         :return: minimum and maximum configurable latency per flow in nanoseconds.
         :rtype: PE_LATENCYRANGE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PE_CORRUPT:
     """
@@ -222,58 +251,65 @@
         IP / TCP / UDP corruption modes are not supported on default flow (0)
 
     """
 
     code: typing.ClassVar[int] = 1660
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        corruption_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=CorruptionType)  # coded byte, specifying corruption type.
+    class GetDataAttr(ResponseBodyStruct):
+        corruption_type: CorruptionType = field(XmpByte())
+        """coded byte, specifying corruption type."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        corruption_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=CorruptionType)  # coded byte, specifying corruption type.
+    class SetDataAttr(RequestBodyStruct):
+        corruption_type: CorruptionType = field(XmpByte())
+        """coded byte, specifying corruption type."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the impairment corruption type of a flow.
 
         :return: the impairment corruption type of a flow.
         :rtype: PE_CORRUPT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
-    def set(self, corruption_type: CorruptionType) -> "Token":
+    def set(self, corruption_type: CorruptionType) -> Token[None]:
         """Set the impairment corruption type.
 
         :param corruption_type: corruption type
         :type corruption_type: CorruptionType
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex], corruption_type=corruption_type))
 
     set_off = functools.partialmethod(set, CorruptionType.OFF)
     """Set the corruption type to OFF.
     """
+
     set_eth = functools.partialmethod(set, CorruptionType.ETH)
     """Set the corruption type to Ethernet.
     """
+
     set_ip = functools.partialmethod(set, CorruptionType.IP)
     """Set the corruption type to IP.
     """
+
     set_udp = functools.partialmethod(set, CorruptionType.UDP)
     """Set the corruption type to UDP.
     """
+
     set_tcp = functools.partialmethod(set, CorruptionType.TCP)
     """Set the corruption type to TCP.
     """
+
     set_ber = functools.partialmethod(set, CorruptionType.BER)
     """Set the corruption type to Bit Error Rate.
     """
 
 
 @register_command
 @dataclass
@@ -286,374 +322,414 @@
         probability [see PED_FIXED] * (depth + 1) should be less than 1,000,000.
 
     """
 
     code: typing.ClassVar[int] = 1661
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        depth: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, specifies the misordering depth (Range 1 - 32). Default value. Note: probability [see PED_FIXED] * (depth + 1) should be less than 1,000,000.
+    class GetDataAttr(ResponseBodyStruct):
+        depth: int = field(XmpInt())
+        """integer, specifies the misordering depth (Range 1 - 32). Default value. Note: probability [see PED_FIXED] * (depth + 1) should be less than 1,000,000."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        depth: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, specifies the misordering depth (Range 1 - 32). Default value. Note: probability [see PED_FIXED] * (depth + 1) should be less than 1,000,000.
+    class SetDataAttr(RequestBodyStruct):
+        depth: int = field(XmpInt())
+        """integer, specifies the misordering depth (Range 1 - 32). Default value. Note: probability [see PED_FIXED] * (depth + 1) should be less than 1,000,000."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the misordering depth in number of packets of a flow.
 
         :return: the misordering depth (Range 1 - 32). Default value.
         :rtype: PE_MISORDER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
-    def set(self, depth: int) -> "Token":
+    def set(self, depth: int) -> Token[None]:
         """Set the misordering depth in number of packets of a flow. Note: probability [see
         PED_FIXED] * (depth + 1) should be less than 1,000,000.
 
         :param depth: the misordering depth (Range 1 - 32). Default value.
         :type depth: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex], depth=depth))
 
 
 @register_command
 @dataclass
 class PE_BANDPOLICER:
     """
     Configures the bandwidth policer.
     """
 
     code: typing.ClassVar[int] = 1662
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, enables/disables policer. Note: PED_ENABLE is not supported for the policer.
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PolicerMode)  # coded byte, sets policer mode.
-        cir: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, policer committed information rate in units of 100 kbps (range 0 to 1000000), default is 0.
-        cbs: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, policer committed burst size in bytes (range 0 to 4194304), default is 0.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enables/disables policer. Note: PED_ENABLE is not supported for the policer."""
+        mode: PolicerMode = field(XmpByte())
+        """coded byte, sets policer mode."""
+        cir: int = field(XmpInt())
+        """integer, policer committed information rate in units of 100 kbps (range 0 to 1000000), default is 0."""
+        cbs: int = field(XmpInt())
+        """integer, policer committed burst burst in bytes (range 0 to 4194304), default is 0."""
+
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enables/disables policer. Note: PED_ENABLE is not supported for the policer."""
+        mode: PolicerMode = field(XmpByte())
+        """coded byte, sets policer mode."""
+        cir: int = field(XmpInt())
+        """integer, policer committed information rate in units of 100 kbps (range 0 to 1000000), default is 0."""
+        cbs: int = field(XmpInt())
+        """integer, policer committed burst size in bytes (range 0 to 4194304), default is 0."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, enables/disables policer. Note: PED_ENABLE is not supported for the policer.
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PolicerMode)  # coded byte, sets policer mode.
-        cir: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, policer committed information rate in units of 100 kbps (range 0 to 1000000), default is 0.
-        cbs: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, policer committed burst burst in bytes (range 0 to 4194304), default is 0.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the bandwidth policer configuration.
 
         :return: enabled/disabled, policer mode, committed information rate, and committed burst size.
         :rtype: PE_BANDPOLICER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
-    def set(self, on_off: OnOff, mode: PolicerMode, cir: int, cbs: int) -> "Token":
+    def set(self, on_off: OnOff, mode: PolicerMode, cir: int, cbs: int) -> Token[None]:
         """Set the bandwidth policer configuration.
 
         :param on_off: enables/disables policer. Note: PED_ENABLE is not supported for the policer.
         :type on_off: OnOff
         :param mode: policer mode
         :type mode: PolicerMode
         :param cir: policer committed information rate in units of 100 kbps (range 0 to 1000000), default is 0.
         :type cir: int
         :param cbs: policer committed burst burst in bytes (range 0 to 4194304), default is 0.
         :type cbs: int
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex], on_off=on_off, mode=mode, cir=cir, cbs=cbs)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex], on_off=on_off, mode=mode, cir=cir, cbs=cbs))
 
 
 @register_command
 @dataclass
 class PE_BANDSHAPER:
     """
     Configures the bandwidth shaper. L1 (0) (Shaper performed at Layer 1 level. I.e. including
     the preamble and min interpacket gap) L2 (1) (Shaper performed at Layer 2 level. I.e. excluding the preamble and min interpacket gap) Default value: L2 (0)
     """
 
     code: typing.ClassVar[int] = 1663
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, enables/disables shaper.
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PolicerMode)  # coded byte, sets shaper mode.
-        cir: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, shaper committed information rate in units of 100 kbps (range 0 to 1000000), default is 0.
-        cbs: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, shaper committed burst size in bytes (range 0 to 4194304), default is 0.
-        buffer_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, shaper buffer size in bytes (range 0 to 2097152), default is 0.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, enables/disables shaper.
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PolicerMode)  # coded byte, sets shaper mode.
-        cir: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, shaper committed information rate in units of 100 kbps (range 0 to 1000000), default is 0.
-        cbs: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, shaper committed burst size in bytes (range 0 to 4194304), default is 0.
-        buffer_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, shaper buffer size in bytes (range 0 to 2097152), default is 0.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enables/disables shaper."""
+        mode: PolicerMode = field(XmpByte())
+        """coded byte, sets shaper mode."""
+        cir: int = field(XmpInt())
+        """integer, shaper committed information rate in units of 100 kbps (range 0 to 1000000), default is 0."""
+        cbs: int = field(XmpInt())
+        """integer, shaper committed burst size in bytes (range 0 to 4194304), default is 0."""
+        buffer_size: int = field(XmpInt())
+        """integer, shaper buffer size in bytes (range 0 to 2097152), default is 0."""
+
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, enables/disables shaper."""
+        mode: PolicerMode = field(XmpByte())
+        """coded byte, sets shaper mode."""
+        cir: int = field(XmpInt())
+        """integer, shaper committed information rate in units of 100 kbps (range 0 to 1000000), default is 0."""
+        cbs: int = field(XmpInt())
+        """integer, shaper committed burst size in bytes (range 0 to 4194304), default is 0."""
+        buffer_size: int = field(XmpInt())
+        """integer, shaper buffer size in bytes (range 0 to 2097152), default is 0."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the bandwidth shaper configuration.
 
         :return: the bandwidth shaper configuration, including on/off, mode, CIR, CBS, and shaper buffer size.
         :rtype: PE_BANDSHAPER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
-    def set(self, on_off: OnOff, mode: PolicerMode, cir: int, cbs: int, buffer_size: int) -> "Token":
+    def set(self, on_off: OnOff, mode: PolicerMode, cir: int, cbs: int, buffer_size: int) -> Token[None]:
         """Set the bandwidth shaper configuration.
 
         :param on_off: enables/disables shaper
         :type on_off: OnOff
         :param mode: shaper mode
         :type mode: PolicerMode
         :param cir: shaper committed information rate in units of 100 kbps (range 0 to 1000000), default is 0.
         :type cir: int
         :param cbs: shaper committed burst size in bytes (range 0 to 4194304), default is 0.
         :type cbs: int
         :param buffer_size: shaper buffer size in bytes (range 0 to 2097152), default is 0.
         :type buffer_size: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex], on_off=on_off, mode=mode, cir=cir, cbs=cbs, buffer_size=buffer_size),
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._flow_xindex],
+                on_off=on_off,
+                mode=mode,
+                cir=cir,
+                cbs=cbs,
+                buffer_size=buffer_size
+            )
         )
 
 
 @register_command
 @dataclass
 class PE_DROPTOTAL:
     """
     Obtains statistics concerning all the packets dropped between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1750
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_drop_count_total: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped in all flows.
-        pkt_drop_count_programmed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped as programmed in all flows.
-        pkt_drop_count_bandwidth: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped due to bandwidth control in all flows.
-        pkt_drop_count_other: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped for other reasons in all flows.
-        pkt_drop_ratio_total: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets dropped in all flows, expressed in ppm.
-        pkt_drop_ratio_programmed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets dropped as programmed in all flows, expressed in ppm.
-        pkt_drop_ratio_bandwidth: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets dropped due to bandwidth control in all flows, expressed in ppm.
-        pkt_drop_ratio_other: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets dropped for other reasons in all flows, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_drop_count_total: int = field(XmpLong())
+        """long integer, total number of packets dropped in all flows."""
+        pkt_drop_count_programmed: int = field(XmpLong())
+        """long integer, total number of packets dropped as programmed in all flows."""
+        pkt_drop_count_bandwidth: int = field(XmpLong())
+        """long integer, total number of packets dropped due to bandwidth control in all flows."""
+        pkt_drop_count_other: int = field(XmpLong())
+        """long integer, total number of packets dropped for other reasons in all flows."""
+        pkt_drop_ratio_total: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped in all flows, expressed in ppm."""
+        pkt_drop_ratio_programmed: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped as programmed in all flows, expressed in ppm."""
+        pkt_drop_ratio_bandwidth: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped due to bandwidth control in all flows, expressed in ppm."""
+        pkt_drop_ratio_other: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped for other reasons in all flows, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets dropped between this receive port and its partner TX port.
 
         :return:
             total number of packets dropped in all flows,
             total number of packets dropped as programmed in all flows,
             total number of packets dropped due to bandwidth control in all flows,
             total number of packets dropped for other reasons in all flows,
             ratio of number of packets dropped in all flows, expressed in ppm,
             ratio of number of packets dropped as programmed in all flows, expressed in ppm,
             ratio of number of packets dropped due to bandwidth control in all flows, expressed in ppm,
             ratio of number of packets dropped for other reasons in all flows, expressed in ppm.
         :rtype: PE_DROPTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_LATENCYTOTAL:
     """
     Obtains statistics concerning all the packets delayed this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1751
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets delayed in all flows.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets delayed in all flows, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets delayed in all flows."""
+        ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets delayed in all flows, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets delayed this receive port and its
         partner TX port.
 
         :return: number of packets delayed in all flows, and ratio of number of packets delayed in all flows, expressed in ppm.
         :rtype: PE_LATENCYTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_DUPTOTAL:
     """
     Obtains statistics concerning all the packets duplicated between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1752
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets duplicated in all flows.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets duplicated in all flows, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets duplicated in all flows."""
+        ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets duplicated in all flows, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets duplicated between this receive
         port and its partner TX port.
 
         :return: number of packets duplicated in all flows, ratio of number of packets duplicated in all flows, expressed in ppm.
         :rtype: PE_DUPTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_MISTOTAL:
     """
     Obtains statistics concerning all the packets mis-ordered between this receive
     port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1753
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets mis-ordered in all flows.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets mis-ordered in all flows, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets mis-ordered in all flows."""
+        ratio: int = field(XmpLong())
+        """long integer, number of packets mis-ordered in all flows, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets mis-ordered between this receive port and its partner TX port.
 
         :return: number of packets mis-ordered in all flows, number of packets mis-ordered in all flows, expressed in ppm.
         :rtype: PE_MISTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_CORTOTAL:
     """
     Obtains statistics concerning all the packets corrupted on between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1754
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        total_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets corrupted in all flows.
-        fcs_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with Ethernet FCS corrupted in all flows.
-        ip_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with IP header checksum corrupted in all flows.
-        udp_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with UDP checksum corrupted in all flows.
-        tcp_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with TCP checksum corrupted in all flows.
-        total_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets corrupted in all flows, expressed in ppm.
-        fcs_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with Ethernet FCS corrupted in all flows, expressed in ppm.
-        ip_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with IP Header checksum corrupted in all flows, expressed in ppm.
-        udp_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with UDP checksum corrupted in all flows, expressed in ppm.
-        tcp_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with TCP checksum corrupted in all flows, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        total_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets corrupted in all flows."""
+        fcs_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with Ethernet FCS corrupted in all flows."""
+        ip_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with IP header checksum corrupted in all flows."""
+        udp_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with UDP checksum corrupted in all flows."""
+        tcp_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with TCP checksum corrupted in all flows."""
+        total_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets corrupted in all flows, expressed in ppm."""
+        fcs_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with Ethernet FCS corrupted in all flows, expressed in ppm."""
+        ip_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with IP Header checksum corrupted in all flows, expressed in ppm."""
+        udp_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with UDP checksum corrupted in all flows, expressed in ppm."""
+        tcp_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with TCP checksum corrupted in all flows, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets corrupted on between this receive port and its partner TX port.
 
         :return: number of packets corrupted in all flows;
             number of packets with Ethernet FCS corrupted in all flows;
             number of packets with IP header checksum corrupted in all flows;
             number of packets with UDP checksum corrupted in all flows;
             number of packets with TCP checksum corrupted in all flows;
             ratio of number of packets corrupted in all flows, expressed in ppm;
             ratio of number of packets with Ethernet FCS corrupted in all flows expressed in ppm;
             ratio of number of packets with IP Header checksum corrupted in all flows, expressed in ppm;
             ratio of number of packets with UDP checksum corrupted in all flows, expressed in ppm;
             ratio of number of packets with TCP checksum corrupted in all flows, expressed in ppm
         :rtype: PE_CORTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_JITTERTOTAL:
     """
     Obtains statistics concerning all the packets jittered between this receive port
     and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1755
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets jittered in all flows.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets jittered in all flows expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets jittered in all flows."""
+        ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets jittered in all flows expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets jittered between this receive port
         and its partner TX port.
 
         :return: number of packets jittered in all flows, ratio of number of packets jittered in all flows expressed in ppm.
         :rtype: PE_JITTERTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_CLEAR:
     """
@@ -661,206 +737,212 @@
     jitter) statistics for a Chimera port and flows on the port. The byte and packet
     counts will restart at zero.
     """
 
     code: typing.ClassVar[int] = 1756
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Clear all the impairment (duplicate, drop, mis-ordered, corrupted, latency and
         jitter) statistics for a Chimera port and flows on the port. The byte and packet
         counts will restart at zero.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port))
 
 
 @register_command
 @dataclass
 class PE_FLOWDROPTOTAL:
     """
     Obtains statistics concerning all the packets dropped in a flow between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1770
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_drop_count_total: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped for the flow.
-        pkt_drop_count_programmed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped as programmed for the flow.
-        pkt_drop_count_bandwidth: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped due to bandwidth control for the flow.
-        pkt_drop_count_other: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, total number of packets dropped for other reasons for the flow.
-        pkt_drop_ratio_total: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets dropped for the flow, expressed in ppm.
-        pkt_drop_ratio_programmed: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets dropped as programmed for the flow, expressed in ppm.
-        pkt_drop_ratio_bandwidth: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets dropped due to bandwidth control for the flow, expressed in ppm.
-        pkt_drop_ratio_other: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets dropped for other reasons for the flow, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_drop_count_total: int = field(XmpLong())
+        """long integer, total number of packets dropped for the flow."""
+        pkt_drop_count_programmed: int = field(XmpLong())
+        """long integer, total number of packets dropped as programmed for the flow."""
+        pkt_drop_count_bandwidth: int = field(XmpLong())
+        """long integer, total number of packets dropped due to bandwidth control for the flow."""
+        pkt_drop_count_other: int = field(XmpLong())
+        """long integer, total number of packets dropped for other reasons for the flow."""
+        pkt_drop_ratio_total: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped for the flow, expressed in ppm."""
+        pkt_drop_ratio_programmed: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped as programmed for the flow, expressed in ppm."""
+        pkt_drop_ratio_bandwidth: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped due to bandwidth control for the flow, expressed in ppm."""
+        pkt_drop_ratio_other: int = field(XmpLong())
+        """long integer, ratio of number of packets dropped for other reasons for the flow, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets dropped in a flow between this receive port and its partner TX port.
 
         :return:
             total number of packets dropped for the flow,
             total number of packets dropped as programmed for the flow,
             total number of packets dropped due to bandwidth control for the flow,
             total number of packets dropped for other reasons for the flow,
             ratio of number of packets dropped for the flow, expressed in ppm,
             ratio of number of packets dropped as programmed for the flow, expressed in ppm,
             ratio of number of packets dropped due to bandwidth control for the flow, expressed in ppm,
             ratio of number of packets dropped for other reasons for the flow, expressed in ppm.
         :rtype: PE_FLOWDROPTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PE_FLOWLATENCYTOTAL:
     """
     Obtains statistics concerning all the packets delayed between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1771
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets delayed in the flow.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets delayed in the flow, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets delayed in the flow."""
+        ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets delayed in the flow, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets delayed between this receive port and its partner TX port.
 
         :return: number of packets delayed in the flow, ratio of number of packets delayed in the flow, expressed in ppm.
         :rtype: PE_FLOWLATENCYTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PE_FLOWDUPTOTAL:
     """
     Obtains statistics concerning all the packets duplicated in a flow between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1772
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets duplicated for the flow.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets duplicated for the flow - expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets duplicated for the flow."""
+        ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets duplicated for the flow - expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets duplicated in a flow between this receive port and its partner TX port.
 
         :return: number of packets duplicated for the flow, ratio of number of packets duplicated for the flow - expressed in ppm.
         :rtype: PE_FLOWDUPTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PE_FLOWMISTOTAL:
     """
     Obtains statistics concerning all the packets mis-ordered in a flow between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1773
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets mis-ordered for the flow.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets mis-ordered for the flow."""
+        ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets mis-ordered in a flow between this receive port and its partner TX port.
 
         :return: number of packets mis-ordered for the flow, ratio of number of packets, expressed in ppm.
         :rtype: PE_FLOWMISTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PE_FLOWCORTOTAL:
     """
     Obtains statistics concerning all the packets corrupted in a flow between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1774
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        total_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets corrupted for the flow.
-        fcs_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with Ethernet FCS corrupted for the flow.
-        ip_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with IP header checksum corrupted for the flow.
-        udp_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with UDP checksum corrupted for the flow.
-        tcp_corrupted_pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets with TCP checksum corrupted for the flow.
-        total_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets corrupted for the flow expressed in ppm.
-        fcs_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with Ethernet FCS corrupted for the flow expressed in ppm.
-        ip_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with IP Header checksum corrupted for the flow expressed in ppm.
-        udp_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with UDP checksum corrupted for the flow expressed in ppm.
-        tcp_corrupted_pkt_ratio: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long integer, ratio of number of packets with TCP checksum corrupted for the flow expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        total_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets corrupted for the flow."""
+        fcs_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with Ethernet FCS corrupted for the flow."""
+        ip_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with IP header checksum corrupted for the flow."""
+        udp_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with UDP checksum corrupted for the flow."""
+        tcp_corrupted_pkt_count: int = field(XmpLong())
+        """long integer, number of packets with TCP checksum corrupted for the flow."""
+        total_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets corrupted for the flow expressed in ppm."""
+        fcs_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with Ethernet FCS corrupted for the flow expressed in ppm."""
+        ip_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with IP Header checksum corrupted for the flow expressed in ppm."""
+        udp_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with UDP checksum corrupted for the flow expressed in ppm."""
+        tcp_corrupted_pkt_ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets with TCP checksum corrupted for the flow expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets corrupted in a flow between this receive port and its partner TX port.
 
         :return:
             number of packets corrupted for the flow,
             number of packets with Ethernet FCS corrupted for the flow,
             number of packets with IP header checksum corrupted for the flow,
             number of packets with UDP checksum corrupted for the flow,
@@ -868,43 +950,46 @@
             ratio of number of packets corrupted for the flow expressed in ppm,
             ratio of number of packets with Ethernet FCS corrupted for the flow expressed in ppm,
             ratio of number of packets with IP Header checksum corrupted for the flow expressed in ppm,
             ratio of number of packets with UDP checksum corrupted for the flow expressed in ppm,
             ratio of number of packets with TCP checksum corrupted for the flow expressed in ppm.
         :rtype: PE_FLOWCORTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PE_FLOWJITTERTOTAL:
     """
     Obtains statistics concerning all the packets jittered in a flow between this receive port and its partner TX port.
     """
 
     code: typing.ClassVar[int] = 1775
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pkt_count: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, number of packets jittered in the flow.
-        ratio: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, ratio of number of packets jittered in the flow, expressed in ppm.
+    class GetDataAttr(ResponseBodyStruct):
+        pkt_count: int = field(XmpLong())
+        """long integer, number of packets jittered in the flow."""
+        ratio: int = field(XmpLong())
+        """long integer, ratio of number of packets jittered in the flow, expressed in ppm."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get statistics concerning all the packets jittered in a flow between this receive port and its partner TX port.
 
         :return: number of packets jittered in the flow, ratio of number of packets jittered in the flow, expressed in ppm
         :rtype: PE_FLOWJITTERTOTAL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PE_FLOWCLEAR:
     """
@@ -912,30 +997,22 @@
     jitter) statistics on a particular flow on the port. The byte and packet counts
     will restart at zero.
     """
 
     code: typing.ClassVar[int] = 1776
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Clear all the impairment (duplicate, drop, mis-ordered, corrupted, latency and
         jitter) statistics on a particular flow on the port. The byte and packet counts
         will restart at zero.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._flow_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pec_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pec_commands.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,22 +1,32 @@
-#: Impairment Port Custom Distribution Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpInt,
+    XmpLong,
+    XmpSequence,
+    XmpStr
+)
+from .enums import (
+    OnOff,
+    LatencyTypeCustomDist,
+)
 
 
 @register_command
 @dataclass
 class PEC_INDICES:
     """
     The full list of which custom distributions which are defined for a port. These
@@ -25,48 +35,52 @@
     distribution (default values) for each value that is not already in use, and
     deletes each custom distribution that is not mentioned in the list. The same can
     be accomplished one-custom-distribution-at-a-time using the PEC_VAL and
     PEC_DELETE commands.
 
     .. note::
 
-        Custom distributions which are currently defined are not affected when mentioned in a PEC_INDICES set command. Custom distributions which are currently assigned to an impairment cannot be deleted and any attempt of deleting such a custom distribution using either PEC_DELETE` or PEC_INDICES` will result in an error.
+        Custom distributions which are currently defined are not affected when mentioned in a PEC_INDICES set command.
+        Custom distributions which are currently assigned to an impairment cannot be deleted and any attempt of deleting
+        such a custom distribution using either PEC_DELETE` or PEC_INDICES` will result in an error.
 
     """
 
     code: typing.ClassVar[int] = 1610
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        indices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList, climb=(0, 40))  # list of integers, a list of the indices to the custom distributions which are currently defined on that port, max 40 elements.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        indices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList, climb=(0, 40))  # list of integers, a list of the indices to the custom distributions which are currently defined on that port, max 40 elements.
+    class GetDataAttr(ResponseBodyStruct):
+        indexations: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, a list of the indices to the custom distributions which are currently defined on that port, max 40 elements."""
+
+    class SetDataAttr(RequestBodyStruct):
+        indexations: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, a list of the indices to the custom distributions which are currently defined on that port, max 40 elements."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a list of the indices to the custom distributions which are currently defined on that port.
 
         :return: a list of the indices to the custom distributions which are currently defined on that port
         :rtype: PEC_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, indices: typing.List[int]) -> "Token":
+    def set(self, indexations: typing.List[int]) -> Token[None]:
         """Set a list of indices to create new custom distributions.
 
-        :param indices: a list of indices to create new custom distributions
-        :type indices: List[int]
+        :param indexations: a list of indices to create new custom distributions
+        :type indexations: typing.List[int]
         """
-        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=indices))
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indexations=indexations))
 
 
 @register_command
 @dataclass
 class PEC_VAL:
     """
     Definition of custom distribution. Custom distributions can be defined for
@@ -74,177 +88,178 @@
     port will maintain a list of defined custom distributions, identified by an
     CUST_ID. (Range: 1 - 40).
     """
 
     code: typing.ClassVar[int] = 1680
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _custom_distribution_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        linear: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, defines the way the FPGA RAM content is played out.
-        symmetric: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, reserved for future use, must be set to OFF.
-        entry_count: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, defines the number of entries in "dataX" (allowed value: 512,1024). NOTE: For Latency, 1024 entries are used, and for rest, 512 entries are used)
-        data_x: XmpField[xt.XmpLongList] = XmpField(xt.XmpLongList)  # array of long integers, array size="num_entries", holds values to be filled in the RAM memory.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        linear: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, defines the way the FPGA RAM content is played out.
-        symmetric: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, reserved for future use, must be set to OFF.
-        entry_count: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, defines the number of entries in "dataX" (allowed value: 512,1024). NOTE: For Latency, 1024 entries are used, and for rest, 512 entries are used)
-        data_x: XmpField[xt.XmpLongList] = XmpField(xt.XmpLongList)  # array of long integers, array size="num_entries", holds values to be filled in the RAM memory.
+    class GetDataAttr(ResponseBodyStruct):
+        linear: OnOff = field(XmpByte())
+        """coded byte, defines the way the FPGA RAM content is played out."""
+        symmetric: OnOff = field(XmpByte())
+        """coded byte, reserved for future use, must be set to OFF."""
+        entry_count: int = field(XmpInt())
+        """integer, defines the number of entries in "dataX" (allowed value: 512,1024). NOTE: For Latency, 1024 entries are used, and for rest, 512 entries are used)"""
+        data_x: typing.List[int] = field(XmpSequence(types_chunk=[XmpLong()]))
+        """array of long integers, array size="num_entries", holds values to be filled in the RAM memory."""
+
+    class SetDataAttr(RequestBodyStruct):
+        linear: OnOff = field(XmpByte())
+        """coded byte, defines the way the FPGA RAM content is played out."""
+        symmetric: OnOff = field(XmpByte())
+        """coded byte, reserved for future use, must be set to OFF."""
+        entry_count: int = field(XmpInt())
+        """integer, defines the number of entries in "dataX" (allowed value: 512,1024). NOTE: For Latency, 1024 entries are used, and for rest, 512 entries are used)"""
+        data_x: typing.List[int] = field(XmpSequence(types_chunk=[XmpLong()]))
+        """array of long integers, array size="num_entries", holds values to be filled in the RAM memory."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the definition of custom distribution.
 
         :return: definition of custom distribution
         :rtype: PEC_VAL.GetDataAttr.
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._custom_distribution_xindex]))
 
-    def set(self, linear: OnOff, symmetric: OnOff, entry_count: int, data_x: typing.List[int]) -> "Token":
+    def set(self, linear: OnOff, symmetric: OnOff, entry_count: int, data_x: typing.List[int]) -> Token[None]:
         """Set the definition of custom distribution. Custom distributions can be defined for
         latency with 1024 entries and for non-latency impairments with 512 entries. Each
         port will maintain a list of defined custom distributions, identified by an
         CUST_ID. (Range: 1 - 40).
 
         :param linear: defines the way the FPGA RAM content is played out
         :type linear: OnOff
         :param symmetric: reserved for future use, must be set to 0.
         :type symmetric: OnOff
         :param entry_count: defines the number of entries in "data_x" (allowed value: 512,1024). For Latency, 1024 entries are used, and for rest, 512 entries are used.
         :type entry_count: int
         :param data_x: array size equals to "entry_count", holds values to be filled in the RAM memory.
-        :type data_x: List[int]
+        :type data_x: typing.List[int]
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._custom_distribution_xindex],
                 linear=linear,
                 symmetric=symmetric,
                 entry_count=entry_count,
-                data_x=data_x,
-            ),
+                data_x=data_x
+            )
         )
 
 
 @register_command
 @dataclass
 class PEC_COMMENT:
     """
     Defines the user-defined description string of a custom distribution.
     """
 
     code: typing.ClassVar[int] = 1681
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _custom_distribution_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the user-specified comment/description for the custom distribution.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the user-specified comment/description for the custom distribution.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the user-specified comment/description for the custom distribution."""
+
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the user-specified comment/description for the custom distribution."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the user-defined description string of a custom distribution.
 
         :return: the user-specified comment/description for the custom distribution.
         :rtype: PEC_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._custom_distribution_xindex]))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the user-defined description string of a custom distribution.
 
         :param comment: the user-specified comment/description for the custom distribution.
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._custom_distribution_xindex], comment=comment))
 
 
 @register_command
 @dataclass
 class PEC_DELETE:
     """
     Deletes the custom distribution definition.
 
     .. note::
 
-        Once a customer has defined a customer distribution using PEC_VAL, it is defined until it is explicitly deleted.Only customer distributions which are not referenced by any impairments, can be deleted.
+        Once a customer has defined a customer distribution using PEC_VAL, it is defined until it is explicitly deleted.
+        Only customer distributions which are not referenced by any impairments, can be deleted.
 
     """
 
     code: typing.ClassVar[int] = 1682
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _custom_distribution_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Deletes the custom distribution definition.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._custom_distribution_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._custom_distribution_xindex]))
 
 
 @register_command
 @dataclass
 class PEC_DISTTYPE:
     """
     Retrieves if a custom distribution is defined for latency or non-latency.
 
     .. note::
 
-        Using PEC_DISTTYPE as set has no effect. The distribution type is determined upon custom distribution creation and cannot be modified later. However, it is legal to issue the PEC_DISTTYPE set command with no effect.
+        Using PEC_DISTTYPE as set has no effect. The distribution type is determined upon custom distribution creation and cannot be modified later.
+        However, it is legal to issue the PEC_DISTTYPE set command with no effect.
 
     """
 
     code: typing.ClassVar[int] = 1683
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _custom_distribution_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        latency_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=LatencyTypeCustomDist)  # byte, 0 indicates interpacket distribution, 1 indicates latency distribution.
+    class GetDataAttr(ResponseBodyStruct):
+        latency_type: LatencyTypeCustomDist = field(XmpByte())
+        """byte, 0 indicates interpacket distribution, 1 indicates latency distribution."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the latency type of a custom distribution.
 
         :return: latency type of a custom distribution
         :rtype: PEC_DISTTYPE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._custom_distribution_xindex]))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/ped_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/ped_commands.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,23 +1,28 @@
-#: Impairment Port Distribution Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
-import functools
 import typing
+import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpInt,
+    XmpLong,
+)
+from .enums import OnOff
 
 
 @register_command
 @dataclass
 class PED_SCHEDULE:
     """
     Configure the impairment scheduler function.  The configuration of the scheduler
@@ -30,49 +35,60 @@
     running in "Repeat Period" configuration of "Duration" and "Repeat Period" is
     required.
     """
 
     code: typing.ClassVar[int] = 1611
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the "on" period. Units = multiples of 10 ms (range 1 to 65535), default is 1
-        period: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the "total" period. Units = multiples of 10 ms (range 0 to 65535), default is 0
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        duration: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the "on" period. Units = multiples of 10 ms (range 1 to 65535), default is 1
-        period: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the "total" period. Units = multiples of 10 ms (range 0 to 65535), default is 0
+    class GetDataAttr(ResponseBodyStruct):
+        duration: int = field(XmpInt())
+        """integer, specifies the "on" period. Units = multiples of 10 ms (range 1 to 65535), default is 1"""
+        period: int = field(XmpInt())
+        """integer, specifies the "total" period. Units = multiples of 10 ms (range 0 to 65535), default is 0"""
+
+    class SetDataAttr(RequestBodyStruct):
+        duration: int = field(XmpInt())
+        """integer, specifies the "on" period. Units = multiples of 10 ms (range 1 to 65535), default is 1"""
+        period: int = field(XmpInt())
+        """integer, specifies the "total" period. Units = multiples of 10 ms (range 0 to 65535), default is 0"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the impairment scheduler configuration.
 
         :return: the impairment scheduler configuration
         :rtype: PED_SCHEDULE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, duration: int, period: int) -> "Token":
+    def set(self, duration: int, period: int) -> Token[None]:
         """Set the impairment scheduler configuration.
 
         :param duration: specifies the "on" period. Units = multiples of 10 ms (range 1 to 65535), default is 1
         :type duration: int
         :param period: specifies the "total" period. Units = multiples of 10 ms (range 0 to 65535), default is 0
         :type period: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], duration=duration, period=period),
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._flow_xindex, self._impairment_type_xindex],
+                duration=duration,
+                period=period
+            )
         )
 
 
 @register_command
 @dataclass
 class PED_ONESHOTSTATUS:
     """
@@ -83,66 +99,59 @@
         The return value is only valid, if the configured distribution is either accumulate & burst (DELAY) or fixed burst (non-DELAY).
 
     """
 
     code: typing.ClassVar[int] = 1612
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        one_shot_status: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, specifies the status.
+    class GetDataAttr(ResponseBodyStruct):
+        one_shot_status: int = field(XmpByte())
+        """byte, specifies the status."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the one-shot completion status.
 
         :return: the one-shot completion status
         :rtype: PED_ONESHOTSTATUS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
 
 @register_command
 @dataclass
 class PED_OFF:
     """Configure Impairments Distribution to OFF. Assigning a different distribution than OFF to an impairment
     will activate the impairment. To de-activate the impairment assign distribution OFF.
     """
 
     code: typing.ClassVar[int] = 1620
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Configure Impairments Distribution to OFF. Assigning a different distribution than OFF to an impairment
         will activate the impairment. To de-activate the impairment assign distribution OFF.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._flow_xindex, self._impairment_type_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
 
 @register_command
 @dataclass
 class PED_FIXED:
     """
     Configuration of Fixed Rate distribution. This is predictable distribution with
@@ -153,42 +162,44 @@
         In case of misordering, a special limit applies, probability * (depth + 1) should be less than 1000000.
 
     """
 
     code: typing.ClassVar[int] = 1621
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        probability: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the fixed probability in ppm. Default value is 0.
+    class GetDataAttr(ResponseBodyStruct):
+        probability: int = field(XmpInt())
+        """integer, specifies the fixed probability in ppm. Default value is 0."""
+
+    class SetDataAttr(RequestBodyStruct):
+        probability: int = field(XmpInt())
+        """integer, specifies the fixed probability in ppm. Default value is 0."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        probability: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the fixed probability in ppm. Default value is 0.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the probability of a Fixed Rate distribution.
 
         :return: the fixed probability in ppm. Default value is 0.
         :rtype: PED_FIXED.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, probability: int) -> "Token":
+    def set(self, probability: int) -> Token[None]:
         """Set the probability of a Fixed Rate distribution.
 
         :param probability: the fixed probability in ppm. Default value is 0.
         :type probability: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._flow_xindex, self._impairment_type_xindex],
@@ -206,42 +217,44 @@
     equal to the configured probability over time. Random probability in ppm (i.e. 1
     means 0.0001%)
     """
 
     code: typing.ClassVar[int] = 1622
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        probability: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the random probability in ppm. Default value is 0.
+    class GetDataAttr(ResponseBodyStruct):
+        probability: int = field(XmpInt())
+        """integer, specifies the random probability in ppm. Default value is 0."""
+
+    class SetDataAttr(RequestBodyStruct):
+        probability: int = field(XmpInt())
+        """integer, specifies the random probability in ppm. Default value is 0."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        probability: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the random probability in ppm. Default value is 0.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the probability of a Random Rate distribution.
 
         :return: specifies the random probability in ppm. Default value is 0.
         :rtype: PED_RANDOM.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, probability: int) -> "Token":
+    def set(self, probability: int) -> Token[None]:
         """Set the probability of a Random Rate distribution.
 
         :param probability: specifies the random probability in ppm. Default value is 0.
         :type probability: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._flow_xindex, self._impairment_type_xindex],
@@ -256,46 +269,50 @@
     """
     Configuration of Bit Error Rate distribution.
     """
 
     code: typing.ClassVar[int] = 1623
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        coef: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the coefficient for BER. Default value: 1 (Range is 1 to 9).
-        exp: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the exponent for BER. Default value: -10 (Range is -18 to -1).
+    class GetDataAttr(ResponseBodyStruct):
+        coef: int = field(XmpInt())
+        """integer, specifies the coefficient for BER. Default value: 1 (Range is 1 to 9)."""
+        exp: int = field(XmpInt())
+        """integer, specifies the exponent for BER. Default value: -10 (Range is -18 to -1)."""
+
+    class SetDataAttr(RequestBodyStruct):
+        coef: int = field(XmpInt())
+        """integer, specifies the coefficient for BER. Default value: 1 (Range is 1 to 9)."""
+        exp: int = field(XmpInt())
+        """integer, specifies the exponent for BER. Default value: -10 (Range is -18 to -1)."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        coef: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the coefficient for BER. Default value: 1 (Range is 1 to 9).
-        exp: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the exponent for BER. Default value: -10 (Range is -18 to -1).
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Bit Error Rate distribution.
 
         :return: the configuration of Bit Error Rate distribution
         :rtype: PED_BER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, coef: int, exp: int) -> "Token":
+    def set(self, coef: int, exp: int) -> Token[None]:
         """Set the configuration of Bit Error Rate distribution.
 
         :param coef: specifies the coefficient for BER. Default value: 1 (Range is 1 to 9).
         :type coef: int
         :param exp: specifies the exponent for BER. Default value: -10 (Range is -18 to -1).
         :type exp: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], coef=coef, exp=exp))
 
 
 @register_command
 @dataclass
 class PED_FIXEDBURST:
     """
@@ -306,169 +323,186 @@
         In case of ``_impairment_type_xindex`` = ``MISO``, burst size is fixed to 1.
 
     """
 
     code: typing.ClassVar[int] = 1624
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        burst_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the burst size (Range 1 - 16383). Default value = 1.
+    class GetDataAttr(ResponseBodyStruct):
+        burst_size: int = field(XmpInt())
+        """integer, specifies the burst size (Range 1 - 16383). Default value = 1."""
+
+    class SetDataAttr(RequestBodyStruct):
+        burst_size: int = field(XmpInt())
+        """integer, specifies the burst size (Range 1 - 16383). Default value = 1."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        burst_size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the burst size (Range 1 - 16383). Default value = 1.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Fixed Burst distribution.
 
         :return: configuration of Fixed Burst distribution.
         :rtype: PED_FIXEDBURST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, burst_size: int) -> "Token":
+    def set(self, burst_size: int) -> Token[None]:
         """Set the configuration of Fixed Burst distribution.
 
         :param burst_size: specifies the burst size (Range 1 - 16383). Default value = 1.
         :type burst_size: int
         """
+
         return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], burst_size=burst_size)
+            self._connection,
+            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], burst_size=burst_size)
         )
 
 
 @register_command
 @dataclass
 class PED_RANDOMBURST:
     """
     Configuration of Random Burst distribution.
     """
 
     code: typing.ClassVar[int] = 1625
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        minimum: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies minimum burst size. Default value: 0 (Range 0 to 65535)
-        maximum: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies maximum burst size. Default value: 0 (Range 0 to 65535)
-        probability: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the per packet probability of initiating a burst in ppm. Default value: 0.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        minimum: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies minimum burst size. Default value: 0 (Range 0 to 65535)
-        maximum: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies maximum burst size. Default value: 0 (Range 0 to 65535)
-        probability: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the per packet probability of initiating a burst in ppm. Default value: 0.
+    class GetDataAttr(ResponseBodyStruct):
+        minimum: int = field(XmpInt())
+        """integer, specifies minimum burst size. Default value: 0 (Range 0 to 65535)"""
+        maximum: int = field(XmpInt())
+        """integer, specifies maximum burst size. Default value: 0 (Range 0 to 65535)"""
+        probability: int = field(XmpInt())
+        """integer, specifies the per packet probability of initiating a burst in ppm. Default value: 0."""
+
+    class SetDataAttr(RequestBodyStruct):
+        minimum: int = field(XmpInt())
+        """integer, specifies minimum burst size. Default value: 0 (Range 0 to 65535)"""
+        maximum: int = field(XmpInt())
+        """integer, specifies maximum burst size. Default value: 0 (Range 0 to 65535)"""
+        probability: int = field(XmpInt())
+        """integer, specifies the per packet probability of initiating a burst in ppm. Default value: 0."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Random Burst distribution.
 
         :return: configuration of Random Burst distribution.
         :rtype: PED_RANDOMBURST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, minimum: int, maximum: int, probability: int) -> "Token":
+    def set(self, minimum: int, maximum: int, probability: int) -> Token[None]:
         """Set the configuration of Random Burst distribution.
 
         :param minimum: specifies minimum burst size. Default value: 0 (Range 0 to 65535)
         :type minimum: int
         :param maximum: specifies maximum burst size. Default value: 0 (Range 0 to 65535)
         :type maximum: int
         :param probability: specifies the per packet probability of initiating a burst in ppm. Default value: 0.
         :type probability: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._flow_xindex, self._impairment_type_xindex],
                 minimum=minimum,
                 maximum=maximum,
                 probability=probability
-            ),
+            )
         )
 
 
 @register_command
 @dataclass
 class PED_GE:
     """
     Configuration of Gilbert-Elliot distribution.
     """
 
     code: typing.ClassVar[int] = 1626
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        good_state_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the good state probability in ppm. Default value: 0.
-        good_state_trans_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the good state transition probability in ppm. Default value: 0.
-        bad_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the bad state probability in ppm. Default value: 0.
-        bad_state_trans_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the bad state transition probability in ppm. Default value: 0.
+    class GetDataAttr(ResponseBodyStruct):
+        good_state_prob: int = field(XmpInt())
+        """integer, specifies the good state probability in ppm. Default value: 0."""
+        good_state_trans_prob: int = field(XmpInt())
+        """integer, specifies the good state transition probability in ppm. Default value: 0."""
+        bad_state_prob: int = field(XmpInt())
+        """integer, specifies the bad state probability in ppm. Default value: 0."""
+        bad_state_trans_prob: int = field(XmpInt())
+        """integer, specifies the bad state transition probability in ppm. Default value: 0."""
+
+    class SetDataAttr(RequestBodyStruct):
+        good_state_prob: int = field(XmpInt())
+        """integer, specifies the good state probability in ppm. Default value: 0."""
+        good_state_trans_prob: int = field(XmpInt())
+        """integer, specifies the good state transition probability in ppm. Default value: 0."""
+        bad_state_prob: int = field(XmpInt())
+        """integer, specifies the bad state probability in ppm. Default value: 0."""
+        bad_state_trans_prob: int = field(XmpInt())
+        """integer, specifies the bad state transition probability in ppm. Default value: 0."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        good_state_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the good state probability in ppm. Default value: 0.
-        good_state_trans_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the good state transition probability in ppm. Default value: 0.
-        bad_state_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the bad state probability in ppm. Default value: 0.
-        bad_state_trans_prob: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifies the bad state transition probability in ppm. Default value: 0.
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Gilbert-Elliot distribution.
 
         :return: the configuration of Gilbert-Elliot distribution.
         :rtype: PED_GE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, good_state_prob: int, good_state_trans_prob: int, bad_state_prob: int, bad_state_trans_prob: int) -> "Token":
+    def set(self, good_state_prob: int, good_state_trans_prob: int, bad_state_prob: int, bad_state_trans_prob: int) -> Token[None]:
         """Set the configuration of Gilbert-Elliot distribution.
 
         :param good_state_prob: specifies the good state probability in ppm. Default value: 0.
         :type good_state_prob: int
         :param good_state_trans_prob: specifies the good state transition probability in ppm. Default value: 0.
         :type good_state_trans_prob: int
         :param bad_state_prob: specifies the bad state probability in ppm. Default value: 0.
         :type bad_state_prob: int
         :param bad_state_trans_prob: specifies the bad state transition probability in ppm. Default value: 0.
         :type bad_state_trans_prob: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._flow_xindex, self._impairment_type_xindex],
                 good_state_prob=good_state_prob,
                 good_state_trans_prob=good_state_trans_prob,
                 bad_state_prob=bad_state_prob,
-                bad_state_trans_prob=bad_state_trans_prob,
-            ),
+                bad_state_trans_prob=bad_state_trans_prob
+            )
         )
 
 
 @register_command
 @dataclass
 class PED_UNI:
     """
@@ -479,120 +513,135 @@
         If minimum is less than minimum latency, value is set to minimum latency. If minimum is greater than maximum latency, value is set to maximum latency.
 
     """
 
     code: typing.ClassVar[int] = 1627
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        minimum: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, in case of iid != DELAY, specifies the minimum no. of packets. Default value: 0 (Range 0 to 4194288). In case of iid = DELAY, specifies the minimum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
-        maximum: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, in case of iid != DELAY, specifies the maximum no. of packets. Default value: 0 (Range 0 to 4194288). In case of iid = DELAY, specifies the maximum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+    class GetDataAttr(ResponseBodyStruct):
+        minimum: int = field(XmpLong())
+        """long, in case of iid != DELAY, specifies the minimum no. of packets. Default value: 0 (Range 0 to 4194288).
+        In case of iid = DELAY, specifies the minimum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+        """
+        maximum: int = field(XmpLong())
+        """long, in case of iid != DELAY, specifies the maximum no. of packets. Default value: 0 (Range 0 to 4194288).
+        In case of iid = DELAY, specifies the maximum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+        """
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        minimum: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, in case of iid != DELAY, specifies the minimum no. of packets. Default value: 0 (Range 0 to 4194288). In case of iid = DELAY, specifies the minimum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
-        maximum: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, in case of iid != DELAY, specifies the maximum no. of packets. Default value: 0 (Range 0 to 4194288). In case of iid = DELAY, specifies the maximum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+    class SetDataAttr(RequestBodyStruct):
+        minimum: int = field(XmpLong())
+        """long, in case of iid != DELAY, specifies the minimum no. of packets. Default value: 0 (Range 0 to 4194288).
+        In case of iid = DELAY, specifies the minimum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+        """
+        maximum: int = field(XmpLong())
+        """long, in case of iid != DELAY, specifies the maximum no. of packets. Default value: 0 (Range 0 to 4194288).
+        In case of iid = DELAY, specifies the maximum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Uniform distribution.
 
         :return: the configuration of Uniform distribution.
         :rtype: PED_UNI.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, minimum: int, maximum: int) -> "Token":
+    def set(self, minimum: int, maximum: int) -> Token[None]:
         """Set the configuration of Uniform distribution.
 
-        :param minimum: in case of iid != DELAY, specifies the minimum no. of packets. Default value: 0 (Range 0 to 4194288). In case of iid = DELAY, specifies the minimum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+        :param minimum: in case of iid != DELAY, specifies the minimum no. of packets. Default value: 0 (Range 0 to 4194288).
+            In case of iid = DELAY, specifies the minimum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
         :type minimum: int
-        :param maximum: in case of iid != DELAY, specifies the maximum no. of packets. Default value: 0 (Range 0 to 4194288). In case of iid = DELAY, specifies the maximum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
+        :param maximum: in case of iid != DELAY, specifies the maximum no. of packets. Default value: 0 (Range 0 to 4194288).
+            In case of iid = DELAY, specifies the maximum latency limit. Unit is nanosecond (must be multiples of 100 ns). Default value: minimum latency.
         :type maximum: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], minimum=minimum, maximum=maximum),
+            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], minimum=minimum, maximum=maximum)
         )
 
 
 @register_command
 @dataclass
 class PED_GAUSS:
     """
     Configuration of Gaussian distribution.
 
     .. note::
 
-        In case of ``_impairment_type_xindex != DELAY``: (1) mean plus 3 times standard deviation should be less than or equal to max allowed (4194288). (2) mean should always be at least 3 times the standard deviation, this to ensure that the impairment distance is always positive.
-
-        In case of ``_impairment_type_xindex = DELAY``: (1) mean plus 3 times standard deviation should be less than or equal to the maximum latency. (2) mean minus 3 times the standard deviation should be greater than or equal to minimum latency.
+        In case of ``_impairment_type_xindex != DELAY``:
+            (1) mean plus 3 times standard deviation should be less than or equal to max allowed (4194288).
+            (2) mean should always be at least 3 times the standard deviation, this to ensure that the impairment distance is always positive.
+
+        In case of ``_impairment_type_xindex = DELAY``:
+            (1) mean plus 3 times standard deviation should be less than or equal to the maximum latency.
+            (2) mean minus 3 times the standard deviation should be greater than or equal to minimum latency.
 
     """
 
     code: typing.ClassVar[int] = 1628
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mean: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Gaussian mean. In case of iid != DELAY, specifies the Gaussian mean value as number of packets.Default value: 0 packets (Range 0 to 4194288). In case of iid = DELAY, specifies the Gaussian mean value. Units is nanosecond (must be multiples of 100 ns).
-        std_deviation: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Gaussian standard deviation. In case of iid != DELAY, specifies the standard deviation as number of packets. Default value: 0 packets (Range 0 to 4194288). In case of iid = DELAY, specifies the the Gaussian standard deviation. Units is nanosecond (must be multiples of 100 ns). Default value: 0 ns.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mean: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Gaussian mean. In case of iid != DELAY, specifies the Gaussian mean value as number of packets.Default value: 0 packets (Range 0 to 4194288). In case of iid = DELAY, specifies the Gaussian mean value. Units is nanosecond (must be multiples of 100 ns).
-        std_deviation: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Gaussian standard deviation. In case of iid != DELAY, specifies the standard deviation as number of packets. Default value: 0 packets (Range 0 to 4194288). In case of iid = DELAY, specifies the the Gaussian standard deviation. Units is nanosecond (must be multiples of 100 ns). Default value: 0 ns.
+    class GetDataAttr(ResponseBodyStruct):
+        mean: int = field(XmpLong())
+        """long, specifies the Gaussian mean. In case of iid != DELAY, specifies the Gaussian mean value as number of packets.Default value: 0 packets (Range 0 to 4194288).
+        In case of iid = DELAY, specifies the Gaussian mean value. Units is nanosecond (must be multiples of 100 ns).
+        """
+        std_deviation: int = field(XmpLong())
+        """long, specifies the Gaussian standard deviation. In case of iid != DELAY, specifies the standard deviation as number of packets.
+        Default value: 0 packets (Range 0 to 4194288). In case of iid = DELAY, specifies the the Gaussian standard deviation.
+        Units is nanosecond (must be multiples of 100 ns). Default value: 0 ns.
+        """
+
+    class SetDataAttr(RequestBodyStruct):
+        mean: int = field(XmpLong())
+        """long, specifies the Gaussian mean. In case of iid != DELAY, specifies the Gaussian mean value as number of packets.Default value: 0 packets (Range 0 to 4194288).
+        In case of iid = DELAY, specifies the Gaussian mean value. Units is nanosecond (must be multiples of 100 ns)."""
+        std_deviation: int = field(XmpLong())
+        """long, specifies the Gaussian standard deviation. In case of iid != DELAY, specifies the standard deviation as number of packets.
+        Default value: 0 packets (Range 0 to 4194288). In case of iid = DELAY, specifies the the Gaussian standard deviation.
+        Units is nanosecond (must be multiples of 100 ns). Default value: 0 ns.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Gaussian distribution.
 
         :return: the configuration of Gaussian distribution
         :rtype: PED_GAUSS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, mean: int, std_deviation: int) -> "Token":
+    def set(self, mean: int, std_deviation: int) -> Token[None]:
         """Set the configuration of Gaussian distribution.
 
         :param mean: specifies the Gaussian mean.
         :type mean: int
         :param std_deviation: specifies the Gaussian standard deviation.
         :type std_deviation: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], mean=mean, std_deviation=std_deviation),
+            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], mean=mean, std_deviation=std_deviation)
         )
 
 
 @register_command
 @dataclass
 class PED_POISSON:
     """
@@ -607,160 +656,181 @@
         In case of ``_impairment_type_xindex = DELAY``, mean plus 3 times standard deviation should be less than or equal to the maximum latency.
 
     """
 
     code: typing.ClassVar[int] = 1629
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mean: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Poisson mean value. In case of iid = DELAY specifies the Poisson mean. Unit is nanosecond (must be multiples of 100ns). Default value: 0 ns. In case of iid != DELAY specifies the Poisson mean in number of packets packets. Default value: 9 packets (Range 0 to 4194288).
+    class GetDataAttr(ResponseBodyStruct):
+        mean: int = field(XmpLong())
+        """long, specifies the Poisson mean value. In case of iid = DELAY specifies the Poisson mean. Unit is nanosecond (must be multiples of 100ns).
+        Default value: 0 ns. In case of iid != DELAY specifies the Poisson mean in number of packets packets. Default value: 9 packets (Range 0 to 4194288).
+        """
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mean: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Poisson mean value. In case of iid = DELAY specifies the Poisson mean. Unit is nanosecond (must be multiples of 100ns). Default value: 0 ns. In case of iid != DELAY specifies the Poisson mean in number of packets packets. Default value: 9 packets (Range 0 to 4194288).
+    class SetDataAttr(RequestBodyStruct):
+        mean: int = field(XmpLong())
+        """long, specifies the Poisson mean value. In case of iid = DELAY specifies the Poisson mean. Unit is nanosecond (must be multiples of 100ns).
+        Default value: 0 ns. In case of iid != DELAY specifies the Poisson mean in number of packets packets. Default value: 9 packets (Range 0 to 4194288).
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Poisson distribution.
 
         :return: the configuration of Poisson distribution
         :rtype: PED_POISSON.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, mean: int) -> "Token":
+    def set(self, mean: int) -> Token[None]:
         """Set the configuration of Poisson distribution.
 
         :param mean: specifies the Poisson mean value.
         :type mean: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], mean=mean))
 
 
 @register_command
 @dataclass
 class PED_GAMMA:
     """
     Configuration of Gamma distribution.
 
     .. note::
 
-        Mean and Standard deviation are calculated from Shape and Scale parameters and validation is performed using those. standard deviation = [SQRT(shape * scale * scale)]mean = [shape * scale].
+        Mean and Standard deviation are calculated from Shape and Scale parameters and validation is performed using those.
+        standard deviation = [SQRT(shape * scale * scale)]mean = [shape * scale].
 
-        In case of ``_impairment_type_xindex != DELAY``, (1) mean plus 4 times standard deviation should be less than or equal to max allowed(4194288). (2)shape and scale should be greater than or equal to 0.
+        In case of ``_impairment_type_xindex != DELAY``,
+        (1) mean plus 4 times standard deviation should be less than or equal to max allowed(4194288).
+        (2)shape and scale should be greater than or equal to 0.
 
         In case of ``_impairment_type_xindex = DELAY``, mean plus 4 times standard deviation should be less than or equal to the maximum latency.
 
     """
 
     code: typing.ClassVar[int] = 1630
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        shape: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long, specifies the shape. Units: none. Default value: 0.
-        scale: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Gamma function scale parameter. In case of iid = DELAY, units: nanosecond (must be multiples of 100 ns). Default value: 0 ns. In case of iid != DELAY, units: number of packets.Default value: 0 packets.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        shape: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long, specifies the shape. Units: none. Default value: 0.
-        scale: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the Gamma function scale parameter. In case of iid = DELAY, units: nanosecond (must be multiples of 100 ns). Default value: 0 ns. In case of iid != DELAY, units: number of packets.Default value: 0 packets.
+    class GetDataAttr(ResponseBodyStruct):
+        shape: int = field(XmpLong())
+        """long, specifies the shape. Units: none. Default value: 0."""
+        scale: int = field(XmpLong())
+        """long, specifies the Gamma function scale parameter. In case of iid = DELAY, units: nanosecond
+        (must be multiples of 100 ns). Default value: 0 ns. In case of iid != DELAY, units: number of packets.Default value: 0 packets.
+        """
+
+    class SetDataAttr(RequestBodyStruct):
+        shape: int = field(XmpLong())
+        """long, specifies the shape. Units: none. Default value: 0."""
+        scale: int = field(XmpLong())
+        """long, specifies the Gamma function scale parameter. In case of iid = DELAY, units: nanosecond (must be multiples of 100 ns). Default value: 0 ns.
+        In case of iid != DELAY, units: number of packets.Default value: 0 packets.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Gamma distribution.
 
         :return: the configuration of Gamma distribution
         :rtype: PED_GAMMA.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, shape: int, scale: int) -> "Token":
+    def set(self, shape: int, scale: int) -> Token[None]:
         """Set the configuration of Gamma distribution.
 
         :param shape: specifies the shape. Units: none. Default value: 0.
         :type shape: int
         :param scale: specifies the Gamma function scale parameter.
         :type scale: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], shape=shape, scale=scale),
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._flow_xindex, self._impairment_type_xindex],
+                shape=shape,
+                scale=scale
+            )
         )
 
 
 @register_command
 @dataclass
 class PED_CUST:
     """
     Associate a custom distribution to a flow and impairment type.
 
     .. note::
 
         Before associating a custom distribution, the below validation checks are applied.
 
-        In case of ``_impairment_type_xindex != DELAY``, (1) Custom values should be less than or equal to max allowed (4194288). (2) Custom distribution bust contain 512 values.
-
-        In case of ``_impairment_type_xindex = DELAY``, (1) Custom values should be less than or equal to the maximum latency. (2) Custom values should be greater than or equal to minimum latency. (3) Custom distribution should contain 1024 values.
+        In case of ``_impairment_type_xindex != DELAY``,
+        (1) Custom values should be less than or equal to max allowed (4194288).
+        (2) Custom distribution bust contain 512 values.
+
+        In case of ``_impairment_type_xindex = DELAY``,
+        (1) Custom values should be less than or equal to the maximum latency.
+        (2) Custom values should be greater than or equal to minimum latency.
+        (3) Custom distribution should contain 1024 values.
 
     """
 
     code: typing.ClassVar[int] = 1631
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        cust_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, custom distribution identifier.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        cust_id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, custom distribution identifier.
+    class GetDataAttr(ResponseBodyStruct):
+        cust_id: int = field(XmpInt())
+        """integer, custom distribution identifier."""
+
+    class SetDataAttr(RequestBodyStruct):
+        cust_id: int = field(XmpInt())
+        """integer, custom distribution identifier."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the custom distribution identifier that is associated to a flow and impairment type.
 
         :return: custom distribution identifier
         :rtype: PED_CUST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, cust_id: int) -> "Token":
+    def set(self, cust_id: int) -> Token[None]:
         """Associate a custom distribution to a flow and impairment type.
 
         :param cust_id: custom distribution identifier
         :type cust_id: int
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], cust_id=cust_id)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], cust_id=cust_id))
 
 
 @register_command
 @dataclass
 class PED_CONST:
     """
     Configuration of Constant Delay distribution (DELAY only). Unit is ns (must be
@@ -771,46 +841,44 @@
         If the latency is less than minimum latency, value is set to minimum latency. If the latency is greater than maximum latency, value is set to maximum latency.
 
     """
 
     code: typing.ClassVar[int] = 1640
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        delay: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the constant delay/latency time. Unit is nanosecond (must be multiples of 100 ns). Default value: Minimum supported per speed and FEC mode.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        delay: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the constant delay/latency time. Unit is nanosecond (must be multiples of 100 ns). Default value: Minimum supported per speed and FEC mode.
+    class GetDataAttr(ResponseBodyStruct):
+        delay: int = field(XmpLong())
+        """long, specifies the constant delay/latency time. Unit is nanosecond (must be multiples of 100 ns). Default value: Minimum supported per speed and FEC mode."""
+
+    class SetDataAttr(RequestBodyStruct):
+        delay: int = field(XmpLong())
+        """long, specifies the constant delay/latency time. Unit is nanosecond (must be multiples of 100 ns). Default value: Minimum supported per speed and FEC mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Constant Delay distribution (DELAY only).
 
         :return: the configuration of Constant Delay distribution (DELAY only)
         :rtype: PED_CONST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, delay: int) -> "Token":
+    def set(self, delay: int) -> Token[None]:
         """Set the configuration of Constant Delay distribution (DELAY only).
 
         :param delay: specifies the constant delay/latency time. Unit is nanosecond (must be multiples of 100 ns). Default value: Minimum supported per speed and FEC mode.
         :type delay: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], delay=delay))
 
 
 @register_command
 @dataclass
 class PED_ACCBURST:
     """
@@ -821,46 +889,44 @@
         If the delay is less than minimum latency, value is set to minimum latency. If the delay is greater than maximum latency, value is set to maximum latency.
 
     """
 
     code: typing.ClassVar[int] = 1641
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        delay: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the burst delay time. Units = nanosecond (must multiples of 100 ns). Default value: minimum latency.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        delay: XmpField[xt.XmpLong] = XmpField(
-            xt.XmpLong
-        )  # long, specifies the burst delay time. Units = nanosecond (must multiples of 100 ns). Default value: minimum latency.
+    class GetDataAttr(ResponseBodyStruct):
+        delay: int = field(XmpLong())
+        """long, specifies the burst delay time. Units = nanosecond (must multiples of 100 ns). Default value: minimum latency."""
+
+    class SetDataAttr(RequestBodyStruct):
+        delay: int = field(XmpLong())
+        """long, specifies the burst delay time. Units = nanosecond (must multiples of 100 ns). Default value: minimum latency."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Accumulate & Burst distribution (DELAY only).
 
         :return: the configuration of Accumulate & Burst distribution (DELAY only)
         :rtype: PED_ACCBURST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, delay: int) -> "Token":
+    def set(self, delay: int) -> Token[None]:
         """Set the configuration of Accumulate & Burst distribution (DELAY only).
 
         :param delay: specifies the burst delay time. Units = nanosecond (must multiples of 100 ns). Default value: minimum latency.
         :type delay: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], delay=delay))
 
 
 @register_command
 @dataclass
 class PED_STEP:
     """
@@ -871,52 +937,53 @@
         If the low/high is less than minimum latency, value is set to minimum latency. If the low/high is greater than maximum latency, value is set to maximum latency.
 
     """
 
     code: typing.ClassVar[int] = 1642
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        low: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long, specifies the packet delay in the 'low' state of the step. Units = nanosecond (must be multiples of 100 ns).
-        high: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long, specifies the packet delay in the 'high' state of the step. Units = nanosecond (must be multiples of 100 ns).
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        low: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long, specifies the packet delay in the 'low' state of the step. Units = nanosecond (must be multiples of 100 ns).
-        high: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long, specifies the packet delay in the 'high' state of the step. Units = nanosecond (must be multiples of 100 ns).
+    class GetDataAttr(ResponseBodyStruct):
+        low: int = field(XmpLong())
+        """long, specifies the packet delay in the 'low' state of the step. Units = nanosecond (must be multiples of 100 ns)."""
+        high: int = field(XmpLong())
+        """long, specifies the packet delay in the 'high' state of the step. Units = nanosecond (must be multiples of 100 ns)."""
+
+    class SetDataAttr(RequestBodyStruct):
+        low: int = field(XmpLong())
+        """long, specifies the packet delay in the 'low' state of the step. Units = nanosecond (must be multiples of 100 ns)."""
+        high: int = field(XmpLong())
+        """long, specifies the packet delay in the 'high' state of the step. Units = nanosecond (must be multiples of 100 ns)."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of Step distribution (DELAY only).
 
         :return: the configuration of Step distribution (DELAY only)
         :rtype: PED_STEP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, low: int, high: int) -> "Token":
+    def set(self, low: int, high: int) -> Token[None]:
         """Set the configuration of Step distribution (DELAY only).
 
         :param low: specifies the packet delay in the 'low' state of the step. Units = nanosecond (must be multiples of 100 ns).
         :type low: int
         :param high: specifies the packet delay in the 'high' state of the step. Units = nanosecond (must be multiples of 100 ns).
         :type high: int
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], low=low, high=high)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], low=low, high=high))
 
 
-# TODO: add descriptions
 @register_command
 @dataclass
 class PED_ENABLE:
     """
     Control whether this impairment distribution is enabled.
 
     .. note::
@@ -924,41 +991,44 @@
         This command is not applicable for PE_BANDPOLICER and PE_BANDSHAPER because they have a separate ``ON / OFF`` parameter.
 
     """
 
     code: typing.ClassVar[int] = 1644
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
     _impairment_type_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether impairment is enabled.
-
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifying whether impairment is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        action: OnOff = field(XmpByte())
+        """coded byte, specifying whether impairment is enabled."""
+
+    class SetDataAttr(RequestBodyStruct):
+        action: OnOff = field(XmpByte())
+        """coded byte, specifying whether impairment is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the status of this impairment distribution.
 
         :return: the status of this impairment distribution
         :rtype: PED_ENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex]))
 
-    def set(self, action: OnOff) -> "Token[GetDataAttr]":
+    def set(self, action: OnOff) -> Token[None]:
         """Set the status of this impairment distribution.
 
         :param action: the status of this impairment distribution
         :type action: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._impairment_type_xindex], action=action))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable impairment distribution"""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable impairment distribution"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pef_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pef_commands.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,104 +1,110 @@
-#: Impairment Port Filter Definition Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import ipaddress
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpIPv4Address,
+    XmpIPv6Address,
+    XmpSequence,
+    Hex,
+)
+from .enums import (
+    OnOff,
+    YesNo,
+    ProtocolOption,
+    FilterUse,
+    InfoAction,
+    L2PlusPresent,
+    L3PlusPresent,
+    FilterMode,
+    FilterType,
+    FilterVlanType,
+)
 
 
 @register_command
 @dataclass
 class PEF_INIT:
     """
     Prepares for setting up a filter definition.  When called, all filter
     definitions in the shadow-set which are not applied are discarded and replaced
     with the default values (DEFAULT).
 
     .. note::
 
         There are 2 register copies used to configure the filters:
 
-            (1) ``Shadow-copy (type value = 0)`` temporary copy configured by sever. Values stored in ``shadow-copy`` have no immediate effect on the flow filters. PEF_APPLY will pass the values from the ``shadow-copy`` to the ``working-copy``.
+            (1) ``Shadow-copy (type value = 0)`` temporary copy configured by sever.
+                Values stored in ``shadow-copy`` have no immediate effect on the flow filters. PEF_APPLY will pass the values from the ``shadow-copy`` to the ``working-copy``.
 
-            (2) ``Working-copy (type value = 1)`` reflects what is currently used for filtering in the FPGA. ``Working-copy`` cannot be written directly. Only ``shadow-copy`` allows direct write.
+            (2) ``Working-copy (type value = 1)`` reflects what is currently used for filtering in the FPGA.
+                ``Working-copy`` cannot be written directly. Only ``shadow-copy`` allows direct write.
 
             (3) All ``set`` actions are performed on ``shadow-copy`` ONLY.
 
             (4) Only when PEF_APPLY is called, ``working-copy`` and FPGA are updated with values from the ``shadow-copy``.
     """
 
     code: typing.ClassVar[int] = 1700
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Setting up a filter definition.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._flow_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PEF_APPLY:
     """
     Applies filter definitions from "shadow-copy" to "working-copy". This
     also pushes these settings to the FPGA.
     """
 
     code: typing.ClassVar[int] = 1701
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Applies filter definitions from "shadow-copy" to "working-copy"."""
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._flow_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PEF_ENABLE:
     """
     Defines if filtering is enabled for the flow.
@@ -108,47 +114,50 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1702
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the state of the filter.
+    class GetDataAttr(ResponseBodyStruct):
+        state: OnOff = field(XmpByte())
+        """coded byte, specifies the state of the filter."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the state of the filter.
+    class SetDataAttr(RequestBodyStruct):
+        state: OnOff = field(XmpByte())
+        """coded byte, specifies the state of the filter."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get if filtering is enabled for the flow.
 
         :return: filter state
         :rtype: PEF_ENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, state: OnOff) -> "Token":
+    def set(self, state: OnOff) -> Token[None]:
         """Set the filter state.
 
         :param state: state of the filter
         :type state: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], state=state))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Set the filter state to OFF.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Set the filter state to ON.
     """
 
 
 @register_command
 @dataclass
@@ -161,49 +170,51 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1703
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of Ethernet information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of Ethernet information.
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of Ethernet information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of Ethernet information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of Ethernet information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of Ethernet information.
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of Ethernet information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of Ethernet information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the filter action settings on Ethernet header.
 
         :return: Filter setting
         :rtype: PEF_ETHSETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set the filter action settings on Ethernet header.
 
         :param use: specifies if Ethernet information is expected
         :type use: FilterUse
         :param action: specifies the use of Ethernet information.
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_ETHSRCADDR:
     """
     Defines the Ethernet Source Address settings for the Ethernet filter.
@@ -213,56 +224,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1704
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of Ethernet Source Address information.
-        value: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000.
-        mask: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF.
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of Ethernet Source Address information."""
+        value: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000."""
+        mask: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of Ethernet Source Address information.
-        value: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000.
-        mask: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF.
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of Ethernet Source Address information."""
+        value: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000."""
+        mask: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Ethernet Source Address settings for the Ethernet filter.
 
         :return: the Ethernet Source Address settings for the Ethernet filter
         :rtype: PEF_ETHSRCADDR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: str, mask: str) -> "Token":
+    def set(self, use: OnOff, value: Hex, mask: Hex) -> Token[None]:
         """Set the Ethernet Source Address settings for the Ethernet filter.
 
         :param use: specifies the use of Ethernet Source Address information
         :type use: OnOff
         :param value: specifying the six bytes of the address. Default value: 0x000000000000.
-        :type value: str
+        :type value: Hex
         :param mask: specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF.
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Ethernet Source Address is not used for the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Ethernet Source Address is used for the filter."""
 
 
 @register_command
 @dataclass
 class PEF_ETHDESTADDR:
@@ -274,56 +290,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1705
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of Ethernet information
-        value: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000
-        mask: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of Ethernet information"""
+        value: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000"""
+        mask: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of Ethernet information
-        value: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000
-        mask: XmpField[xt.XmpHex6] = XmpField(xt.XmpHex6)  # six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of Ethernet information"""
+        value: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the six bytes of the address. Default value: 0x000000000000"""
+        mask: Hex = field(XmpHex(size=6))
+        """six hex bytes, specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Ethernet Destination Address settings for the Ethernet filter.
 
         :return: the Ethernet Destination Address settings for the Ethernet filter.
         :rtype: PEF_ETHDESTADDR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: str, mask: str) -> "Token":
+    def set(self, use: OnOff, value: Hex, mask: Hex) -> Token[None]:
         """Set the Ethernet Destination Address settings for the Ethernet filter.
 
         :param use: specifies the use of Ethernet Destination Address information
         :type use: OnOff
         :param value: specifying the six bytes of the address. Default value: 0x000000000000
-        :type value: str
+        :type value: Hex
         :param mask: specifying the mask corresponding to the address. Default value: 0xFFFFFFFFFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Ethernet Destination Address is not used for the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Ethernet Destination Address is used for the filter."""
 
 
 @register_command
 @dataclass
 class PEF_L2PUSE:
@@ -335,50 +356,55 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1706
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L2PlusPresent)  # coded byte, specifies the presence of Layer 2+ protocols.
+    class GetDataAttr(ResponseBodyStruct):
+        use: L2PlusPresent = field(XmpByte())
+        """coded byte, specifies the presence of Layer 2+ protocols."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L2PlusPresent)  # coded byte, specifies the presence of Layer 2+ protocols.
+    class SetDataAttr(RequestBodyStruct):
+        use: L2PlusPresent = field(XmpByte())
+        """coded byte, specifies the presence of Layer 2+ protocols."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Layer 2+ protocols settings for the filter.
 
         :return: the Layer 2+ protocols settings for the filter
         :rtype: PEF_L2PUSE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: L2PlusPresent) -> "Token":
+    def set(self, use: L2PlusPresent) -> Token[None]:
         """Set the Layer 2+ protocols settings for the filter.
 
         :param use:  specifies the presence of Layer 2+ protocols.
         :type use: L2PlusPresent
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use))
 
     set_na = functools.partialmethod(set, L2PlusPresent.NA)
     """Set the presence of Layer 2+ protocols to NA."""
+
     set_vlan1 = functools.partialmethod(set, L2PlusPresent.VLAN1)
     """Set the presence of Layer 2+ protocols to one VLAN Tag."""
+
     set_vlan2 = functools.partialmethod(set, L2PlusPresent.VLAN2)
     """Set the presence of Layer 2+ protocols to two VLAN Tags."""
+
     set_mpls = functools.partialmethod(set, L2PlusPresent.MPLS)
     """Set the presence of Layer 2+ protocols to MPLS."""
 
 
 @register_command
 @dataclass
 class PEF_VLANSETTINGS:
@@ -390,49 +416,51 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1707
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies if VLAN information is expected.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the use of VLAN information.
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies if VLAN information is expected."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the use of VLAN information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies if VLAN information is expected.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the use of VLAN information.
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies if VLAN information is expected."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the use of VLAN information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get filter action settings on VLAN header.
 
         :return: filter action settings on VLAN header
         :rtype: PEF_VLANSETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set filter action settings on VLAN header.
 
         :param use: specifies if VLAN information is expected
         :type use: FilterUse
         :param action: specifies the action of VLAN information
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_VLANTAG:
     """
     Basic mode only. Defines the VLAN TAG settings for the VLAN filter.
@@ -442,60 +470,62 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1708
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
-    vlan_type: FilterVlanType  # coded byte, the sub-index value specifies the VLAN type. VLAN1 (0) (INNER VLAN Tag is specified for the filter – used also when only 1 VLAN) indicates single/inner VLAN-TPID = 0x8100. VLAN2 (1) (OUTER VLAN Tag is specified for the filter) indicates outer VLAN-TPID=0x88A8
+    _filter_type: FilterType
+    _vlan_type: FilterVlanType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of VLAN information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # decimal digits, specifying the 12 bit value of the tag. Default value: 0.
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex digits, specifying the 12 bit value of the tag. Default value: 0x0FFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of VLAN information"""
+        value: int = field(XmpInt())
+        """decimal digits, specifying the 12 bit value of the tag. Default value: 0."""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex digits, specifying the 12 bit value of the tag. Default value: 0x0FFF"""
+
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of VLAN information"""
+        value: int = field(XmpInt())
+        """decimal digits, specifying the 12 bit value of the tag. Default value: 0."""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex digits, specifying the 12 bit value of the tag. Default value: 0x0FFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of VLAN information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # decimal digits, specifying the 12 bit value of the tag. Default value: 0.
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex digits, specifying the 12 bit value of the tag. Default value: 0x0FFF
-
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the VLAN TAG settings for the VLAN filter.
 
         :return: the VLAN TAG settings for the VLAN filter
         :rtype: PEF_VLANTAG.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self.vlan_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._vlan_type]))
+
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set the VLAN TAG settings for the VLAN filter.
 
         :param use: specifies the use of VLAN TAG information
         :type use: OnOff
         :param value: specifying the 12 bit value of the tag. Default value: 0.
         :type value: int
         :param mask: specifying the 12 bit value of the tag. Default value: 0x0FFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self.vlan_type], use=use, value=value, mask=mask
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._vlan_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """VLAN TAG is not used for the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """VLAN TAG is used for the filter."""
 
 
 @register_command
 @dataclass
 class PEF_VLANPCP:
@@ -507,109 +537,113 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1709
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
-    vlan_type: FilterVlanType  # coded byte, the sub-index value specifies the VLAN type. VLAN1 (0) (INNER VLAN Tag is specified for the filter – used also when only 1 VLAN) indicates single/inner VLAN-TPID = 0x8100. VLAN2 (1) (OUTER VLAN Tag is specified for the filter) indicates outer VLAN-TPID=0x88A8
-
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of VLAN information.
-        value: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, specifying the value of the PCP. Default value: 0 (Range: 0 to 7)
-        mask: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, specifying the 8 bit value mask. Default value: 0x07
+    _filter_type: FilterType
+    _vlan_type: FilterVlanType
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of VLAN information.
-        value: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, specifying the value of the PCP. Default value: 0 (Range: 0 to 7)
-        mask: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, specifying the 8 bit value mask. Default value: 0x07
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of VLAN information."""
+        value: int = field(XmpByte())
+        """byte, specifying the value of the PCP. Default value: 0 (Range: 0 to 7)"""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the 8 bit value mask. Default value: 0x07"""
+
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of VLAN information."""
+        value: int = field(XmpByte())
+        """byte, specifying the value of the PCP. Default value: 0 (Range: 0 to 7)"""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the 8 bit value mask. Default value: 0x07"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the VLAN PCP settings for the VLAN filter.
 
         :return: the VLAN PCP settings for the VLAN filter
         :rtype: PEF_VLANPCP.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self.vlan_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._vlan_type]))
+
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set the VLAN PCP settings for the VLAN filter.
 
         :param use: specifies the use of VLAN PCP information
         :type use: OnOff
         :param value: specifying the value of the PCP. Default value: 0 (Range: 0 to 7)
         :type value: int
         :param mask: specifying the 8 bit value mask. Default value: 0x07
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self.vlan_type], use=use, value=value, mask=mask
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._vlan_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """VLAN PCP is not used for the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """VLAN PCP is used for the filter."""
 
 
 @register_command
 @dataclass
 class PEF_MPLSSETTINGS:
     """
     Basic mode only. Defines what filter action is performed on the MPLS header.
     """
 
     code: typing.ClassVar[int] = 1710
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of MPLS information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action on MPLS information
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of MPLS information"""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action on MPLS information"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of MPLS information
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action on MPLS information
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of MPLS information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action on MPLS information"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the filter action settings on the MPLS header.
 
         :return: the filter action settings on the MPLS header
         :rtype: PEF_MPLSSETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set the filter action settings on the MPLS header.
 
         :param use: specifies the use of MPLS information
         :type use: FilterUse
         :param action: specifies specifies if MPLS information is expected
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_MPLSLABEL:
     """
     Basic mode only. Defines the MPLS label settings for the filter.
@@ -619,56 +653,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1711
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of MPLS information.
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the 20 bit value of the label. Default value: 0.
-        mask: XmpField[xt.XmpHex3] = XmpField(xt.XmpHex3)  # three hex bytes, specifying the 20 bit value of the label. Default value: 0x0FFFFF,
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of MPLS information."""
+        value: int = field(XmpInt())
+        """integer, specifying the 20 bit value of the label. Default value: 0."""
+        mask: Hex = field(XmpHex(size=3))
+        """three hex bytes, specifying the 20 bit value of the label. Default value: 0x0FFFFF,"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of MPLS information.
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, specifying the 20 bit value of the label. Default value: 0.
-        mask: XmpField[xt.XmpHex3] = XmpField(xt.XmpHex3)  # three hex bytes, specifying the 20 bit value of the label. Default value: 0x0FFFFF,
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of MPLS information."""
+        value: int = field(XmpInt())
+        """integer, specifying the 20 bit value of the label. Default value: 0."""
+        mask: Hex = field(XmpHex(size=3))
+        """three hex bytes, specifying the 20 bit value of the label. Default value: 0x0FFFFF,"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the MPLS label settings for the filter.
 
         :return: the MPLS label settings for the filter
         :rtype: PEF_MPLSLABEL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set the MPLS label settings for the filter.
 
         :param use: specifies the use of MPLS label information.
         :type use: OnOff
         :param value: specifying the 20-bit value of the label. Default value: 0.
         :type value: int
         :param mask: specifying the 20-bit value of the label. Default value: 0x0FFFFF,
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """The MPLS label is not used by the filter"""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """The MPLS label is used by the filter"""
 
 
 @register_command
 @dataclass
 class PEF_MPLSTOC:
@@ -680,56 +719,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1712
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of MPLS TOC information.
-        value: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, specifying the value of the MPLS TOC. Default value: 0 (Range: 0 to 7).
-        mask: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, specifying the filter mask for the value of the MPLS TOC. Default value: 0x07
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of MPLS TOC information."""
+        value: int = field(XmpByte())
+        """byte, specifying the value of the MPLS TOC. Default value: 0 (Range: 0 to 7)."""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the filter mask for the value of the MPLS TOC. Default value: 0x07"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of MPLS TOC information.
-        value: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, specifying the value of the MPLS TOC. Default value: 0 (Range: 0 to 7).
-        mask: XmpField[xt.XmpHex1] = XmpField(xt.XmpHex1)  # hex byte, specifying the filter mask for the value of the MPLS TOC. Default value: 0x07
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of MPLS TOC information."""
+        value: int = field(XmpByte())
+        """byte, specifying the value of the MPLS TOC. Default value: 0 (Range: 0 to 7)."""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the filter mask for the value of the MPLS TOC. Default value: 0x07"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the MPLS TOC settings for the filter.
 
         :return: the MPLS TOC settings for the filter
         :rtype: PEF_MPLSTOC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set the MPLS TOC settings for the filter.
 
         :param use: specifies the use of MPLS TOC information
         :type use: OnOff
         :param value: specifying the value of the MPLS TOC. Default value: 0 (Range: 0 to 7).
         :type value: int
         :param mask: specifying the filter mask for the value of the MPLS TOC. Default value: 0x07
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """The MPLS TOC is not used by the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """The MPLS TOC is used by the filter."""
 
 
 @register_command
 @dataclass
 class PEF_L3USE:
@@ -742,48 +786,52 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1713
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L3PlusPresent)  # coded byte, specifies the presence of Layer 3 protocols:
+    class GetDataAttr(ResponseBodyStruct):
+        use: L3PlusPresent = field(XmpByte())
+        """coded byte, specifies the presence of Layer 3 protocols:"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=L3PlusPresent)  # coded byte, specifies the presence of Layer 3 protocols:
+    class SetDataAttr(RequestBodyStruct):
+        use: L3PlusPresent = field(XmpByte())
+        """coded byte, specifies the presence of Layer 3 protocols:"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get Layer 3 protocols settings for the filter.
 
         :return: Layer 3 protocols settings for the filter.
         :rtype: PEF_L3USE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: L3PlusPresent) -> "Token":
+    def set(self, use: L3PlusPresent) -> Token[None]:
         """Set Layer 3 protocols settings for the filter.
 
         :param use: specifies the presence of Layer 3 protocols
         :type use: L3PlusPresent
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use))
 
     set_na = functools.partialmethod(set, L3PlusPresent.NA)
     """Set Layer 3 protocol presence to NA."""
+
     set_ip4 = functools.partialmethod(set, L3PlusPresent.IP4)
     """Set Layer 3 protocol presence to IPv4."""
+
     set_ip6 = functools.partialmethod(set, L3PlusPresent.IP6)
     """Set Layer 3 protocol presence to IPv6."""
 
 
 @register_command
 @dataclass
 class PEF_IPV4SETTINGS:
@@ -795,49 +843,51 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1714
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of IPv4 information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of IPv4 information.
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of IPv4 information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of IPv4 information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of IPv4 information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of IPv4 information.
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of IPv4 information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of IPv4 information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the filter action settings on IPv4 header.
 
         :return: the filter action settings on IPv4 header
         :rtype: PEF_IPV4SETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set the filter action settings on IPv4 header.
 
         :param use: specifies the use of IPv4 information
         :type use: FilterUse
         :param action: specifies the action of IPv4 information
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_IPV4SRCADDR:
     """
     Basic mode only. Defines the IPv4 Source Address settings for the IPv4 filter.
@@ -847,56 +897,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1715
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv4 Source Address.
-        value: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, specifying the four bytes of the address. Default value: 0.0.0.0
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv4 Source Address."""
+        value: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, specifying the four bytes of the address. Default value: 0.0.0.0"""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv4 Source Address.
-        value: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, specifying the four bytes of the address. Default value: 0.0.0.0
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv4 Source Address."""
+        value: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, specifying the four bytes of the address. Default value: 0.0.0.0"""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IPv4 Source Address settings for the IPv4 filter.
 
         :return: the IPv4 Source Address settings for the IPv4 filter
         :rtype: PEF_IPV4SRCADDR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: typing.Union[str, int, ipaddress.IPv4Address], mask: str) -> "Token":
+    def set(self, use: OnOff, value: ipaddress.IPv4Address, mask: Hex) -> Token[None]:
         """Set the IPv4 Source Address settings for the IPv4 filter.
 
         :param use: specifies the use of IPv4 Source Address information
         :type use: OnOff
         :param value: specifying the four bytes of the address. Default value: 0.0.0.0
-        :type value: typing.Union[str, int, ipaddress.IPv4Address]
+        :type value: ipaddress.IPv4Address
         :param mask: specifying the filter mask of the value. Default value: 0xFFFFFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """IPv4 Source Address is not used by the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """IPv4 Source Address is used by the filter."""
 
 
 @register_command
 @dataclass
 class PEF_IPV4DESTADDR:
@@ -908,56 +963,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1716
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv4 Destination Address.
-        value: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, specifying the four bytes of the address. Default value: 0.0.0.0
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv4 Destination Address."""
+        value: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, specifying the four bytes of the address. Default value: 0.0.0.0"""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv4 Destination Address.
-        value: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, specifying the four bytes of the address. Default value: 0.0.0.0
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv4 Destination Address."""
+        value: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, specifying the four bytes of the address. Default value: 0.0.0.0"""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, specifying the filter mask of the value. Default value: 0xFFFFFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IPv4 Destination Address settings for the IPv4 filter.
 
         :return: the IPv4 Destination Address settings for the IPv4 filter
         :rtype: PEF_IPV4DESTADDR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: typing.Union[str, int, ipaddress.IPv4Address], mask: str) -> "Token":
+    def set(self, use: OnOff, value: ipaddress.IPv4Address, mask: Hex) -> Token[None]:
         """Set the IPv4 Destination Address settings for the IPv4 filter.
 
         :param use: specifies the use of IPv4 Destination Address information
         :type use: OnOff
         :param value: specifying the four bytes of the address. Default value: 0.0.0.0
-        :type value: typing.Union[str, int, ipaddress.IPv4Address]
+        :type value: ipaddress.IPv4Address
         :param mask: specifying the filter mask of the value. Default value: 0xFFFFFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """IPv4 Destination Address is not used by the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """IPv4 Destination Address is used by the filter."""
 
 
 @register_command
 @dataclass
 class PEF_IPV4DSCP:
@@ -969,64 +1029,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1717
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
+
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv4 information."""
+        value: int = field(XmpByte())
+        """byte, specifying the value of the IPv4 DSCP/TOS in the upper 6 bits. value[7:2] = DSCP/TOS, value[1:0] = reserved (must be zero). Default value: 0"""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the filter mask of the value in the upper 6 bits. mask[7:2] = DSCP/TOS mask, mask[1:0] = reserved (must be zero). Default value: 0xFC"""
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv4 information.
-        value: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte
-        )  # byte, specifying the value of the IPv4 DSCP/TOS in the upper 6 bits. value[7:2] = DSCP/TOS, value[1:0] = reserved (must be zero). Default value: 0
-        mask: XmpField[xt.XmpHex1] = XmpField(
-            xt.XmpHex1
-        )  # hex byte, specifying the filter mask of the value in the upper 6 bits. mask[7:2] = DSCP/TOS mask, mask[1:0] = reserved (must be zero). Default value: 0xFC
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv4 information.
-        value: XmpField[xt.XmpByte] = XmpField(
-            xt.XmpByte
-        )  # byte, specifying the value of the IPv4 DSCP/TOS in the upper 6 bits. value[7:2] = DSCP/TOS, value[1:0] = reserved (must be zero). Default value: 0
-        mask: XmpField[xt.XmpHex1] = XmpField(
-            xt.XmpHex1
-        )  # hex byte, specifying the filter mask of the value in the upper 6 bits. mask[7:2] = DSCP/TOS mask, mask[1:0] = reserved (must be zero). Default value: 0xFC
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv4 information."""
+        value: int = field(XmpByte())
+        """byte, specifying the value of the IPv4 DSCP/TOS in the upper 6 bits. value[7:2] = DSCP/TOS, value[1:0] = reserved (must be zero). Default value: 0"""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the filter mask of the value in the upper 6 bits. mask[7:2] = DSCP/TOS mask, mask[1:0] = reserved (must be zero). Default value: 0xFC"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get IPv4 DSCP/TOS settings for the filter.
 
         :return: IPv4 DSCP/TOS settings for the filter.
         :rtype: PEF_IPV4DSCP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set IPv4 DSCP/TOS settings for the filter.
 
         :param use: specifies the use of IPv4 DSCP/TOS information.
         :type use: OnOff
         :param value: specifying the value of the IPv4 DSCP/TOS in the upper 6 bits. value[7:2] = DSCP/TOS, value[1:0] = reserved (must be zero). Default value: 0
         :type value: int
         :param mask: specifying the filter mask of the value in the upper 6 bits. mask[7:2] = DSCP/TOS mask, mask[1:0] = reserved (must be zero). Default value: 0xFC
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """IPv4 DSCP/TOS is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """IPv4 DSCP/TOS is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_IPV6SETTINGS:
@@ -1038,49 +1095,51 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1718
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of IPv6 information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of IPv6 information.
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of IPv6 information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of IPv6 information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of IPv6 information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of IPv6 information.
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of IPv6 information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of IPv6 information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get filter action settings on the IPv6 header.
 
         :return: specifies the use of IPv6 header
         :rtype: PEF_IPV6SETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set filter action settings on the IPv6 header.
 
         :param use: specifies the use of IPv6 header
         :type use: FilterUse
         :param action: specifies the action of IPv6 header
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_IPV6SRCADDR:
     """
     Basic mode only. Defines the IPv6 Source Address settings for the IPv6 filter.
@@ -1090,56 +1149,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1719
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv6 Source Address.
-        value: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000
-        mask: XmpField[xt.XmpHex16] = XmpField(xt.XmpHex16)  # 16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv6 Source Address."""
+        value: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000"""
+        mask: Hex = field(XmpHex(size=16))
+        """16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv6 Source Address.
-        value: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000
-        mask: XmpField[xt.XmpHex16] = XmpField(xt.XmpHex16)  # 16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv6 Source Address."""
+        value: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000"""
+        mask: Hex = field(XmpHex(size=16))
+        """16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IPv6 Source Address settings for the IPv6 filter.
 
         :return: the IPv6 Source Address settings for the IPv6 filter
         :rtype: PEF_IPV6SRCADDR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: str, mask: str) -> "Token":
+    def set(self, use: OnOff, value: ipaddress.IPv6Address, mask: Hex) -> Token[None]:
         """Set the IPv6 Source Address settings for the IPv6 filter.
 
         :param use: specifies the use of IPv6 Source Address information
         :type use: OnOff
         :param value: specifying the address. Default : 0x00000000000000000000000000000000
-        :type value: str
+        :type value: ipaddress.IPv6Address
         :param mask: specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """IPv6 Source Address is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """IPv6 Source Address is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_IPV6DESTADDR:
@@ -1151,56 +1215,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1720
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv6 Destination Address.
-        value: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000
-        mask: XmpField[xt.XmpHex16] = XmpField(xt.XmpHex16)  # 16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv6 Destination Address."""
+        value: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000"""
+        mask: Hex = field(XmpHex(size=16))
+        """16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv6 Destination Address.
-        value: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # 16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000
-        mask: XmpField[xt.XmpHex16] = XmpField(xt.XmpHex16)  # 16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv6 Destination Address."""
+        value: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """16 hex bytes, specifying the address. Default : 0x00000000000000000000000000000000"""
+        mask: Hex = field(XmpHex(size=16))
+        """16 hex bytes, specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IPv6 Destination Address settings for the IPv6 filter.
 
         :return: IPv6 Destination Address settings for the IPv6 filter
         :rtype: PEF_IPV6DESTADDR.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: str, mask: str) -> "Token":
+    def set(self, use: OnOff, value: ipaddress.IPv6Address, mask: Hex) -> Token[None]:
         """Set the IPv6 Destination Address settings for the IPv6 filter.
 
         :param use:  specifies the use of IPv6 Destination Address information
         :type use: OnOff
         :param value: specifying the address. Default : 0x00000000000000000000000000000000
-        :type value: str
+        :type value: ipaddress.IPv6Address
         :param mask: specifying the six first bytes of the address. Default value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """IPv6 Destination Address is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """IPv6 Destination Address is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_IPV6TC:
@@ -1212,64 +1281,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1721
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
+
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv6 information."""
+        value: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """byte, specifying the value of the IPv6 Traffic Class in the upper 6 bits. value[7:2] = IPv6 Traffic Class. value[1:0] = reserved (must be zero). Default value: 0"""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the filter mask for the value in the upper 6 bits. mask[7:2] = IPv6 Traffic Class mask. mask[1:0] = reserved (must be zero). Default value: 0xFC"""
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv6 information.
-        value: XmpField[xt.XmpIPV6Address] = XmpField(
-            xt.XmpIPV6Address
-        )  # byte, specifying the value of the IPv6 Traffic Class in the upper 6 bits. value[7:2] = IPv6 Traffic Class. value[1:0] = reserved (must be zero). Default value: 0
-        mask: XmpField[xt.XmpHex1] = XmpField(
-            xt.XmpHex1
-        )  # hex byte, specifying the filter mask for the value in the upper 6 bits. mask[7:2] = IPv6 Traffic Class mask. mask[1:0] = reserved (must be zero). Default value: 0xFC
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of IPv6 information.
-        value: XmpField[xt.XmpIPV6Address] = XmpField(
-            xt.XmpIPV6Address
-        )  # byte, specifying the value of the IPv6 Traffic Class in the upper 6 bits. value[7:2] = IPv6 Traffic Class. value[1:0] = reserved (must be zero). Default value: 0
-        mask: XmpField[xt.XmpHex1] = XmpField(
-            xt.XmpHex1
-        )  # hex byte, specifying the filter mask for the value in the upper 6 bits. mask[7:2] = IPv6 Traffic Class mask. mask[1:0] = reserved (must be zero). Default value: 0xFC
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of IPv6 information."""
+        value: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """byte, specifying the value of the IPv6 Traffic Class in the upper 6 bits. value[7:2] = IPv6 Traffic Class. value[1:0] = reserved (must be zero). Default value: 0"""
+        mask: Hex = field(XmpHex(size=1))
+        """hex byte, specifying the filter mask for the value in the upper 6 bits. mask[7:2] = IPv6 Traffic Class mask. mask[1:0] = reserved (must be zero). Default value: 0xFC"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get IPv6 Traffic Class settings used for the filter.
 
         :return: IPv6 Traffic Class settings used for the filter
         :rtype: PEF_IPV6TC.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: ipaddress.IPv6Address, mask: Hex) -> Token[None]:
         """Set IPv6 Traffic Class settings used for the filter.
 
         :param use: specifies the use of the IPv6 Traffic Class information.
         :type use: OnOff
         :param value: specifying the value of the IPv6 Traffic Class in the upper 6 bits. value[7:2] = IPv6 Traffic Class. value[1:0] = reserved (must be zero). Default value: 0
-        :type value: int
+        :type value: ipaddress.IPv6Address
         :param mask: specifying the filter mask for the value in the upper 6 bits. mask[7:2] = IPv6 Traffic Class mask. mask[1:0] = reserved (must be zero). Default value: 0xFC
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """IPv6 Traffic Class is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """IPv6 Traffic Class is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_UDPSETTINGS:
@@ -1281,49 +1347,51 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1722
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of UDP information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of UDP information.
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of UDP information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies action use of UDP information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of UDP information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies action use of UDP information.
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of UDP information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of UDP information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get filter settings on the UDP header.
 
         :return: filter action settings on the UDP header
         :rtype: PEF_UDPSETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set filter settings on the UDP header.
 
         :param use: specifies the use of UDP information.
         :type use: FilterUse
         :param action: specifies the action of UDP information.
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_UDPSRCPORT:
     """
     Basic mode only. Defines UDP Source Port settings used for the filter.
@@ -1333,56 +1401,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``
 
     """
 
     code: typing.ClassVar[int] = 1723
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of UDP Source Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the UDP Source Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of UDP Source Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the UDP Source Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of UDP Source Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the UDP Source Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of UDP Source Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the UDP Source Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get UDP Source Port settings used for the filter.
 
         :return: UDP Source Port settings used for the filter.
         :rtype: PEF_UDPSRCPORT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set UDP Source Port settings used for the filter.
 
         :param use: specifies the use of UDP Source Port information
         :type use: OnOff
         :param value: specifying the value of the UDP Source Port. Default value: 0
         :type value: int
         :param mask: specifying the filter mask for the value. Default value: 0xFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """UDP Source Port is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """UDP Source Port is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_UDPDESTPORT:
@@ -1393,56 +1466,61 @@
 
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
     """
 
     code: typing.ClassVar[int] = 1724
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of UDP Destination Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the UDP Destination Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of UDP Destination Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the UDP Destination Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of UDP Destination Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the UDP Destination Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of UDP Destination Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the UDP Destination Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get UDP Destination Port settings used for the filter.
 
         :return: UDP Destination Port settings used for the filter.
         :rtype: PEF_UDPDESTPORT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set UDP Destination Port settings used for the filter.
 
         :param use: specifies the use of UDP Destination Port information
         :type use: OnOff
         :param value: specifying the value of the UDP Destination Port. Default value: 0
         :type value: int
         :param mask: specifying the filter mask for the value. Default value: 0xFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """UDP Destination Port is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """UDP Destination Port is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_TCPSETTINGS:
@@ -1455,49 +1533,51 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
 
     """
 
     code: typing.ClassVar[int] = 1725
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of TCP information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of TCP information.
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of TCP information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of TCP information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of TCP information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of TCP information.
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of TCP information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of TCP information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get filter action settings on the TCP header.
 
         :return: filter action settings on the TCP header.
         :rtype: PEF_TCPSETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set filter action settings on the TCP header.
 
         :param use: specifies the use of TCP information.
         :type use: FilterUse
         :param action: specifies the action of TCP information.
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_TCPSRCPORT:
     """
     Basic mode only. Defines TCP Source Port settings used for the filter.
@@ -1507,56 +1587,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
 
     """
 
     code: typing.ClassVar[int] = 1726
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of TCP Source Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the TCP Source Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of TCP Source Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the TCP Source Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of TCP Source Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the TCP Source Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of TCP Source Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the TCP Source Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get TCP Source Port settings used for the filter.
 
         :return: TCP Source Port settings used for the filter.
         :rtype: PEF_TCPSRCPORT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set TCP Source Port settings used for the filter.
 
         :param use:  specifies the use of TCP Source Port information
         :type use: OnOff
         :param value: specifies the value of the TCP Source Port. Default value: 0
         :type value: int
         :param mask: specifies the filter mask for the value. Default value: 0xFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """TCP Source Port is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """TCP Source Port is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_TCPDESTPORT:
@@ -1568,56 +1653,61 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
 
     """
 
     code: typing.ClassVar[int] = 1727
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of TCP Destination Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the TCP Destination Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of TCP Destination Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the TCP Destination Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of TCP Destination Port information
-        value: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer , specifying the value of the TCP Destination Port. Default value: 0
-        mask: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of TCP Destination Port information"""
+        value: int = field(XmpInt())
+        """integer , specifying the value of the TCP Destination Port. Default value: 0"""
+        mask: Hex = field(XmpHex(size=2))
+        """two hex bytes , specifying the filter mask for the value. Default value: 0xFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get TCP Destination Port settings used for the filter.
 
         :return: TCP Destination Port settings used for the filter.
         :rtype: PEF_TCPDESTPORT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: OnOff, value: int, mask: str) -> "Token":
+    def set(self, use: OnOff, value: int, mask: Hex) -> Token[None]:
         """Set TCP Destination Port settings used for the filter.
 
         :param use: specifies the use of TCP Destination Port information
         :type use: OnOff
         :param value: specifies the value of the TCP Destination Port. Default value: 0
         :type value: int
         :param mask: specifies the filter mask for the value. Default value: 0xFFFF
-        :type mask: str
+        :type mask: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, value=value, mask=mask))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """TCP Destination Port is not used in the filter."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """TCP Destination Port is used in the filter."""
 
 
 @register_command
 @dataclass
 class PEF_ANYSETTINGS:
@@ -1629,49 +1719,51 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
 
     """
 
     code: typing.ClassVar[int] = 1728
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of ANY field information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of ANY field information.
+    class GetDataAttr(ResponseBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of ANY field information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of ANY field information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterUse)  # coded byte, specifies the use of ANY field information.
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of ANY field information.
+    class SetDataAttr(RequestBodyStruct):
+        use: FilterUse = field(XmpByte())
+        """coded byte, specifies the use of ANY field information."""
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of ANY field information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the settings of filtering state on ANY field in a packet.
 
         :return: settings of filtering state on ANY field in a packet.
         :rtype: PEF_ANYSETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, use: FilterUse, action: InfoAction) -> "Token":
+    def set(self, use: FilterUse, action: InfoAction) -> Token[None]:
         """Set the settings of filtering state on ANY field in a packet.
 
         :param use: specifies the use of ANY field information.
         :type use: FilterUse
         :param action:  specifies the action of ANY field information.
         :type action: InfoAction
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], use=use, action=action))
 
 
 @register_command
 @dataclass
 class PEF_ANYCONFIG:
     """
     Basic mode only. Defines the ANY field filter configuration. The "ANY field"
@@ -1684,54 +1776,57 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
 
     """
 
     code: typing.ClassVar[int] = 1729
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        position: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, specifies the start position of the ANY field. Default value: 0, Range:0-127
-        value: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # 8 hex bytes, specifying the six bytes of the field. Default value: 0x000000000000
-        mask: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # 8 hex bytes, specifying the six bytes of the field. Default value: 0xFFFFFFFFFFFF
+    class GetDataAttr(ResponseBodyStruct):
+        position: int = field(XmpByte())
+        """byte, specifies the start position of the ANY field. Default value: 0, Range:0-127"""
+        value: Hex = field(XmpHex(size=6))
+        """6 hex bytes, specifying the six bytes of the field. Default value: 0x000000000000"""
+        mask: Hex = field(XmpHex(size=6))
+        """6 hex bytes, specifying the six bytes of the field. Default value: 0xFFFFFFFFFFFF"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        position: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, specifies the start position of the ANY field. Default value: 0, Range:0-127
-        value: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # 8 hex bytes, specifying the six bytes of the field. Default value: 0x000000000000
-        mask: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # 8 hex bytes, specifying the six bytes of the field. Default value: 0xFFFFFFFFFFFF
+    class SetDataAttr(RequestBodyStruct):
+        position: int = field(XmpByte())
+        """byte, specifies the start position of the ANY field. Default value: 0, Range:0-127"""
+        value: Hex = field(XmpHex(size=6))
+        """6 hex bytes, specifying the six bytes of the field. Default value: 0x000000000000"""
+        mask: Hex = field(XmpHex(size=6))
+        """6 hex bytes, specifying the six bytes of the field. Default value: 0xFFFFFFFFFFFF"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the ANY field filter configuration.
 
         :return: the ANY field filter configuration
         :rtype: PEF_ANYCONFIG.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, position: int, value: str, mask: str) -> "Token":
+    def set(self, position: int, value: Hex, mask: Hex) -> Token[None]:
         """Set the ANY field filter configuration
 
         :param position: specifies the start position of the ANY field. Default value: 0, Range:0-127
         :type position: int
         :param value: specifying the six bytes of the field. Default value: 0x000000000000
         :type value: str
         :param mask: specifying the six bytes of the field. Default value: 0xFFFFFFFFFFFF
         :type mask: str
         """
-        return Token(
-            self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], position=position, value=value, mask=mask),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], position=position, value=value, mask=mask))
 
 
 @register_command
 @dataclass
 class PEF_TPLDSETTINGS:
     """
     Defines if filtering on TPLD field in a packet is used for flow filtering. The
@@ -1744,44 +1839,44 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
 
     """
 
     code: typing.ClassVar[int] = 1730
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of TPLD information.
+    class GetDataAttr(ResponseBodyStruct):
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of TPLD information."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        action: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=InfoAction)  # coded byte, specifies the action of TPLD information.
+    class SetDataAttr(RequestBodyStruct):
+        action: InfoAction = field(XmpByte())
+        """coded byte, specifies the action of TPLD information."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the settings of filtering on TPLD field in a packet.
 
         :return: the settings of filtering on TPLD field in a packet.
         :rtype: PEF_TPLDSETTINGS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, action: InfoAction) -> "Token":
+    def set(self, action: InfoAction) -> Token[None]:
         """Set the settings of filtering on TPLD field in a packet.
 
-        :param use: specifies the use of TPLD information.
-        :type use: FilterUse
         :param action: specifies the action of TPLD information.
         :type action: InfoAction
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], action=action))
 
 
 @register_command
 @dataclass
 class PEF_TPLDCONFIG:
     """
@@ -1792,120 +1887,119 @@
         For SET, the only allowed ``_filter_type`` is ``shadow-copy``.
 
     """
 
     code: typing.ClassVar[int] = 1731
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
-    _test_payload_filter_index: int  # integer, the sub-index value which indicates the tpld filter index (range 0 to 15)
+    _filter_type: FilterType
+    _test_payload_filter_index: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of TPLD field information.
-        id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # int, specifies the TPLD ID. Range: 0-2015, Default value: 0
+    class GetDataAttr(ResponseBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of TPLD field information."""
+        id: int = field(XmpInt())
+        """int, specifies the TPLD ID. Range: 0-2015, Default value: 0"""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        use: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, specifies the use of TPLD field information.
-        id: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # int, specifies the TPLD ID. Range: 0-2015, Default value: 0
+    class SetDataAttr(RequestBodyStruct):
+        use: OnOff = field(XmpByte())
+        """coded byte, specifies the use of TPLD field information."""
+        id: int = field(XmpInt())
+        """int, specifies the TPLD ID. Range: 0-2015, Default value: 0"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the TPLD filter configuration.
 
         :return: the use of TPLD field information, and the TPLD ID. Range: 0-2015, Default value: 0
         :rtype: PEF_TPLDCONFIG.GetDataAttr
         """
-        return Token(
-            self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._test_payload_filter_index])
-        )
 
-    def set(self, use: OnOff, id: int) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._test_payload_filter_index]))
+
+    def set(self, use: OnOff, id: int) -> Token[None]:
         """Set the TPLD filter configuration.
 
         :param use: specifies the use of TPLD field information
         :type use: OnOff
         :param id: specifies the TPLD ID. Range: 0-2015, Default value: 0
         :type id: int
         """
-        return Token(
-            self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._test_payload_filter_index], use=use, id=id),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._test_payload_filter_index], use=use, id=id))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """The TPLD information is not used."""
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """The TPLD information is used."""
 
 
 @register_command
 @dataclass
 class PEF_ISSHADOWDIRTY:
     """
     Get shadow filter status (if shadow is in sync with working copy or not).
     """
 
     code: typing.ClassVar[int] = 1734
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        is_in_sync: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=YesNo)  # coded byte, if shadow is in sync with working copy or not.
+    class GetDataAttr(ResponseBodyStruct):
+        is_in_sync: YesNo = field(XmpByte())
+        """coded byte, if shadow is in sync with working copy or not."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get shadow filter status.
 
         :return: if shadow is in sync with working copy or not.
         :rtype: PEF_ISSHADOWDIRTY.GetDataAttr
         """
-        return Token(
-            self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex])
-        )
+
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PEF_CANCEL:
     """Undo updates to shadow filter settings, sets dirty false."""
 
     code: typing.ClassVar[int] = 1735
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Undo updates to shadow filter settings, sets dirty false.
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex]))
 
 
 @register_command
 @dataclass
 class PEF_VALUE:
     """
-    This command is valid only for ``Extended filter mode`` (check PEF_MODE).
+    This command is valid only for ``Extended filter mode`` (check :class:`PEF_MODE`).
 
-    Defines the byte values that can be matched if selected by PEF_MASK.
+    Defines the byte values that can be matched if selected by :class:`PEF_MASK`.
 
     If ``<protocol_segment_index> = 0`` the maximum number of match value
     bytes that can be set is determined by the total length of the protocol segments
     specified with PEF_PROTOCOL.
 
     E.g. if PEF_PROTOCOL is set to ETHERNET then only
     12 bytes can be set. In order to set the full 128 bytes, either specify a
@@ -1919,214 +2013,204 @@
 
     The ``get`` command always returns the number of bytes specified by the protocol segment.
     """
 
     code: typing.ClassVar[int] = 1777
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
-    _protocol_segment_index: int  # integer, if 0, the server receives/sends the value of all protocol segments when called. If > 0, the server receives/sends only the indicated index protocol segment.
+    _filter_type: FilterType
+    _protocol_segment_index: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        value: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the raw bytes comprising the packet header.
+    class GetDataAttr(ResponseBodyStruct):
+        value: Hex = field(XmpHex())
+        """list of hex bytes, the raw bytes comprising the packet header."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        value: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the raw bytes comprising the packet header.
+    class SetDataAttr(RequestBodyStruct):
+        value: Hex = field(XmpHex())
+        """list of hex bytes, the raw bytes comprising the packet header."""
 
-    def get(self) -> "Token[GetDataAttr]":
-        """Get the byte values that can be matched if selected by PEF_MASK.
+    def get(self) -> Token[GetDataAttr]:
+        """Get the byte values that can be matched if selected by :class:`PEF_MASK`.
 
-        :return: the byte values that can be matched if selected by PEF_MASK
+        :return: the byte values that can be matched if selected by :class:`PEF_MASK`
         :rtype: PEF_VALUE.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._protocol_segment_index]))
 
-    def set(self, value: str) -> "Token":
-        """Set the byte values that can be matched if selected by PEF_MASK.
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
+
+    def set(self, value: Hex) -> Token[None]:
+        """Set the byte values that can be matched if selected by :class:`PEF_MASK`.
 
         :param value: the raw bytes comprising the packet header
-        :type value: str
+        :type value: Hex
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._flow_xindex, self._filter_type, self._protocol_segment_index],
-                value=value
-            )
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], value=value))
 
 
 @register_command
 @dataclass
 class PEF_MASK:
     """
-    This command is valid only for ``Extended filter mode`` (check PEF_MODE`).
+    This command is valid only for ``Extended filter mode`` (check :class:`PEF_MODE`).
 
-    Defines the mask byte values that select the values specified by PEF_VALUE`.
+    Defines the mask byte values that select the values specified by :class:`PEF_VALUE`.
 
     For a chosen ``<protocol_segment_index>`` the first byte in the value masks the
-    first byte of the corresponding PEF_VALUE and so on.
+    first byte of the corresponding :class:`PEF_VALUE` and so on.
 
     If ``<protocol_segment_index> = 0`` the maximum number of match value
     bytes that can be set is determined by the total length of the protocol segments
     specified with PEF_PROTOCOL`.
 
     E.g. if PEF_PROTOCOL is set to ETHERNET then only
     12 bytes can be set. In order to set the full 128 bytes, either specify a
     detailed protocol segment list, or use the raw protocol segment type. This specifies 12 + 116 = 128 bytes.
 
     If ``<protocol_segment_index> != 0`` only the bytes covered by that segment are manipulated,
     so if PEF_PROTOCOL is set to ``ETHERNET VLAN ETHERTYPE eCPRI`` then ``<protocol_segment_index> = 4`` selects the 8
     bytes of the eCPRI header starting at byte position (12 + 2 + 4) = 18.
 
-    ``get/set`` semantics are similar to PEF_VALUE.
+    ``get/set`` semantics are similar to :class:`PEF_VALUE`.
     """
 
     code: typing.ClassVar[int] = 1778
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
-    _protocol_segment_index: int  # integer, if 0, the server receives/sends the value of all protocol segments when called. If > 0, the server receives/sends only the indicated index protocol segment.
+    _filter_type: FilterType
+    _protocol_segment_index: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        masks: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  #
+    class GetDataAttr(ResponseBodyStruct):
+        masks: Hex = field(XmpHex())
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        masks: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  #
+    class SetDataAttr(RequestBodyStruct):
+        masks: Hex = field(XmpHex())
 
-    def get(self) -> "Token[GetDataAttr]":
-        """Get the mask byte values that select the values specified by PEF_VALUE.
+    def get(self) -> Token[GetDataAttr]:
+        """Get the mask byte values that select the values specified by :class:`PEF_VALUE`.
 
-        :return: the mask byte values that select the values specified by PEF_VALUE.
+        :return: the mask byte values that select the values specified by :class:`PEF_VALUE`.
         :rtype: PEF_MASK.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type, self._protocol_segment_index]))
 
-    def set(self, masks: str) -> "Token":
-        """Set the mask byte values that select the values specified by PEF_VALUE`.
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
+
+    def set(self, masks: Hex) -> Token[None]:
+        """Set the mask byte values that select the values specified by :class:`PEF_VALUE``.
 
         :param masks: mask byte values
-        :type masks: str
+        :type masks: Hex
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._flow_xindex, self._filter_type, self._protocol_segment_index],
-                masks=masks
-            )
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], masks=masks))
 
 
 @register_command
 @dataclass
 class PEF_PROTOCOL:
     """
-    This command is valid only for ``Extended filter mode`` (check `PEF_MODE`_).
+    This command is valid only for ``Extended filter mode`` (check :class:`PEF_MODE`).
 
     Defines the sequence of protocol segments that can be
     matched. The total length of the specified segments cannot exceed 128 bytes. If
     an existing sequence of segments is changed (using PEF_PROTOCOL) the underlying
     value and mask bytes remain unchanged, even though the semantics of those bytes
     may have changed. However, if the total length, in bytes, of the segments is
     reduced, then the excess bytes of value and mask are set to zero. I.e. to update
     an existing filter, you must first correct the list of segments (using
-    PEF_PROTOCOL) and subsequently update the filtering value (using `PEF_VALUE`_) and filtering mask (`PEF_MASK`_).
+    PEF_PROTOCOL) and subsequently update the filtering value (using :class:`PEF_VALUE`) and filtering mask (:class:`PEF_MASK`).
     """
 
     code: typing.ClassVar[int] = 1779
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        segment_list: XmpField[xt.XmpByteList] = XmpField(
-            xt.XmpByteList, choices=ProtocolOption
-        )  # list of bytes, specifying the list of protocol segment types in the order they are expected in a frame. First segment type must be ETHERNET; the following can be chosen freely.
+    class GetDataAttr(ResponseBodyStruct):
+        segment_list: typing.List[ProtocolOption] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of bytes, specifying the list of protocol segment types in the order they are expected in a frame. First segment type must be ETHERNET;
+        the following can be chosen freely.
+        """
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        segment_list: XmpField[xt.XmpByteList] = XmpField(
-            xt.XmpByteList, choices=ProtocolOption
-        )  # list of bytes, specifying the list of protocol segment types in the order they are expected in a frame. First segment type must be ETHERNET; the following can be chosen freely.
+    class SetDataAttr(RequestBodyStruct):
+        segment_list: typing.List[ProtocolOption] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of bytes, specifying the list of protocol segment types in the order they are expected in a frame. First segment type must be ETHERNET;
+        the following can be chosen freely.
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the sequence of protocol segments that can be matched.
 
         :return: the sequence of protocol segments that can be matched.
         :rtype: PEF_PROTOCOL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, segment_list: typing.List[ProtocolOption]) -> "Token":
+    def set(self, segment_list: typing.List[ProtocolOption]) -> Token[None]:
         """Set the sequence of protocol segments that can be matched.
 
-        :param segment_list: specifying the list of protocol segment types in the order they are expected in a frame. First segment type must be ``ETHERNET``; the following can be chosen freely.
+        :param segment_list: specifying the list of protocol segment types in the order they are expected in a frame.
+            First segment type must be ``ETHERNET``; the following can be chosen freely.
         :type segment_list: typing.List[ProtocolOption]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], segment_list=segment_list))
 
 
 @register_command
 @dataclass
 class PEF_MODE:
     """Control the filter mode."""
 
     code: typing.ClassVar[int] = 1780
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _flow_xindex: int
-    _filter_type: FilterType  # integer, the sub-index value which indicates the filter type - “shadow-copy”(0) or “working-copy”(1).
+    _filter_type: FilterType
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterMode)  # integer, the mode of the filter.
+    class GetDataAttr(ResponseBodyStruct):
+        mode: FilterMode = field(XmpByte())
+        """integer, the mode of the filter."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mode: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=FilterMode)  # integer, the mode of the filter.
+    class SetDataAttr(RequestBodyStruct):
+        mode: FilterMode = field(XmpByte())
+        """integer, the mode of the filter."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the filter mode.
 
         :return: the filter mode
         :rtype: PEF_MODE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type]))
 
-    def set(self, mode: FilterMode) -> "Token":
+    def set(self, mode: FilterMode) -> Token[None]:
         """Set the filter mode.
 
         :param mode: the mode of the filter.
         :type sid: FlowMode
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._flow_xindex, self._filter_type], mode=mode))
 
     set_basic = functools.partialmethod(set, FilterMode.BASIC)
     """Set the filter mode to Basic."""
+
     set_extended = functools.partialmethod(set, FilterMode.EXTENDED)
     """Set the filter mode to Extended."""
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pf_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pf_commands.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,23 +1,29 @@
-#: L23 Port Filter Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpInt,
+    XmpSequence,
+    XmpStr
+)
+from .enums import OnOff
 
 
 @register_command
 @dataclass
 class PF_INDICES:
     """
     The full list of which filters are defined for a port. These are the sub-index
@@ -28,152 +34,141 @@
     same can be accomplished one-filter-at-a-time using the PF_CREATE and PF_DELETE
     commands.
     """
 
     code: typing.ClassVar[int] = 211
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        filter_xindices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the list of indices of filters on a port.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        filter_xindices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the list of indices of filters on a port.
+    class GetDataAttr(ResponseBodyStruct):
+        filter_xindices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the list of indices of filters on a port."""
+
+    class SetDataAttr(RequestBodyStruct):
+        filter_xindices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the list of indices of filters on a port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the full list of which filters are defined for a port.
 
         :return: the list of indices of filters on a port
         :rtype: PF_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, filter_xindices: typing.List[int]) -> "Token":
+    def set(self, filter_xindices: typing.List[int]) -> Token[None]:
         """Create a new empty filter for each index value that is not already in use, and deletes each filter that is not mentioned in the list.
 
         :param filter_xindices: the list of indices of filters to be created on a port.
-        :type filter_xindices: List[int]
+        :type filter_xindices: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, filter_xindices=filter_xindices))
 
 
 @register_command
 @dataclass
 class PF_CREATE:
     """
     Creates an empty filter definition with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 212
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _filter_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Creates an empty filter definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._filter_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._filter_xindex]))
 
 
 @register_command
 @dataclass
 class PF_DELETE:
     """
     Deletes the filter definition with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 213
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _filter_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Delete the filter definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._filter_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._filter_xindex]))
 
 
 @register_command
 @dataclass
 class PF_ENABLE:
     """
     Whether a filter is currently active on a port. While a filter is enabled its
     condition cannot be changed, nor can any match term or length terms used by it.
     """
 
     code: typing.ClassVar[int] = 214
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _filter_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the filter is enabled.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether the filter is enabled.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the filter is enabled."""
+
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether the filter is enabled."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether a filter is currently active on the port.
 
         :return: whether the filter is enabled
         :rtype: PF_ENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._filter_xindex]))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether a filter is currently active on the port.
 
         :param on_off: whether the filter is enabled
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._filter_xindex], on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable a filter on a port.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable a filter on a port.
     """
 
 
 @register_command
 @dataclass
@@ -181,41 +176,43 @@
     """
     The description of a filter.
     """
 
     code: typing.ClassVar[int] = 215
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _filter_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the description of the filter.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the description of the filter.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the description of the filter."""
+
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, the description of the filter."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the description of a filter.
 
         :return: the description of the filter
         :rtype: PF_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._filter_xindex]))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the description of a filter.
 
         :param comment: the description of the filter.
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._filter_xindex], comment=comment))
 
 
 @register_command
 @dataclass
 class PF_CONDITION:
     """
@@ -258,47 +255,58 @@
         which supports Boolean expressions using the operators ``&, |, and ~``, and simply query the chassis for the resulting script-level definition.
 
     """
 
     code: typing.ClassVar[int] = 216
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _filter_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        and_expression_0: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
-        and_not_expression_0: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms.
-        and_expression_1: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
-        and_not_expression_1: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms.
-        and_expression_2: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
-        and_expression_3: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        and_expression_0: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
-        and_not_expression_0: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms.
-        and_expression_1: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
-        and_not_expression_1: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms.
-        and_expression_2: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
-        and_expression_3: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # unsigned integer, encoding a compound term which is a set of the match terms AND length terms.
+    class GetDataAttr(ResponseBodyStruct):
+        and_expression_0: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
+        and_not_expression_0: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms."""
+        and_expression_1: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
+        and_not_expression_1: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms."""
+        and_expression_2: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
+        and_expression_3: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
+
+    class SetDataAttr(RequestBodyStruct):
+        and_expression_0: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
+        and_not_expression_0: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms."""
+        and_expression_1: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
+        and_not_expression_1: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match NOT terms AND length NOT terms."""
+        and_expression_2: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
+        and_expression_3: int = field(XmpInt())
+        """unsigned integer, encoding a compound term which is a set of the match terms AND length terms."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the condition on the terms specifying when the filter is satisfied.
 
         :return: and_expression_0, and_not_expression_0, and_expression_1, and_not_expression_1, and_expression_2, and and_expression_3.
 
         :rtype: ~PF_CONDITION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._filter_xindex]))
 
-    def set(self, and_expression_0: int, and_not_expression_0: int, and_expression_1: int, and_not_expression_1: int, and_expression_2: int, and_expression_3: int) -> "Token":
+    def set(self, and_expression_0: int, and_not_expression_0: int, and_expression_1: int, and_not_expression_1: int, and_expression_2: int, and_expression_3: int) -> Token[None]:
         """Set the condition on the terms specifying when the filter is satisfied.
 
         :param and_expression_0: encoding a compound term which is a set of the match terms AND length terms.
         :type and_expression_0: int
         :param and_not_expression_0: encoding a compound term which is a set of the match NOT terms AND length NOT terms.
         :type and_not_expression_0: int
         :param and_expression_1: encoding a compound term which is a set of the match terms AND length terms.
@@ -307,14 +315,15 @@
         :type and_not_expression_1: int
         :param and_expression_2: encoding a compound term which is a set of the match terms AND length terms.
         :type and_expression_2: int
         :param and_expression_3: encoding a compound term which is a set of the match terms AND length terms.
         :type and_expression_3: int
 
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._filter_xindex],
@@ -334,35 +343,37 @@
     """
     The string representation of a filter.
     """
 
     code: typing.ClassVar[int] = 217
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _filter_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        string_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the string representation of the filter.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        string_name: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, the string representation of the filter.
+    class GetDataAttr(ResponseBodyStruct):
+        string_name: str = field(XmpStr())
+        """string, the string representation of the filter."""
+
+    class SetDataAttr(RequestBodyStruct):
+        string_name: str = field(XmpStr())
+        """string, the string representation of the filter."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the string representation of a filter.
 
         :return: the string representation of a filter
         :rtype: ~PF_STRING.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._filter_xindex]))
 
-    def set(self, string_name: str) -> "Token":
+    def set(self, string_name: str) -> Token[None]:
         """Set the string representation of a filter.
 
         :param string_name: the string representation of the filter
         :type string_name: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._filter_xindex], string_name=string_name))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pl_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pl_commands.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,27 @@
-#: L23 Port Length Term Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpInt,
+    XmpSequence,
+)
+from .enums import LengthCheckType
 
 
 @register_command
 @dataclass
 class PL_INDICES:
     """
     The full list of which length terms are defined for a port. These are the sub-
@@ -27,157 +31,148 @@
     each length term that is not mentioned in the list. The same can be accomplished
     one- length-term-at-a-time using the PL_CREATE and PL_DELETE commands.
     """
 
     code: typing.ClassVar[int] = 207
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        length_term_xindices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the sub-index of a length term definition for the port.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        length_term_xindices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the sub-index of a length term definition for the port.
+    class GetDataAttr(ResponseBodyStruct):
+        length_term_xindices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the sub-index of a length term definition for the port."""
+
+    class SetDataAttr(RequestBodyStruct):
+        length_term_xindices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the sub-index of a length term definition for the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the full list of which length terms are defined for a port.
 
         :return: the full list of which length terms are defined for a port
         :rtype: PL_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, length_term_xindices: typing.List[int]) -> "Token":
+    def set(self, length_term_xindices: typing.List[int]) -> Token[None]:
         """Create a new empty length term for each value that is not already in use, and deletes each length term that is not mentioned in the list.
 
         :param length_term_xindices: the list of indices of length terms to be created on a port.
-        :type length_term_xindices: List[int]
+        :type length_term_xindices: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, length_term_xindices=length_term_xindices))
 
 
 @register_command
 @dataclass
 class PL_CREATE:
     """
     Creates an empty length term definition with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 208
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _length_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Creates an empty length term definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._length_term_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._length_term_xindex]))
 
 
 @register_command
 @dataclass
 class PL_DELETE:
     """
     Deletes the length term definition with the specified sub-index value. A length
     term cannot be deleted while it is used in the condition of any filter for the
     port.
     """
 
     code: typing.ClassVar[int] = 209
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _length_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Deletes the length term definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._length_term_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._length_term_xindex]))
 
 
 @register_command
 @dataclass
 class PL_LENGTH:
     """
     The specification for a length-based check that is applied on the packets
     received on the port.
     """
 
     code: typing.ClassVar[int] = 210
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _length_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        length_check_type: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=LengthCheckType)  # coded integer, whether to test for shorter-than or longer-than.
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the value to compare the packet length against.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        length_check_type: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=LengthCheckType)  # coded integer, whether to test for shorter-than or longer-than.
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the value to compare the packet length against.
+    class GetDataAttr(ResponseBodyStruct):
+        length_check_type: LengthCheckType = field(XmpInt())
+        """coded integer, whether to test for shorter-than or longer-than."""
+        size: int = field(XmpInt())
+        """integer, the value to compare the packet length against."""
+
+    class SetDataAttr(RequestBodyStruct):
+        length_check_type: LengthCheckType = field(XmpInt())
+        """coded integer, whether to test for shorter-than or longer-than."""
+        size: int = field(XmpInt())
+        """integer, the value to compare the packet length against."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the configuration of a length-based check that is applied on the packets received on a port.
 
         :return: whether to test for shorter-than or longer-than, and the value to compare the packet length against
         :rtype: PL_LENGTH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._length_term_xindex]))
 
-    def set(self, length_check_type: LengthCheckType, size: int) -> "Token":
+    def set(self, length_check_type: LengthCheckType, size: int) -> Token[None]:
         """Set the configuration of a length-based check that is applied on the packets received on a port.
 
         :param length_check_type: whether to test for shorter-than or longer-than
         :type length_check_type: LengthCheckType
         :param size: the value to compare the packet length against
         :type size: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._length_term_xindex], length_check_type=length_check_type, size=size),
+            build_set_request(self, module=self._module, port=self._port, indices=[self._length_term_xindex], length_check_type=length_check_type, size=size)
         )
 
     set_at_most = functools.partialmethod(set, LengthCheckType.AT_MOST)
     """Set the length check to be short than or equal to the given length (at most).
     """
+
     set_at_least = functools.partialmethod(set, LengthCheckType.AT_LEAST)
     """Set the length check to be longer than or equal to the given length (at least).
     """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/pm_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/pm_commands.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,22 +1,29 @@
-#: L23 Port Match Term Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpSequence,
+    Hex,
+)
+from .enums import ProtocolOption
 
 
 @register_command
 @dataclass
 class PM_INDICES:
     """
     The full list of which match terms are defined for a port. These are the sub-
@@ -26,109 +33,95 @@
     deletes each match term that is not mentioned in the list. The same can be
     accomplished one match-term-at-a-time using the PM_CREATE and PM_DELETE commands.
     """
 
     code: typing.ClassVar[int] = 200
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        match_term_xindices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the sub-index of a match term definition for the port.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        match_term_xindices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the sub-index of a match term definition for the port.
+    class GetDataAttr(ResponseBodyStruct):
+        match_term_xindices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the sub-index of a match term definition for the port."""
+
+    class SetDataAttr(RequestBodyStruct):
+        match_term_xindices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the sub-index of a match term definition for the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the full list of which match terms are defined for a port.
 
         :return: the full list of which match terms are defined for a port
         :rtype: PM_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, match_term_xindices: typing.List[int]) -> "Token":
+    def set(self, match_term_xindices: typing.List[int]) -> Token[None]:
         """Creates a new empty match term for each value that is not already in use, and delete each match term that is not mentioned in the list
 
         :param match_term_xindices: the sub-index of a match term definition for the port
-        :type match_term_xindices: List[int]
+        :type match_term_xindices: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, match_term_xindices=match_term_xindices))
 
 
 @register_command
 @dataclass
 class PM_CREATE:
     """
     Creates an empty match term definition with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 201
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _match_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Creates an empty match term definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._match_term_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex]))
 
 
 @register_command
 @dataclass
 class PM_DELETE:
     """
     Deletes the match term definition with the specified sub-index value. A match
     term cannot be deleted while it is used in the condition of any filter for the
     port.
     """
 
     code: typing.ClassVar[int] = 202
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _match_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Deletes the match term definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._match_term_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex]))
 
 
 @register_command
 @dataclass
 class PM_PROTOCOL:
     """
     The protocol segments assumed on the packets received on the port. This is
@@ -136,124 +129,128 @@
     packet header is being matched. The actual value definition of the match
     position is specified with PM_POSITION.
     """
 
     code: typing.ClassVar[int] = 203
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _match_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        segments: XmpField[xt.XmpByteList] = XmpField(
-            xt.XmpByteList, choices=ProtocolOption
-        )  # list of coded bytes, a number specifying a built-in protocol segment: Uses the same coded values as the PS_HEADERPROTOCOL parameter.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        segments: XmpField[xt.XmpByteList] = XmpField(
-            xt.XmpByteList, choices=ProtocolOption
-        )  # list of coded bytes, a number specifying a built-in protocol segment: Uses the same coded values as the PS_HEADERPROTOCOL parameter.
+    class GetDataAttr(ResponseBodyStruct):
+        segments: typing.List[ProtocolOption] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of coded bytes, a number specifying a built-in protocol segment: Uses the same coded values as the PS_HEADERPROTOCOL parameter."""
+
+    class SetDataAttr(RequestBodyStruct):
+        segments: typing.List[ProtocolOption] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of coded bytes, a number specifying a built-in protocol segment: Uses the same coded values as the PS_HEADERPROTOCOL parameter."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the protocol segments assumed on the packets received on the port.
 
         :return: a number specifying a built-in protocol segment: Uses the same coded values as the PS_HEADERPROTOCOL parameter.
         :rtype: PM_PROTOCOL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex]))
 
-    def set(self, segments: typing.List[ProtocolOption]) -> "Token":
+    def set(self, segments: typing.List[ProtocolOption]) -> Token[None]:
         """Set the protocol segments assumed on the packets received on the port.
 
         :param segments: a number specifying a built-in protocol segment: Uses the same coded values as the PS_HEADERPROTOCOL parameter
-        :type segments: List[ProtocolOption]
+        :type segments: typing.List[ProtocolOption]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex], segments=segments))
 
 
 @register_command
 @dataclass
 class PM_POSITION:
     """
     The position within each received packet where content matching begins for the port.
     """
 
     code: typing.ClassVar[int] = 204
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _match_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        byte_offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, offset from the start of the packet bytes.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        byte_offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, offset from the start of the packet bytes.
+    class GetDataAttr(ResponseBodyStruct):
+        byte_offset: int = field(XmpInt())
+        """integer, offset from the start of the packet bytes."""
+
+    class SetDataAttr(RequestBodyStruct):
+        byte_offset: int = field(XmpInt())
+        """integer, offset from the start of the packet bytes."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the position within each received packet where content matching begins for the port.
 
         :return: offset from the start of the packet bytes
         :rtype: PM_POSITION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex]))
 
-    def set(self, byte_offset: int) -> "Token":
+    def set(self, byte_offset: int) -> Token[None]:
         """Set the position within each received packet where content matching begins for the port.
 
         :param byte_offset: offset from the start of the packet bytes
         :type byte_offset: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex], byte_offset=byte_offset))
 
 
 @register_command
 @dataclass
 class PM_MATCH:
     """
     The value that must be found at the match term position for packets received on
     the port. The mask can make certain bit positions don't-care.
     """
 
     code: typing.ClassVar[int] = 205
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _match_term_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        mask: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # eight hex bytes, which bits are significant in the match operation.
-        value: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # eight hex bytes, the value that must be found for the match term to be true.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mask: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # eight hex bytes, which bits are significant in the match operation.
-        value: XmpField[xt.XmpHex8] = XmpField(xt.XmpHex8)  # eight hex bytes, the value that must be found for the match term to be true.
+    class GetDataAttr(ResponseBodyStruct):
+        mask: Hex = field(XmpHex(size=8))
+        """eight hex bytes, which bits are significant in the match operation."""
+        value: Hex = field(XmpHex(size=8))
+        """eight hex bytes, the value that must be found for the match term to be true."""
+
+    class SetDataAttr(RequestBodyStruct):
+        mask: Hex = field(XmpHex(size=8))
+        """eight hex bytes, which bits are significant in the match operation."""
+        value: Hex = field(XmpHex(size=8))
+        """eight hex bytes, the value that must be found for the match term to be true."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the value that must be found at the match term position for packets received on the port.
 
         :return: which bits are significant in the match operation, and the value that must be found for the match term to be true.
         :rtype: PM_MATCH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex]))
 
-    def set(self, mask: str, value: str) -> "Token":
+    def set(self, mask: Hex, value: Hex) -> Token[None]:
         """Set the value that must be found at the match term position for packets received on the port.
 
         :param mask: which bits are significant in the match operation
-        :type mask: str
+        :type mask: Hex
         :param value: the value that must be found for the match term to be true
-        :type value: str
+        :type value: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._match_term_xindex], mask=mask, value=value))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/ps_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/ps_commands.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,134 +1,140 @@
-#: L23 Port Stream Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import ipaddress
 import typing
 import functools
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpInt,
+    XmpIPv4Address,
+    XmpIPv6Address,
+    XmpLong,
+    XmpMacAddress,
+    XmpSequence,
+    XmpStr,
+    Hex,
+)
+from .enums import (
+    OnOff,
+    OnOffWithSuppress,
+    ProtocolOption,
+    ModifierAction,
+    LengthType,
+    PayloadType,
+    PFCMode,
+)
 
 
 @register_command
 @dataclass
 class PS_INDICES:
     """
     The full list of which streams are defined for a port. These are the sub-index
     values that are used for the parameters defining the traffic patterns
     transmitted for the port. Setting the value of this command creates a new
     empty stream for each value that is not already in use, and deletes each stream
     that is not mentioned in the list. The same can be accomplished one-stream-at-a-
-    time using the `PS_CREATE`_ and `PS_DELETE`_ commands.
+    time using the :class:`PS_CREATE` and :class:`PS_DELETE` commands.
     """
 
     code: typing.ClassVar[int] = 150
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        stream_indices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the sub-indices of streams on the port.
+    class GetDataAttr(ResponseBodyStruct):
+        stream_indices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the sub-indices of streams on the port."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        stream_indices: XmpField[xt.XmpIntList] = XmpField(xt.XmpIntList)  # list of integers, the sub-indices of streams on the port.
+    class SetDataAttr(RequestBodyStruct):
+        stream_indices: typing.List[int] = field(XmpSequence(types_chunk=[XmpInt()]))
+        """list of integers, the sub-indices of streams on the port."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the full list of which streams are defined for a port.
 
         :return: the sub-indices of streams on the port
         :rtype: PS_INDICES.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
 
-    def set(self, stream_indices: typing.List[int]) -> "Token":
+    def set(self, stream_indices: typing.List[int]) -> Token[None]:
         """Creates a new empty stream for each value that is not already in use, and deletes each stream that is not mentioned in the list.
 
         :param stream_indices: the sub-indices of streams on the port
-        :type stream_indices: List[int]
+        :type stream_indices: typing.List[int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, stream_indices=stream_indices))
 
 
 @register_command
 @dataclass
 class PS_CREATE:
     """
     Creates an empty stream definition with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 151
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Creates an empty stream definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._stream_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_DELETE:
     """
     Deletes the stream definition with the specified sub-index value.
     """
 
     code: typing.ClassVar[int] = 152
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Deletes the stream definition with the specified sub-index value.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._stream_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_ENABLE:
     """
     This property determines if a stream contributes outgoing packets for a port.
@@ -137,52 +143,56 @@
     traffic is enabled. The sum of the rates of all enabled or suppressed streams
     must not exceed the effective port rate.
     """
 
     code: typing.ClassVar[int] = 153
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOffWithSuppress)  # coded byte, specifying a stream state.
+    class GetDataAttr(ResponseBodyStruct):
+        state: OnOffWithSuppress = field(XmpByte())
+        """coded byte, specifying a stream state."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        state: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOffWithSuppress)  # coded byte, specifying a stream state.
+    class SetDataAttr(RequestBodyStruct):
+        state: OnOffWithSuppress = field(XmpByte())
+        """coded byte, specifying a stream state."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the stream status.
 
         :return: status of the stream
         :rtype: PS_ENABLE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, state: OnOffWithSuppress) -> "Token":
+    def set(self, state: OnOffWithSuppress) -> Token[None]:
         """Set the stream status. The value can be toggled between ON and SUPPRESS while traffic is enabled at the
         port level. Streams in the OFF state cannot be set to any other value while
         traffic is enabled. The sum of the rates of all enabled or suppressed streams
         must not exceed the effective port rate.
 
         :param state: a stream state
         :type state: OnOffWithSuppress
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], state=state))
 
     set_off = functools.partialmethod(set, OnOffWithSuppress.OFF)
     """Set the stream status to OFF.
     """
+
     set_on = functools.partialmethod(set, OnOffWithSuppress.ON)
     """Set the stream status to ON.
     """
+
     set_suppress = functools.partialmethod(set, OnOffWithSuppress.SUPPRESS)
     """Set the stream status to SUPPRESS.
     """
 
 
 @register_command
 @dataclass
@@ -196,89 +206,93 @@
     stream. The minimum value is 1. The port will transmit continuously until the
     user stops the traffic.
     """
 
     code: typing.ClassVar[int] = 154
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        packet_count: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the number of packets that the port will send. When Port TX Mode is set to NORMAL, STRICT UNIFORM or BURST: 0 or -1 (disable packet limitation). When Port TX Mode is set to SEQUENTIAL: 1 or larger (minimum value since the port transmits at least 1 packet per stream per round).
+    class GetDataAttr(ResponseBodyStruct):
+        packet_count: int = field(XmpInt())
+        """integer, the number of packets that the port will send. When Port TX Mode is set to NORMAL, STRICT UNIFORM or BURST: 0 or -1 (disable packet limitation).
+        When Port TX Mode is set to SEQUENTIAL: 1 or larger (minimum value since the port transmits at least 1 packet per stream per round).
+        """
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        packet_count: XmpField[xt.XmpInt] = XmpField(
-            xt.XmpInt
-        )  # integer, the number of packets that the port will send. When Port TX Mode is set to NORMAL, STRICT UNIFORM or BURST: 0 or -1 (disable packet limitation). When Port TX Mode is set to SEQUENTIAL: 1 or larger (minimum value since the port transmits at least 1 packet per stream per round).
+    class SetDataAttr(RequestBodyStruct):
+        packet_count: int = field(XmpInt())
+        """integer, the number of packets that the port will send. When Port TX Mode is set to NORMAL, STRICT UNIFORM or BURST: 0 or -1 (disable packet limitation).
+        When Port TX Mode is set to SEQUENTIAL: 1 or larger (minimum value since the port transmits at least 1 packet per stream per round).
+        """
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """If Port TX Mode is NORMAL, STRICT UNIFORM or BURST: get the number of packets that will be transmitted when traffic is started on a port.
         If Port TX Mode is SEQUENTIAL: get the number of sequential packets sent before switching to the next stream.
 
         :return: the number of packets
         :rtype: PS_PACKETLIMIT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, packet_count: int) -> "Token":
+    def set(self, packet_count: int) -> Token[None]:
         """If Port TX Mode is NORMAL, STRICT UNIFORM or BURST: set the number of packets that will be transmitted when traffic is started on a port,
         0 or -1 (disable packet limitation).
         If Port TX Mode is SEQUENTIAL: set the number of sequential packets sent before switching to the next stream,
         1 or larger (minimum value since the port transmits at least 1 packet per stream per round).
 
         :param packet_count:  the number of packets
         :type packet_count: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], packet_count=packet_count))
 
 
 @register_command
 @dataclass
 class PS_COMMENT:
     """
     The description of a stream.
     """
 
     code: typing.ClassVar[int] = 155
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, specifying the description of the stream.
+    class GetDataAttr(ResponseBodyStruct):
+        comment: str = field(XmpStr())
+        """string, specifying the description of the stream."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        comment: XmpField[xt.XmpStr] = XmpField(xt.XmpStr)  # string, specifying the description of the stream.
+    class SetDataAttr(RequestBodyStruct):
+        comment: str = field(XmpStr())
+        """string, specifying the description of the stream."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the description of a stream.
 
         :return: the description of the stream
         :rtype: PS_COMMENT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, comment: str) -> "Token":
+    def set(self, comment: str) -> Token[None]:
         """Set the description of a stream.
 
         :param comment: the description of the stream
         :type comment: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], comment=comment))
 
 
 @register_command
 @dataclass
 class PS_TPLDID:
     """
@@ -293,130 +307,140 @@
     inter-chassis mechanism, the test payload identifier assignments should be
     planned globally across all the chassis and ports of the testbed.
     """
 
     code: typing.ClassVar[int] = 157
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        test_payload_identifier: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the test payload identifier value. -1 = disable test payloads.
+    class GetDataAttr(ResponseBodyStruct):
+        test_payload_identifier: int = field(XmpInt())
+        """integer, the test payload identifier value. -1 = disable test payloads."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        test_payload_identifier: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the test payload identifier value. -1 = disable test payloads.
+    class SetDataAttr(RequestBodyStruct):
+        test_payload_identifier: int = field(XmpInt())
+        """integer, the test payload identifier value. -1 = disable test payloads."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the identifier of the test payloads inserted into packets transmitted for a stream.
 
         :return: the test payload identifier value. -1 = disable test payloads.
         :rtype: PS_TPLDID.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, test_payload_identifier: int) -> "Token":
+    def set(self, test_payload_identifier: int) -> Token[None]:
         """Set the identifier of the test payloads inserted into packets transmitted for a stream.
         A value of -1 disables test payloads for the stream. Test payloads are
         inserted at the end of each packet, and contains time-stamp and sequence-number
         information.
 
         :param test_payload_identifier: the test payload identifier value. -1 = disable test payloads
         :type test_payload_identifier: int
         """
+
         return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], test_payload_identifier=test_payload_identifier)
+            self._connection,
+            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], test_payload_identifier=test_payload_identifier)
         )
 
 
 @register_command
 @dataclass
 class PS_INSERTFCS:
     """
     Whether a valid frame checksum is added to the packets of a stream.
     """
 
     code: typing.ClassVar[int] = 158
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether frame checksums are inserted.
+    class GetDataAttr(ResponseBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether frame checksums are inserted."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        on_off: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=OnOff)  # coded byte, whether frame checksums are inserted.
+    class SetDataAttr(RequestBodyStruct):
+        on_off: OnOff = field(XmpByte())
+        """coded byte, whether frame checksums are inserted."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get whether a valid frame checksum is added to the packets of a stream.
 
         :return: whether frame checksums are inserted
         :rtype: PS_INSERTFCS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, on_off: OnOff) -> "Token":
+    def set(self, on_off: OnOff) -> Token[None]:
         """Set whether a valid frame checksum is added to the packets of a stream.
 
         :param on_off: whether frame checksums are inserted
         :type on_off: OnOff
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], on_off=on_off))
 
     set_off = functools.partialmethod(set, OnOff.OFF)
     """Disable a valid frame checksum to be added to the packets of a stream.
     """
+
     set_on = functools.partialmethod(set, OnOff.ON)
     """Enable a valid frame checksum to be added to the packets of a stream.
     """
 
 
 @register_command
 @dataclass
 class PS_AUTOADJUST:
     """
-    .. versionadded:: 1.1
-    
+    .. versionadded:: v2.0
+
     Executing PS_AUTOADJUST will adjust the packet length distribution (:class:`PS_PACKETLENGTH`) of the stream:
-    
+
         (1) Set the type of packet length distribution (:class:`PS_PACKETLENGTH` ``<length_type>``) to ``FIXED``.
-    
-        (2) Set the lower limit on the packet length (:class:`PS_PACKETLENGTH` ``<min_val>``) to exactly fit the specified protocol headers, TPLD and FCS (but never set to less than 64).
 
-        (3) Set the payload type of packets transmitted for the stream (:class:`PS_PAYLOAD` ``<payload_type>``) to ``PATTERN``. 
-    
-        (4) If necessary, also set the maximum number of header content bytes (`P_MAXHEADERLENGTH <p_maxheaderlength_label>` ``<max_header_length>``) that can be freely specified for each generated stream of the port to a higher value, if needed to accommodate the header size of the stream (implicitly given by the `PS_PACKETHEADER` command).
+        (2) Set the lower limit on the packet length (:class:`PS_PACKETLENGTH` ``<min_val>``) to exactly fit the specified protocol headers,
+        TPLD and FCS (but never set to less than 64).
+
+        (3) Set the payload type of packets transmitted for the stream (:class:`PS_PAYLOAD` ``<payload_type>``) to ``PATTERN``.
+
+        (4) If necessary, also set the maximum number of header content bytes (`P_MAXHEADERLENGTH <p_maxheaderlength_label>` ``<max_header_length>``)
+        that can be freely specified for each generated stream of the port to a higher value, if needed to accommodate the header size of the stream
+        (implicitly given by the `PS_PACKETHEADER` command).
 
-        (5) If the needed maximum header length (`P_MAXHEADERLENGTH <p_maxheaderlength_label>` ``<max_header_length>``) is not possible with the actual number of active streams for the port, the command will fail with :`<BADVALUE>`.
+        (5) If the needed maximum header length (`P_MAXHEADERLENGTH <p_maxheaderlength_label>` ``<max_header_length>``)
+        is not possible with the actual number of active streams for the port, the command will fail with :`<BADVALUE>`.
     """
 
     code: typing.ClassVar[int] = 159
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Adjust the packet length distribution of a stream.
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_ARPREQUEST:
     """
@@ -430,37 +454,38 @@
     reply is received on the test port. If no reply is received within 500
     milliseconds, it returns.
     """
 
     code: typing.ClassVar[int] = 161
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        mac_address: XmpField[xt.XmpMacAddress] = XmpField(xt.XmpMacAddress)  # six hex bytes, specifying the six bytes of the MAC address.
+    class GetDataAttr(ResponseBodyStruct):
+        mac_address: Hex = field(XmpMacAddress())
+        """six hex bytes, specifying the six bytes of the MAC address."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Generates an outgoing ARP request on the test port. The packet header for the
         stream must contain an IP protocol segment, and the destination IP address is
         used in the ARP request. If there is a gateway IP address specified for the port
         and it is on a different subnet than the destination IP address in the packet
         header, then the gateway IP address is used instead. The framing of the ARP
         request matches the packet header, including any VLAN protocol segments. This
         command does not generate an immediate result, but waits until an ARP
         reply is received on the test port. If no reply is received within 500
         milliseconds, it returns.
 
         :return: the MAC address of the peer port
         :rtype: PS_ARPREQUEST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_PINGREQUEST:
     """
@@ -472,36 +497,38 @@
     PS_ARPREQUEST. This command does not generate an immediate result, but
     waits until a ping reply is received on the test port.
     """
 
     code: typing.ClassVar[int] = 162
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        delay: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of milliseconds for the ping reply to arrive.
-        time_to_live: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, the time-to-live value in the ping reply packet.
+    class GetDataAttr(ResponseBodyStruct):
+        delay: int = field(XmpInt())
+        """integer, the number of milliseconds for the ping reply to arrive."""
+        time_to_live: int = field(XmpByte())
+        """byte, the time-to-live value in the ping reply packet."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Generates an outgoing ping request using the ICMP protocol on the test port. The
         packet header for the stream must contain an IP protocol segment, with valid
         source and destination IP addresses. The framing of the ping request matches the
         packet header, including any VLAN protocol segments, and the destination MAC
         address must also be valid, possibly containing a value obtained with
         PS_ARPREQUEST. This command does not generate an immediate result, but
         waits until a ping reply is received on the test port.
 
         :return: the number of milliseconds for the ping reply to arrive, and the time-to-live value in the ping reply packet.
         :rtype: PS_PINGREQUEST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_MODIFIEREXTRANGE:
     """
@@ -514,61 +541,67 @@
     will begin with the max value instead of the min value and decrement from there:
     {max, max-1, max-2, ...., min, max, max-1...}.
     """
 
     code: typing.ClassVar[int] = 167
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
-    modifier_xindex: int
-
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        min_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minimum modifier value.
-        step: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the increment between modifier values.
-        max_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the maximum modifier value.
+    _modifier_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        min_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minimum modifier value.
-        step: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the increment between modifier values.
-        max_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the maximum modifier value.
+    class GetDataAttr(ResponseBodyStruct):
+        min_val: int = field(XmpInt())
+        """integer, the minimum modifier value."""
+        step: int = field(XmpInt())
+        """integer, the increment between modifier values."""
+        max_val: int = field(XmpInt())
+        """integer, the maximum modifier value."""
+
+    class SetDataAttr(RequestBodyStruct):
+        min_val: int = field(XmpInt())
+        """integer, the minimum modifier value."""
+        step: int = field(XmpInt())
+        """integer, the increment between modifier values."""
+        max_val: int = field(XmpInt())
+        """integer, the maximum modifier value."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the range specification for an extended packet modifier for a stream header,
         specifying which values the modifier should take on.
 
         :return: the minimum modifier value, the increment between modifier values, the maximum modifier value.
         :rtype: PS_MODIFIEREXTRANGE.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self.modifier_xindex]))
 
-    def set(self, min_val: int, step: int, max_val: int) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._modifier_xindex]))
+
+    def set(self, min_val: int, step: int, max_val: int) -> Token[None]:
         """Set the range specification for an extended packet modifier for a stream header,
         specifying which values the modifier should take on. This applies only to
         incrementing and decrementing modifiers; random modifiers always produce every
         possible bit pattern. The range is specified as a three values: mix, step, and
         max, where max must be equal to min plus a multiple of step. Note that when
         "decrement" is specified in PS_MODIFIEREXT as the action, the value sequence
         will begin with the max value instead of the min value and decrement from there:
-        {max, max-1, max-2, ...., min, max, max-1...}.vv
+        {max, max-1, max-2, ...., min, max, max-1...}.
 
         :param min_val: the minimum modifier value
         :type min_val: int
         :param step: the increment between modifier values
         :type step: int
         :param max_val: the maximum modifier value
         :type max_val: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self.modifier_xindex], min_val=min_val, step=step, max_val=max_val),
+            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._modifier_xindex], min_val=min_val, step=step, max_val=max_val)
         )
 
 
 @register_command
 @dataclass
 class PS_MODIFIERRANGE:
     """
@@ -581,42 +614,46 @@
     max value instead of the min value and decrement from there: {max, max-1, max-2,
     ...., min, max, max-1...}.
     """
 
     code: typing.ClassVar[int] = 168
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
-    modifier_xindex: int
-
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        min_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minimum modifier value.
-        step: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the increment between modifier values.
-        max_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the maximum modifier value.
+    _modifier_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        min_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the minimum modifier value.
-        step: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the increment between modifier values.
-        max_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the maximum modifier value.
+    class GetDataAttr(ResponseBodyStruct):
+        min_val: int = field(XmpInt())
+        """integer, the minimum modifier value."""
+        step: int = field(XmpInt())
+        """integer, the increment between modifier values."""
+        max_val: int = field(XmpInt())
+        """integer, the maximum modifier value."""
+
+    class SetDataAttr(RequestBodyStruct):
+        min_val: int = field(XmpInt())
+        """integer, the minimum modifier value."""
+        step: int = field(XmpInt())
+        """integer, the increment between modifier values."""
+        max_val: int = field(XmpInt())
+        """integer, the maximum modifier value."""
 
-    def get(self) -> "Token[GetDataAttr]":
-        """Get the range specification for a packet modifier for a stream header, specifying which
-        values the modifier should take on.
+    def get(self) -> Token[GetDataAttr]:
+        """Get the range specification for a packet modifier for a stream header, specifying which values the modifier should take on.
 
         :return: the minimum modifier value, the increment between modifier values, the maximum modifier value.
         :rtype: PS_MODIFIERRANGE.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self.modifier_xindex]))
 
-    def set(self, min_val: int, step: int, max_val: int) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._modifier_xindex]))
+
+    def set(self, min_val: int, step: int, max_val: int) -> Token[None]:
         """Set the range specification for a packet modifier for a stream header, specifying which
         values the modifier should take on. This applies only to incrementing and
         decrementing modifiers; random modifiers always produce every possible bit
         pattern. The range is specified as three values: mix, step, and max, where max
         must be equal to min plus a multiple of step. Note that when "decrement" is
         specified in PS_MODIFIER as the action, the value sequence will begin with the
         max value instead of the min value and decrement from there: {max, max-1, max-2,
@@ -625,17 +662,18 @@
         :param min_val: the minimum modifier value
         :type min_val: int
         :param step: the increment between modifier values
         :type step: int
         :param max_val: the maximum modifier value
         :type max_val: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self.modifier_xindex], min_val=min_val, step=step, max_val=max_val),
+            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._modifier_xindex], min_val=min_val, step=step, max_val=max_val)
         )
 
 
 @register_command
 @dataclass
 class PS_RATEFRACTION:
     """
@@ -648,49 +686,51 @@
     stream rates. Get value is only valid if the rate was last set using this
     command.
     """
 
     code: typing.ClassVar[int] = 169
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        stream_rate_ppm: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, stream rate expressed as a ppm value between 0 and 1,000,000.
+    class GetDataAttr(ResponseBodyStruct):
+        stream_rate_ppm: int = field(XmpInt())
+        """integer, stream rate expressed as a ppm value between 0 and 1,000,000."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        stream_rate_ppm: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, stream rate expressed as a ppm value between 0 and 1,000,000.
+    class SetDataAttr(RequestBodyStruct):
+        stream_rate_ppm: int = field(XmpInt())
+        """integer, stream rate expressed as a ppm value between 0 and 1,000,000."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the rate of the traffic transmitted for a stream expressed in millionths of the
         effective rate for the port. Get value is only valid if the rate was last set using this
         command.
 
         :return: stream rate expressed as a ppm value between 0 and 1,000,000
         :rtype: PS_RATEFRACTION.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, stream_rate_ppm: int) -> "Token":
+    def set(self, stream_rate_ppm: int) -> Token[None]:
         """Set the rate of the traffic transmitted for a stream expressed in millionths of the
         effective rate for the port. The bandwidth consumption includes the inter-frame
         gap and is independent of the length of the packets generated for the stream.
         The sum of the bandwidth consumption for all the enabled streams must not exceed
         the effective rate for the port. Setting this command also instructs the
         Manager to attempt to keep the rate-percentage unchanged in case it has to cap
         stream rates.
 
         :param stream_rate_ppm: stream rate expressed as a ppm value between 0 and 1,000,000.
         :type stream_rate_ppm: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], stream_rate_ppm=stream_rate_ppm))
 
 
 @register_command
 @dataclass
 class PS_RATEPPS:
     """
@@ -703,49 +743,51 @@
     cap stream rates. Get value is only valid if the rate was the last set using
     this command.
     """
 
     code: typing.ClassVar[int] = 170
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        stream_rate_pps: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, stream rate expressed in packets per second.
+    class GetDataAttr(ResponseBodyStruct):
+        stream_rate_pps: int = field(XmpInt())
+        """integer, stream rate expressed in packets per second."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        stream_rate_pps: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, stream rate expressed in packets per second.
+    class SetDataAttr(RequestBodyStruct):
+        stream_rate_pps: int = field(XmpInt())
+        """integer, stream rate expressed in packets per second."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get The rate of the traffic transmitted for a stream expressed in packets per
         second. Get value is only valid if the rate was the last set using
         this command.
 
         :return: stream rate expressed in packets per second
         :rtype: PS_RATEPPS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, stream_rate_pps: int) -> "Token":
+    def set(self, stream_rate_pps: int) -> Token[None]:
         """Set The rate of the traffic transmitted for a stream expressed in packets per
         second. The bandwidth consumption is heavily dependent on the length of the
         packets generated for the stream, and also on the inter-frame gap for the port.
         The sum of the bandwidth consumption for all the enabled streams must not exceed
         the effective rate for the port. Setting this command also instructs the
         Manager to attempt to keep the packets-per-second unchanged in case it has to
         cap stream rates.
 
         :param stream_rate_pps: stream rate expressed in packets per second
         :type stream_rate_pps: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], stream_rate_pps=stream_rate_pps))
 
 
 @register_command
 @dataclass
 class PS_RATEL2BPS:
     """
@@ -759,51 +801,53 @@
     cap stream rates. Get value is only valid if the rate was the last set using
     this command.
     """
 
     code: typing.ClassVar[int] = 171
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        l2_bps: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, stream rate expressed in bits per second.
+    class GetDataAttr(ResponseBodyStruct):
+        l2_bps: int = field(XmpLong())
+        """long integer, stream rate expressed in bits per second."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        l2_bps: XmpField[xt.XmpLong] = XmpField(xt.XmpLong)  # long integer, stream rate expressed in bits per second.
+    class SetDataAttr(RequestBodyStruct):
+        l2_bps: int = field(XmpLong())
+        """long integer, stream rate expressed in bits per second."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the rate of the traffic transmitted for a stream, expressed in units of bits-
         per-second at layer-2, thus including the Ethernet header but excluding the
         inter-frame gap. Get value is only valid if the rate was the last set using
         this command.
 
         :return: stream rate expressed in bits per second
         :rtype: PS_RATEL2BPS.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, l2_bps: int) -> "Token":
+    def set(self, l2_bps: int) -> Token[None]:
         """Set the rate of the traffic transmitted for a stream, expressed in units of bits-
         per-second at layer-2, thus including the Ethernet header but excluding the
         inter-frame gap. The bandwidth consumption is somewhat dependent on the length
         of the packets generated for the stream, and also on the inter-frame gap for the
         port. The sum of the bandwidth consumption for all the enabled streams must not
         exceed the effective rate for the port. Setting this command also instructs
         the Manager to attempt to keep the layer-2 bps rate unchanged in case it has to
         cap stream rates.
 
         :param l2_bps: stream rate expressed in bits per second
         :type l2_bps: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], l2_bps=l2_bps))
 
 
 @register_command
 @dataclass
 class PS_BURST:
     """
@@ -815,52 +859,56 @@
     0 means even, non-bursty, spacing. The exact spacing achieved depends on the
     other enabled streams of the port.
     """
 
     code: typing.ClassVar[int] = 174
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of packets lumped together in a burst.
-        density: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the percentage of the available spacing that is inserted between bursts.
+    class GetDataAttr(ResponseBodyStruct):
+        size: int = field(XmpInt())
+        """integer, the number of packets lumped together in a burst."""
+        density: int = field(XmpInt())
+        """integer, the percentage of the available spacing that is inserted between bursts."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        size: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of packets lumped together in a burst.
-        density: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the percentage of the available spacing that is inserted between bursts.
+    class SetDataAttr(RequestBodyStruct):
+        size: int = field(XmpInt())
+        """integer, the number of packets lumped together in a burst."""
+        density: int = field(XmpInt())
+        """integer, the percentage of the available spacing that is inserted between bursts."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the burstiness of the traffic transmitted for a stream, expressed in terms of
         the number of packets in each burst, and how densely they are packed together.
 
         :return: the number of packets lumped together in a burst, and the percentage of the available spacing that is inserted between bursts
         :rtype: ~PS_BURST.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, size: int, density: int) -> "Token":
+    def set(self, size: int, density: int) -> Token[None]:
         """Set the burstiness of the traffic transmitted for a stream, expressed in terms of
         the number of packets in each burst, and how densely they are packed together.
         The burstiness does not affect the bandwidth consumed by the stream, only the
         spacing between the packets. A density value of 100 means that the packets are
         packed tightly together, only spaced by the minimum inter-frame gap. A value of
         0 means even, non-bursty, spacing. The exact spacing achieved depends on the
         other enabled streams of the port.
 
         :param size: the number of packets lumped together in a burst
         :type size: int
         :param density: the percentage of the available spacing that is inserted between bursts
         :type density: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], size=size, density=density))
 
 
 @register_command
 @dataclass
 class PS_PACKETHEADER:
     """
@@ -873,55 +921,57 @@
     is specified as raw bytes, since the script environment does not know the field-
     by-field layout of the various protocol segments.
     """
 
     code: typing.ClassVar[int] = 175
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the raw bytes comprising the packet header.
+    class GetDataAttr(ResponseBodyStruct):
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, the raw bytes comprising the packet header."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the raw bytes comprising the packet header.
+    class SetDataAttr(RequestBodyStruct):
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, the raw bytes comprising the packet header."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the packet header of a stream. This
         starts with the 14 bytes of the Ethernet header, followed by any contained
         protocol segments. All packets transmitted for the stream start with this fixed
         header. Individual byte positions of the packet header may be varied on a
         packet-to-packet basis using modifiers. The full packet comprises the header,
         the payload, an optional test payload, and the frame checksum. The header data
         is specified as raw bytes, since the script environment does not know the field-
         by-field layout of the various protocol segments.
 
         :return: the raw bytes comprising the packet header
         :rtype: PS_PACKETHEADER.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, hex_data: str) -> "Token":
+    def set(self, hex_data: Hex) -> Token[None]:
         """Set the packet header of a stream. This
         starts with the 14 bytes of the Ethernet header, followed by any contained
         protocol segments. All packets transmitted for the stream start with this fixed
         header. Individual byte positions of the packet header may be varied on a
         packet-to-packet basis using modifiers. The full packet comprises the header,
         the payload, an optional test payload, and the frame checksum. The header data
         is specified as raw bytes, since the script environment does not know the field-
         by-field layout of the various protocol segments.
 
         :param hex_data: the raw bytes comprising the packet header
-        :type hex_data: str
+        :type hex_data: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], hex_data=hex_data))
 
 
 @register_command
 @dataclass
 class PS_HEADERPROTOCOL:
     """
@@ -935,92 +985,96 @@
     type of each segment that precedes the segment where the hardware calculation is
     to be performed.
     """
 
     code: typing.ClassVar[int] = 176
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        segments: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList, choices=ProtocolOption)  # list of coded bytes, a number specifying a built-in protocol segment.
+    class GetDataAttr(ResponseBodyStruct):
+        segments: typing.List[ProtocolOption] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of coded bytes, a number specifying a built-in protocol segment."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        segments: XmpField[xt.XmpByteList] = XmpField(xt.XmpByteList, choices=ProtocolOption)  # list of coded bytes, a number specifying a built-in protocol segment.
+    class SetDataAttr(RequestBodyStruct):
+        segments: typing.List[ProtocolOption] = field(XmpSequence(types_chunk=[XmpByte()]))
+        """list of coded bytes, a number specifying a built-in protocol segment."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the packet header segments in protocol names.
 
         :return: a number specifying a built-in protocol segment
         :rtype: PS_HEADERPROTOCOL.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, segments: typing.List[ProtocolOption]) -> "Token":
+    def set(self, segments: typing.List[ProtocolOption]) -> Token[None]:
         """Inform the Xena tester how to interpret the packet header
         byte sequence specified with PS_PACKETHEADER.  This is mainly for information
         purposes, and the stream will transmit the packet header bytes even if no
         protocol segments are specified.  The Xena tester however support calculation of
         certain field values in hardware, such as the IP, TCP and UDP length and
         checksum fields. This allow the use of hardware modifiers for these protocol
         segments. In order for this function to work the Xena tester needs to know the
         type of each segment that precedes the segment where the hardware calculation is
         to be performed.
 
         :param segments: a number specifying a built-in protocol segment
-        :type segments: List[ProtocolOption]
+        :type segments: typing.List[ProtocolOption]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], segments=segments))
 
 
 @register_command
 @dataclass
 class PS_MODIFIERCOUNT:
     """
     The number of standard 16-bit modifiers active on the packet header of a stream.
     Each modifier is specified using PS_MODIFIER.
     """
 
     code: typing.ClassVar[int] = 177
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        modifier_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of modifiers for the stream.
+    class GetDataAttr(ResponseBodyStruct):
+        modifier_count: int = field(XmpInt())
+        """integer, the number of modifiers for the stream."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        modifier_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of modifiers for the stream.
+    class SetDataAttr(RequestBodyStruct):
+        modifier_count: int = field(XmpInt())
+        """integer, the number of modifiers for the stream."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of standard 16-bit modifiers active on the packet header of a stream.
         Each modifier is specified using PS_MODIFIER.
 
         :return: the number of modifiers for the stream
         :rtype: PS_MODIFIERCOUNT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, modifier_count: int) -> "Token":
+    def set(self, modifier_count: int) -> Token[None]:
         """Set the number of standard 16-bit modifiers active on the packet header of a stream.
         Each modifier is specified using PS_MODIFIER.
 
         :param modifier_count: the number of modifiers for the stream
         :type modifier_count: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], modifier_count=modifier_count))
 
 
 @register_command
 @dataclass
 class PS_MODIFIER:
     """
@@ -1032,49 +1086,57 @@
     bits in each packet. Packets can be repeated so that a certain number of
     identical packets are transmitted before applying the next modification.
     """
 
     code: typing.ClassVar[int] = 178
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
-    modifier_xindex: int
-
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        position: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the byte position from the start of the packet.
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, the mask specifying which bits to affect.
-        action: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=ModifierAction)  # coded integer, which action to perform on the affected bits.
-        repetition: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, how many times to repeat on each packet.
+    _modifier_xindex: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        position: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the byte position from the start of the packet.
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, the mask specifying which bits to affect.
-        action: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=ModifierAction)  # coded integer, which action to perform on the affected bits.
-        repetition: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, how many times to repeat on each packet.
+    class GetDataAttr(ResponseBodyStruct):
+        position: int = field(XmpInt())
+        """integer, the byte position from the start of the packet."""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, the mask specifying which bits to affect."""
+        action: ModifierAction = field(XmpInt())
+        """coded integer, which action to perform on the affected bits."""
+        repetition: int = field(XmpInt())
+        """integer, how many times to repeat on each packet."""
+
+    class SetDataAttr(RequestBodyStruct):
+        position: int = field(XmpInt())
+        """integer, the byte position from the start of the packet."""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, the mask specifying which bits to affect."""
+        action: ModifierAction = field(XmpInt())
+        """coded integer, which action to perform on the affected bits."""
+        repetition: int = field(XmpInt())
+        """integer, how many times to repeat on each packet."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get a packet modifier for a stream header. The headers of each packet transmitted
         for the stream will be varied according to the modifier specification. This
         command requires two sub-indices, one for the stream and one for the modifier.
         A modifier is positioned at a fixed place in the header, selects a number of
         consecutive bits starting from that position, and applies an action to those
         bits in each packet. Packets can be repeated so that a certain number of
         identical packets are transmitted before applying the next modification.
 
-        :return: the byte position from the start of the packet, the mask specifying which bits to affect, which action to perform on the affected bits, and how many times to repeat on each packet
+        :return: the byte position from the start of the packet, the mask specifying which bits to affect, which action to perform on the affected bits,
+            and how many times to repeat on each packet
         :rtype: PS_MODIFIER.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self.modifier_xindex]))
 
-    def set(self, position: int, mask: str, action: ModifierAction, repetition: int) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._modifier_xindex]))
+
+    def set(self, position: int, mask: Hex, action: ModifierAction, repetition: int) -> Token[None]:
         """Set a packet modifier for a stream header. The headers of each packet transmitted
         for the stream will be varied according to the modifier specification. This
         command requires two sub-indices, one for the stream and one for the modifier.
         A modifier is positioned at a fixed place in the header, selects a number of
         consecutive bits starting from that position, and applies an action to those
         bits in each packet. Packets can be repeated so that a certain number of
         identical packets are transmitted before applying the next modification.
@@ -1084,34 +1146,37 @@
         :param mask: the mask specifying which bits to affect
         :type mask: str
         :param action: which action to perform on the affected bits
         :type action: ModifierAction
         :param repetition: how many times to repeat on each packet
         :type repetition: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
-                indices=[self._stream_xindex, self.modifier_xindex],
+                indices=[self._stream_xindex, self._modifier_xindex],
                 position=position,
                 mask=mask,
                 action=action,
-                repetition=repetition,
-            ),
+                repetition=repetition
+            )
         )
 
     set_inc = functools.partialmethod(set, action=ModifierAction.INC)
     """Set a packet modifier action to incrementing.
     """
+
     set_dec = functools.partialmethod(set, action=ModifierAction.DEC)
     """Set a packet modifier action to decrementing.
     """
+
     set_random = functools.partialmethod(set, action=ModifierAction.RANDOM)
     """Set a packet modifier action to random.
     """
 
 
 @register_command
 @dataclass
@@ -1124,78 +1189,96 @@
     packet, whereas the header has constant length. Length variation complements,
     and is independent of, the content variation produced by header modifiers.
     """
 
     code: typing.ClassVar[int] = 179
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        length_type: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=LengthType)  # coded integer, the kind of distribution of packet length.
-        min_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, lower limit on the packet length.
-        max_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, upper limit on the packet length.
+    class GetDataAttr(ResponseBodyStruct):
+        length_type: LengthType = field(XmpInt())
+        """coded integer, the kind of distribution of packet length."""
+        min_val: int = field(XmpInt())
+        """integer, lower limit on the packet length."""
+        max_val: int = field(XmpInt())
+        """integer, upper limit on the packet length."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        length_type: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=LengthType)  # coded integer, the kind of distribution of packet length.
-        min_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, lower limit on the packet length.
-        max_val: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, upper limit on the packet length.
+    class SetDataAttr(RequestBodyStruct):
+        length_type: LengthType = field(XmpInt())
+        """coded integer, the kind of distribution of packet length."""
+        min_val: int = field(XmpInt())
+        """integer, lower limit on the packet length."""
+        max_val: int = field(XmpInt())
+        """integer, upper limit on the packet length."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the length distribution of the packets transmitted for a stream. The length of
         the packets transmitted for a stream can be varied from packet to packet,
         according to a choice of distributions within a specified min..max range. The
         length of each packet is reflected in the size of the payload portion of the
         packet, whereas the header has constant length. Length variation complements,
         and is independent of, the content variation produced by header modifiers.
 
         :return: the kind of distribution of packet length, lower limit on the packet length, and upper limit on the packet length.
         :rtype: PS_PACKETLENGTH.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, length_type: LengthType, min_val: int, max_val: int) -> "Token":
+    def set(self, length_type: LengthType, min_val: int, max_val: int) -> Token[None]:
         """Set the length distribution of the packets transmitted for a stream. The length of
         the packets transmitted for a stream can be varied from packet to packet,
         according to a choice of distributions within a specified min..max range. The
         length of each packet is reflected in the size of the payload portion of the
         packet, whereas the header has constant length. Length variation complements,
         and is independent of, the content variation produced by header modifiers.
 
         :param length_type: the kind of distribution of packet length
         :type length_type: LengthType
         :param min_val: lower limit on the packet length
         :type min_val: int
         :param max_val: upper limit on the packet length
         :type max_val: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], length_type=length_type, min_val=min_val, max_val=max_val),
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._stream_xindex],
+                length_type=length_type,
+                min_val=min_val,
+                max_val=max_val
+            )
         )
 
     set_fixed = functools.partialmethod(set, LengthType.FIXED)
     """Set the packet length distribution to Fixed.
     """
+
     set_incrementing = functools.partialmethod(set, LengthType.INCREMENTING)
     """Set the packet length distribution to Incrementing. Length per packet: {min, min+1, min+2,
     ...., max-2, max-1, max...}.
     """
+
     set_butterfly = functools.partialmethod(set, LengthType.BUTTERFLY)
     """Set the packet length distribution to Butterfly. Length per packet: {min, max, min+1, max-1, min+2, max-2,
     ...}.
     """
+
     set_random = functools.partialmethod(set, LengthType.RANDOM)
     """Set the packet length distribution to Random.
     """
+
     set_mix = functools.partialmethod(set, LengthType.MIX)
     """Set the packet length distribution to Mix.
     """
 
 
 @register_command
 @dataclass
@@ -1208,81 +1291,85 @@
     variation complements and is independent of the content variation produced by
     header modifiers.
     """
 
     code: typing.ClassVar[int] = 180
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        payload_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PayloadType)  # coded byte, the kind of payload content.
-        hex_data: XmpField[xt.XmpHexList] = XmpField(
-            xt.XmpHexList
-        )  # list of hex bytes, a pattern of bytes to be repeated. The maximum length of the pattern is 18 bytes. Only used if the type is set to PATTERN.
+    class GetDataAttr(ResponseBodyStruct):
+        payload_type: PayloadType = field(XmpByte())
+        """coded byte, the kind of payload content."""
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, a pattern of bytes to be repeated. The maximum length of the pattern is 18 bytes. Only used if the type is set to PATTERN."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        payload_type: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PayloadType)  # coded byte, the kind of payload content.
-        hex_data: XmpField[xt.XmpHexList] = XmpField(
-            xt.XmpHexList
-        )  # list of hex bytes, a pattern of bytes to be repeated. The maximum length of the pattern is 18 bytes. Only used if the type is set to PATTERN.
+    class SetDataAttr(RequestBodyStruct):
+        payload_type: PayloadType = field(XmpByte())
+        """coded byte, the kind of payload content."""
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, a pattern of bytes to be repeated. The maximum length of the pattern is 18 bytes. Only used if the type is set to PATTERN."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the payload content of the packets transmitted for a stream. The payload portion
         of a packet starts after the header and continues up until the test payload or
         the frame checksum. The payload may vary in length and is filled with either an
         incrementing sequence of byte values or a repeated multi-byte pattern. Length
         variation complements and is independent of the content variation produced by
         header modifiers.
 
         :return: the kind of payload content, and a pattern of bytes to be repeated.
         :rtype: PS_PAYLOAD.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, payload_type: PayloadType, hex_data: str) -> "Token":
+    def set(self, payload_type: PayloadType, hex_data: Hex) -> Token[None]:
         """Set the payload content of the packets transmitted for a stream. The payload portion
         of a packet starts after the header and continues up until the test payload or
         the frame checksum. The payload may vary in length and is filled with either an
         incrementing sequence of byte values or a repeated multi-byte pattern. Length
         variation complements and is independent of the content variation produced by
         header modifiers.
 
         :param payload_type: the kind of payload content
         :type payload_type: PayloadType
         :param hex_data: a pattern of bytes to be repeated. The maximum length of the pattern is 18 bytes. Only used if the type is set to PATTERN.
-        :type hex_data: str
+        :type hex_data: Hex
         """
-        return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], payload_type=payload_type, hex_data=hex_data)
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], payload_type=payload_type, hex_data=hex_data))
 
     set_pattern = functools.partialmethod(set, PayloadType.PATTERN)
     """Set payload type to the custom pattern.
     """
-    set_incrementing = set_inc_byte = functools.partialmethod(set, PayloadType.INC8)
+
+    set_inc_byte = functools.partialmethod(set, PayloadType.INC8)
     """Set payload type to Incrementing 0xFF (8-bit mode).
     """
+
     set_prbs = functools.partialmethod(set, PayloadType.PRBS)
     """Set payload type to PRBS.
     """
+
     set_random = functools.partialmethod(set, PayloadType.RANDOM)
     """Set payload type to Random.
     """
-    set_decrementing = set_dec_byte = functools.partialmethod(set, PayloadType.DEC8)
+
+    set_dec_byte = functools.partialmethod(set, PayloadType.DEC8)
     """Set payload type to Decrementing 0xFF (8-bit mode).
     """
+
     set_inc_word = functools.partialmethod(set, PayloadType.INC16)
     """Set payload type to Incrementing 0xFFFF (16-bit mode).
     """
+
     set_dec_word = functools.partialmethod(set, PayloadType.DEC16)
     """Set payload type to Decrementing 0xFFFF (16-bit mode).
     """
 
 
 @register_command
 @dataclass
@@ -1290,81 +1377,85 @@
     """
     An IPv4 gateway configuration specified for a stream.
     """
 
     code: typing.ClassVar[int] = 181
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        gateway: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, IPv4 gateway address of the stream.
+    class GetDataAttr(ResponseBodyStruct):
+        gateway: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, the IPv4 gateway address of the stream."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        gateway: XmpField[xt.XmpIPV4Address] = XmpField(xt.XmpIPV4Address)  # address, the IPv4 gateway address of the stream.
+    class SetDataAttr(RequestBodyStruct):
+        gateway: ipaddress.IPv4Address = field(XmpIPv4Address())
+        """address, IPv4 gateway address of the stream."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IPv4 gateway address of a stream.
 
         :return: the IPv4 gateway address of the stream
         :rtype: PS_IPV4GATEWAY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, gateway: typing.Union[str, ipaddress.IPv4Address, int]) -> "Token":
+    def set(self, gateway: ipaddress.IPv4Address) -> Token[None]:
         """Set the IPv4 gateway address of a stream.
 
         :param gateway: the IPv4 gateway address of the stream
         :type gateway: Union[str, ipaddress.IPv4Address, int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], gateway=gateway))
 
 
 @register_command
 @dataclass
 class PS_IPV6GATEWAY:
     """
     An IPv6 gateway configuration specified for a stream.
     """
 
     code: typing.ClassVar[int] = 182
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        gateway: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # address, IPv6 gateway address of the stream.
+    class GetDataAttr(ResponseBodyStruct):
+        gateway: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """address, the IPv6 gateway address of the stream."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        gateway: XmpField[xt.XmpIPV6Address] = XmpField(xt.XmpIPV6Address)  # address, the IPv6 gateway address of the stream.
+    class SetDataAttr(RequestBodyStruct):
+        gateway: ipaddress.IPv6Address = field(XmpIPv6Address())
+        """address, IPv6 gateway address of the stream."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the IPv6 gateway address of a stream.
 
         :return: the IPv6 gateway address of the stream
         :rtype: PS_IPV6GATEWAY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, gateway: typing.Union[str, ipaddress.IPv6Address, int]) -> "Token":
+    def set(self, gateway: ipaddress.IPv6Address) -> Token[None]:
         """Set the IPv6 gateway address of a stream.
 
         :param gateway: the IPv6 gateway address of the stream
         :type gateway: Union[str, ipaddress.IPv6Address, int]
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], gateway=gateway))
 
 
 @register_command
 @dataclass
 class PS_BURSTGAP:
     """
@@ -1372,50 +1463,54 @@
     (inter-packet gap) and the gap after a burst defined in one stream stops until a
     burst defined in the next stream starts (inter-burst gap).
     """
 
     code: typing.ClassVar[int] = 183
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        inter_packet_gap: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, Burst Inter Packet Gap (in bytes).
-        inter_burst_gap: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, Inter Burst Gap (in bytes).
+    class GetDataAttr(ResponseBodyStruct):
+        inter_packet_gap: int = field(XmpInt())
+        """integer, Burst Inter Packet Gap (in bytes)."""
+        inter_burst_gap: int = field(XmpInt())
+        """integer, Inter Burst Gap (in bytes)."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        inter_packet_gap: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, Burst Inter Packet Gap (in bytes).
-        inter_burst_gap: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, Inter Burst Gap (in bytes).
+    class SetDataAttr(RequestBodyStruct):
+        inter_packet_gap: int = field(XmpInt())
+        """integer, Burst Inter Packet Gap (in bytes)."""
+        inter_burst_gap: int = field(XmpInt())
+        """integer, Inter Burst Gap (in bytes)."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the gap between packets in a burst (inter-packet gap) and the gap after a burst defined in one stream stops until a
         burst defined in the next stream starts (inter-burst gap).
 
         :return: the gap between packets in a burst
         :rtype: PS_BURSTGAP.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, inter_packet_gap: int, inter_burst_gap: int) -> "Token":
+    def set(self, inter_packet_gap: int, inter_burst_gap: int) -> Token[None]:
         """Set the gap between packets in a burst (inter-packet gap) and the gap after a burst defined in one stream stops until a
         burst defined in the next stream starts (inter-burst gap).
 
         :param inter_packet_gap: Burst Inter Packet Gap (in bytes).
         :type inter_packet_gap: int
         :param inter_burst_gap: Inter Burst Gap (in bytes).
         :type inter_burst_gap: int
         """
+
         return Token(
             self._connection,
-            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], inter_packet_gap=inter_packet_gap, inter_burst_gap=inter_burst_gap),
+            build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], inter_packet_gap=inter_packet_gap, inter_burst_gap=inter_burst_gap)
         )
 
 
 @register_command
 @dataclass
 class PS_INJECTFCSERR:
     """
@@ -1424,38 +1519,30 @@
     the system under test. Traffic must be on for the port, and the stream must be
     enabled.
     """
 
     code: typing.ClassVar[int] = 185
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Set a frame checksum error in one of the packets currently being transmitted
         from a stream. This can aid in analyzing the error-detection functionality of
         the system under test. Traffic must be on for the port, and the stream must be
         enabled.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._stream_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_INJECTSEQERR:
     """
     Force a sequence error by skipping a test payload sequence number in one of the
@@ -1463,38 +1550,30 @@
     error-detection functionality of the system under test. Traffic must be on for
     the port, and the stream must be enabled and include test payloads.
     """
 
     code: typing.ClassVar[int] = 186
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Set a sequence error by skipping a test payload sequence number in one of the
         packets currently being transmitted from a stream. This can aid in analyzing the
         error-detection functionality of the system under test. Traffic must be on for
         the port, and the stream must be enabled and include test payloads.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._stream_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_INJECTMISERR:
     """
     Force a misorder error by swapping the test payload sequence numbers in two of
@@ -1502,38 +1581,30 @@
     the error-detection functionality of the system under test. Traffic must be on
     for the port, and the stream must be enabled and include test payloads.
     """
 
     code: typing.ClassVar[int] = 187
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Set a misorder error by swapping the test payload sequence numbers in two of
         the packets currently being transmitted from a stream. This can aid in analyzing
         the error-detection functionality of the system under test. Traffic must be on
         for the port, and the stream must be enabled and include test payloads.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._stream_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_INJECTPLDERR:
     """
     Force a payload integrity error in one of the packets currently being
@@ -1544,41 +1615,33 @@
     the test payload. Traffic must be on for the port, and the stream must be
     enabled and include test payloads.
     """
 
     code: typing.ClassVar[int] = 188
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Set a payload integrity error in one of the packets currently being
         transmitted from a stream. Payload integrity validation is only available for
         incrementing payloads, and the error is created by changing a byte from the
         incrementing sequence. The packet will have a correct frame checksum, but the
         receiving Xena chassis will detect the invalid payload based on information in
         the test payload. Traffic must be on for the port, and the stream must be
         enabled and include test payloads.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._stream_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_INJECTTPLDERR:
     """
     Force a test payload error in one of the packets currently being transmitted
@@ -1587,39 +1650,31 @@
     will be a lost packet for the stream. Traffic must be on for the port, and the
     stream must be enabled and include test payloads.
     """
 
     code: typing.ClassVar[int] = 189
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
+    class SetDataAttr(RequestBodyStruct):
         pass
 
-    def set(self) -> "Token":
+    def set(self) -> Token[None]:
         """Set a test payload error in one of the packets currently being transmitted
         from a stream. This means that the test payload will not be recognized at the
         receiving port, so it will be counted as a no-test-payload packet, and there
         will be a lost packet for the stream. Traffic must be on for the port, and the
         stream must be enabled and include test payloads.
         """
-        return Token(
-            self._connection,
-            build_set_request(
-                self,
-                module=self._module,
-                port=self._port,
-                indices=[self._stream_xindex],
-            ),
-        )
+
+        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
 
 @register_command
 @dataclass
 class PS_MODIFIEREXT:
     """
     An extended packet modifier for a stream header. The headers of each packet
@@ -1632,35 +1687,41 @@
     that a certain number of identical packets are transmitted before applying the
     next modification.
     """
 
     code: typing.ClassVar[int] = 190
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
     _modifier_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        position: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the byte position from the start of the packet. Cannot be < 1!
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, the mask specifying which bits to affect.
-        action: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=ModifierAction)  # coded integer, which action to perform on the affected bits.
-        repetition: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, how many times to repeat on each packet. Note: For now the only value supported is 1.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        position: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the byte position from the start of the packet. Cannot be < 1!
-        mask: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # four hex bytes, the mask specifying which bits to affect.
-        action: XmpField[xt.XmpInt] = XmpField(xt.XmpInt, choices=ModifierAction)  # coded integer, which action to perform on the affected bits.
-        repetition: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, how many times to repeat on each packet. Note: For now the only value supported is 1.
+    class GetDataAttr(ResponseBodyStruct):
+        position: int = field(XmpInt())
+        """integer, the byte position from the start of the packet. Cannot be < 1!"""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, the mask specifying which bits to affect."""
+        action: ModifierAction = field(XmpInt())
+        """coded integer, which action to perform on the affected bits."""
+        repetition: int = field(XmpInt())
+        """integer, how many times to repeat on each packet. Note: For now the only value supported is 1."""
+
+    class SetDataAttr(RequestBodyStruct):
+        position: int = field(XmpInt())
+        """integer, the byte position from the start of the packet. Cannot be < 1!"""
+        mask: Hex = field(XmpHex(size=4))
+        """four hex bytes, the mask specifying which bits to affect."""
+        action: ModifierAction = field(XmpInt())
+        """coded integer, which action to perform on the affected bits."""
+        repetition: int = field(XmpInt())
+        """integer, how many times to repeat on each packet. Note: For now the only value supported is 1."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get an extended packet modifier for a stream header. The headers of each packet
         transmitted for the stream will be varied according to the modifier
         specification. The modifier acts on 24 bits and takes up the space for two
         16-bit modifiers to do this. This command requires two sub-indices, one for
         the stream and one for the modifier. A modifier is positioned at a fixed place
         in the header, selects a number of consecutive bits starting from that position,
         and applies an action to those bits in each packet. Packets can be repeated so
@@ -1668,17 +1729,18 @@
         next modification.
 
         :return: the byte position from the start of the packet. Cannot be < 1!,
             the mask specifying which bits to affect, which action to perform on the affected bits,
             and how many times to repeat on each packet. Note: For now the only value supported is 1.
         :rtype: PS_MODIFIEREXT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._modifier_xindex]))
 
-    def set(self, position: int, mask: str, action: ModifierAction, repetition: int) -> "Token":
+    def set(self, position: int, mask: Hex, action: ModifierAction, repetition: int) -> Token[None]:
         """Set an extended packet modifier for a stream header. The headers of each packet
         transmitted for the stream will be varied according to the modifier
         specification. The modifier acts on 24 bits and takes up the space for two
         16-bit modifiers to do this. This command requires two sub-indices, one for
         the stream and one for the modifier. A modifier is positioned at a fixed place
         in the header, selects a number of consecutive bits starting from that position,
         and applies an action to those bits in each packet. Packets can be repeated so
@@ -1690,34 +1752,37 @@
         :param mask: the mask specifying which bits to affect
         :type mask: str
         :param action: which action to perform on the affected bits,
         :type action: ModifierAction
         :param repetition: how many times to repeat on each packet. Note: For now the only value supported is 1.
         :type repetition: int
         """
+
         return Token(
             self._connection,
             build_set_request(
                 self,
                 module=self._module,
                 port=self._port,
                 indices=[self._stream_xindex, self._modifier_xindex],
                 position=position,
                 mask=mask,
                 action=action,
-                repetition=repetition,
-            ),
+                repetition=repetition
+            )
         )
 
     set_inc = functools.partialmethod(set, action=ModifierAction.INC)
     """Set modifier action to Incrementing.
     """
+
     set_dec = functools.partialmethod(set, action=ModifierAction.DEC)
     """Set modifier action to Decrementing.
     """
+
     set_random = functools.partialmethod(set, action=ModifierAction.RANDOM)
     """Set modifier action to Random.
     """
 
 
 @register_command
 @dataclass
@@ -1726,43 +1791,45 @@
     The number of extended 24-bit modifiers active on the packet header of a stream.
     Each modifier is specified using PS_MODIFIEREXT.
     """
 
     code: typing.ClassVar[int] = 191
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        ext_modifier_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of extended 24-bit modifiers for the stream.
+    class GetDataAttr(ResponseBodyStruct):
+        ext_modifier_count: int = field(XmpInt())
+        """integer, the number of extended 24-bit modifiers for the stream."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        ext_modifier_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of extended 24-bit modifiers for the stream.
+    class SetDataAttr(RequestBodyStruct):
+        ext_modifier_count: int = field(XmpInt())
+        """integer, the number of extended 24-bit modifiers for the stream."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of extended 24-bit modifiers active on the packet header of a stream.
         Each modifier is specified using PS_MODIFIEREXT.
 
         :return: the number of extended 24-bit modifiers for the stream
         :rtype: PS_MODIFIEREXTCOUNT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, ext_modifier_count: int) -> "Token":
+    def set(self, ext_modifier_count: int) -> Token[None]:
         """Set the number of extended 24-bit modifiers active on the packet header of a stream.
         Each modifier is specified using PS_MODIFIEREXT.
 
         :param ext_modifier_count: the number of extended 24-bit modifiers for the stream
         :type ext_modifier_count: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], ext_modifier_count=ext_modifier_count))
 
 
 @register_command
 @dataclass
 class PS_CDFOFFSET:
     """
@@ -1776,57 +1843,59 @@
     feature requires that the P_PAYLOADMODE command on the parent port has been
     set to CDF. This enables the feature for all streams on this port.
     """
 
     code: typing.ClassVar[int] = 195
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the location where the CDF data will be inserted.
+    class GetDataAttr(ResponseBodyStruct):
+        offset: int = field(XmpInt())
+        """integer, the location where the CDF data will be inserted."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        offset: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the location where the CDF data will be inserted.
+    class SetDataAttr(RequestBodyStruct):
+        offset: int = field(XmpInt())
+        """integer, the location where the CDF data will be inserted."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the CDF offset for the stream. This command is part of the Custom Data Field (CDF) feature. The CDF offset
         for the stream is the location in the stream data packets where the various CDF
         data will be inserted. All fields for a given stream uses the same offset
         value. The default value is zero (0) which means that the CDF data  will be
         inserted at the very start of the packet, thus overwriting the packet protocol
         headers.  If you want the CDF data to start immediately after the end of the
         packet protocol headers you will have to set the CDF field offset manually. The
         feature requires that the P_PAYLOADMODE command on the parent port has been
         set to CDF. This enables the feature for all streams on this port.
 
         :return: the location where the CDF data will be inserted
         :rtype: PS_CDFOFFSET.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, offset: int) -> "Token":
+    def set(self, offset: int) -> Token[None]:
         """Set the CDF offset for the stream. This command is part of the Custom Data Field (CDF) feature. The CDF offset
         for the stream is the location in the stream data packets where the various CDF
         data will be inserted. All fields for a given stream uses the same offset
         value. The default value is zero (0) which means that the CDF data  will be
         inserted at the very start of the packet, thus overwriting the packet protocol
         headers.  If you want the CDF data to start immediately after the end of the
         packet protocol headers you will have to set the CDF field offset manually. The
         feature requires that the P_PAYLOADMODE command on the parent port has been
         set to CDF. This enables the feature for all streams on this port.
 
         :param offset: the location where the CDF data will be inserted
         :type offset: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], offset=offset))
 
 
 @register_command
 @dataclass
 class PS_CDFCOUNT:
     """
@@ -1838,52 +1907,54 @@
     new count. The feature requires that the P_PAYLOADMODE command on the parent
     port has been set to CDF. This enables the feature for all streams on this port.
     """
 
     code: typing.ClassVar[int] = 196
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        cdf_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of CDF data fields to allocate for the stream.
+    class GetDataAttr(ResponseBodyStruct):
+        cdf_count: int = field(XmpInt())
+        """integer, the number of CDF data fields to allocate for the stream."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        cdf_count: XmpField[xt.XmpInt] = XmpField(xt.XmpInt)  # integer, the number of CDF data fields to allocate for the stream.
+    class SetDataAttr(RequestBodyStruct):
+        cdf_count: int = field(XmpInt())
+        """integer, the number of CDF data fields to allocate for the stream."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the number of custom data fields available for each stream. You can set a different number
         of fields for each stream. Changing the field count value to a larger value will
         leave all existing fields intact. Changing the field count value to a smaller
         value will remove all existing fields with an index larger than or equal to the
         new count. The feature requires that the P_PAYLOADMODE command on the parent
         port has been set to CDF. This enables the feature for all streams on this port.
 
         :return: the number of CDF data fields to allocate for the stream
         :rtype: PS_CDFCOUNT.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, cdf_count: int) -> "Token":
+    def set(self, cdf_count: int) -> Token[None]:
         """Set the number of custom data fields available for each stream. You can set a different number
         of fields for each stream. Changing the field count value to a larger value will
         leave all existing fields intact. Changing the field count value to a smaller
         value will remove all existing fields with an index larger than or equal to the
         new count. The feature requires that the P_PAYLOADMODE command on the parent
         port has been set to CDF. This enables the feature for all streams on this port.
 
 
         :param cdf_count: the number of CDF data fields to allocate for the stream
         :type cdf_count: int
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], cdf_count=cdf_count))
 
 
 @register_command
 @dataclass
 class PS_CDFDATA:
     """
@@ -1895,54 +1966,63 @@
     command on the parent port has been set to CDF. This enables the feature for
     all streams on this port.
     """
 
     code: typing.ClassVar[int] = 197
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
     _custom_data_field_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, a pattern of bytes to be used.
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, the actual field data for a single field.
+    class GetDataAttr(ResponseBodyStruct):
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, the actual field data for a single field."""
+
+    class SetDataAttr(RequestBodyStruct):
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, a pattern of bytes to be used."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the actual field data for a single field. It is possible to define fields with
         different data lengths for each stream. If the length of a data field exceeds
         (packet length - CDF offset) defined for the stream the field data will be
         truncated when transmitted. The feature requires that the P_PAYLOADMODE
         command on the parent port has been set to CDF. This enables the feature for
         all streams on this port.
 
         :return: the actual field data for a single field
         :rtype: PS_CDFDATA.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._custom_data_field_xindex]))
 
-    def set(self, hex_data: str) -> "Token":
+    def set(self, hex_data: Hex) -> Token[None]:
         """Set the actual field data for a single field. It is possible to define fields with
         different data lengths for each stream. If the length of a data field exceeds
         (packet length - CDF offset) defined for the stream the field data will be
         truncated when transmitted. The feature requires that the P_PAYLOADMODE
         command on the parent port has been set to CDF. This enables the feature for
         all streams on this port.
 
         :param hex_data: a pattern of bytes to be used
-        :type hex_data: str
+        :type hex_data: Hex
         """
+
         return Token(
-            self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex, self._custom_data_field_xindex], hex_data=hex_data)
+            self._connection,
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._stream_xindex, self._custom_data_field_xindex],
+                hex_data=hex_data
+            )
         )
 
 
 @register_command
 @dataclass
 class PS_EXTPAYLOAD:
     """
@@ -1954,79 +2034,83 @@
     The feature requires the P_PAYLOADMODE command on the parent port being set to
     EXTPL. This enables the feature for all streams on this port.
     """
 
     code: typing.ClassVar[int] = 199
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, a pattern of bytes to be repeated.
+    class GetDataAttr(ResponseBodyStruct):
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, a pattern of bytes to be repeated."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        hex_data: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # list of hex bytes, a pattern of bytes to be repeated.
+    class SetDataAttr(RequestBodyStruct):
+        hex_data: Hex = field(XmpHex())
+        """list of hex bytes, a pattern of bytes to be repeated."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the extended payload in bytes of a stream.
 
         :return: the extended payload in bytes of a stream
         :rtype: PS_EXTPAYLOAD.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, hex_data: str) -> "Token":
+    def set(self, hex_data: Hex) -> Token[None]:
         """Set the extended payload in bytes of a stream. The PS_EXTPAYLOAD command allow the definition
         of a much larger (up to MTU) payload buffer for each stream. The extended
         payload will be inserted immediately after the end of the protocol segment area.
         The feature requires the P_PAYLOADMODE command on the parent port being set to
         EXTPL. This enables the feature for all streams on this port.
 
         :param hex_data: the extended payload in bytes of a stream
-        :type hex_data: str
+        :type hex_data: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], hex_data=hex_data))
 
 
 @register_command
 @dataclass
 class PS_PFCPRIORITY:
     """
     Set and get the Priority Flow Control (PFC) mode.
     """
 
     code: typing.ClassVar[int] = 219
     pushed: typing.ClassVar[bool] = True
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _stream_xindex: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        pcp: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PFCMode)  # coded byte, Priority Flow Control mode.
+    class GetDataAttr(ResponseBodyStruct):
+        pcp: PFCMode = field(XmpByte())
+        """coded byte, Priority Flow Control mode."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        pcp: XmpField[xt.XmpByte] = XmpField(xt.XmpByte, choices=PFCMode)  # coded byte, Priority Flow Control mode.
+    class SetDataAttr(RequestBodyStruct):
+        pcp: PFCMode = field(XmpByte())
+        """coded byte, Priority Flow Control mode."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the Priority Flow Control (PFC) mode of a stream.
 
         :return: the Priority Flow Control mode of the stream
         :rtype: PS_PFCPRIORITY.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._stream_xindex]))
 
-    def set(self, pcp: PFCMode) -> "Token":
+    def set(self, pcp: PFCMode) -> Token[None]:
         """Set the Priority Flow Control (PFC) mode of a stream.
 
         :param pcp: the Priority Flow Control mode of the stream
         :type pcp: str
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._stream_xindex], pcp=pcp))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/commands/px_commands.py` & `xoa-driver-2.0.0/xoa_driver/internals/commands/px_commands.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,168 +1,195 @@
-#: L23 Port Transceiver Commands
-
+from __future__ import annotations
 from dataclasses import dataclass
 import typing
 
-from ..protocol.command_builders import (
+from xoa_driver.internals.core.builders import (
     build_get_request,
     build_set_request
 )
-from .. import interfaces
-from ..transporter.token import Token
-from ..protocol.fields import data_types as xt
-from ..protocol.fields.field import XmpField
-from ..registry import register_command
-# from .enums import *  # noqa: F403
+from xoa_driver.internals.core import interfaces
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.core.transporter.registry import register_command
+from xoa_driver.internals.core.transporter.protocol.payload import (
+    field,
+    RequestBodyStruct,
+    ResponseBodyStruct,
+    XmpByte,
+    XmpHex,
+    XmpSequence,
+    Hex,
+)
 
 
 @register_command
 @dataclass
 class PX_RW:
     """
     Provides read and write access to the register interface supported by the port transceiver.  It
     is possible to both read and write register values.
     """
 
     code: typing.ClassVar[int] = 501
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _page_xindex: int
     _register_xaddress: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        value: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # 4 hex bytes, register value of the port transceiver
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        value: XmpField[xt.XmpHex4] = XmpField(xt.XmpHex4)  # 4 hex bytes, register value of the port transceiver
+    class GetDataAttr(ResponseBodyStruct):
+        value: Hex = field(XmpHex(size=4))
+        """4 hex bytes, register value of the port transceiver"""
+
+    class SetDataAttr(RequestBodyStruct):
+        value: Hex = field(XmpHex(size=4))
+        """4 hex bytes, register value of the port transceiver"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the register value of a transceiver.
 
         :return: the register value of a transceiver
         :rtype: PX_RW.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._page_xindex, self._register_xaddress]))
 
-    def set(self, value: str) -> "Token":
+    def set(self, value: Hex) -> Token[None]:
         """Set the register value of a transceiver.
 
         :param value: register value of a transceiver
-        :type value: str
+        :type value: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._page_xindex, self._register_xaddress], value=value))
 
 
 @register_command
 @dataclass
 class PX_RW_SEQ:
     """
     .. versionadded: v1.1
 
-    :term:`I2C<I2C>` sequential access to a transceiver's register. When invoked, the ``<byte_count>`` number of bytes will be read or written in one I2C transaction, in which the ``<value>`` is read or written with only a single register address setup. A subsequent invocation will perform a second I2C transaction in the same manner. ``<_page_xindex>``: the transceiver page address, integer, 0-255. ``<_register_xaddress>``: the address within the page, integer, 0-255.
+    :term:`I2C<I2C>` sequential access to a transceiver's register.
+    When invoked, the ``<byte_count>`` number of bytes will be read or written in one I2C transaction,
+    in which the ``<value>`` is read or written with only a single register address setup.
+    A subsequent invocation will perform a second I2C transaction in the same manner.
+    ``<_page_xindex>``: the transceiver page address, integer, 0-255.
+    ``<_register_xaddress>``: the address within the page, integer, 0-255.
     """
 
     code: typing.ClassVar[int] = 503
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _page_xindex: int
     _register_xaddress: int
-    _byte_count: int
+    _byte_xcount: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        value: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # the bytes to be read or written in one I2C transaction. The number of bytes in the ``<value>`` equals ``<byte_count>``.
+    class GetDataAttr(ResponseBodyStruct):
+        value: Hex = field(XmpHex())
+        """the bytes to be read or written in one I2C transaction. The number of bytes in the ``<value>`` equals ``<byte_count>``."""
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        value: XmpField[xt.XmpHexList] = XmpField(xt.XmpHexList)  # the bytes to be read or written in one I2C transaction. The number of bytes in the ``<value>`` equals ``<byte_count>``.
+    class SetDataAttr(RequestBodyStruct):
+        value: Hex = field(XmpHex())
+        """the bytes to be read or written in one I2C transaction. The number of bytes in the ``<value>`` equals ``<byte_count>``."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the register value of a transceiver in one I2C transaction.
 
         :return: the register value of a transceiver
         :rtype: PX_RW_SEQ.GetDataAttr
         """
-        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._page_xindex, self._register_xaddress, self._byte_count]))
 
-    def set(self, value: str) -> "Token":
+        return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._page_xindex, self._register_xaddress, self._byte_xcount]))
+
+    def set(self, value: Hex) -> Token[None]:
         """Set the register value of a transceiver in one I2C transaction.
 
         :param value: register value of a transceiver
-        :type value: str
+        :type value: Hex
         """
-        return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._page_xindex, self._register_xaddress, self._byte_count], value=value))
+
+        return Token(
+            self._connection,
+            build_set_request(
+                self,
+                module=self._module,
+                port=self._port,
+                indices=[self._page_xindex, self._register_xaddress, self._byte_xcount],
+                value=value
+            )
+        )
 
 
 @register_command
 @dataclass
 class PX_MII:
     """Provides access to the register interface supported by the media-independent interface (MII) transceiver.  It
     is possible to both read and write register values."""
 
     code: typing.ClassVar[int] = 537
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
     _register_xaddress: int
 
-    @dataclass(frozen=True)
-    class SetDataAttr:
-        value: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # 2 hex bytes, register value of the transceiver
-
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        value: XmpField[xt.XmpHex2] = XmpField(xt.XmpHex2)  # 2 hex bytes, register value of the transceiver
+    class GetDataAttr(ResponseBodyStruct):
+        value: Hex = field(XmpHex(size=2))
+        """2 hex bytes, register value of the transceiver"""
+
+    class SetDataAttr(RequestBodyStruct):
+        value: Hex = field(XmpHex(size=2))
+        """2 hex bytes, register value of the transceiver"""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get the register value of a transceiver.
 
         :return: the register value of a transceiver
         :rtype: PX_MII.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port, indices=[self._register_xaddress]))
 
-    def set(self, value: str) -> "Token":
+    def set(self, value: Hex) -> Token[None]:
         """Set the register value of a transceiver.
 
         :param value: register value of a transceiver
-        :type value: str
+        :type value: Hex
         """
+
         return Token(self._connection, build_set_request(self, module=self._module, port=self._port, indices=[self._register_xaddress], value=value))
 
 
 @register_command
 @dataclass
 class PX_TEMPERATURE:
     """
     Transceiver temperature in degrees Celsius.
     """
 
     code: typing.ClassVar[int] = 538
     pushed: typing.ClassVar[bool] = False
 
-    _connection: "interfaces.IConnection"
+    _connection: 'interfaces.IConnection'
     _module: int
     _port: int
 
-    @dataclass(frozen=True)
-    class GetDataAttr:
-        integral_part: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, temperature value before the decimal digit.
-        fractional_part: XmpField[xt.XmpByte] = XmpField(xt.XmpByte)  # byte, 1/256th of a degree Celsius after the decimal digit.
+    class GetDataAttr(ResponseBodyStruct):
+        integral_part: int = field(XmpByte())
+        """byte, temperature value before the decimal digit."""
+        fractional_part: int = field(XmpByte())
+        """byte, 1/256th of a degree Celsius after the decimal digit."""
 
-    def get(self) -> "Token[GetDataAttr]":
+    def get(self) -> Token[GetDataAttr]:
         """Get transceiver temperature in degrees Celsius.
 
         :return: temperature value before the decimal digit, and 1/256th of a degree Celsius after the decimal digit.
         :rtype: PX_TEMPERATURE.GetDataAttr
         """
+
         return Token(self._connection, build_get_request(self, module=self._module, port=self._port))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/protocol/command_builders.py` & `xoa-driver-2.0.0/xoa_driver/internals/core/builders.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,55 +1,39 @@
-from typing import TYPE_CHECKING, Type
-
-if TYPE_CHECKING:
-    from . import struct_header
-from . import struct_response
-from . import struct_request
-from .constants import (
-    CommandType,
-    NOTHING,
-)
-from xoa_driver.internals.core.interfaces import (
+from __future__ import annotations
+from .transporter.protocol.struct_request import Request
+from .transporter.protocol._constants import CommandType
+from .transporter._typings import (
     ICmdOnlySet,
     ICmdOnlyGet,
-    CMD_TYPE,
 )
 
 
-def build_set_request(cls: ICmdOnlySet, **kwargs) -> "struct_request.Request":
+def build_set_request(cls: ICmdOnlySet, **kwargs) -> Request:
     indices = kwargs.pop("indices", [])
-    module = kwargs.pop("module", NOTHING)
-    port = kwargs.pop("port", NOTHING)
+    module = kwargs.pop("module", None)
+    port = kwargs.pop("port", None)
     req_values = cls.SetDataAttr(**kwargs)
-    set_get = CommandType.COMMAND_VALUE.value
-    return struct_request.Request(
-        type(cls).__name__,
-        indices,
-        set_get,
-        cls.code,
-        module,
-        port,
-        req_values
+    return Request(
+        class_name=type(cls).__name__,
+        cmd_type=CommandType.COMMAND_VALUE,
+        cmd_code=cls.code,
+        module_index=module,
+        port_index=port,
+        indices=indices,
+        values=req_values
     )
 
 
-def build_get_request(cls: ICmdOnlyGet, **kwargs) -> "struct_request.Request":
+def build_get_request(cls: ICmdOnlyGet, **kwargs) -> Request:
     indices = kwargs.pop("indices", [])
-    module = kwargs.pop("module", NOTHING)
-    port = kwargs.pop("port", NOTHING)
+    module = kwargs.pop("module", None)
+    port = kwargs.pop("port", None)
     req_values = None
-    set_get = CommandType.COMMAND_QUERY.value
-    return struct_request.Request(
-        type(cls).__name__,
-        indices,
-        set_get,
-        cls.code,
-        module,
-        port,
-        req_values
+    return Request(
+        class_name=type(cls).__name__,
+        cmd_type=CommandType.COMMAND_QUERY,
+        cmd_code=cls.code,
+        module_index=module,
+        port_index=port,
+        indices=indices,
+        values=req_values
     )
-
-
-def build_from_bytes(cls: Type[CMD_TYPE], header: "struct_header.ResponseHeader", data: bytes) -> "struct_response.Response":
-    """Parse bytes retrieved from server to Response structure."""
-    properties_structure = getattr(cls, "GetDataAttr", None)
-    return struct_response.Response(header, cls.__name__, data, properties_structure)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/transporter/request_id.py` & `xoa-driver-2.0.0/xoa_driver/internals/core/transporter/_request_id_counter.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from enum import IntEnum
 import asyncio
+from enum import IntEnum
 
 
 class ReservedRequestID(IntEnum):
-    PUSH_REQUEST = 0
+    PUSH_REQUEST = 0x0
     REQUEST_ID_LIMIT = 0xFFFFFFFF
 
     @classmethod
     def started(cls) -> int:
         return max(list(cls)[:-1]).value
 
 
-class RequestId:
+class RequestIdCounter:
     """Aggrigator of request ID."""
     __slots__ = ("__req_id", "__lock",)
 
     def __init__(self) -> None:
         self.__req_id = ReservedRequestID.started()
         self.__lock = asyncio.Lock()
 
-    async def get_avaliable(self) -> int:
+    async def get_number(self) -> int:
         async with self.__lock:
             if self.__req_id >= ReservedRequestID.REQUEST_ID_LIMIT:
                 self.__req_id = ReservedRequestID.started()
             else:
                 self.__req_id += 1
             return self.__req_id
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/core/transporter/token.py` & `xoa-driver-2.0.0/xoa_driver/internals/core/token.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,34 +1,37 @@
+from __future__ import annotations
 from typing import (
-    TYPE_CHECKING,
+    Any,
+    Awaitable,
     TypeVar,
-    Generic,
+    # Generic,
+    Generator
 )
 from dataclasses import dataclass
-if TYPE_CHECKING:
-    from .. import interfaces
-    from .. import protocol
 
+from . import interfaces
+from .transporter.protocol.struct_request import Request
 
-AwaitableDataType = TypeVar("AwaitableDataType")
+
+AwaitableDataType = TypeVar("AwaitableDataType", covariant=True)
 
 
 @dataclass(frozen=True)
-class Token(Generic[AwaitableDataType]):
+class Token(Awaitable[AwaitableDataType]):
     """
     A wrapper of connection and request.
     Which can be used for await an single command or organized in to the ordered
     sequence of the commands which will be send to the server in single request.
     """
     __slots__ = ('connection', 'request',)
 
-    connection: "interfaces.IConnection"
-    request: "protocol.Request"
+    connection: interfaces.IConnection
+    request: Request
 
-    def __await__(self):
+    def __await__(self) -> Generator[Any, None, AwaitableDataType]:
         return self.__ask().__await__()
 
     async def __ask(self) -> AwaitableDataType:
         (
             data,
             fut
         ) = await self.connection.prepare_data(self.request)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/base_index.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/base_index.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/cg.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/cg.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,15 @@
     final,
     List,
     Type,
     TypeVar,
     TYPE_CHECKING,
 )
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_INDICES,
     P4G_CREATE,
     P4G_DELETE,
     P4G_ENABLE,
     P4G_COMMENT,
     P4G_CLEAR_COUNTERS,
     P4G_ROLE,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/histogram.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/histogram.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_TIME_HIST_CONF,
     P4G_PAYLOAD_HIST_CONF,
     P4G_TRANSACTION_HIST_CONF,
     P4G_APP_TRANSACTION_HIST,
     P4G_RECALC_TIME_HIST,
     P4G_RECALC_PAYLOAD_HIST,
     P4G_RECALC_TRANSACTION_HIST,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/l2.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/l2.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_L2_CLIENT_MAC,
     P4G_L2_SERVER_MAC,
     P4G_L2_USE_ADDRESS_RES,
     P4G_L2_USE_GW,
     P4G_L2_GW,
     P4G_L2_IPV6_GW,
     P4G_VLAN_ENABLE,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/l3.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/l3.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_CLIENT_RANGE,
     P4G_SERVER_RANGE,
     P4G_IP_DS_TYPE,
     P4G_IP_DS_VALUE,
     P4G_IP_DS_MASK,
     P4G_IP_DS_MINMAX,
     P4G_IP_DS_STEP,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/raw.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/raw.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_RAW_TEST_SCENARIO,
     P4G_RAW_PAYLOAD_TYPE,
     P4G_RAW_PAYLOAD_TOTAL_LEN,
     P4G_RAW_PAYLOAD,
     P4G_RAW_PAYLOAD_REPEAT_LEN,
     P4G_RAW_HAS_DOWNLOAD_REQ,
     P4G_RAW_CLOSE_CONN,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/replay.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/replay.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_REPLAY_FILE_INDICES,
     P4G_REPLAY_FILE_NAME,
     P4G_REPLAY_FILE_CLEAR,
     P4G_REPLAY_UTILIZATION,
     P4G_REPLAY_USER_INCARNATION,
     P4G_REPLAY_USER_REPETITIONS,
     P4G_APP_REPLAY_COUNTERS,
@@ -23,15 +23,15 @@
         self.__group_idx = group_idx
         self.indices = P4G_REPLAY_FILE_INDICES(conn, module_id, port_id, group_idx)
         """
         
         :type: P4G_REPLAY_FILE_INDICES
         """
 
-    def name(self, replay_file_idx: int) -> "P4G_REPLAY_FILE_NAME":  # TODO: Not sure about function name
+    def name(self, replay_file_idx: int) -> "P4G_REPLAY_FILE_NAME":
         """
         
         :type: P4G_REPLAY_FILE_NAME
         """
         return P4G_REPLAY_FILE_NAME(
             self.__conn,
             self.__module_id,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/tcp.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/tcp.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_CLEAR_POST_STAT,
     P4G_TCP_RTT_VALUE,
     P4G_TCP_STATE_CURRENT,
     P4G_TCP_STATE_TOTAL,
     P4G_TCP_STATE_RATE,
     P4G_TCP_RX_PAYLOAD_COUNTERS,
     P4G_TCP_TX_PAYLOAD_COUNTERS,
@@ -41,15 +41,15 @@
     """TCP ACK configuration"""
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, group_idx: int) -> None:
         self.duplicate_thresholds = P4G_TCP_DUP_THRES(conn, module_id, port_id, group_idx)
         """
         
         :type: P4G_TCP_DUP_THRES
         """
-        self.frequency = P4G_TCP_ACK_FREQUENCY(conn, module_id, port_id, group_idx)  # TODO: probably need a better name to be closer to cmd description
+        self.frequency = P4G_TCP_ACK_FREQUENCY(conn, module_id, port_id, group_idx)
         """
         
         :type: P4G_TCP_ACK_FREQUENCY
         """
         self.timeout = P4G_TCP_ACK_TIMEOUT(conn, module_id, port_id, group_idx)
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/tls.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/tls.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_TLS_ENABLE,
     P4G_TLS_CIPHER_SUITES,
     P4G_TLS_MAX_RECORD_SIZE,
     P4G_TLS_CERTIFICATE_FILENAME,
     P4G_TLS_PRIVATE_KEY_FILENAME,
     P4G_TLS_DHPARAMS_FILENAME,
     P4G_TLS_CLOSE_NOTIFY,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/udp.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/udp.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_UDP_PACKET_SIZE_TYPE,
     P4G_UDP_PACKET_SIZE_MINMAX,
     P4G_UDP_PACKET_SIZE_VALUE,
     P4G_UDP_STATE_CURRENT,
     P4G_UDP_STATE_TOTAL,
     P4G_UDP_STATE_RATE,
     P4G_UDP_RX_PAYLOAD_COUNTERS,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/connection_group/user_state.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/connection_group/user_state.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_USER_STATE_CURRENT,
     P4G_USER_STATE_TOTAL,
     P4G_USER_STATE_RATE,
 )
 
 
 class GUserState:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/filter/base_filter.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/filter/base_filter.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
     Type,
     TypeVar,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PF_INDICES,
     PF_CREATE,
     PF_DELETE,
     PF_ENABLE,
     PF_COMMENT,
     PF_CONDITION,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/filter/genuine_filter.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/filter/genuine_filter.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import PF_STRING
+from xoa_driver.internals.commands import PF_STRING
 
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from xoa_driver.internals.utils import kind
     from xoa_driver.internals.utils.indices import observer as idx_obs
 
 from .base_filter import BaseFilterIdx
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/length_term.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/length_term.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
     TypeVar,
     Type,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PL_INDICES,
     PL_CREATE,
     PL_DELETE,
     PL_LENGTH,
 )
 
 if TYPE_CHECKING:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/match_term.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/match_term.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     List,
     Type,
     TypeVar,
     TYPE_CHECKING,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PM_INDICES,
     PM_CREATE,
     PM_DELETE,
     PM_PROTOCOL,
     PM_POSITION,
     PM_MATCH,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/port_dataset.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/port_dataset.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
     TypeVar,
     Type,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PD_INDICES,
     PD_CREATE,
     PD_DELETE,
     PD_ENABLE,
     PD_SOURCE,
     PD_RANGE,
     PD_SAMPLES,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/streams/base_stream.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/streams/base_stream.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     List,
     Type,
     TypeVar,
     TYPE_CHECKING,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PS_INDICES,
     PS_CREATE,
     PS_DELETE,
     PS_ENABLE,
     PS_PACKETLIMIT,
     PS_COMMENT,
     PS_TPLDID,
@@ -79,15 +79,15 @@
         """32-bit modifier position, action, repetition
 
         :type: PS_MODIFIEREXT
         """
 
         self.range = PS_MODIFIEREXTRANGE(conn, module_id, port_id, stream_idx, modifier_idx)
         """32-bit modifier's range
-        
+
         :type: PS_MODIFIEREXTRANGE
         """
 
 
 class HModifier:
     """L23 Modifier Configuration"""
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, stream_idx: int, modifier_idx: int) -> None:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/indices/streams/genuine_stream.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/indices/streams/genuine_stream.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PS_INSERTFCS,
     PS_INJECTFCSERR,
 )
 from .base_stream import (
     BaseStreamIdx,
     SInjectError
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/base_module.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/base_module.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,16 +6,16 @@
     Generic
 )
 from abc import (
     ABC,
     abstractmethod,
 )
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     M_MODEL,
     M_PORTCOUNT,
     M_RESERVATION,
     M_RESERVEDBY,
     M_SERIALNO,
     M_VERSIONNO
 )
@@ -36,45 +36,45 @@
 
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         self._conn = conn
         self.module_id = init_data.module_id
         self.ports_count = init_data.ports_count
         self.reservation = M_RESERVATION(self._conn, self.module_id)
         """Test module's reservation action.
-                
+
         :type: M_RESERVATION
         """
 
         self.reserved_by = M_RESERVEDBY(self._conn, self.module_id)
         """Test module's reservation status.
-                
+
         :type: M_RESERVEDBY
         """
 
         self.model = M_MODEL(self._conn, self.module_id)
         """Test module's model.
-                
+
         :type: M_MODEL
         """
 
         self.serial_number = M_SERIALNO(self._conn, self.module_id)
         """Test module's serial number.
-                
+
         :type: M_SERIALNO
         """
 
         self.version_number = M_VERSIONNO(self._conn, self.module_id)
         """Test module's version number.
-                
+
         :type: M_VERSIONNO
         """
 
         self.port_count = M_PORTCOUNT(self._conn, self.module_id)
         """Max port count of the test module.
-                
+
         :type: M_PORTCOUNT
         """
 
     @property
     @abstractmethod
     def info(self) -> T:
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/module_chimera.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/module_chimera.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import typing
 import asyncio
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_STATUS,
     M_UPGRADE,
     M_UPGRADEPROGRESS,
     M_CFPTYPE,
     M_COMMENT,
     M_CAPABILITIES,
     M_CLOCKPPB,
@@ -18,117 +18,115 @@
     M_REVISION,
     M_MEDIA,
     M_MEDIASUPPORT,
     M_TIMESYNC,
     M_CLOCKSYNCSTATUS,
     M_NAME,
     M_CFPCONFIGEXT,
-    M_CFPCONFIG,
 )
 
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.utils import attributes as utils
 from xoa_driver.internals.state_storage import modules_state
 from xoa_driver import ports
 from . import base_module as bm
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from . import __interfaces as m_itf
 
 
 class ChTXClock:
     """
     Advanced timing feature (Chimera).
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.source = M_TXCLOCKSOURCE_NEW(conn, module_id)
         """
         The source that drives the TX clock rate of the ports on the test module.
-        
+
         :type: M_TXCLOCKSOURCE_NEW
         """
         self.status = M_TXCLOCKSTATUS_NEW(conn, module_id)
         """
         TX clock status of the test module.
-        
+
         :type: M_TXCLOCKSTATUS_NEW
         """
 
 
 class ChCFP:
     """
     CFP test module (Chimera).
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.type = M_CFPTYPE(conn, module_id)
         """
         The transceiver's CFP type currently inserted.
-        
+
         :type: M_CFPTYPE
         """
-        self.config = M_CFPCONFIG(conn, module_id)
-        """
-        The CFP configuration of the test module.
-        
-        :type: M_CFPCONFIG
-        """
-        self.config_extended = M_CFPCONFIGEXT(conn, module_id)
+        self.config = M_CFPCONFIGEXT(conn, module_id)
         """
         The CFP configuration of the test module.
-        
+
         :type: M_CFPCONFIGEXT
         """
 
 
 class ChUpgrade:
     """
     Upgrade test module (Chimera).
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.start = M_UPGRADE(conn, module_id)
         """
         Start the upgrade progress of the test module.
-        
+
         :type: M_UPGRADE
         """
         self.progress = M_UPGRADEPROGRESS(conn, module_id)
         """
         Upgrade progress status of the test module.
-        
+
         :type: M_UPGRADEPROGRESS
         """
 
+
 class ChTiming:
     """Test module timing and clock configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.source = M_TIMESYNC(conn, module_id)
         """Timing source of the test module.
 
         :type: M_TIMESYNC
         """
 
         self.clock_local_adjust = M_CLOCKPPB(conn, module_id)
         """Time adjustment controlling of the local clock of the test module, which drives the TX rate of the test ports.
-        
+
         :type: M_CLOCKPPB
         """
 
         self.clock_sync_status = M_CLOCKSYNCSTATUS(conn, module_id)
         """Test module's clock sync status.
 
         :type: M_CLOCKSYNCSTATUS
         """
 
 
 class ModuleChimera(bm.BaseModule["modules_state.ModuleLocalState"]):
     """
     This is a conceptual class of Chimera module.
     """
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
 
         self._local_states = modules_state.ModuleLocalState()
 
         self.tx_clock = ChTXClock(conn, self.module_id)
         """
@@ -157,50 +155,50 @@
 
         :type: ChUpgrade
         """
 
         self.capabilities = M_CAPABILITIES(conn, self.module_id)
         """
         Test module's capabilities.
-        
+
         :type: M_CAPABILITIES
         """
 
         self.comment = M_COMMENT(conn, self.module_id)
         """
         Test module's description.
-        
+
         :type: M_COMMENT
         """
 
         self.status = M_STATUS(conn, self.module_id)
         """
         Test module's status.
-        
+
         :type: M_STATUS
         """
 
         self.clock_ppb = M_CLOCKPPB(conn, self.module_id)
         """
         Test module's local clock adjustment.
-        
+
         :type: M_CLOCKPPB
         """
 
         self.emulator_bypass_mode = M_EMULBYPASS(conn, self.module_id)
         """
         Bypass mode of the Chimera module.
-        
+
         :type: M_EMULBYPASS
         """
 
         self.latency_mode = M_LATENCYMODE(conn, self.module_id)
         """
         Latency mode of the Chimera module.
-        
+
         :type: M_LATENCYMODE
         """
 
         self.revision = M_REVISION(conn, self.module_id)
         """Test module's model P/N name.
 
         :type: M_REVISION
@@ -249,20 +247,15 @@
         return self
 
     on_cfp_type_change = functools.partialmethod(utils.on_event, M_CFPTYPE)
     """
     Register a callback function to the event that the module's CFP type changes.
     """
 
-    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIG)
-    """
-    Register a callback function to the event that the module's CFP configuration changes.
-    """
-
-    on_cfp_config_extended_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
+    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
     """
     Register a callback function to the event that the module's CFP configuration changes.
     """
 
     on_status_change = functools.partialmethod(utils.on_event, M_STATUS)
     """
     Register a callback function to the event that the module's model changes.
@@ -300,50 +293,53 @@
     """Register a callback to the event that the module's clock that drives the port TX rates changes."""
 
 
 @typing.final
 @revisions.register_chimera_module(rev="Chimera-100G-5S-2P")
 class MChi100G5S2P(ModuleChimera):
     """Chimera module Chi-100G-5S-2P"""
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.PChi100G5S2P] = pm.PortsManager(
             conn=conn,
             ports_type=ports.PChi100G5S2P,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
         """Port index manager of Chi-100G-5S-2P
-        
+
         :type: PortsManager
         """
 
 
 @typing.final
 @revisions.register_chimera_module(rev="Chimera-100G-5S-2P[b]")
 class MChi100G5S2P_b(ModuleChimera):
     """Chimera module Chi-100G-5S-2P[b]"""
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.PChi100G5S2P_b] = pm.PortsManager(
             conn=conn,
             ports_type=ports.PChi100G5S2P_b,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
         """Port index manager of Chi-100G-5S-2P[b]
-        
+
         :type: PortsManager
         """
 
 
 @typing.final
-@revisions.register_chimera_module(rev="Chimera-40G-2S-2P")
+@revisions.register_chimera_module(rev="Chimera-40G-5S-2P")
 class MChi40G2S2P(ModuleChimera):
     """Chimera module Chi-40G-2S-2P"""
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.PChi40G2S2P] = pm.PortsManager(
             conn=conn,
             ports_type=ports.PChi40G2S2P,
             module_id=self.module_id,
             ports_count=self.ports_count
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/module_l23ve.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/module_l23ve.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import asyncio
 import typing
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_COMMENT,
     M_CAPABILITIES,
     M_MULTIUSER
 )
 from xoa_driver import ports
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.state_storage import modules_state
 from . import base_module as bm
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from . import __interfaces as m_itf
 
 
@@ -23,38 +23,38 @@
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
 
         self._local_states = modules_state.ModuleLocalState()
 
         self.comment = M_COMMENT(conn, self.module_id)
         """Test module's description.
-        
+
         :type: M_COMMENT
         """
 
         self.capabilities = M_CAPABILITIES(conn, self.module_id)
         """Test module's capabilities.
-        
+
         :type: M_CAPABILITIES
         """
 
         self.multiuser = M_MULTIUSER(conn, self.module_id)
         """If multiple users are allowed to control the same test module.
-        
+
         :type: M_MULTIUSER
         """
 
         self.ports: pm.PortsManager[ports.PortL23VE] = pm.PortsManager(
             conn=conn,
             ports_type=ports.PortL23VE,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
         """L23 VE Port index manager of this test module.
-        
+
         :type: PortsManager
         """
 
     @property
     def info(self) -> modules_state.ModuleLocalState:
         """Return the module's local state
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/module_l47.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/module_l47.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import asyncio
 import functools
 import typing
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_LICENSE_DEMO_INFO,
     M_LICENSE_MAINTENANCE_INFO,
     M_LICENSE_CWB_DETECTED,
     M_LICENSE_UPDATE,
     M_LICENSE_UPDATE_STATUS,
     M_LICENSE_LIST_BSON,
     M_LICENSE_ONLINE,
@@ -35,27 +35,28 @@
     M4_CAPTURE_FILE_DELETE,
     M4E_MODE,
     M4E_RESERVE,
     M4_TLS_CIPHER_SUITES,
 )
 from xoa_driver.internals.hli_v1 import revisions
 from xoa_driver.internals.utils import attributes as utils
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.state_storage import modules_state
 from xoa_driver import ports
 from . import base_module as bm
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from . import __interfaces as m_itf
 
 
 class License:
     """
     License management of a Vulcan tester.
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.demo_info = M_LICENSE_DEMO_INFO(conn, module_id)
         """
         Returns info about the demo status of the module.
 
         :type: M_LICENSE_DEMO_INFO
         """
@@ -103,14 +104,15 @@
         """
 
 
 class CaptureParse:
     """
     Parse a captured pcap file.
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.start = M4_REPLAY_PARSE_START(conn, module_id)
         """
         To start parsing an uploaded Capture File (in PCAP format) intended for use in a replay test scenario.
 
         :type: M4_REPLAY_PARSE_START
         """
@@ -137,14 +139,15 @@
         """
 
 
 class ReplayFile:
     """
     The pcap files to replay.
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.list_bson = M4_REPLAY_FILE_LIST_BSON(conn, module_id)
         """
         Returns a list of replay files formatted in BSON.
 
         :type: M4_REPLAY_FILE_LIST_BSON
         """
@@ -164,27 +167,29 @@
         """
 
 
 class Replay:
     """
     PCAP replay settings and control.
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.file = ReplayFile(conn, module_id)
         """
         Replay file settings and control.
-        
+
         :type: ReplayFile
         """
 
 
 class Capture:
     """
     Captured pcap file settings and control.
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.size = M4_CAPTURE_SIZE(conn, module_id)
         """
         Specify whether to capture whole packets(large) or truncated packets.
 
         :type: M4_CAPTURE_SIZE
         """
@@ -209,23 +214,24 @@
 
         :type: M4_CAPTURE_FILE_DELETE
         """
 
         self.parse = CaptureParse(conn, module_id)
         """
         Capture file parser settings.
-        
+
         :type: CaptureParse
         """
 
 
 class PacketEngine:
     """
     Packet engine.
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.license_info = M4_LICENSE_INFO(conn, module_id)
         """
         Returns the number of available and free PE licenses.
 
         :type: M4_LICENSE_INFO
         """
@@ -245,14 +251,15 @@
         """
 
 
 class ModuleSystem:
     """
     L47 module info.
     """
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.id = M4_SYSTEMID(conn, module_id)
         """
         The system identifier of the module.
 
         :type: M4_SYSTEMID
         """
@@ -272,14 +279,15 @@
 
 
 @revisions.register_vulcan_module(rev="Xena L47 Module")
 class ModuleL47(bm.BaseModule["modules_state.ModuleLocalState"]):
     """
     This is a conceptual class of L47 test module on a Vulcan tester.
     """
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
 
         self._local_states = modules_state.ModuleLocalState()
 
         self.version_number = M4_VERSIONNO(conn, self.module_id)
         """
@@ -314,62 +322,62 @@
         The system memory information.
 
         :type: M4_MEM_INFO
         """
 
         self.module_system = ModuleSystem(conn, self.module_id)
         """L47 module info.
-        
+
         :type: ModuleSystem
         """
 
         self.license = License(conn, self.module_id)
         """L47 license management.
-        
+
         :type: License
         """
 
         self.replay = Replay(conn, self.module_id)
         """L47 pcap replay.
-        
+
         :type: Replay
         """
-        
+
         self.capture = Capture(conn, self.module_id)
         """L47 capture to pcap files.
-        
+
         :type: Capture
         """
 
         self.packet_engine = PacketEngine(conn, self.module_id)
         """L47 packet engine.
-        
+
         :type: ~xoa_driver.internals.hli_v1.modules.module_l47.PacketEngine
         """
 
         self.ports: pm.PortsManager[ports.PortL47] = pm.PortsManager(
             conn=conn,
             ports_type=ports.PortL47,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
         """
         L47 Port index manager of this test module.
-        
+
         :type: PortsManager
         """
 
     @property
     def info(self) -> modules_state.ModuleLocalState:
         """Return the module's local state
 
         :return: the module's local state
         :rtype: ModuleLocalState
         """
-        
+
         return self._local_states
 
     async def _setup(self) -> Self:
         await asyncio.gather(
             self._local_states.initiate(self),
             self.ports.fill()
         )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_combi.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_combi.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import typing
 import functools
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.core.commands import P_CAPABILITIES
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.commands import P_CAPABILITIES
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.utils.cap_id import CapID
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
@@ -36,46 +36,48 @@
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-10G-4S-2P-Combi")
 class MOdin10G4S2PCombi(ModuleL23):
     """Test module Odin-10G-4S-2P-Combi
     """
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
         PORTS_MAP = {
             D_FAMELY_ID.to_int(): ports.POdin1G4S4PCombi,
             F_FAMELY_ID.to_int(): ports.POdin10G4S2PCombi,
         }
         self.ports: pm.PortsCombiManager[CombiTypes] = pm.PortsCombiManager(
             conn=conn,
             resolver=functools.partial(_port_resolver, port_map=PORTS_MAP),
             module_id=self.module_id,
             ports_count=self.ports_count
         )
         """Port Index Manager of Odin-10G-4S-2P-Combi
-        
+
         :type: PortsCombiManager
         """
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-10G-4S-2P-Combi[b]")
 class MOdin10G4S2PCombi_b(ModuleL23):
     """Test module Odin-10G-4S-2P-Combi[b]
     """
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
         PORTS_MAP = {
             D_FAMELY_ID.to_int(): ports.POdin1G4S4PCombi_b,
             F_FAMELY_ID.to_int(): ports.POdin10G4S2PCombi_b,
         }
         self.ports: pm.PortsCombiManager[CombiTypesB] = pm.PortsCombiManager(
             conn=conn,
             resolver=functools.partial(_port_resolver, port_map=PORTS_MAP),
             module_id=self.module_id,
             ports_count=self.ports_count
         )
         """Port Index Manager of Odin-10G-4S-2P-Combi[b]
-        
+
         :type: PortsCombiManager
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_d.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_d.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
-from xoa_driver import ports
-from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.v2 import ports
+from xoa_driver.internals.hli_v2 import revisions
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
@@ -20,15 +20,15 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S6P] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S6P,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port Index Manager of Odin-1G-3S-6P"""
+        """Port index manager of Odin-1G-3S-6P"""
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-1G-3S-6P[b]")
 class MOdin1G3S6P_b(ModuleL23):
     """Test module Odin-1G-3S-6P[b]"""
 
@@ -36,15 +36,15 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S6P_b] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S6P_b,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port Index Manager of Odin-1G-3S-6P[b]"""
+        """Port index manager of Odin-1G-3S-6P[b]"""
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-1G-3S-6P-E")
 class MOdin1G3S6PE(ModuleL23):
     """Test module Odin-1G-3S-6P-E"""
 
@@ -52,15 +52,15 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S6PE] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S6PE,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port Index Manager of Odin-1G-3S-6P-E"""
+        """Port index manager of Odin-1G-3S-6P-E"""
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-1G-3S-2P-T")
 class MOdin1G3S2PT(ModuleL23):
     """Test module Odin-1G-3S-2P-T"""
 
@@ -68,8 +68,8 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S2PT] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S2PT,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port Index Manager of Odin-1G-3S-2P-T"""
+        """Port index manager of Odin-1G-3S-2P-T"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_e.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_e.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_f.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_f.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_g.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_g.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_h.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_h.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_i.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_i.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_j.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_j.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_k.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_k.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_l.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_l.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_l1.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_l1.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_CLOCKPPBSWEEP,
     M_CLOCKSWEEPSTATUS,
 )
 
 
 class MClockSweep:
     """Test module local clock sweep"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_m.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_m.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/family_n.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_n.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver import ports
 from xoa_driver.internals.hli_v1 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/modules/modules_l23/module_l23_base.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/module_l23_base.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,28 +1,27 @@
 import asyncio
 import functools
 from typing import (
     TYPE_CHECKING,
     Optional,
 )
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_STATUS,
     M_UPGRADE,
     M_UPGRADEPROGRESS,
     M_TIMESYNC,
     M_CFPTYPE,
+    M_CFPCONFIGEXT,
     M_COMMENT,
     # M_TIMEADJUSTMENT,
     M_CAPABILITIES,
     M_MEDIASUPPORT,
     M_FPGAREIMAGE,
     M_MULTIUSER,
-    M_CFPCONFIGEXT,
-    M_CFPCONFIG,
     M_CLOCKPPB,
     M_SMAINPUT,
     M_SMAOUTPUT,
     M_SMASTATUS,
     M_NAME,
     M_REVISION,
     M_MEDIA,
@@ -31,45 +30,47 @@
     M_TXCLOCKSTATUS_NEW,
     M_TXCLOCKFILTER_NEW,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from xoa_driver.internals.utils import attributes as utils
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.state_storage import modules_state
 
 from .. import base_module as bm
 from .. import __interfaces as m_itf
 
 
 class TXClock:
     """Advanced timing clock"""
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.source = M_TXCLOCKSOURCE_NEW(conn, module_id)
         """The source that drives the TX clock rate of the ports on the test module.
 
         :type: M_TXCLOCKSOURCE_NEW
         """
 
         self.status = M_TXCLOCKSTATUS_NEW(conn, module_id)
         """TX clock status of the test module.
-        
+
         :type: M_TXCLOCKSTATUS_NEW
         """
 
         self.filter = M_TXCLOCKFILTER_NEW(conn, module_id)
         """Loop bandwidth on the TX clock filter of the test module.
 
         :type: M_TXCLOCKFILTER_NEW
         """
 
 
 class SMA:
     """SMA connector"""
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.input = M_SMAINPUT(conn, module_id)
         """SMA input of the test module.
 
         :type: M_SMAINPUT
         """
 
@@ -84,14 +85,15 @@
 
         :type: M_SMASTATUS
         """
 
 
 class AdvancedTiming:
     """Advanced Timing config and control"""
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.clock_tx = TXClock(conn, module_id)
         """Advanced timing clock config and status
 
         :type: TXClock
         """
 
@@ -100,28 +102,23 @@
 
         :type: SMA
         """
 
 
 class CFP:
     """Test module CFP"""
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.type = M_CFPTYPE(conn, module_id)
         """The transceiver's CFP type currently inserted.
 
         :type: M_CFPTYPE
         """
 
-        self.config = M_CFPCONFIG(conn, module_id)
-        """The CFP configuration of the test module.
-
-        :type: M_CFPCONFIG
-        """
-
-        self.config_extended = M_CFPCONFIGEXT(conn, module_id)
+        self.config = M_CFPCONFIGEXT(conn, module_id)
         """The CFP configuration of the test module.
 
         :type: M_CFPCONFIGEXT
         """
 
 
 class MTiming:
@@ -132,27 +129,28 @@
         """Timing source of the test module.
 
         :type: M_TIMESYNC
         """
 
         self.clock_local_adjust = M_CLOCKPPB(conn, module_id)
         """Time adjustment controlling of the local clock of the test module, which drives the TX rate of the test ports.
-        
+
         :type: M_CLOCKPPB
         """
 
         self.clock_sync_status = M_CLOCKSYNCSTATUS(conn, module_id)
         """Test module's clock sync status.
 
         :type: M_CLOCKSYNCSTATUS
         """
 
 
 class MUpgrade:
     """Test module upgrade"""
+
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.start = M_UPGRADE(conn, module_id)
         """Start the upgrade progress of the test module.
 
         :type: M_UPGRADE
         """
 
@@ -170,14 +168,15 @@
 
 
 class ModuleL23(bm.BaseModule["modules_state.ModuleL23LocalState"]):
     """
     This is a conceptual class of L23 test module on a Valkyrie tester.
 
     """
+
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
 
         self._local_states = modules_state.ModuleL23LocalState()
 
         self.name = M_NAME(conn, self.module_id)
         """Test module's name.
@@ -225,39 +224,39 @@
         """Test module's capabilities.
 
         :type: M_CAPABILITIES
         """
 
         self.timing = MTiming(conn, self.module_id)
         """Test module's timing configuration.
-        
+
         :type: MTiming
         """
 
         self.advanced_timing = AdvancedTiming(conn, self.module_id)
         """Test module's advanced timing configuration.
-        
+
         :type: AdvancedTiming
         """
 
         self.cfp = CFP(conn, self.module_id)
         """Test module's CFP configuration.
-        
+
         :type: CFP
         """
 
         self.upgrade = MUpgrade(conn, self.module_id)
         """Test module's upgrade settings.
 
         :type: MUpgrade
         """
 
         self.ports: Optional[pm.PortsManager] = None
         """L23 Port Index Manager of the test module.
-        
+
         :type: PortsManager
         """
 
     @property
     def info(self) -> modules_state.ModuleL23LocalState:
         """Return the module's local state
 
@@ -275,18 +274,15 @@
         )
         self._local_states.register_subscriptions(self)
         return self
 
     on_cfp_type_change = functools.partialmethod(utils.on_event, M_CFPTYPE)
     """Register a callback to the event that the module's CFP type (:class:`M_CFPTYPE`) changes."""
 
-    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIG)
-    """Register a callback to the event that the module's CFP configuration changes."""
-
-    on_cfp_config_extended_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
+    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
     """Register a callback to the event that the module's CFP configuration changes."""
 
     on_status_change = functools.partialmethod(utils.on_event, M_STATUS)
     """Register a callback to the event that the module's status changes."""
 
     on_revision_change = functools.partialmethod(utils.on_event, M_REVISION)
     """Register a callback to the event that the module's model type changes."""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/base_port.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/base_port.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,16 +5,16 @@
     abstractmethod,
 )
 from typing import (
     TYPE_CHECKING,
     TypeVar,
     Generic,
 )
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     P_RESERVATION,
     P_RESERVEDBY,
     P_RESET,
     P_COMMENT,
     P_INTERFACE,
     P_RECEIVESYNC,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_capture.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_capture.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_CAPTURE,
     PC_TRIGGER,
     PC_KEEP,
     PC_STATS,
     PC_EXTRA,
     PC_PACKET,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import functools
 import typing
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_CAPABILITIES,
     P_SPEED,
     P_SPEEDREDUCTION,
     P_INTERFRAMEGAP,
     P_MACADDRESS,
     P_IPADDRESS,
     P_ARPREPLY,
@@ -67,183 +67,183 @@
 
 class TxSinglePacket:
     """L23 port single-packet transmission"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.send = P_XMITONE(conn, module_id, port_id)
         """Send one packet from the L23 port without a stream config.
-        
+
         :type: P_XMITONE
         """
 
         self.time = P_XMITONETIME(conn, module_id, port_id)
         """The time at which the latest packet was transmitted using the P_XMITONE` command.
-        
+
         :type: P_XMITONETIME
         """
 
 
 class TxConfiguration:
     """L23 port TX configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.mode = P_TXMODE(conn, module_id, port_id)
         """L23 port TX mode.
-        
+
         :type: P_TXMODE
         """
 
         self.enable = P_TXENABLE(conn, module_id, port_id)
         """Enabling L23 port TX.
-        
+
         :type: P_TXENABLE
         """
 
         self.time_limit = P_TXTIMELIMIT(conn, module_id, port_id)
         """L23 port TX time limit.
-        
+
         :type: P_TXTIMELIMIT
         """
 
         self.time = P_TXTIME(conn, module_id, port_id)
         """L23 port TX time.
-        
+
         :type: P_TXTIME
         """
 
         self.prepare = P_TXPREPARE(conn, module_id, port_id)
         """Prepare L23 port for transmission.
-        
+
         :type: P_TXPREPARE
         """
 
         self.delay = P_TXDELAY(conn, module_id, port_id)
         """L23 port TX delay.
-        
+
         :type: P_TXDELAY
         """
 
         self.packet_limit = P_TXPACKETLIMIT(conn, module_id, port_id)
         """L23 port TX packet limit
-        
+
         :type: P_TXPACKETLIMIT
         """
 
         self.burst_period = P_TXBURSTPERIOD(conn, module_id, port_id)
         """L23 port TX burst period.
-        
+
         :type: P_TXBURSTPERIOD
         """
 
 
 class Rate:
     """L23 port TX rate"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.fraction = P_RATEFRACTION(conn, module_id, port_id)
         """L23 port rate in ppm.
-        
+
         :type: P_RATEFRACTION
         """
 
         self.pps = P_RATEPPS(conn, module_id, port_id)
         """L23 port rate in packets per second.
-        
+
         :type: P_RATEPPS
         """
 
         self.l2_bps = P_RATEL2BPS(conn, module_id, port_id)
         """L23 port rate in L2 bits per second.
-        
+
         :type: P_RATEL2BPS
         """
 
 
 class Multicast:
     """L23 port multicast configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.mode = P_MULTICAST(conn, module_id, port_id)
         """L23 port multicast mode.
-        
+
         :type: P_MULTICAST
         """
 
         self.mode_extended = P_MULTICASTEXT(conn, module_id, port_id)
         """L23 port multicast extended mode.
-        
+
         :type: P_MULTICASTEXT
         """
 
         self.source_list = P_MCSRCLIST(conn, module_id, port_id)
         """L23 port multicast source list.
-        
+
         :type: P_MCSRCLIST
         """
 
         self.header = P_MULTICASTHDR(conn, module_id, port_id)
         """L23 port multicast IGMP header.
-        
+
         :type: P_MULTICASTHDR
         """
 
 
 class IPv4:
     """L23 port IPv4 configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.address = P_IPADDRESS(conn, module_id, port_id)
         """L23 port IPv4 address.
-        
+
         :type: P_IPADDRESS
         """
 
         self.arp_reply = P_ARPREPLY(conn, module_id, port_id)
         """L23 port reply to ARP request.
-        
+
         :type: P_ARPREPLY
         """
 
         self.ping_reply = P_PINGREPLY(conn, module_id, port_id)
         """L23 port reply to PING request.
-        
+
         :type: P_PINGREPLY
         """
 
 
 class IPv6:
     """L23 port IPv6 configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.address = P_IPV6ADDRESS(conn, module_id, port_id)
         """L23 port IPv6 address.
-        
+
         :type: P_IPV6ADDRESS
         """
 
         self.arp_reply = P_ARPV6REPLY(conn, module_id, port_id)
         """L23 port reply to NDP Neighbor Solicitation.
-        
+
         :type: P_ARPV6REPLY
         """
 
         self.ping_reply = P_PINGV6REPLY(conn, module_id, port_id)
         """L23 port reply to PINGv6 request.
-        
+
         :type: P_PINGV6REPLY
         """
 
 
 class NetworkConfiguration:  # will be extended in genuine ports
     """L23 port networking configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.mac_address = P_MACADDRESS(conn, module_id, port_id)
         """L23 port MAC address.
-        
+
         :type: P_MACADDRESS
         """
 
         self.ipv4 = IPv4(conn, module_id, port_id)
         """L23 port IPv4 address configuration.
         """
 
@@ -254,260 +254,260 @@
 
 class LatencyConfiguration:
     """L23 port latency configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.offset = P_LATENCYOFFSET(conn, module_id, port_id)
         """L23 port latency offset.
-        
+
         :type: P_LATENCYOFFSET
         """
 
         self.mode = P_LATENCYMODE(conn, module_id, port_id)
         """L23 port latency measurement mode.
-        
+
         :type: P_LATENCYMODE
         """
 
 
 class Mix:
     """L23 port IMIX configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.weights = P_MIXWEIGHTS(conn, module_id, port_id)
         """L23 port IMIX weights
-        
+
         :type: P_MIXWEIGHTS
         """
 
         self.lengths = tuple(
             P_MIXLENGTH(conn, module_id, port_id, idx)
             for idx in range(16)
         )  # TODO: need to add manager for handle specific indices only
         """L23 port IMIX lengths.
-        
+
         :type: P_MIXLENGTH
         """
 
 
 class Speed:
     """L23 port speed configuration"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.current = P_SPEED(conn, module_id, port_id)
         """L23 port current speed in units of Mbps.
-        
+
         :type: P_SPEED
         """
 
         self.reduction = P_SPEEDREDUCTION(conn, module_id, port_id)
         """L23 port speed reduction in ppm.
-        
+
         :type: P_SPEEDREDUCTION
         """
 
 
 class Traffic:
     """L23 port traffic generation"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.state = P_TRAFFIC(conn, module_id, port_id)
         """L23 port traffic status and action.
-        
+
         :type: P_TRAFFIC
         """
 
         self.error = P_TRAFFICERR(conn, module_id, port_id)
         """L23 port traffic error.
-        
+
         :type: P_TRAFFICERR
         """
 
 
 class BasePortL23(base_port.BasePort[ports_state.PortL23LocalState]):
     """L23 port layout which is relevant to all L23 ports."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
         self.capabilities = P_CAPABILITIES(conn, module_id, port_id)
         """L23 port capabilities.
-        
+
         :type: P_CAPABILITIES
         """
 
         self.pause = P_PAUSE(conn, module_id, port_id)
         """L23 port response to Ethernet PAUSE frames.
-        
+
         :type: P_PAUSE
         """
 
         self.loop_back = P_LOOPBACK(conn, module_id, port_id)
         """L23 port loopback mode.
-        
+
         :type: P_LOOPBACK
         """
 
         self.errors_count = P_ERRORS(conn, module_id, port_id)
         """L23 port errors.
-        
+
         :type: P_ERRORS
         """
 
         self.interframe_gap = P_INTERFRAMEGAP(conn, module_id, port_id)
         """L23 port interframe gap.
-        
+
         :type: P_INTERFRAMEGAP
         """
 
         self.max_header_length = P_MAXHEADERLENGTH(conn, module_id, port_id)
         """L23 port maximum header length.
-        
+
         :type: P_MAXHEADERLENGTH
         """
 
         self.tpld_mode = P_TPLDMODE(conn, module_id, port_id)
         """L23 port test payload mode.
-        
+
         :type: P_TPLDMODE
         """
 
         self.pfc_enable = P_PFCENABLE(conn, module_id, port_id)
         """L23 port Ethernet Priority Flow Control (PFC).
-        
+
         :type: P_PFCENABLE
         """
 
         self.random_seed = P_RANDOMSEED(conn, module_id, port_id)
         """L23 port seed value.
-        
+
         :type: P_RANDOMSEED
         """
 
         self.payload_mode = P_PAYLOADMODE(conn, module_id, port_id)
         """L23 port payload mode.
-        
+
         :type: P_PAYLOADMODE
         """
 
         self.autotrain = P_AUTOTRAIN(conn, module_id, port_id)
         """L23 port interval between auto training packets.
-        
+
         :type: P_AUTOTRAIN
         """
 
         self.gap_monitor = P_GAPMONITOR(conn, module_id, port_id)
         """L23 port gap monitor.
-        
+
         :type: P_GAPMONITOR
         """
 
         self.checksum = P_CHECKSUM(conn, module_id, port_id)
         """L23 port extra payload integrity checksum.
-        
+
         :type: P_CHECKSUM
         """
 
         self.arp_rx_table = P_ARPRXTABLE(conn, module_id, port_id)
         """L23 port ARP table.
-        
+
         :type: P_ARPRXTABLE
         """
 
         self.ndp_rx_table = P_NDPRXTABLE(conn, module_id, port_id)
         """L23 port NDP table.
-        
+
         :type: P_NDPRXTABLE
         """
 
         self.capturer = PortCapture(conn, module_id, port_id)
         """L23 port capturer configuration.
-        
+
         :type: PortCapture
         """
 
         self.speed = Speed(conn, module_id, port_id)
         """L23 port speed configuration.
-        
+
         :type: Speed
         """
 
         self.traffic = Traffic(conn, module_id, port_id)
         """L23 port traffic configuration.
-        
+
         :type: Traffic
         """
 
         self.mix = Mix(conn, module_id, port_id)
         """L23 port IMIX configuration.
-        
+
         :type: Mix
         """
 
         self.latency_config = LatencyConfiguration(conn, module_id, port_id)
         """L23 port latency configuration.
-        
+
         self.latency_config = LatencyConfiguration(conn, module_id, port_id)
-        :type: 
+        :type:
         """
 
         self.rate = Rate(conn, module_id, port_id)
         """L23 port rate.
-        
+
         :type: Rate
         """
 
         self.tx_config = TxConfiguration(conn, module_id, port_id)
         """L23 port TX configuration.
-        
+
         :type: TxConfiguration
         """
 
         self.tx_single_pkt = TxSinglePacket(conn, module_id, port_id)
         """L23 port single-packet TX configuration.
-        
+
         :type: TxSinglePacket
         """
 
         self.multicast = Multicast(conn, module_id, port_id)
         """L23 port multicast configuration.
-        
+
         :type: Multicast
         """
 
         self.net_config = NetworkConfiguration(conn, module_id, port_id)
         """L23 port network configuration.
-        
+
         :type: NetworkConfiguration
         """
 
         self.local_states = ports_state.PortL23LocalState()
         """L23 port local states.
-        
+
         :type: PortL23LocalState
         """
 
         self.length_terms: LengthTermIndices = idx_mgr.IndexManager(
             conn,
             LengthTermIdx,
             module_id,
             port_id
         )
         """L23 port's length term index manager.
-        
+
         :type: LengthTermIndices
         """
 
         self.match_terms: MatchTermIndices = idx_mgr.IndexManager(
             conn,
             MatchTermIdx,
             module_id,
             port_id
         )
         """L23 port's match term index manager.
-        
+
         :type: MatchTermIndices
         """
 
     on_speed_change = functools.partialmethod(utils.on_event, P_SPEED)
     """Register a callback to the event that the port's speed changes."""
 
     on_traffic_change = functools.partialmethod(utils.on_event, P_TRAFFIC)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23_genuine.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_l23_genuine.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import functools
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_FLASH,
     P_SPEEDSELECTION,
     P_SPEEDS_SUPPORTED,
     P_UAT_MODE,
     P_UAT_FLR,
     P_STATUS,
     P_TCVRSTATUS,
@@ -37,21 +37,21 @@
 
 class SpeedMode:
     """L23 port's speed mode"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.selection = P_SPEEDSELECTION(conn, module_id, port_id)
         """L23 port speed mode selection.
-        
+
         :type: P_SPEEDSELECTION
         """
 
         self.supported = P_SPEEDS_SUPPORTED(conn, module_id, port_id)
         """L23 port's supported speed modes.
-        
+
         :type: P_SPEEDS_SUPPORTED
         """
 
 
 class GenuineSpeed(Speed):
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
@@ -61,21 +61,21 @@
 
 class UnAvailableTime:
     """UnAvailable Time"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.mode = P_UAT_MODE(conn, module_id, port_id)
         """L23 port's Unavailable Time mode.
-        
+
         :type: P_UAT_MODE
         """
 
         self.frame_loss_ratio = P_UAT_FLR(conn, module_id, port_id)
         """L23 port's Frame Loss Ratio for UAT.
-        
+
         :type: P_UAT_FLR
         """
 
 
 class PortStatistics:
     """L23 port statistics"""
 
@@ -93,39 +93,39 @@
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
 
         self._local_states = ports_state.PortL23GenuineLocalState()
 
         self.flash = P_FLASH(conn, module_id, port_id)
         """L23 port flashes.
-        
+
         :type: P_FLASH
         """
 
         self.status = P_STATUS(conn, module_id, port_id)
         """L23 port's received optical signal level'.
-        
+
         :type: P_STATUS
         """
 
         self.config_load_mode = P_LOADMODE(conn, module_id, port_id)
         """Chimera Port loading mode.
-        
+
         :type: P_LOADMODE
         """
 
         self.tcvr_status = P_TCVRSTATUS(conn, module_id, port_id)
         """L23 port transceiver status information.
-        
+
         :type: P_TCVRSTATUS
         """
 
         self.fec_mode = PP_FECMODE(conn, module_id, port_id)
         """L23 port FEC mode.
-        
+
         :type: PP_FECMODE
         """
 
         self.speed = GenuineSpeed(conn, module_id, port_id)
         """L23 port speed configuration.
 
         :type: GenuineSpeed
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_reception_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_reception_statistics.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import (
     TYPE_CHECKING,
     Dict,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PR_TPLDJITTER,
     PR_TOTAL,
     PR_NOTPLD,
     PR_EXTRA,
     PR_TPLDS,
     PR_TPLDTRAFFIC,
     PR_TPLDERRORS,
@@ -33,39 +33,39 @@
 
 class PrsTPLD:
     """L23 port's TPLD traffic statistics."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, tpld_idx: int) -> None:
         self.traffic = PR_TPLDTRAFFIC(conn, module_id, port_id, tpld_idx)
         """L23 port's statistics of traffic with TPLD.
-        
+
         :type: PR_TPLDTRAFFIC
         """
 
         self.traffic_ext = PR_TPLDTRAFFICEXT(conn, module_id, port_id, tpld_idx)
         """L23 port's statistics of traffic with TPLD. (extended)
         
         :type: PR_TPLDTRAFFICEXT
         """
 
         self.errors = PR_TPLDERRORS(conn, module_id, port_id, tpld_idx)
         """L23 port's error statistics of traffic with TPLD.
-        
+
         :type: PR_TPLDERRORS
         """
 
         self.latency = PR_TPLDLATENCY(conn, module_id, port_id, tpld_idx)
         """L23 port's latency statistics of traffic with TPLD.
-        
+
         :type: PR_TPLDLATENCY
         """
 
         self.jitter = PR_TPLDJITTER(conn, module_id, port_id, tpld_idx)
         """L23 port's jitter statistics of traffic with TPLD.
-        
+
         :type: PR_TPLDJITTER
         """
 
 
 class PortReceptionStatistics:
     """Port RX statistics"""
 
@@ -74,49 +74,49 @@
         self.__module_id = module_id
         self.__port_id = port_id
 
         self.__tpld_ids = PR_TPLDS(conn, module_id, module_id)
 
         self.total = PR_TOTAL(conn, module_id, port_id)
         """L23 port's total traffic statistics.
-        
+
         :type: PR_TOTAL
         """
 
         self.total_ext = PR_TOTALEXT(conn, module_id, port_id)
         """L23 port's total traffic statistics. (extended)
         
         :type: PR_TOTALEXT
         """
 
         self.no_tpld = PR_NOTPLD(conn, module_id, port_id)
         """L23 port's statistics of traffic without TPLD.
-        
+
         :type: PR_NOTPLD
         """
 
         self.no_tpld_ext = PR_NOTPLDEXT(conn, module_id, port_id)
         """L23 port's statistics of traffic without TPLD. (extended)
         
         :type: PR_NOTPLDEXT
         """
 
         self.extra = PR_EXTRA(conn, module_id, port_id)
         """L23 port's extra traffic statistics.
-        
+
         :type: PR_EXTRA
         """
         self.pfc_stats = PR_PFCSTATS(conn, module_id, port_id)
         """L23 port's statistics of received PFC packets.
-        
+
         :type: PR_PFCSTATS
         """
         self.clear = PR_CLEAR(conn, module_id, port_id)
         """Clear all RX statistics on the L23 port.
-        
+
         :type: PR_CLEAR
         """
 
     def obtain_filter_statistics(self, filter: int) -> "PR_FILTER":
         """Obtain L23 port filtered traffic statistics.
 
         :param filter: index of the filter
@@ -173,33 +173,33 @@
 # region Genuine Ports
 class GPrsUat():
     """L23 port UAT info."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.status = PR_UAT_STATUS(conn, module_id, port_id)
         """L23 port UAT status.
-        
+
         :type: PR_UAT_STATUS
         """
 
         self.time = PR_UAT_TIME(conn, module_id, port_id)
         """L23 port number of unavailable seconds.
-        
+
         :type: PR_UAT_TIME
         """
 
 
 class GenuinePortReceptionStatistics(PortReceptionStatistics):
     """L23 port RX statistics."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
         self.calibrate = PR_CALIBRATE(conn, module_id, port_id)
         """L23 port calibration of latency for received packets.
-        
+
         :type: PR_CALIBRATE
         """
 
         self.uat = GPrsUat(conn, module_id, port_id)
         """L23 port UAT info.
 
         :type: GPrsUat
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transceiver.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transceiver.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PX_RW,
     PX_MII,
     PX_TEMPERATURE,
     PX_RW_SEQ,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transmission_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/bases/port_transmission_statistics.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import (
     TYPE_CHECKING,
     Union,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from xoa_driver.internals.hli_v1.indices.streams.genuine_stream import GenuineStreamIdx
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PT_TOTAL,
     PT_NOTPLD,
     PT_STREAM,
     PT_CLEAR,
     PT_EXTRA,
     PT_TOTALEXT,
     PT_NOTPLDEXT,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/general.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/general.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,21 +3,21 @@
     Tuple,
     Type,
     TypeVar,
     TYPE_CHECKING
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import (
+from xoa_driver.internals.commands.enums import (
     FilterType,
     FilterVlanType,
     ProtocolOption,
     FilterMode,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PEF_ETHSETTINGS,
     PEF_ETHSRCADDR,
     PEF_ETHDESTADDR,
     PEF_L2PUSE,
     PEF_VLANSETTINGS,
     PEF_VLANTAG,
     PEF_VLANPCP,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/shadow.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/shadow.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,25 +2,26 @@
     TYPE_CHECKING,
     Dict,
     Type,
     Union
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import (
+from xoa_driver.internals.commands.enums import (
     FilterType,
     ProtocolOption,
     FilterMode,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PEF_INIT,
     PEF_APPLY,
     PEF_ENABLE,
     PEF_PROTOCOL,
     PEF_MODE,
+    PEF_CANCEL,
 )
 from . import general
 
 
 class ModeExtendedS(general.ModeExtended):
     async def use_segments(self, *segments: ProtocolOption) -> None:
         segments_payload = [
@@ -42,30 +43,35 @@
         self._module_id = module_id
         self._port_id = port_id
         self._flow_index = flow_index
         self._filter_type = FilterType.SHADOW
 
         self.initiating = PEF_INIT(conn, module_id, port_id, flow_index)
         """Preparing filter definition.
-        
+
         :type: PEF_INIT
         """
         self.apply = PEF_APPLY(conn, module_id, port_id, flow_index)
         """Apply filter definition.
-        
+
         :type: PEF_APPLY
         """
         self.enable = PEF_ENABLE(conn, module_id, port_id, flow_index, self._filter_type)
         """Enabling the filter.
-        
+
         :type: PEF_ENABLE
         """
+        self.cancel = PEF_CANCEL(conn, module_id, port_id, flow_index)
+        """Cancel changes made to Shadow and restores them to the ones in Working.
+
+        :type: PEF_CANCEL
+        """
         # self.mode = PEF_MODE(conn, module_id, port_id, flow_index, self._filter_type)
         # """Filter mode.
-        # 
+        #
         # :type: PEF_MODE`
         # """
 
     async def get_mode(self) -> Union[general.ModeBasic, ModeExtendedS]:
         mode_types: Dict[FilterMode, Type[Union[general.ModeBasic, ModeExtendedS]]] = {
             FilterMode.BASIC: general.ModeBasic,
             FilterMode.EXTENDED: ModeExtendedS,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/working.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/working.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,15 @@
     Dict,
     Type,
     Union,
     TYPE_CHECKING
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import (
+from xoa_driver.internals.commands.enums import (
     FilterType,
     FilterMode,
 )
 from . import general
 
 
 class FilterDefinitionWorking:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_custom_distribution.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_custom_distribution.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PEC_INDICES,
     PEC_VAL,
     PEC_COMMENT,
     PEC_DELETE,
     PEC_DISTTYPE,
 )
 
@@ -22,27 +22,27 @@
         self.__observer = observer
         self.__conn = conn
         self.__module_id = module_id
         self.__port_id = port_id
         self.__cdi = custom_distribution_index
         self.definition = PEC_VAL(conn, module_id, port_id, custom_distribution_index)
         """Custom distribution definition.
-        
+
         :type: PEC_VAL
         """
 
         self.comment = PEC_COMMENT(conn, module_id, port_id, custom_distribution_index)
         """Custom distribution description.
-        
+
         :type: PEC_COMMENT
         """
 
         self.type = PEC_DISTTYPE(conn, module_id, port_id, custom_distribution_index)
         """Custom distribution type.
-        
+
         :type: PEC_DISTTYPE
         """
 
     async def delete(self) -> None:
         """
         Deleting an existing Custom Distribution
         """
@@ -78,15 +78,15 @@
             CustomDistribution(
                 self.__observer,
                 self.__conn,
                 self.__module_id,
                 self.__port_id,
                 idx
             )
-            for idx in _resp.indices
+            for idx in _resp.indexations
         ]
 
     def __len__(self) -> int:
         """Return the number of existing indices"""
         return len(self.__items)
 
     def __iter__(self):
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_distribution.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/pe_distribution.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import ImpairmentTypeIndex
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands.enums import ImpairmentTypeIndex
+from xoa_driver.internals.commands import (
     PED_SCHEDULE,
     PED_ONESHOTSTATUS,
     PED_OFF,
     PED_FIXED,
     PED_RANDOM,
     PED_BER,
     PED_FIXEDBURST,
@@ -46,33 +46,33 @@
 
         self.off = PED_OFF(conn, module_id, port_id, flow_index, impairment_type_index)
         """Impairments Distribution to OFF.
 
         :type: PED_OFF
         """
 
-        self.fixed = PED_FIXED(conn, module_id, port_id, flow_index, impairment_type_index)
+        self.fixed_rate = PED_FIXED(conn, module_id, port_id, flow_index, impairment_type_index)
         """Fixed Rate distribution configuration.
 
         :type: PED_FIXED
         """
 
-        self.random = PED_RANDOM(conn, module_id, port_id, flow_index, impairment_type_index)
+        self.random_rate = PED_RANDOM(conn, module_id, port_id, flow_index, impairment_type_index)
         """Random Rate distribution configuration.
 
         :type: PED_RANDOM
         """
 
         self.bit_error_rate = PED_BER(conn, module_id, port_id, flow_index, impairment_type_index)
         """Bit Error Rate distribution configuration.
 
         :type: PED_BER
         """
 
-        self.random = PED_RANDOMBURST(conn, module_id, port_id, flow_index, impairment_type_index)
+        self.random_burst = PED_RANDOMBURST(conn, module_id, port_id, flow_index, impairment_type_index)
         """Random Burst configuration.
 
         :type: PED_RANDOMBURST
         """
 
         self.ge = PED_GE(conn, module_id, port_id, flow_index, impairment_type_index)
         """Gilbert-Elliot distribution configuration.
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_chimera.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_chimera.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import asyncio
 import functools
 from typing import TYPE_CHECKING
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_CAPABILITIES,
     P_INTERFACE,
     P_STATUS,
     P_TXENABLE,
     P_LOADMODE,
     P_EMULATE,
 )
@@ -24,47 +24,48 @@
 class PortChimera(base_port.BasePort[ports_state.PortChimeraLocalState]):
     """Chimera port for traffic impairment."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
         self.capabilities = P_CAPABILITIES(conn, module_id, port_id)
         """Chimera port capabilities.
-        
+
         :type: P_CAPABILITIES
         """
 
         self.interface = P_INTERFACE(conn, module_id, port_id)
         """Physical interface type of the Chimera port.
-        
+
         :type: P_INTERFACE
         """
 
         self.status = P_STATUS(conn, module_id, port_id)
         """Chimera port's received optical signal level'.
-        
+
         :type: P_STATUS
         """
 
         self.tx_enable = P_TXENABLE(conn, module_id, port_id)
         """Enabling Chimera port TX.
-        
+
         :type: P_TXENABLE
         """
 
         self.load_mode = P_LOADMODE(conn, module_id, port_id)
         """Load mode of the Chimera port.
-        
+
         :type: P_LOADMODE
         """
 
-        self.emulation = ChimeraPE(self._conn, *self.kind)  # TODO: Missing description
+        self.emulation = ChimeraPE(self._conn, *self.kind)
+        """Chimera Port Emulation """
 
         self.emulate = P_EMULATE(conn, module_id, port_id)
         """Chimera port emulation control.
-        
+
         :type: P_EMULATE
         """
 
         self.custom_distributions = CustomDistributions(conn, module_id, port_id)
         """Custom distributions."""
 
         self.pcs_pma = PcsPma(conn, self)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_emulation.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/port_emulation.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 from typing import (
     TYPE_CHECKING,
     Tuple,
 )
-from dataclasses import astuple
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PE_FCSDROP,
     PE_TPLDMODE,
     PE_COMMENT,
     PE_INDICES,
     PE_LATENCYRANGE,
     PE_CORRUPT,
     PE_MISORDER,
@@ -43,86 +42,86 @@
 
 class CTotalFlow:
     """Total flow statistics."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
         self.drop_packets = PE_FLOWDROPTOTAL(conn, module_id, port_id, flow_index)
         """Statistics of all packets dropped in a flow.
-        
+
         :type: PE_FLOWDROPTOTAL
         """
 
         self.latency_packets = PE_FLOWLATENCYTOTAL(conn, module_id, port_id, flow_index)
         """Statistics of all packets delayed in a flow.
-        
+
         :type: PE_FLOWLATENCYTOTAL
         """
 
         self.duplicated_packets = PE_FLOWDUPTOTAL(conn, module_id, port_id, flow_index)
         """Statistics of all packets duplicate in a flow.
-        
+
         :type: PE_FLOWDUPTOTAL
         """
 
         self.mis_ordered_packets = PE_FLOWMISTOTAL(conn, module_id, port_id, flow_index)
         """Statistics of all packets misordered in a flow.
-        
+
         :type: PE_FLOWMISTOTAL
         """
 
         self.corrupted_packets = PE_FLOWCORTOTAL(conn, module_id, port_id, flow_index)
         """Statistics of all packets corrupted in a flow.
-        
+
         :type: PE_FLOWCORTOTAL
         """
 
         self.jittered_packets = PE_FLOWJITTERTOTAL(conn, module_id, port_id, flow_index)
         """Statistics of all packets jittered in a flow.
-        
+
         :type: PE_FLOWJITTERTOTAL
         """
 
 
 class StatisticsTotals:
     """Total port statistics."""
 
     def __init__(self, conn, module_id, port_id) -> None:
         self.drop = PE_DROPTOTAL(conn, module_id, port_id)
         """Statistics of all packets dropped on the port.
-        
+
         :type: PE_DROPTOTAL
         """
 
         self.latency = PE_LATENCYTOTAL(conn, module_id, port_id)
         """Statistics of all packets delayed on the port.
-        
+
         :type: PE_LATENCYTOTAL
         """
 
         self.duplicated = PE_DUPTOTAL(conn, module_id, port_id)
         """Statistics of all packets duplicated on the port.
-        
+
         :type: PE_DUPTOTAL
         """
 
         self.mis_ordered = PE_MISTOTAL(conn, module_id, port_id)
         """Statistics of all packets mirordered on the port.
-        
+
         :type: PE_MISTOTAL
         """
 
         self.corrupted = PE_CORTOTAL(conn, module_id, port_id)
         """Statistics of all packets corrupted on the port.
-        
+
         :type: PE_CORTOTAL
         """
 
         self.jittered = PE_JITTERTOTAL(conn, module_id, port_id)
         """Statistics of all packets jittered on the port.
-        
+
         :type: PE_JITTERTOTAL
         """
 
 
 class CFlowStatistics:
     """Per flow statistics."""
 
@@ -134,61 +133,61 @@
         """TX statistics."""
 
         self.total = CTotalFlow(conn, module_id, port_id, flow_index)
         """Total flow statistics."""
 
         self.clear = PE_FLOWCLEAR(conn, module_id, port_id, flow_index)
         """Clear the impairment statistics on a flow.
-        
+
         :type: PE_FLOWCLEAR
         """
 
 
 class CBandwidth:
     """Bandwidth configuration."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
         self.policer = PE_BANDPOLICER(conn, module_id, port_id, flow_index)
         """Bandwidth policer configuration.
-        
+
         :type: PE_BANDPOLICER
         """
 
         self.shaper = PE_BANDSHAPER(conn, module_id, port_id, flow_index)
         """Bandwidth shaper configuration.
-        
+
         :type: PE_BANDSHAPER
         """
 
 
 class CFlow:
     """Flow settings."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
         self.comment = PE_COMMENT(conn, module_id, port_id, flow_index)
         """Flow description.
-        
+
         :type: PE_COMMENT
         """
 
         self.latency_range = PE_LATENCYRANGE(conn, module_id, port_id, flow_index)
         """Flow latency range.
-        
+
         :type: PE_LATENCYRANGE
         """
 
         self.corruption = PE_CORRUPT(conn, module_id, port_id, flow_index)
         """Corruption type.
-        
+
         :type: PE_CORRUPT
         """
 
         self.misordering = PE_MISORDER(conn, module_id, port_id, flow_index)
         """Misordering depth
-        
+
         :type: PE_MISORDER
         """
 
         self.bandwidth_control = CBandwidth(conn, module_id, port_id, flow_index)
         """Bandwidth configuration."""
 
         self.statistics = CFlowStatistics(conn, module_id, port_id, flow_index)
@@ -209,37 +208,37 @@
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self._conn = conn
         self.module_id = module_id
         self.port_id = port_id
         self.drop_fcs_errors = PE_FCSDROP(conn, module_id, port_id)
         """Action on FCS errors.
-        
+
         :type: PE_FCSDROP
         """
 
         self.clear = PE_CLEAR(conn, module_id, port_id)
         """Clear impairment statistics.
-        
+
         :type: PE_CLEAR
         """
 
         self.statistics = StatisticsTotals(conn, module_id, port_id)
         """Total port statistics."""
 
         self.tpld_mode = PE_TPLDMODE(conn, module_id, port_id)
         """TPLD mode.
-        
+
         :type: PE_TPLDMODE
         """
 
         self.flows: Tuple["CFlow", ...] = tuple()
 
     def __await__(self):
         return self._setup().__await__()
 
     async def _setup(self) -> None:
-        indices = astuple(await PE_INDICES(self._conn, self.module_id, self.port_id).get())
+        indices = await PE_INDICES(self._conn, self.module_id, self.port_id).get()
         self.flows = tuple(
             CFlow(self._conn, self.module_id, self.port_id, idx)
-            for idx in indices
+            for idx in indices.to_tuple()
         )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/reception_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/reception_statistics.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PR_FLOWTOTAL,
     PR_FLOWCLEAR,
 )
 
 
 class ReceptionStatistics:
     """Chimera RX statistics."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
         self.total = PR_FLOWTOTAL(conn, module_id, port_id, flow_index)
         """RX statistics of a flow.
-        
+
         :type: PR_FLOWTOTAL
         """
 
         self.clear = PR_FLOWCLEAR(conn, module_id, port_id, flow_index)
         """Clear RX statistics of a flow.
-        
+
         :type: PR_FLOWCLEAR
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/chimera/transmission_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/chimera/transmission_statistics.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PT_FLOWTOTAL,
     PT_FLOWCLEAR,
 )
 
 
 class TransmissionStatistics:
     """Chimera TX statistics."""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_combi.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_combi.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import P_AUTONEGSELECTION
+from xoa_driver.internals.commands import P_AUTONEGSELECTION
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
 from . import family_f
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_d.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_d.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_MDIXMODE,
     P_AUTONEGSELECTION,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_e.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_e.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_AUTONEGSELECTION,  # questionable which ports are electrical
     P_LPENABLE,
     P_LPTXMODE,
     P_LPSTATUS,
     P_LPPARTNERAUTONEG,
     P_LPSNRMARGIN,
     P_LPRXPOWER,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_f.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_f.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import functools
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
     P_TXRUNTLENGTH,
     P_RXRUNTLENGTH,
     P_RXRUNTLEN_ERRS,
     P_TXPREAMBLE_REMOVE,
     P_RXPREAMBLE_INSERT,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_g.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_g.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
@@ -13,45 +13,40 @@
     PcsPma,
     SerDes,
 )
 
 
 class FamilyG(BasePortL23Genuine):
     pcs_pma: PcsPma
-    """PCS/PMA layer
-
-    :type: PcsPma
+    """PCS/PMA settings.
+        
+    :type: ~xoa_driver.internals.hli_v1.ports.port_l23.pcs_pma_ghijkl.PcsPma
     """
     
-    ser_des: Tuple[SerDes, ...]
+    serdes: Tuple[SerDes, ...]
     """SerDes index
 
     :type: Tuple[SerDes, ...]
     """
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
         self.dynamic = P_DYNAMIC(conn, module_id, port_id)
         """L23 port's dynamic traffic change.
         
         :type: P_DYNAMIC
         """
 
-        self.pcs_pma = PcsPma(conn, self)
-        """PCS/PMA settings.
-        
-        :type: ~xoa_driver.internals.hli_v1.ports.port_l23.pcs_pma_ghijkl.PcsPma
-        """
-
     async def _setup(self) -> Self:
         await super()._setup()
         self.serdes = tuple(
             SerDes(self._conn, *self.kind, serdes_xindex=serdes_xindex)
             for serdes_xindex in range(self.info.capabilities.serdes_count)
         )
+        self.pcs_pma = PcsPma(self._conn, self)
         return self
 
     on_dynamic_change = functools.partialmethod(utils.on_event, P_DYNAMIC)
     """Register a callback to the event that the port's dynamic traffic setting changes."""
 
 
 class PLoki100G3S1P(FamilyG):
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_h.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_h.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
 from .pcs_pma_ghijkl import (
-    # PcsPma,
+    PcsPma,
     SerDes,
 )
 
 
 class FamilyH(BasePortL23Genuine):
-    ser_des: Tuple[SerDes, ...]
+    serdes: Tuple[SerDes, ...]
     """SerDes index
 
     :type: Tuple[SerDes, ...]
     """
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
@@ -41,14 +41,27 @@
     on_dynamic_change = functools.partialmethod(utils.on_event, P_DYNAMIC)
     """Register a callback to the event that the port's dynamic traffic setting changes."""
 
 
 class PLoki100G5S1P(FamilyH):
     """L23 port on Loki-100G-5S-1P module.
     """
-    ...
+
+    pcs_pma: PcsPma
+    """PCS/PMA settings.
+        
+    :type: ~xoa_driver.internals.hli_v1.ports.port_l23.pcs_pma_ghijkl.PcsPma
+    """
+
+    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
+        super().__init__(conn, module_id, port_id)
+
+    async def _setup(self) -> Self:
+        await super()._setup()
+        self.pcs_pma = PcsPma(self._conn, self)
+        return self
 
 
 class POdin100G3S1P(FamilyH):
     """L23 port on Odin-100G-3S-1P module.
     """
     ...
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_i.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_i.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_FAULTSIGNALING,
     P_FAULTSTATUS,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_j.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_j.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     # P_FAULTSIGNALING,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_k.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_k.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     # P_FAULTSIGNALING,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_l.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_l.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     # P_FAULTSIGNALING,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_l1.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_l1.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
     # PL1_AUTONEGINFO,
     # PL1_LINKTRAININFO,
     # PL1_LOG,
     # PL1_CFG_TMP,
 )
 from xoa_driver.internals.utils import attributes as utils
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/family_m.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/family_m.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from typing import TYPE_CHECKING
 
-from xoa_driver.internals.core.commands import P_BRRMODE
+from xoa_driver.internals.commands import P_BRRMODE
 
 from .bases.port_l23_genuine import BasePortL23Genuine
 
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/fault_jkl.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/fault_jkl.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_FAULTSIGNALING,
     P_FAULTSTATUS,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ghijkl.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ghijkl.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import (
     TYPE_CHECKING,
     Tuple,
 )
 from typing_extensions import Self
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PP_ALARMS_ERRORS,
     PP_TXLANECONFIG,
     PP_TXLANEINJECT,
     PP_TXPRBSCONFIG,
     PP_TXERRORRATE,
     PP_TXINJECTONE,
     PP_RXTOTALSTATS,
@@ -43,177 +43,177 @@
 
 class PcsPmaAlarms:
     """L23 high-speed port PCS/PMA alarms"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.errors = PP_ALARMS_ERRORS(conn, module_id, port_id)
         """Error count of each alarm on a L23 high-speed port.
-        
+
         :type: PP_ALARMS_ERRORS
         """
 
 
 class PcsPmaTransceiver:
     """L23 high-speed port PCS/PMA transceivers"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.tx_laser_power = PP_TXLASERPOWER(conn, module_id, port_id)
         """Power of TX laser.
-        
+
         :type: PP_TXLASERPOWER
         """
 
         self.rx_laser_power = PP_RXLASERPOWER(conn, module_id, port_id)
         """Power of RX laser.
-        
+
         :type: PP_RXLASERPOWER
         """
 
 
 class PcsPmaRxLaneStatus:
     """L23 high-speed port PCS/PMA lane status"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, lane_idx: int) -> None:
         self.errors = PP_RXLANEERRORS(conn, module_id, port_id, lane_idx)
         """RX lane error statistics.
-        
+
         :type: PP_RXLANEERRORS
         """
 
         self.lock = PP_RXLANELOCK(conn, module_id, port_id, lane_idx)
         """RX lane lock.
-        
+
         :type: PP_RXLANELOCK
         """
 
         self.status = PP_RXLANESTATUS(conn, module_id, port_id, lane_idx)
         """RX lane status
-        
+
         :type: PP_RXLANESTATUS
         """
 
 
 class PcsPmaTxErrorGeneration:
     """L23 high-speed port PCS/PMA TX error generation."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.error_rate = PP_TXERRORRATE(conn, module_id, port_id)
         """The rate of continuous bit-level error injection.
-        
+
         :type: PP_TXERRORRATE
         """
 
         self.inject_one = PP_TXINJECTONE(conn, module_id, port_id)
         """Inject a single bit-level error.
-        
+
         :type: PP_TXINJECTONE
         """
 
 
 class PcsPmaRx:
     """L23 high-speed port PCS/PMA RX"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.total_status = PP_RXTOTALSTATS(conn, module_id, port_id)
         """RX FEC total counters.
-        
+
         :type: PP_RXTOTALSTATS
         """
 
         self.fec_status = PP_RXFECSTATS(conn, module_id, port_id)
         """RX FEC statistics.
-        
+
         :type: PP_RXFECSTATS
         """
 
         self.clear = PP_RXCLEAR(conn, module_id, port_id)
         """Clear all the PCS/PMA receiver statistics.
-        
+
         :type: PP_RXCLEAR
         """
 
 
 class PcsPmaPhy:
     """L23 high-speed port PCS/PMA PHY settings."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.auto_neg = PP_PHYAUTONEG(conn, module_id, port_id)
         """ Auto-negotiation settings of the PHY.
-        
+
         :type: PP_PHYAUTONEG
         """
 
         self.signal_status = PP_PHYSIGNALSTATUS(conn, module_id, port_id)
         """The PHY signal status.
-        
+
         :type: PP_PHYSIGNALSTATUS
         """
 
         self.settings = PP_PHYSETTINGS(conn, module_id, port_id)
         """Low-level PHY settings
-        
+
         :type: PP_PHYSETTINGS
         """
 
 
 class Lane:
     """L23 high-speed port lane configuration and status."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, lane_idx: int) -> None:
         self.rx_status = PcsPmaRxLaneStatus(conn, module_id, port_id, lane_idx)
         """PCS/PMA RX lane status.
         """
 
         self.tx_error_inject = PP_TXLANEINJECT(conn, module_id, port_id, lane_idx)
         """Inject CAUI error into a TX lane.
-        
+
         :type: PP_TXLANEINJECT
         """
 
         self.tx_config = PP_TXLANECONFIG(conn, module_id, port_id, lane_idx)
         """TX lane configuration.
-        
+
         :type: PP_TXLANECONFIG
         """
 
 
 class PcsPma:
     """L23 high-speed port PCS/PMA"""
 
     def __init__(self, conn: "itf.IConnection", port) -> None:
         self._conn = conn
         self.__port = port
 
         self.alarms = PcsPmaAlarms(conn, *port.kind)
         """PCS/PMA alarms
-        
+
         :type: PcsPmaAlarms
         """
 
         self.transceiver = PcsPmaTransceiver(conn, *port.kind)
         """PCS/PMA transceiver
-        
+
         :type: PcsPmaTransceiver
         """
 
         self.error_gen = PcsPmaTxErrorGeneration(conn, *port.kind)
         """PCS/PMA error generation
-        
+
         :type: PcsPmaTxErrorGeneration
         """
 
         self.rx = PcsPmaRx(conn, *port.kind)
         """PCS/PMA RX
-        
+
         :type: PcsPmaRx
         """
 
         self.phy = PcsPmaPhy(conn, *port.kind)
         """PCS/PMA PHY
-        
+
         :type: PcsPmaPhy
         """
 
         self.prbs_config = PRBSConfig(conn, *port.kind)
         """PCS/PMA PRBS Configuration
         
         :type: PRBSConfig
@@ -227,66 +227,66 @@
 
 class PRBSConfig:
     """L23 high-speed port PRBS configuration."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.type = PP_PRBSTYPE(conn, module_id, port_id)
         """PRBS type used when in PRBS mode.
-        
+
         :type: PP_PRBSTYPE
         """
 
         self.tx_type = PP_TXPRBSTYPE(conn, module_id, port_id)
         """TX PRBS type used when in PRBS mode.
-        
+
         :type: PP_TXPRBSTYPE
         """
 
         self.rx_type = PP_RXPRBSTYPE(conn, module_id, port_id)
         """RX PRBS type used when in PRBS mode.
-        
+
         :type: PP_RXPRBSTYPE
         """
 
 
 class SDEyeDiagram:
     """L23 high-speed port SerDes eye diagram."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, serdes_xindex: int) -> None:
         self.__conn = conn
         self.__module_id = module_id
         self.__port_id = port_id
         self.__serdes_index = serdes_xindex
         self.measure = PP_EYEMEASURE(conn, module_id, port_id, serdes_xindex)
         """BER eye measurement.
-        
+
         :type: PP_EYEMEASURE
         """
 
         self.resolution = PP_EYERESOLUTION(conn, module_id, port_id, serdes_xindex)
         """Resolution for BER eye measurement.
-        
+
         :type: PP_EYERESOLUTION
         """
 
         self.info = PP_EYEINFO(conn, module_id, port_id, serdes_xindex)
         """Information of BER eye measurement.
-        
+
         :type: PP_EYEINFO
         """
 
         self.ber = PP_EYEBER(conn, module_id, port_id, serdes_xindex)
         """BER estimation of an eye diagram.
-        
+
         :type: PP_EYEBER
         """
 
         self.dwell_bits = PP_EYEDWELLBITS(conn, module_id, port_id, serdes_xindex)
         """Dwell bits for an eye capture.
-        
+
         :type: PP_EYEDWELLBITS
         """
 
     def __await__(self):
         return self._setup().__await__()
 
     async def _setup(self) -> Self:
@@ -306,73 +306,78 @@
 
 class SDPhy:
     """L23 high-speed port SerDes PHY configuration and status."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, serdes_xindex: int) -> None:
         self.tx_equalizer = PP_PHYTXEQ(conn, module_id, port_id, serdes_xindex)
         """Equalizer settings of the on-board PHY in the TX direction.
-        
+
         :type: PP_PHYTXEQ
         """
 
         self.rx_equalizer = PP_PHYRXEQ(conn, module_id, port_id, serdes_xindex)
         """Equalizer settings of the on-board PHY in the RX direction.
-        
+
         :type: PP_PHYRXEQ
         """
 
         self.retune = PP_PHYRETUNE(conn, module_id, port_id, serdes_xindex)
         """Retuning of the PHY.
-        
+
         :type: PP_PHYRETUNE
         """
 
         self.autotune = PP_PHYAUTOTUNE(conn, module_id, port_id, serdes_xindex)
         """Autotune of the PHY.
-        
+
         :type: PP_PHYAUTOTUNE
         """
 
 
 class Prbs:
     """L23 high-speed port SerDes PRBS configuration and status."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, serdes_xindex: int) -> None:
         self.tx_config = PP_TXPRBSCONFIG(conn, module_id, port_id, serdes_xindex)
         """TX PRBS configuration of a SerDes.
-        
+
         :type: PP_TXPRBSCONFIG
         """
 
         self.status = PP_RXPRBSSTATUS(conn, module_id, port_id, serdes_xindex)
         """RX PRBS status on a SerDes
-        
+
         :type: PP_RXPRBSSTATUS
         """
 
+        self.config = PRBSConfig(conn, module_id, port_id)
+        """
+        L23 high-speed port PRBS configuration.
+        """
+
 
 class SerDes:
     """L23 high-speed port SerDes configuration and status."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, serdes_xindex: int) -> None:
         self.prbs = Prbs(conn, module_id, port_id, serdes_xindex)
         """PRBS configuration
-        
+
         :type: Prbs
         """
 
         self.phy = SDPhy(conn, module_id, port_id, serdes_xindex)
         """PHY configuration
-        
+
         :type: SDPhy
         """
 
         self.eye_diagram = SDEyeDiagram(conn, module_id, port_id, serdes_xindex)
         """Eye diagram
-        
+
         :type: SDEyeDiagram
         """
 
     def __await__(self):
         return self._setup().__await__()
 
     async def _setup(self) -> Self:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ijkl_chimera.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_ijkl_chimera.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PP_LINKFLAP_PARAMS,
     PP_LINKFLAP_ENABLE,
     PP_PMAERRPUL_PARAMS,
     PP_PMAERRPUL_ENABLE,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_l.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/pcs_pma_l.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     Tuple,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PP_AUTONEG,
     PP_AUTONEGSTATUS,
     PP_LINKTRAIN,
     PP_LINKTRAINSTATUS,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l23/port_l23ve.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l23/port_l23ve.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from typing import TYPE_CHECKING
 from .bases.port_l23 import BasePortL23
 from .bases.port_reception_statistics import PortReceptionStatistics
 from .bases.port_transmission_statistics import PortTransmissionStatistics
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_MDIXMODE,
     # P_ENGINENAMES, # TODO: need to implement
     # P_ENGINELOAD, # TODO: need to implement
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 from xoa_driver.internals.utils.indices import index_manager as idx_mgr
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/counters.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/counters.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4_ETH_TX_COUNTERS,
     P4_ETH_RX_COUNTERS,
     P4_PORT_TX_COUNTERS,
     P4_PORT_RX_COUNTERS,
     P4_PORT_COUNTERS,
     P4_IPV4_RX_COUNTERS,
     P4_IPV4_TX_COUNTERS,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/main.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/main.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4_TRAFFIC,
     P4_STATE,
     P4_CAPABILITIES,
     P4_STATE_STATUS,
     P4_VLAN_OFFLOAD,
     P4_ARP_CONFIG,
     P4_NDP_CONFIG,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/ports/port_l47/packet_engine.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/ports/port_l47/packet_engine.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4E_ASSIGN,
     P4E_AVAILABLE,
     P4E_ALLOCATE,
     P4E_ALLOCATION_INFO,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/_base_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/_base_tester.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,50 +1,48 @@
+from __future__ import annotations
 from typing import (
     TypeVar,
     Awaitable,
     Generic,
     Callable,
     Generator,
     Any
 )
 from abc import (
     ABC,
     abstractmethod,
 )
 import functools
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     C_RESERVATION,
     C_DOWN,
     C_PASSWORD,
     C_TIME,
     C_CAPABILITIES,
     C_DEBUGLOGS,
     C_NAME,
     C_MODEL,
     C_COMMENT,
     C_VERSIONNO,
     C_SERIALNO,
     C_RESERVEDBY,
     C_FLASH,
 )
-from xoa_driver.internals.core.transporter import (
-    establish_connection,
-    TransportationHandler,
-)
-
-import xoa_driver.internals.hli_v1.testers._tester_session as session
+from xoa_driver.internals.core.funcs import establish_connection
+from xoa_driver.internals.core.transporter.handler import TransportationHandler
+from xoa_driver.internals.core.transporter.logger import CustomLogger
+from xoa_driver.internals.utils import session
 from xoa_driver.internals.state_storage import testers_state
 
 
 T = TypeVar('T', bound="BaseTester")
 TesterStateStorage = TypeVar('TesterStateStorage', bound="testers_state.TesterLocalState")
 
 
-# TODO: lately update imports to correct style
 # min version = 83.2
 class BaseTester(ABC, Generic[TesterStateStorage]):
     """
     Basic Tester class.
 
     :param host: tester's address/hostname
     :type host: str
@@ -53,19 +51,22 @@
     :param password: login password of the tester, defaults to "xena"
     :type password: str, optional
     :param port: the port number for connection establishment, default to 22606
     :type port: int, optional
     :param debug: `True` if debug log output from the tester is needed, and `False` otherwise
     :type debug: int, optional
     """
-    
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
+
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
         self.__host = host
         self.__port = port
-        self._conn = TransportationHandler(debug=debug)
+        self._conn = TransportationHandler(
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
         self.session = session.TesterSession(
             self._conn,
             username,
             password=password,
             keepalive=True,
         )
         """
@@ -164,15 +165,15 @@
             async def skip():
                 return self
             return skip().__await__()
         return self._setup().__await__()
 
     async def _setup(self: T) -> T:
         await establish_connection(self._conn, self.__host, self.__port)
-        await self.session
+        await self.session.logon()
         return self
 
     def __is_reservation(self, reserved_status: enums.ReservedStatus) -> bool:
         return self.info.reservation == reserved_status
 
     is_released = functools.partialmethod(__is_reservation, enums.ReservedStatus.RELEASED)
     """Validate if the tester is released.
@@ -192,17 +193,16 @@
     @abstractmethod
     def info(self) -> TesterStateStorage:
         """
         Tester's local information.
 
         :type: TesterStateStorage
         """
-        
-        raise NotImplementedError()
 
+        raise NotImplementedError()
 
     # region Events
 
     # We are not supporting Subscription on Connection made, coz Connection is happens at Awaiting of instance
     # but subscription only registered after instance is already created, means already connected,
     # means On_connected event will never b called, it's can be tweaked, but then Creating process of tester instance
     # will be less intuitive, and in one case subscription will work while in another not.
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/_tester_session.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/session.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,19 +1,18 @@
 import asyncio
 from typing import (
     TYPE_CHECKING,
     Tuple
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.transporter import funcs
-from xoa_driver.internals.core.transporter.exceptions import BadStatus
+from xoa_driver.internals.core import funcs
+from xoa_driver.internals.core.exceptions import XmpBadValueError
 from xoa_driver.internals import exceptions
-from xoa_driver import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_LOGON,
     C_LOGOFF,
     C_OWNER,
     C_TIMEOUT,
     C_KEEPALIVE,
     C_INDICES,
     C_STATSESSION,
@@ -31,42 +30,47 @@
     :param password: login password of the tester, defaults to "xena"
     :type password: str, optional
     :param timeout_seconds: the timeout to close idle connection
     :type port: int, optional
     :param keepalive: `True` if keepalive signal is needed, and `False` otherwise, defaults to `False`.
     :type keepalive: bool, optional
     """
-    
+
     __slots__ = ("_conn", "owner_name", "pwd", "timeout", "keepalive")
-    
+
     def __init__(self, conn: "itf.IConnection", owner_name: str, password: str = "xena", timeout_seconds: int = 130, keepalive: bool = False) -> None:
         self._conn = conn
         self.owner_name = owner_name
         self.pwd = password
         self.timeout = timeout_seconds
         self.keepalive = keepalive
 
-    def __await__(self):
-        return self.__setup().__await__()
+    async def logon(self) -> "TesterSession":
+        logon, *_ = await funcs.apply(
+            C_LOGON(self._conn).set(self.pwd),
+            C_OWNER(self._conn).set(self.owner_name),
+            C_TIMEOUT(self._conn).set(self.timeout),
+            return_exceptions=True,
+            token_timeout_sec=1.0
+        )
+        if isinstance(logon, XmpBadValueError):
+            raise exceptions.WrongTesterPasswordError(self.pwd) from None
 
-    async def __setup(self) -> "TesterSession":
-        try:
-            await funcs.apply(
-                C_LOGON(self._conn).set(self.pwd),
-                C_OWNER(self._conn).set(self.owner_name),
-                C_TIMEOUT(self._conn).set(self.timeout),
-            )
-        except BadStatus as e:
-            if e.response.class_name == "C_LOGON" and e.response.command_status == enums.CommandStatus.BADVALUE:
-                raise exceptions.WrongTesterPasswordError(self.pwd) from None
-            raise e
         if self.keepalive:
-            asyncio.create_task(self.__do_keepalive(), name="keepalive")  # TODO: need to handle this task on interruption
+            asyncio.create_task(self.__do_keepalive(), name="keepalive").add_done_callback(
+                self.__handle_exceptions
+            )
         return self
 
+    def __handle_exceptions(self, fut: asyncio.Future) -> None:
+        if fut.cancelled():
+            return None
+        elif e := fut.exception():
+            raise e
+
     async def __do_keepalive(self) -> None:
         while self._conn.is_connected:
             await C_KEEPALIVE(self._conn).get()
             await asyncio.sleep(max(0, self.timeout - 5))
 
     @property
     def is_online(self) -> bool:
@@ -93,12 +97,12 @@
 
         :return: a list of session information
         :rtype: List[C_STATSESSION]
         """
 
         sessions = await C_INDICES(self._conn).get()
         session_ids = sessions.session_ids
-        query_sessions = [
-            C_STATSESSION(self._conn, session_xindex=sid).get()
+        query_sessions = (
+            C_STATSESSION(self._conn, _session_xindex=sid).get()
             for sid in session_ids
-        ]
+        )
         return tuple(await funcs.apply(*query_sessions))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/rest_api.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/rest_api.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_RESTPORT,
     C_RESTENABLE,
     C_RESTSTATUS,
     C_RESTCONTROL,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/time_keeper.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/time_keeper.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_TKLICFILE,
     C_TKLICSTATE,
     C_TKSTATUS,
     C_TKSTATUSEXT,
     C_TKSVCSTATE,
     C_TKGPSSTATE,
     C_TKCONFIG,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/l_23/upload_file.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/l_23/upload_file.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_FILESTART,
     C_FILEDATA,
     C_FILEFINISH
 )
 
 
 class UploadFile:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/genuine/management_interface.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/genuine/management_interface.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_IPADDRESS,
     C_DHCP,
     C_MACADDRESS,
     C_HOSTNAME,
 )
 
 
@@ -12,31 +12,31 @@
     Tester management interface address configuration.
     """
 
     def __init__(self, conn: "itf.IConnection") -> None:
         self.ip_address = C_IPADDRESS(conn)
         """
         Chassis management port IP address configuration.
-        
+
         :type: C_IPADDRESS
         """
 
         self.dhcp = C_DHCP(conn)
         """
         Chassis management port IP address configuration with DHCP.
-                
+
         :type: C_DHCP
         """
 
         self.macaddress = C_MACADDRESS(conn)
         """
         Chassis management port MAC address.
-                
+
         :type: C_MACADDRESS
         """
 
         self.hostname = C_HOSTNAME(conn)
         """
         Chassis hostname.
-                
+
         :type: C_HOSTNAME
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l23_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l23_tester.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,39 @@
+from __future__ import annotations
 from typing import (
     Union,
     TYPE_CHECKING,
     Type,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_PORTCOUNTS,
     C_MULTIUSER,
     C_TRAFFIC,
     C_TRAFFICSYNC,
     C_VERSIONNO_MINOR,
     C_BUILDSTRING,
 )
-from xoa_driver.internals.utils.modules_manager import ModulesManager
+from xoa_driver.internals.utils.managers import modules_manager as mm
 from ._base_tester import BaseTester
 from .genuine import management_interface as mi
 from .genuine.l_23 import (
     upload_file,
     time_keeper,
     rest_api,
 )
 if TYPE_CHECKING:
     from xoa_driver import modules
 
+from xoa_driver.internals.core.transporter.logger import CustomLogger
 from xoa_driver.internals.state_storage import testers_state
 from xoa_driver.internals.hli_v1 import revisions
 from xoa_driver.internals import exceptions
 
 
-TypeL23Manager = ModulesManager[
+TypeL23Manager = mm.ModulesManager[
     Union[
         "modules.GenericL23Module",
         "modules.ModuleChimera",
     ]
 ]
 
 
@@ -64,24 +66,31 @@
     :param password: login password of the tester, defaults to "xena"
     :type password: str, optional
     :param port: the port number for connection establishment, default to 22606
     :type port: int, optional
     :param debug: `True` if debug log output from the tester is needed, and `False` otherwise
     :type debug: int, optional
     """
-    
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
-        super().__init__(host=host, username=username, password=password, port=port, debug=debug)
-        
+
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
+        super().__init__(
+            host=host,
+            username=username,
+            password=password,
+            port=port,
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
+
         self._local_states = testers_state.GenuineTesterLocalState(host, port)
-        
+
         self.management_interface = mi.ManagementInterface(self._conn)
         """
         The management interface address configuration includes IP address, DHCP settings, MAC address and hostname.
-        
+
         :type: ManagementInterface
         """
 
         self.upload_file = upload_file.UploadFile(self._conn)
         """
         File upload functions of the tester.
 
@@ -120,48 +129,47 @@
 
         self.traffic_sync = C_TRAFFICSYNC(self._conn)
         """
         This can be used to start traffic simultaneously on multiple chassis. The ports are identified by pairs of integers (module port).
 
         :type: C_TRAFFICSYNC
         """
-        
+
         self.version_no_minor = C_VERSIONNO_MINOR(self._conn)
         """
         Get the minor version number of the tester firmware.
 
         :type: C_VERSIONNO_MINOR
         """
 
         self.build_string = C_BUILDSTRING(self._conn)
         """
         Identify the hostname of the PC that builds the xenaserver. It uniquely identifies the build of a xenaserver.
 
         :type: C_BUILDSTRING
         """
 
-        self.modules: TypeL23Manager = ModulesManager(self._conn, get_module_type)
+        self.modules: TypeL23Manager = mm.ModulesManager(self._conn, get_module_type)
         """
         Module Index Manager of the L23 tester.
 
         :type: ModulesManager
         """
-    
+
     @property
     def info(self) -> testers_state.GenuineTesterLocalState:
         """Return tester's local state
 
         :return: tester's local state
         :rtype: GenuineTesterLocalState
         """
         return self._local_states
-    
+
     async def _setup(self):
         await super()._setup()
         await self._local_states.initiate(self)
         self._local_states.register_subscriptions(self)
-        
+
         ft_pc = await C_PORTCOUNTS(self._conn).get()
         port_counts = ft_pc.port_counts
         await self.modules.fill_l23(port_counts)
         return self
-
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l23ve_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l23ve_tester.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,29 @@
+from __future__ import annotations
 from typing import Type
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_PORTCOUNTS,
     C_MULTIUSER,
     C_TRAFFIC,
     C_TRAFFICSYNC,
     C_VERSIONNO_MINOR,
 )
-from xoa_driver.internals.utils.modules_manager import ModulesManager
+from xoa_driver.internals.core.transporter.logger import CustomLogger
+from xoa_driver.internals.utils.managers import modules_manager as mm
 from ._base_tester import BaseTester
 
 
 from xoa_driver import modules
 from xoa_driver.internals.state_storage import testers_state
 
 
-TypeL23Manager = ModulesManager["modules.ModuleL23VE"]
+TypeL23Manager = mm.ModulesManager["modules.ModuleL23VE"]
 
 
-def get_module_type(revision: str) -> Type:
+def get_module_type(_: str) -> Type:
     return modules.ModuleL23VE
 
 
 class L23VeTester(BaseTester["testers_state.TesterLocalState"]):
     """
     This is a conceptual class of Xena ValkyrieVE Tester.
     It is essentially an extended :class:`BaseTester`.
@@ -35,23 +37,30 @@
     :type password: str, optional
     :param port: the port number for connection establishment, default to 22606
     :type port: int, optional
     :param debug: `True` if debug log output from the tester is needed, and `False` otherwise
     :type debug: int, optional
     """
 
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
-        super().__init__(host=host, username=username, password=password, port=port, debug=debug)
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
+        super().__init__(
+            host=host,
+            username=username,
+            password=password,
+            port=port,
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
 
         self._local_states = testers_state.TesterLocalState(host, port)
 
         self.multiuser = C_MULTIUSER(self._conn)
         """
         Enable or disable the ability to control one resource from several different TCP connections.
-        
+
         :type:  C_MULTIUSER
         """
 
         self.traffic = C_TRAFFIC(self._conn)
         """
         Starts or stops the traffic on a number of ports on the chassis simultaneously.
         The ports are identified by pairs of integers (module port).
@@ -69,15 +78,15 @@
         self.version_no_minor = C_VERSIONNO_MINOR(self._conn)
         """
         Get the minor version number of the tester firmware.
 
         :type: C_VERSIONNO_MINOR
         """
 
-        self.modules: TypeL23Manager = ModulesManager(self._conn, get_module_type)
+        self.modules: TypeL23Manager = mm.ModulesManager(self._conn, get_module_type)
         """
         Module Index Manager of the L23 VE tester.
 
         :type: ModulesManager
         """
 
     @property
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l47_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l47_tester.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,17 +1,19 @@
+from __future__ import annotations
 from typing import (
     TYPE_CHECKING,
     Type
 )
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_REMOTEPORTCOUNTS,
     C_BUILDSTRING,
 )
-from xoa_driver.internals.utils.modules_manager import ModulesManager
+from xoa_driver.internals.core.transporter.logger import CustomLogger
+from xoa_driver.internals.utils.managers import modules_manager as mm
 from xoa_driver.internals.hli_v1 import revisions
 from xoa_driver.internals import exceptions
 if TYPE_CHECKING:
     from xoa_driver.internals.hli_v1.modules import module_l47 as ml47
 
 from xoa_driver.internals.state_storage import testers_state
 from ._base_tester import BaseTester
@@ -42,34 +44,41 @@
     :type password: str, optional
     :param port: the port number for connection establishment, default to 22606
     :type port: int, optional
     :param debug: `True` if debug log output from the tester is needed, and `False` otherwise
     :type debug: int, optional
     """
 
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
-        super().__init__(host=host, username=username, password=password, port=port, debug=debug)
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
+        super().__init__(
+            host=host,
+            username=username,
+            password=password,
+            port=port,
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
 
         self._local_states = testers_state.GenuineTesterLocalState(host, port)
 
         self.build_string = C_BUILDSTRING(self._conn)
         """
         Identify the hostname of the PC that builds the xenaserver. It uniquely identifies the build of a xenaserver.
 
         :type: C_BUILDSTRING
         """
 
         self.management_interface = mi.ManagementInterface(self._conn)
         """
         The management interface address configuration includes IP address, DHCP settings, MAC address and hostname.
-        
+
         :type: ManagementInterface
         """
 
-        self.modules: ModulesManager["ml47.ModuleL47"] = ModulesManager(self._conn, get_module_type)
+        self.modules: mm.ModulesManager["ml47.ModuleL47"] = mm.ModulesManager(self._conn, get_module_type)
         """
         Module Index Manager of the tester.
 
         :type: ModulesManager
         """
 
     @property
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v1/testers/l47ve_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/testers/l47ve_tester.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,12 +1,13 @@
-
-from xoa_driver.internals.core.commands import (
+from __future__ import annotations
+from xoa_driver.internals.commands import (
     C_BUILDSTRING,
     C_VERSIONNO_MINOR
 )
+from xoa_driver.internals.core.transporter.logger import CustomLogger
 from .l47_tester import L47Tester
 
 
 class L47VeTester(L47Tester):
     """
     This is a conceptual class of Xena VulcanVE Tester.
     It is essentially an extended :class:`BaseTester`.
@@ -20,16 +21,23 @@
     :type password: str, optional
     :param port: the port number for connection establishment, default to 22606
     :type port: int, optional
     :param debug: `True` if debug log output from the tester is needed, and `False` otherwise
     :type debug: int, optional
     """
 
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
-        super().__init__(host=host, username=username, password=password, port=port, debug=debug)
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
+        super().__init__(
+            host=host,
+            username=username,
+            password=password,
+            port=port,
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
         self.version_no_minor = C_VERSIONNO_MINOR(self._conn)
         """
         Get the minor version number of the tester firmware.
 
         :type: C_VERSIONNO_MINOR
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/base_index.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/base_index.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/cg.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/cg.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,15 @@
     final,
     List,
     Type,
     TypeVar,
     TYPE_CHECKING,
 )
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_INDICES,
     P4G_CREATE,
     P4G_DELETE,
     P4G_ENABLE,
     P4G_COMMENT,
     P4G_CLEAR_COUNTERS,
     P4G_ROLE,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/histogram.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/histogram.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_TIME_HIST_CONF,
     P4G_PAYLOAD_HIST_CONF,
     P4G_TRANSACTION_HIST_CONF,
     P4G_APP_TRANSACTION_HIST,
     P4G_RECALC_TIME_HIST,
     P4G_RECALC_PAYLOAD_HIST,
     P4G_RECALC_TRANSACTION_HIST,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/l2.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/l2.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_L2_CLIENT_MAC,
     P4G_L2_SERVER_MAC,
     P4G_L2_USE_ADDRESS_RES,
     P4G_L2_USE_GW,
     P4G_L2_GW,
     P4G_L2_IPV6_GW,
     P4G_VLAN_ENABLE,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/l3.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/l3.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_CLIENT_RANGE,
     P4G_SERVER_RANGE,
     P4G_IP_DS_TYPE,
     P4G_IP_DS_VALUE,
     P4G_IP_DS_MASK,
     P4G_IP_DS_MINMAX,
     P4G_IP_DS_STEP,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/raw.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/raw.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_RAW_TEST_SCENARIO,
     P4G_RAW_PAYLOAD_TYPE,
     P4G_RAW_PAYLOAD_TOTAL_LEN,
     P4G_RAW_PAYLOAD,
     P4G_RAW_PAYLOAD_REPEAT_LEN,
     P4G_RAW_HAS_DOWNLOAD_REQ,
     P4G_RAW_CLOSE_CONN,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/replay.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/replay.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_REPLAY_FILE_INDICES,
     P4G_REPLAY_FILE_NAME,
     P4G_REPLAY_FILE_CLEAR,
     P4G_REPLAY_UTILIZATION,
     P4G_REPLAY_USER_INCARNATION,
     P4G_REPLAY_USER_REPETITIONS,
     P4G_APP_REPLAY_COUNTERS,
@@ -22,15 +22,15 @@
         self.__port_id = port_id
         self.__group_idx = group_idx
         self.indices = P4G_REPLAY_FILE_INDICES(conn, module_id, port_id, group_idx)
         """
         Representation of P4G_REPLAY_FILE_INDICES
         """
 
-    def name(self, replay_file_idx: int) -> "P4G_REPLAY_FILE_NAME":  # TODO: Not sure about function name
+    def name(self, replay_file_idx: int) -> "P4G_REPLAY_FILE_NAME":
         """
         Representation of P4G_REPLAY_FILE_NAME
         """
         return P4G_REPLAY_FILE_NAME(
             self.__conn,
             self.__module_id,
             self.__port_id,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/tcp.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/tcp.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_CLEAR_POST_STAT,
     P4G_TCP_RTT_VALUE,
     P4G_TCP_STATE_CURRENT,
     P4G_TCP_STATE_TOTAL,
     P4G_TCP_STATE_RATE,
     P4G_TCP_RX_PAYLOAD_COUNTERS,
     P4G_TCP_TX_PAYLOAD_COUNTERS,
@@ -40,15 +40,15 @@
 class GAckTcp:
     """TCP ACK configuration"""
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, group_idx: int) -> None:
         self.duplicate_tresholds = P4G_TCP_DUP_THRES(conn, module_id, port_id, group_idx)
         """
         Representation of P4G_TCP_DUP_THRES
         """
-        self.frequency = P4G_TCP_ACK_FREQUENCY(conn, module_id, port_id, group_idx)  # TODO: probably need a better name to be closer to cmd description
+        self.frequency = P4G_TCP_ACK_FREQUENCY(conn, module_id, port_id, group_idx)
         """
         Representation of P4G_TCP_ACK_FREQUENCY
         """
         self.timeout = P4G_TCP_ACK_TIMEOUT(conn, module_id, port_id, group_idx)
         """
         Representation of P4G_TCP_ACK_TIMEOUT
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/tls.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/tls.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_TLS_ENABLE,
     P4G_TLS_CIPHER_SUITES,
     P4G_TLS_MAX_RECORD_SIZE,
     P4G_TLS_CERTIFICATE_FILENAME,
     P4G_TLS_PRIVATE_KEY_FILENAME,
     P4G_TLS_DHPARAMS_FILENAME,
     P4G_TLS_CLOSE_NOTIFY,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/udp.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/udp.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_UDP_PACKET_SIZE_TYPE,
     P4G_UDP_PACKET_SIZE_MINMAX,
     P4G_UDP_PACKET_SIZE_VALUE,
     P4G_UDP_STATE_CURRENT,
     P4G_UDP_STATE_TOTAL,
     P4G_UDP_STATE_RATE,
     P4G_UDP_RX_PAYLOAD_COUNTERS,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/connection_group/user_state.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/connection_group/user_state.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4G_USER_STATE_CURRENT,
     P4G_USER_STATE_TOTAL,
     P4G_USER_STATE_RATE,
 )
 
 
 class GUserState:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/filter/base_filter.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/filter/base_filter.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
     Type,
     TypeVar,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PF_INDICES,
     PF_CREATE,
     PF_DELETE,
     PF_ENABLE,
     PF_COMMENT,
     PF_CONDITION,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/filter/genuine_filter.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/filter/genuine_filter.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import PF_STRING
+from xoa_driver.internals.commands import PF_STRING
 
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from xoa_driver.internals.utils import kind
     from xoa_driver.internals.utils.indices import observer as idx_obs
 
 from .base_filter import BaseFilterIdx
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/length_term.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/length_term.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
     TypeVar,
     Type,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PL_INDICES,
     PL_CREATE,
     PL_DELETE,
     PL_LENGTH,
 )
 
 if TYPE_CHECKING:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/match_term.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/match_term.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     List,
     Type,
     TypeVar,
     TYPE_CHECKING,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PM_INDICES,
     PM_CREATE,
     PM_DELETE,
     PM_PROTOCOL,
     PM_POSITION,
     PM_MATCH,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/port_dataset.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/port_dataset.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
     TypeVar,
     Type,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PD_INDICES,
     PD_CREATE,
     PD_DELETE,
     PD_ENABLE,
     PD_SOURCE,
     PD_RANGE,
     PD_SAMPLES,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/streams/base_stream.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/streams/base_stream.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     List,
     Type,
     TypeVar,
     TYPE_CHECKING,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PS_INDICES,
     PS_CREATE,
     PS_DELETE,
     PS_ENABLE,
     PS_PACKETLIMIT,
     PS_COMMENT,
     PS_TPLDID,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/indices/streams/genuine_stream.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/indices/streams/genuine_stream.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PS_INSERTFCS,
     PS_INJECTFCSERR,
 )
 from .base_stream import (
     BaseStreamIdx,
     SInjectError
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/base_module.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/base_module.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,16 +6,16 @@
     Generic
 )
 from abc import (
     ABC,
     abstractmethod,
 )
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     M_MODEL,
     M_PORTCOUNT,
     M_RESERVATION,
     M_RESERVEDBY,
     M_SERIALNO,
     M_VERSIONNO
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/module_chimera.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/module_chimera.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,30 +1,29 @@
 import typing
 import asyncio
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_STATUS,
     M_UPGRADE,
     M_UPGRADEPROGRESS,
     M_CFPTYPE,
     M_CFPCONFIGEXT,
-    M_CFPCONFIG,
     M_COMMENT,
     M_CAPABILITIES,
     M_CLOCKPPB,
     M_TXCLOCKSOURCE_NEW,
     M_TXCLOCKSTATUS_NEW,
     M_EMULBYPASS,
     M_LATENCYMODE,
 )
 
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.utils import attributes as utils
 from xoa_driver.internals.state_storage import modules_state
 from xoa_driver.v2 import ports
 from . import base_module as bm
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from . import __interfaces as m_itf
@@ -53,20 +52,15 @@
     """
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.type = M_CFPTYPE(conn, module_id)
         """
         The transceiver's CFP type currently inserted.
         Representation of M_CFPTYPE
         """
-        self.config = M_CFPCONFIG(conn, module_id)
-        """
-        The CFP configuration of the test module.
-        Representation of M_CFPCONFIG
-        """
-        self.config_extended = M_CFPCONFIGEXT(conn, module_id)
+        self.config = M_CFPCONFIGEXT(conn, module_id)
         """
         The CFP configuration of the test module.
         Representation of M_CFPCONFIGEXT
         """
 
 
 class ChUpgrade:
@@ -198,20 +192,15 @@
         return self
 
     on_cfp_type_change = functools.partialmethod(utils.on_event, M_CFPTYPE)
     """
     Register a callback to the event that the module's CFP type changes.
     """
 
-    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIG)
-    """
-    Register a callback to the event that the module's CFP configuration changes.
-    """
-
-    on_cfp_config_extended_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
+    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
     """
     Register a callback to the event that the module's CFP configuration changes.
     """
 
     on_status_change = functools.partialmethod(utils.on_event, M_STATUS)
     """
     Register a callback to the event that the module's model changes.
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/module_l23ve.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/module_l23ve.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import asyncio
 import typing
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_COMMENT,
     M_CAPABILITIES,
     M_MULTIUSER
 )
 from xoa_driver.v2 import ports
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.state_storage import modules_state
 from . import base_module as bm
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from . import __interfaces as m_itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/module_l47.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/module_l47.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import asyncio
 import functools
 import typing
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_LICENSE_DEMO_INFO,
     M_LICENSE_MAINTENANCE_INFO,
     M_LICENSE_CWB_DETECTED,
     M_LICENSE_UPDATE,
     M_LICENSE_UPDATE_STATUS,
     M_LICENSE_LIST_BSON,
     M_LICENSE_ONLINE,
@@ -35,15 +35,15 @@
     M4_CAPTURE_FILE_DELETE,
     M4E_MODE,
     M4E_RESERVE,
     M4_TLS_CIPHER_SUITES,
 )
 from xoa_driver.internals.hli_v2 import revisions
 from xoa_driver.internals.utils import attributes as utils
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.state_storage import modules_state
 from xoa_driver.v2 import ports
 from . import base_module as bm
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from . import __interfaces as m_itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_combi.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_combi.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import typing
 import functools
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.core.commands import P_CAPABILITIES
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.commands import P_CAPABILITIES
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.utils.cap_id import CapID
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_d.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v1/modules/modules_l23/family_d.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
-from xoa_driver.v2 import ports
-from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver import ports
+from xoa_driver.internals.hli_v1 import revisions
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
@@ -20,15 +20,15 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S6P] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S6P,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port index manager of Odin-1G-3S-6P"""
+        """Port Index Manager of Odin-1G-3S-6P"""
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-1G-3S-6P[b]")
 class MOdin1G3S6P_b(ModuleL23):
     """Test module Odin-1G-3S-6P[b]"""
 
@@ -36,15 +36,15 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S6P_b] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S6P_b,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port index manager of Odin-1G-3S-6P[b]"""
+        """Port Index Manager of Odin-1G-3S-6P[b]"""
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-1G-3S-6P-E")
 class MOdin1G3S6PE(ModuleL23):
     """Test module Odin-1G-3S-6P-E"""
 
@@ -52,15 +52,15 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S6PE] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S6PE,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port index manager of Odin-1G-3S-6P-E"""
+        """Port Index Manager of Odin-1G-3S-6P-E"""
 
 
 @typing.final
 @revisions.register_valkyrie_module(rev="Odin-1G-3S-2P-T")
 class MOdin1G3S2PT(ModuleL23):
     """Test module Odin-1G-3S-2P-T"""
 
@@ -68,8 +68,8 @@
         super().__init__(conn, init_data)
         self.ports: pm.PortsManager[ports.POdin1G3S2PT] = pm.PortsManager(
             conn=conn,
             ports_type=ports.POdin1G3S2PT,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port index manager of Odin-1G-3S-2P-T"""
+        """Port Index Manager of Odin-1G-3S-2P-T"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_e.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_e.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_f.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_f.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_g.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_g.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_h.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_h.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_i.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_j.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
 
 
 @typing.final
-@revisions.register_valkyrie_module(rev="Loki-100G-5S-2P")
-class MLoki100G5S2P(ModuleL23):
-    """Test module Loki-100G-5S-2P"""
+@revisions.register_valkyrie_module(rev="Thor-100G-5S-4P")
+class MThor100G5S4P(ModuleL23):
+    """Test module Thor-100G-5S-4P"""
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
-        self.ports: pm.PortsManager[ports.PLoki100G5S2P] = pm.PortsManager(
+        self.ports: pm.PortsManager[ports.PThor100G5S4P] = pm.PortsManager(
             conn=conn,
-            ports_type=ports.PLoki100G5S2P,
+            ports_type=ports.PThor100G5S4P,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port index manager of Loki-100G-5S-2P"""
+        """Port index manager of Thor-100G-5S-4P"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_j.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_k.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
 
 
 @typing.final
-@revisions.register_valkyrie_module(rev="Thor-100G-5S-4P")
-class MThor100G5S4P(ModuleL23):
-    """Test module Thor-100G-5S-4P"""
+@revisions.register_valkyrie_module(rev="Thor-400G-7S-1P")
+class MThor400G7S1P(ModuleL23):
+    """Test module Thor-400G-7S-1P"""
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
-        self.ports: pm.PortsManager[ports.PThor100G5S4P] = pm.PortsManager(
+        self.ports: pm.PortsManager[ports.PThor400G7S1P] = pm.PortsManager(
             conn=conn,
-            ports_type=ports.PThor100G5S4P,
+            ports_type=ports.PThor400G7S1P,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port index manager of Thor-100G-5S-4P"""
+        """Port index of Thor-400G-7S-1P"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_k.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_m.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
 
 
 @typing.final
-@revisions.register_valkyrie_module(rev="Thor-400G-7S-1P")
-class MThor400G7S1P(ModuleL23):
-    """Test module Thor-400G-7S-1P"""
+@revisions.register_valkyrie_module(rev="Odin-1G-3S-6P-T1-RJ45")
+class MOdin1G3S6PT1RJ45(ModuleL23):
+    """Test module Odin-1G-3S-6P-T1-RJ45"""
     def __init__(self, conn: "itf.IConnection", init_data: "m_itf.ModuleInitData") -> None:
         super().__init__(conn, init_data)
-        self.ports: pm.PortsManager[ports.PThor400G7S1P] = pm.PortsManager(
+        self.ports: pm.PortsManager[ports.POdin1G3S6PT1RJ45] = pm.PortsManager(
             conn=conn,
-            ports_type=ports.PThor400G7S1P,
+            ports_type=ports.POdin1G3S6PT1RJ45,
             module_id=self.module_id,
             ports_count=self.ports_count
         )
-        """Port index of Thor-400G-7S-1P"""
+        """Port index manager of Odin-1G-3S-6P-T1-RJ45"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_l.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_l.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_l1.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_l1.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_CLOCKPPBSWEEP,
     M_CLOCKSWEEPSTATUS,
 )
 
 
 class MClockSweep:
     """Test module local clock sweep"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/family_n.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/family_n.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import typing
 from xoa_driver.v2 import ports
 from xoa_driver.internals.hli_v2 import revisions
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 
 if typing.TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from .. import __interfaces as m_itf
 
 from .module_l23_base import ModuleL23
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/modules/modules_l23/module_l23_base.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/modules/modules_l23/module_l23_base.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,28 +1,27 @@
 import asyncio
 import functools
 from typing import (
     TYPE_CHECKING,
     Optional,
 )
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_STATUS,
     M_UPGRADE,
     M_UPGRADEPROGRESS,
     M_TIMESYNC,
     M_CFPTYPE,
+    M_CFPCONFIGEXT,
     M_COMMENT,
     # M_TIMEADJUSTMENT,
     M_CAPABILITIES,
     M_MEDIASUPPORT,
     M_FPGAREIMAGE,
     M_MULTIUSER,
-    M_CFPCONFIGEXT,
-    M_CFPCONFIG,
     M_CLOCKPPB,
     M_SMAINPUT,
     M_SMAOUTPUT,
     M_SMASTATUS,
     M_NAME,
     M_REVISION,
     M_MEDIA,
@@ -31,15 +30,15 @@
     M_TXCLOCKSTATUS_NEW,
     M_TXCLOCKFILTER_NEW,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from xoa_driver.internals.utils import attributes as utils
-from xoa_driver.internals.utils import ports_manager as pm
+from xoa_driver.internals.utils.managers import ports_manager as pm
 from xoa_driver.internals.state_storage import modules_state
 
 from .. import base_module as bm
 from .. import __interfaces as m_itf
 
 
 class TXClock:
@@ -96,20 +95,15 @@
     """Test module CFP"""
     def __init__(self, conn: "itf.IConnection", module_id: int) -> None:
         self.type = M_CFPTYPE(conn, module_id)
         """The transceiver's CFP type currently inserted.
         Representation of M_CFPTYPE
         """
 
-        self.config = M_CFPCONFIG(conn, module_id)
-        """The CFP configuration of the test module.
-        Representation of M_CFPCONFIG
-        """
-
-        self.config_extended = M_CFPCONFIGEXT(conn, module_id)
+        self.config = M_CFPCONFIGEXT(conn, module_id)
         """The CFP configuration of the test module.
         Representation of M_CFPCONFIGEXT
         """
 
 
 class MTiming:
     """Test module timing and clock configuration"""
@@ -229,18 +223,15 @@
         )
         self._local_states.register_subscriptions(self)
         return self
 
     on_cfp_type_change = functools.partialmethod(utils.on_event, M_CFPTYPE)
     """Register a callback to the event that the module's CFP type changes."""
 
-    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIG)
-    """Register a callback to the event that the module's CFP configuration changes."""
-
-    on_cfp_config_extended_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
+    on_cfp_config_change = functools.partialmethod(utils.on_event, M_CFPCONFIGEXT)
     """Register a callback to the event that the module's CFP configuration changes."""
 
     on_status_change = functools.partialmethod(utils.on_event, M_STATUS)
     """Register a callback to the event that the module's status changes."""
 
     on_revision_change = functools.partialmethod(utils.on_event, M_REVISION)
     """Register a callback to the event that the module's model type changes."""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/base_port.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/base_port.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,16 +5,16 @@
     abstractmethod,
 )
 from typing import (
     TYPE_CHECKING,
     TypeVar,
     Generic,
 )
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     P_RESERVATION,
     P_RESERVEDBY,
     P_RESET,
     P_COMMENT,
     P_INTERFACE,
     P_RECEIVESYNC,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_capture.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_capture.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     List,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_CAPTURE,
     PC_TRIGGER,
     PC_KEEP,
     PC_STATS,
     PC_EXTRA,
     PC_PACKET,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import functools
 import typing
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_CAPABILITIES,
     P_SPEED,
     P_SPEEDREDUCTION,
     P_INTERFRAMEGAP,
     P_MACADDRESS,
     P_IPADDRESS,
     P_ARPREPLY,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23_genuine.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_l23_genuine.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import functools
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_FLASH,
     P_SPEEDSELECTION,
     P_SPEEDS_SUPPORTED,
     P_UAT_MODE,
     P_UAT_FLR,
     P_STATUS,
     P_TCVRSTATUS,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_reception_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_reception_statistics.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import (
     TYPE_CHECKING,
     Dict,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PR_TPLDJITTER,
     PR_TOTAL,
     PR_NOTPLD,
     PR_EXTRA,
     PR_TPLDS,
     PR_TPLDTRAFFIC,
     PR_TPLDERRORS,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transceiver.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transceiver.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PX_RW,
     PX_MII,
     PX_TEMPERATURE,
     PX_RW_SEQ,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transmission_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/bases/port_transmission_statistics.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import (
     TYPE_CHECKING,
     Union,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
     from xoa_driver.internals.hli_v2.indices.streams.genuine_stream import GenuineStreamIdx
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PT_TOTAL,
     PT_NOTPLD,
     PT_STREAM,
     PT_CLEAR,
     PT_EXTRA,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/general.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/general.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,21 +3,21 @@
     Tuple,
     Type,
     TypeVar,
     TYPE_CHECKING
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import (
+from xoa_driver.internals.commands.enums import (
     FilterType,
     FilterVlanType,
     ProtocolOption,
     FilterMode,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PEF_ETHSETTINGS,
     PEF_ETHSRCADDR,
     PEF_ETHDESTADDR,
     PEF_L2PUSE,
     PEF_VLANSETTINGS,
     PEF_VLANTAG,
     PEF_VLANPCP,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/shadow.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/shadow.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,25 +2,26 @@
     TYPE_CHECKING,
     Dict,
     Type,
     Union
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import (
+from xoa_driver.internals.commands.enums import (
     FilterType,
     ProtocolOption,
     FilterMode,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PEF_INIT,
     PEF_APPLY,
     PEF_ENABLE,
     PEF_PROTOCOL,
     PEF_MODE,
+    PEF_CANCEL,
 )
 from . import general
 
 
 class ModeExtendedS(general.ModeExtended):
     async def use_segments(self, *segments: ProtocolOption) -> None:
         segments_payload = [
@@ -52,14 +53,18 @@
         """Apply filter definition.
         Representation of PEF_APPLY
         """
         self.enable = PEF_ENABLE(conn, module_id, port_id, flow_index, self._filter_type)
         """Enabling the filter.
         Representation of PEF_ENABLE
         """
+        self.cancel = PEF_CANCEL(conn, module_id, port_id, flow_index)
+        """Cancel changes made to Shadow and restores them to the ones in Working.
+        Representation of PEF_CANCEL
+        """
         # self.mode = PEF_MODE(conn, module_id, port_id, flow_index, self._filter_type)
         # """Filter mode.
         # Representation of PEF_MODE`
         # """
 
     async def get_mode(self) -> Union[general.ModeBasic, ModeExtendedS]:
         mode_types: Dict[FilterMode, Type[Union[general.ModeBasic, ModeExtendedS]]] = {
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/working.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/working.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,15 @@
     Dict,
     Type,
     Union,
     TYPE_CHECKING
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import (
+from xoa_driver.internals.commands.enums import (
     FilterType,
     FilterMode,
 )
 from . import general
 
 
 class FilterDefinitionWorking:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_custom_distribution.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_custom_distribution.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,33 +1,36 @@
 from typing import (
     TYPE_CHECKING,
+    Dict,
     List,
 )
+from collections import UserDict
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PEC_INDICES,
     PEC_VAL,
     PEC_COMMENT,
     PEC_DELETE,
     PEC_DISTTYPE,
 )
 
 from xoa_driver.internals.utils.indices import observer
+from xoa_driver.enums import OnOff
 
 
 class CustomDistribution:
     """Custom distribution"""
 
     def __init__(self, observer: "observer.IndicesObserver", conn: "itf.IConnection", module_id: int, port_id: int, custom_distribution_index: int) -> None:
         self.__observer = observer
         self.__conn = conn
         self.__module_id = module_id
         self.__port_id = port_id
-        self.__cdi = custom_distribution_index
+        self.custom_distribution_index = custom_distribution_index
         self.definition = PEC_VAL(conn, module_id, port_id, custom_distribution_index)
         """Custom distribution definition.
         Representation of PEC_VAL
         """
 
         self.comment = PEC_COMMENT(conn, module_id, port_id, custom_distribution_index)
         """Custom distribution description.
@@ -44,79 +47,70 @@
         Deleting an existing Custom Distribution
         """
 
         await PEC_DELETE(
             self.__conn,
             self.__module_id,
             self.__port_id,
-            self.__cdi
+            self.custom_distribution_index
         ).set()
         self.__observer.notify(observer.IndexEvents.DEL, self)
 
 
-class CustomDistributions:
+class CustomDistributions(UserDict[int, "CustomDistribution"]):
     """Custom distributions"""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         self.__conn = conn
         self.__module_id = module_id
         self.__port_id = port_id
-        self.__items: List[CustomDistribution] = []
+        self.data: Dict[int, CustomDistribution] = {}
         self.__observer = observer.IndicesObserver()
         self.__observer.subscribe(
             observer.IndexEvents.DEL,
             self.__remove_from_slot
         )
 
     async def server_sync(self) -> None:
         """Sync the indices with xenaserver"""
-
         _resp = await PEC_INDICES(self.__conn, self.__module_id, self.__port_id).get()
-        self.__items = [
-            CustomDistribution(
+        self.data = {
+            idx: CustomDistribution(
                 self.__observer,
                 self.__conn,
                 self.__module_id,
                 self.__port_id,
                 idx
             )
-            for idx in _resp.indices
-        ]
-
-    def __len__(self) -> int:
-        """Return the number of existing indices"""
-        return len(self.__items)
-
-    def __iter__(self):
-        self.__k = 0
-        return self
-
-    def __next__(self):
-        try:
-            v = self.__items[self.__k]
-        except IndexError:
-            raise StopIteration()
-        else:
-            self.__k += 1
-            return v
-
-    def __getitem__(self, key: int):
-        return self.__items[key]
+            for idx in _resp.indexations
+        }
 
     def __remove_from_slot(self, index_inst: "CustomDistribution") -> None:
         # throws ValueError if element is not exists in list of indices
-        self.__items.remove(index_inst)
+        del self.data[index_inst.custom_distribution_index]
 
-    async def assign(self, idx_cuantity: int = 0) -> None:
-        """
-        Assign Custom distribution indices, all indices which is out of range will be removed.
-        ``idx_cuantity`` permitted values is: 0 <= idx_cuantity <= 40
-        """
-
-        if not (0 <= idx_cuantity <= 40):
-            raise ValueError("idx_cuantity must be in range of: 0 <= idx_cuantity <= 40")
-        await PEC_INDICES(self.__conn, self.__module_id, self.__port_id).set([i for i in range(idx_cuantity)])
-        await self.server_sync()
+    def __setitem__(self, key, value):
+        raise NotImplementedError("Only support assign item by 'add' method")
 
-    async def remove(self, position_idx: int) -> None:
+    async def remove(self, custom_distribution_index: int) -> None:
         """Remove a index from port"""
-        await self.__items[position_idx].delete()
+        await self.data[custom_distribution_index].delete()
+
+    async def __get_available_custom_distribution_index(self) -> int:
+        await self.server_sync()
+        if len(self.keys()) == 40:
+            raise ValueError("The server was full of custom distributions.")
+        return next(i for i in range(1, 41) if i not in self.keys())
+
+    async def add(self, linear: OnOff, entry_count: int, data_x: List[int], comment: str) -> "CustomDistribution":
+        cdi = await self.__get_available_custom_distribution_index()
+        cd = CustomDistribution(
+            self.__observer,
+            self.__conn,
+            self.__module_id,
+            self.__port_id,
+            custom_distribution_index=cdi,
+        )
+        await cd.definition.set(linear=linear, symmetric=OnOff.OFF, entry_count=entry_count, data_x=data_x)
+        await cd.comment.set(comment)
+        self.data[cdi] = cd
+        return cd
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_distribution.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/pe_distribution.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands.enums import ImpairmentTypeIndex
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands.enums import ImpairmentTypeIndex
+from xoa_driver.internals.commands import (
     PED_SCHEDULE,
     PED_ONESHOTSTATUS,
     PED_OFF,
     PED_FIXED,
     PED_RANDOM,
     PED_BER,
     PED_FIXEDBURST,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_chimera.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_chimera.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import asyncio
 import functools
 from typing import TYPE_CHECKING
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_CAPABILITIES,
     P_INTERFACE,
     P_STATUS,
     P_TXENABLE,
     P_LOADMODE,
     P_EMULATE,
 )
@@ -47,15 +47,16 @@
         """
 
         self.load_mode = P_LOADMODE(conn, module_id, port_id)
         """Load mode of the Chimera port.
         Representation of P_LOADMODE
         """
 
-        self.emulation = ChimeraPE(self._conn, *self.kind)  # TODO: Missing description
+        self.emulation = ChimeraPE(self._conn, *self.kind)
+        """Chimera Port Emulation"""
 
         self.emulate = P_EMULATE(conn, module_id, port_id)
         """Chimera port emulation control.
         Representation of P_EMULATE
         """
 
         self.custom_distributions = CustomDistributions(conn, module_id, port_id)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_emulation.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/port_emulation.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,19 +1,18 @@
 from typing import (
     TYPE_CHECKING,
     Tuple,
 )
-from dataclasses import astuple
-from xoa_driver.internals.core.commands.enums import ImpairmentTypeIndex
-from xoa_driver.internals.core.commands.ped_commands import PED_ENABLE, PED_ONESHOTSTATUS, PED_SCHEDULE
+from xoa_driver.internals.commands.enums import ImpairmentTypeIndex
+from xoa_driver.internals.commands.ped_commands import PED_ENABLE, PED_ONESHOTSTATUS, PED_SCHEDULE
 
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PE_FCSDROP,
     PE_TPLDMODE,
     PE_COMMENT,
     PE_INDICES,
     PE_LATENCYRANGE,
     PE_CORRUPT,
     PE_MISORDER,
@@ -185,18 +184,18 @@
 
         self.flow: Tuple["CFlow", ...] = tuple()
 
     def __await__(self):
         return self._setup().__await__()
 
     async def _setup(self) -> None:
-        indices = astuple(await PE_INDICES(self._conn, self.module_id, self.port_id).get())
+        indices = await PE_INDICES(self._conn, self.module_id, self.port_id).get()
         self.flow = tuple(
             CFlow(self._conn, self.module_id, self.port_id, idx)
-            for idx in indices
+            for idx in indices.to_tuple()
         )
 
 
 class CTotalFlowStats:
     """Total flow statistics."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
@@ -286,15 +285,15 @@
         """
 
         self.one_shot_status = PED_ONESHOTSTATUS(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.CORRUPTION)
         """One-shot status.
         Representation of PED_ONESHOTSTATUS
         """
 
-        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.DROP)
+        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.CORRUPTION)
         """Impairment distribution control.
         Representation of PED_ENABLE
         """
 
 
 class CMisorderingImpairment:
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
@@ -311,15 +310,15 @@
         """
 
         self.one_shot_status = PED_ONESHOTSTATUS(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.MISORDER)
         """One-shot status.
         Representation of PED_ONESHOTSTATUS
         """
 
-        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.DROP)
+        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.MISORDER)
         """Impairment distribution control.
         Representation of PED_ENABLE
         """
 
 
 class CLatencyJitterImpairment:
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
@@ -337,15 +336,15 @@
         """
 
         self.one_shot_status = PED_ONESHOTSTATUS(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.LATENCYJITTER)
         """One-shot status.
         Representation of PED_ONESHOTSTATUS
         """
 
-        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.DROP)
+        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.LATENCYJITTER)
         """Impairment distribution control.
         Representation of PED_ENABLE
         """
 
 
 class CDuplicationImpairment:
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, flow_index: int) -> None:
@@ -358,15 +357,15 @@
         """
 
         self.one_shot_status = PED_ONESHOTSTATUS(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.DUPLICATION)
         """One-shot status.
         Representation of PED_ONESHOTSTATUS
         """
 
-        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.DROP)
+        self.enable = PED_ENABLE(conn, module_id, port_id, flow_index, ImpairmentTypeIndex.DUPLICATION)
         """Impairment distribution control.
         Representation of PED_ENABLE
         """
 
 
 class CShaperImpairment:
     """Bandwidth shaper impairment configuration."""
@@ -414,8 +413,8 @@
 
         self.duplication = CDuplicationImpairment(conn, module_id, port_id, flow_index)
 
         self.corruption = CCorruptionImpairment(conn, module_id, port_id, flow_index)
 
         self.policer = CPolicerImpairment(conn, module_id, port_id, flow_index)
 
-        self.shaper = CShaperImpairment(conn, module_id, port_id, flow_index)
+        self.shaper = CShaperImpairment(conn, module_id, port_id, flow_index)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/reception_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/reception_statistics.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PR_FLOWTOTAL,
     PR_FLOWCLEAR,
 )
 
 
 class ReceptionStatistics:
     """Chimera RX statistics."""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/chimera/transmission_statistics.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/chimera/transmission_statistics.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PT_FLOWTOTAL,
     PT_FLOWCLEAR,
 )
 
 
 class TransmissionStatistics:
     """Chimera TX statistics."""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_combi.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_combi.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import P_AUTONEGSELECTION
+from xoa_driver.internals.commands import P_AUTONEGSELECTION
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
 from . import family_f
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_d.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_d.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_MDIXMODE,
     P_AUTONEGSELECTION,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_e.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_e.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_AUTONEGSELECTION,  # questionable which ports are electrical
     P_LPENABLE,
     P_LPTXMODE,
     P_LPSTATUS,
     P_LPPARTNERAUTONEG,
     P_LPSNRMARGIN,
     P_LPRXPOWER,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_f.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_f.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import functools
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
     P_TXRUNTLENGTH,
     P_RXRUNTLENGTH,
     P_RXRUNTLEN_ERRS,
     P_TXPREAMBLE_REMOVE,
     P_RXPREAMBLE_INSERT,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_g.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_g.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,41 +1,52 @@
 import functools
-from typing import TYPE_CHECKING
+from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
 from .pcs_pma_ghijkl import (
     PcsPma,
     SerDes,
 )
 
 
 class FamilyG(BasePortL23Genuine):
+    pcs_pma: PcsPma
+    """PCS/PMA settings.
+        
+    :type: ~xoa_driver.internals.hli_v1.ports.port_l23.pcs_pma_ghijkl.PcsPma
+    """
+    
+    serdes: Tuple[SerDes, ...]
+    """SerDes index
+
+    :type: Tuple[SerDes, ...]
+    """
+
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
         self.dynamic = P_DYNAMIC(conn, module_id, port_id)
         """L23 port's dynamic traffic change.
-        Representation of P_DYNAMIC
+        
+        :type: P_DYNAMIC
         """
 
-        self.pcs_pma = PcsPma(conn, self)
-        """PCS/PMA settings."""
-
     async def _setup(self) -> Self:
         await super()._setup()
         self.serdes = tuple(
             SerDes(self._conn, *self.kind, serdes_xindex=serdes_xindex)
             for serdes_xindex in range(self.info.capabilities.serdes_count)
         )
+        self.pcs_pma = PcsPma(self._conn, self)
         return self
 
     on_dynamic_change = functools.partialmethod(utils.on_event, P_DYNAMIC)
     """Register a callback to the event that the port's dynamic traffic setting changes."""
 
 
 class PLoki100G3S1P(FamilyG):
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_h.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_h.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
 from .bases.port_l23_genuine import BasePortL23Genuine
 from .pcs_pma_ghijkl import (
-    # PcsPma,
+    PcsPma,
     SerDes,
 )
 
 
 class FamilyH(BasePortL23Genuine):
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         super().__init__(conn, module_id, port_id)
@@ -34,14 +34,27 @@
     on_dynamic_change = functools.partialmethod(utils.on_event, P_DYNAMIC)
     """Register a callback to the event that the port's dynamic traffic setting changes."""
 
 
 class PLoki100G5S1P(FamilyH):
     """L23 port on Loki-100G-5S-1P module.
     """
-    ...
+
+    pcs_pma: PcsPma
+    """PCS/PMA settings.
+        
+    :type: ~xoa_driver.internals.hli_v1.ports.port_l23.pcs_pma_ghijkl.PcsPma
+    """
+
+    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
+        super().__init__(conn, module_id, port_id)
+
+    async def _setup(self) -> Self:
+        await super()._setup()
+        self.pcs_pma = PcsPma(self._conn, self)
+        return self
 
 
 class POdin100G3S1P(FamilyH):
     """L23 port on Odin-100G-3S-1P module.
     """
     ...
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_i.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_i.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_FAULTSIGNALING,
     P_FAULTSTATUS,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_j.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_j.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     # P_FAULTSIGNALING,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_k.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_k.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     # P_FAULTSIGNALING,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_l.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_l.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     # P_FAULTSIGNALING,
     P_DYNAMIC,
 )
 from xoa_driver.internals.utils import attributes as utils
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_l1.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_l1.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 
 import functools
 from typing import TYPE_CHECKING, Tuple
 from typing_extensions import Self
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_DYNAMIC,
     # PL1_AUTONEGINFO,
     # PL1_LINKTRAININFO,
     # PL1_LOG,
     # PL1_CFG_TMP,
 )
 from xoa_driver.internals.utils import attributes as utils
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/family_m.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/family_m.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from typing import TYPE_CHECKING
 
-from xoa_driver.internals.core.commands import P_BRRMODE
+from xoa_driver.internals.commands import P_BRRMODE
 
 from .bases.port_l23_genuine import BasePortL23Genuine
 
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/fault_jkl.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/fault_jkl.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from typing import TYPE_CHECKING
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_FAULTSIGNALING,
     P_FAULTSTATUS,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ghijkl.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ghijkl.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import (
     TYPE_CHECKING,
     Tuple,
 )
 from typing_extensions import Self
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PP_ALARMS_ERRORS,
     PP_TXLANECONFIG,
     PP_TXLANEINJECT,
     PP_TXPRBSCONFIG,
     PP_TXERRORRATE,
     PP_TXINJECTONE,
     PP_RXTOTALSTATS,
@@ -297,14 +297,19 @@
         """
 
         self.status = PP_RXPRBSSTATUS(conn, module_id, port_id, serdes_xindex)
         """RX PRBS status on a SerDes
         Representation of PP_RXPRBSSTATUS
         """
 
+        self.config = PRBSConfig(conn, module_id, port_id)
+        """
+        L23 high-speed port PRBS configuration.
+        """
+
 
 class SerDes:
     """L23 high-speed port SerDes configuration and status."""
 
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int, serdes_xindex: int) -> None:
         self.prbs = Prbs(conn, module_id, port_id, serdes_xindex)
         """PRBS configuration"""
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ijkl_chimera.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_ijkl_chimera.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PP_LINKFLAP_PARAMS,
     PP_LINKFLAP_ENABLE,
     PP_PMAERRPUL_PARAMS,
     PP_PMAERRPUL_ENABLE,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_l.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/pcs_pma_l.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import (
     TYPE_CHECKING,
     Tuple,
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     PP_AUTONEG,
     PP_AUTONEGSTATUS,
     PP_LINKTRAIN,
     PP_LINKTRAINSTATUS,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l23/port_l23ve.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l23/port_l23ve.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from typing import TYPE_CHECKING
 from .bases.port_l23 import BasePortL23
 from .bases.port_reception_statistics import PortReceptionStatistics
 from .bases.port_transmission_statistics import PortTransmissionStatistics
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_MDIXMODE,
     # P_ENGINENAMES, # TODO: need to implement
     # P_ENGINELOAD, # TODO: need to implement
 )
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 from xoa_driver.internals.utils.indices import index_manager as idx_mgr
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/counters.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/counters.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4_ETH_TX_COUNTERS,
     P4_ETH_RX_COUNTERS,
     P4_PORT_TX_COUNTERS,
     P4_PORT_RX_COUNTERS,
     P4_PORT_COUNTERS,
     P4_IPV4_RX_COUNTERS,
     P4_IPV4_TX_COUNTERS,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/main.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/main.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import functools
 from typing import TYPE_CHECKING
 from typing_extensions import Self
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4_TRAFFIC,
     P4_STATE,
     P4_CAPABILITIES,
     P4_STATE_STATUS,
     P4_VLAN_OFFLOAD,
     P4_ARP_CONFIG,
     P4_NDP_CONFIG,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/ports/port_l47/packet_engine.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/ports/port_l47/packet_engine.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P4E_ASSIGN,
     P4E_AVAILABLE,
     P4E_ALLOCATE,
     P4E_ALLOCATION_INFO,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/_base_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/_base_tester.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,55 +1,57 @@
+from __future__ import annotations
 from typing import (
     TypeVar,
     Awaitable,
     Generic,
     Callable,
     Generator,
     Any
 )
 from abc import (
     ABC,
     abstractmethod,
 )
 import functools
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     C_RESERVATION,
     C_DOWN,
     C_PASSWORD,
     C_TIME,
     C_CAPABILITIES,
     C_DEBUGLOGS,
     C_NAME,
     C_MODEL,
     C_COMMENT,
     C_VERSIONNO,
     C_SERIALNO,
     C_RESERVEDBY,
 )
-from xoa_driver.internals.core.transporter import (
-    establish_connection,
-    TransportationHandler,
-)
+from xoa_driver.internals.core.funcs import establish_connection
+from xoa_driver.internals.core.transporter.handler import TransportationHandler
+from xoa_driver.internals.core.transporter.logger import CustomLogger
 
-import xoa_driver.internals.hli_v2.testers._tester_session as session
+from xoa_driver.internals.utils import session
 from xoa_driver.internals.state_storage import testers_state
 
 
 T = TypeVar('T', bound="BaseTester")
 TesterStateStorage = TypeVar('TesterStateStorage', bound="testers_state.TesterLocalState")
 
 
-# TODO: lately update imports to correct style
-# min version = 83.2
+# min version = rel v83.2 eq fw v446.5
 class BaseTester(ABC, Generic[TesterStateStorage]):
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
         self.__host = host
         self.__port = port
-        self._conn = TransportationHandler(debug=debug)
+        self._conn = TransportationHandler(
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
         self.session = session.TesterSession(
             self._conn,
             username,
             password=password,
             keepalive=True,
         )
         """
@@ -128,15 +130,15 @@
             async def skip():
                 return self
             return skip().__await__()
         return self._setup().__await__()
 
     async def _setup(self: T) -> T:
         await establish_connection(self._conn, self.__host, self.__port)
-        await self.session
+        await self.session.logon()
         return self
 
     def __is_reservation(self, reserved_status: enums.ReservedStatus) -> bool:
         return self.info.reservation == reserved_status
 
     is_released = functools.partialmethod(__is_reservation, enums.ReservedStatus.RELEASED)
     """Validate if the tester is released.
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/rest_api.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/rest_api.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_RESTPORT,
     C_RESTENABLE,
     C_RESTSTATUS,
     C_RESTCONTROL,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/time_keeper.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/time_keeper.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_TKLICFILE,
     C_TKLICSTATE,
     C_TKSTATUS,
     C_TKSTATUSEXT,
     C_TKSVCSTATE,
     C_TKGPSSTATE,
     C_TKCONFIG,
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/l_23/upload_file.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/l_23/upload_file.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_FILESTART,
     C_FILEDATA,
     C_FILEFINISH
 )
 
 
 class UploadFile:
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/genuine/management_interface.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/genuine/management_interface.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_IPADDRESS,
     C_DHCP,
     C_MACADDRESS,
     C_HOSTNAME,
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/l23_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/l23_tester.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,21 +1,23 @@
+from __future__ import annotations
 from typing import (
     Union,
     TYPE_CHECKING,
     Type,
 )
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_PORTCOUNTS,
     C_MULTIUSER,
     C_TRAFFIC,
     C_TRAFFICSYNC,
     C_VERSIONNO_MINOR,
     C_BUILDSTRING,
 )
-from xoa_driver.internals.utils.modules_manager import ModulesManager
+from xoa_driver.internals.core.transporter.logger import CustomLogger
+from xoa_driver.internals.utils.managers.modules_manager import ModulesManager
 from ._base_tester import BaseTester
 from .genuine import management_interface as mi
 from .genuine.l_23 import (
     upload_file,
     time_keeper,
     rest_api,
 )
@@ -52,16 +54,23 @@
 
 
 class L23Tester(BaseTester["testers_state.GenuineTesterLocalState"]):
     """
     Representation of a physical Xena Valkyrie Tester.
     """
 
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
-        super().__init__(host=host, username=username, password=password, port=port, debug=debug)
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
+        super().__init__(
+            host=host,
+            username=username,
+            password=password,
+            port=port,
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
 
         self._local_states = testers_state.GenuineTesterLocalState(host, port)
 
         self.management_interface = mi.ManagementInterface(self._conn)
         """Tester management interface that includes IP address, DHCP, MAC address and hostname.
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/hli_v2/testers/l23ve_tester.py` & `xoa-driver-2.0.0/xoa_driver/internals/hli_v2/testers/l23ve_tester.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,18 @@
+from __future__ import annotations
 from typing import Type
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     C_PORTCOUNTS,
     C_MULTIUSER,
     C_TRAFFIC,
     C_TRAFFICSYNC,
     C_VERSIONNO_MINOR,
 )
-from xoa_driver.internals.utils.modules_manager import ModulesManager
+from xoa_driver.internals.core.transporter.logger import CustomLogger
+from xoa_driver.internals.utils.managers.modules_manager import ModulesManager
 from ._base_tester import BaseTester
 
 
 from xoa_driver.v2 import modules
 from xoa_driver.internals.state_storage import testers_state
 
 
@@ -22,16 +24,23 @@
 
 
 class L23VeTester(BaseTester["testers_state.TesterLocalState"]):
     """
     Representation of a virtual Xena Valkyrie Tester.
     """
 
-    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, debug: bool = False) -> None:
-        super().__init__(host=host, username=username, password=password, port=port, debug=debug)
+    def __init__(self, host: str, username: str, password: str = "xena", port: int = 22606, *, enable_logging: bool = False, custom_logger: CustomLogger | None = None) -> None:
+        super().__init__(
+            host=host,
+            username=username,
+            password=password,
+            port=port,
+            enable_logging=enable_logging,
+            custom_logger=custom_logger
+        )
 
         self._local_states = testers_state.TesterLocalState(host, port)
 
         self.multiuser = C_MULTIUSER(self._conn)
         """
         Representation of C_MULTIUSER
         """
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/state_storage/_speed_detector.py` & `xoa-driver-2.0.0/xoa_driver/internals/state_storage/_speed_detector.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,18 +1,17 @@
-from typing import (
-    TYPE_CHECKING,
-    List,
-)
+from __future__ import annotations
+from typing import TYPE_CHECKING
+
 from enum import (
     Enum,
     auto
 )
-from xoa_driver.internals.core.commands import enums
+from xoa_driver.internals.commands import enums
 if TYPE_CHECKING:
-    from xoa_driver.internals.core.commands import P_CAPABILITIES
+    from xoa_driver.internals.commands import P_CAPABILITIES
 
 
 class EPortInterfaceSubtype(Enum):
     Unspecified = auto()
     Single = auto()
     Dual = auto()
     Triple = auto()
@@ -47,29 +46,29 @@
         return self.__determinate_interface_subtype in {
             EPortInterfaceSubtype.Triple,
             EPortInterfaceSubtype.Quint,
             EPortInterfaceSubtype.Dual,
             EPortInterfaceSubtype.Single
         }
 
-    def __define_single(self) -> List[enums.PortSpeedMode]:
-        if "T1S" in self.interface:
-            return [
-                enums.PortSpeedMode.AUTO,
-                enums.PortSpeedMode.F100M,
-                enums.PortSpeedMode.F1G,
-            ]
-        return []
+    def __define_single(self) -> list[enums.PortSpeedMode]:
+        if "T1S" not in self.interface:
+            return []
+        return [
+            enums.PortSpeedMode.AUTO,
+            enums.PortSpeedMode.F100M,
+            enums.PortSpeedMode.F1G,
+        ]
 
-    def __define_dual(self) -> List[enums.PortSpeedMode]:
+    def __define_dual(self) -> list[enums.PortSpeedMode]:
         if "T1" in self.interface:
             return [enums.PortSpeedMode.F10MHDX, ]
         return []
 
-    def __define_triple(self) -> List[enums.PortSpeedMode]:
+    def __define_triple(self) -> list[enums.PortSpeedMode]:
         if self.interface.startswith("SFP"):
             if self.capabilities.max_speed == 1_000:
                 return [
                     enums.PortSpeedMode.AUTO,
                     enums.PortSpeedMode.F10M,
                     enums.PortSpeedMode.F100M,
                     enums.PortSpeedMode.F1G,
@@ -92,29 +91,29 @@
                 enums.PortSpeedMode.F100M,
                 enums.PortSpeedMode.F1G,
                 enums.PortSpeedMode.F10G,
                 enums.PortSpeedMode.F100M1G,
             ]
         return []
 
-    def __define_quint(self) -> List[enums.PortSpeedMode]:
+    def __define_quint(self) -> list[enums.PortSpeedMode]:
         speeds = [
             enums.PortSpeedMode.AUTO,
             enums.PortSpeedMode.F100M,
             enums.PortSpeedMode.F1G,
             enums.PortSpeedMode.F2500M,
             enums.PortSpeedMode.F5G,
             enums.PortSpeedMode.F100M1G,
             enums.PortSpeedMode.F100M1G2500M,
         ]
         if self.interface.startswith("10GBASE-T"):
             speeds.append(enums.PortSpeedMode.F10G)
         return speeds
 
-    def find_port_possible_speed(self) -> List[enums.PortSpeedMode]:
+    def find_port_possible_speed(self) -> list[enums.PortSpeedMode]:
         if not self.can_set_port_speed:
             return []
         define_func = {
             EPortInterfaceSubtype.Single: self.__define_single,
             EPortInterfaceSubtype.Dual: self.__define_dual,
             EPortInterfaceSubtype.Triple: self.__define_triple,
             EPortInterfaceSubtype.Quint: self.__define_quint
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/state_storage/modules_state.py` & `xoa-driver-2.0.0/xoa_driver/internals/state_storage/modules_state.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import asyncio
 from typing import List
 from dataclasses import (
     dataclass,
     field,
 )
-from xoa_driver.internals.core.transporter import funcs
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.core import funcs
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     M_MODEL,
     M_RESERVATION,
     M_RESERVEDBY,
     M_MEDIASUPPORT,
 )
 
 from xoa_driver.internals.utils import attributes as utils
@@ -42,15 +42,15 @@
         )
         self.reservation = enums.ReservedStatus(reservation_r.operation)
         self.reserved_by = reserved_by_r.username
         self.model = model_r.model
 
     def register_subscriptions(self, module) -> None:
         module._conn.subscribe(M_RESERVEDBY, utils.Update(self, "reserved_by", "username", module._check_identity))
-        module._conn.subscribe(M_RESERVATION, utils.Update(self, "reservation", "operation", module._check_identity, format=lambda a: enums.ReservedStatus(a)))
+        module._conn.subscribe(M_RESERVATION, utils.Update(self, "reservation", "operation", module._check_identity))
         module._conn.subscribe(M_MODEL, utils.Update(self, "model", "model", module._check_identity))
 
 
 @dataclass(frozen=True)
 class ModuleSpeed:
     """Module's port-speed information.
     """
@@ -117,12 +117,12 @@
             self.__media_info_list.append(mi)
 
     async def initiate(self, module) -> None:
         m_support_resp, *_ = await asyncio.gather(
             M_MEDIASUPPORT(module._conn, module.module_id).get(),
             super().initiate(module)
         )
-        self.media_info_list = m_support_resp.media_info_list  # type: ignore
+        self.media_info_list = m_support_resp.media_info_list
 
     def register_subscriptions(self, module) -> None:
         super().register_subscriptions(module)
         module._conn.subscribe(M_MEDIASUPPORT, utils.Update(self, "media_info_list", "media_info_list", module._check_identity))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/state_storage/ports_state.py` & `xoa-driver-2.0.0/xoa_driver/internals/state_storage/ports_state.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 import asyncio
 from typing import List
 
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     P_CAPABILITIES,
     P4_CAPABILITIES,
     P_RECEIVESYNC,
     P_RESERVEDBY,
     P_RESERVATION,
     P_INTERFACE,
     P_TRAFFIC,
     P4_STATE,
 )
-from xoa_driver.internals.core.transporter import funcs
-from xoa_driver.internals.core.commands import enums
+from xoa_driver.internals.core import funcs
+from xoa_driver.internals.commands import enums
 
 from xoa_driver.internals.utils import attributes as utils
 from ._speed_detector import SpeedDetector
 
 
 class PortLocalState:
     """Port local state
@@ -52,17 +52,17 @@
         )
         self.sync_status = enums.SyncStatus(sync_status_r.sync_status)
         self.interface = interface_r.interface
         self.reservation = enums.ReservedStatus(reservation_r.status)
         self.reserved_by = reserved_by_r.username
 
     def register_subscriptions(self, port) -> None:
-        port._conn.subscribe(P_RECEIVESYNC, utils.Update(self, "sync_status", "sync_status", port._check_identity, format=lambda a: enums.SyncStatus(a)))
+        port._conn.subscribe(P_RECEIVESYNC, utils.Update(self, "sync_status", "sync_status", port._check_identity))
         port._conn.subscribe(P_RESERVEDBY, utils.Update(self, "reserved_by", "username", port._check_identity))
-        port._conn.subscribe(P_RESERVATION, utils.Update(self, "reservation", "status", port._check_identity, format=lambda a: enums.ReservedStatus(a)))
+        port._conn.subscribe(P_RESERVATION, utils.Update(self, "reservation", "status", port._check_identity))
         port._conn.subscribe(P_INTERFACE, utils.Update(self, "interface", "interface", port._check_identity))
 
 
 class PortChimeraLocalState(PortLocalState):
     """Chimera port's local state
     """
     __slots__ = ("capabilities",)
@@ -95,15 +95,15 @@
             super().initiate(port)
         )
         self.capabilities = capabilities
         self.traffic_state = enums.TrafficOnOff(traffic_state_r.on_off)
 
     def register_subscriptions(self, port) -> None:
         super().register_subscriptions(port)
-        port._conn.subscribe(P_TRAFFIC, utils.Update(self, "traffic_state", "on_off", port._check_identity, format=lambda a: enums.TrafficOnOff(a)))
+        port._conn.subscribe(P_TRAFFIC, utils.Update(self, "traffic_state", "on_off", port._check_identity))
 
 
 class PortL23GenuineLocalState(PortL23LocalState):
     """L23 port's local state
     """
     __slots__ = ("port_possible_speed_modes",)
 
@@ -147,8 +147,8 @@
             super().initiate(port)
         )
         self.capabilities = capabilities
         self.traffic_state = enums.L47PortState(traffic_state_r.state)
 
     def register_subscriptions(self, port) -> None:
         super().register_subscriptions(port)
-        port._conn.subscribe(P4_STATE, utils.Update(self, "traffic_state", "state", port._check_identity, format=lambda a: enums.L47PortState(a)))
+        port._conn.subscribe(P4_STATE, utils.Update(self, "traffic_state", "state", port._check_identity))
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/state_storage/testers_state.py` & `xoa-driver-2.0.0/xoa_driver/internals/state_storage/testers_state.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 import asyncio
 from typing import (
     Optional,
     Final,
 )
-
-from xoa_driver.internals.core.transporter import funcs
-from xoa_driver.internals.core.commands import enums
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.core import funcs
+from xoa_driver.internals.commands import enums
+from xoa_driver.internals.commands import (
     C_RESERVATION,
     C_CAPABILITIES,
     C_RESERVEDBY,
 )
 from xoa_driver.internals.utils import attributes as utils
+from xoa_driver.internals.exceptions.testers import UnsupportedFirmwareError
+
+MIN_SUPPORTED_VERSION = 446.5
 
 
 class TesterLocalState:
     """Tester local state
 
     :param host: tester's address/hostname
     :type host: str
@@ -62,35 +64,41 @@
             tester.reservation.get(),
         )
         self.reserved_by = reserved_by_res.username
         self.model = model_res.model
         self.driver_version = v_major_res.pci_driver_version
         self.version_major = v_major_res.chassis_major_version
         self.serial_number = serial_res.serial_number
-        self.reservation = enums.ReservedStatus(reservation_resp.operation)
+        self.reservation = reservation_resp.operation
         self.capabilities = capabilities_resp
 
     def register_subscriptions(self, tester) -> None:
         tester._conn.subscribe(C_RESERVEDBY, utils.Update(self, "reserved_by", "username"))
-        tester._conn.subscribe(C_RESERVATION, utils.Update(self, "reservation", "operation", format=lambda a: enums.ReservedStatus(a)))
+        tester._conn.subscribe(C_RESERVATION, utils.Update(self, "reservation", "operation"))
 
 
 class GenuineTesterLocalState(TesterLocalState):
     """Genuine Tester Local State
 
     :param host: tester's address/hostname
     :type host: str
     :param port: the port number for connection establishment
     :type port: int
     """
-    __slots__ = ("build_string",)
+    __slots__ = ("build_string", "version_minor")
 
     def __init__(self, host: str, port: int) -> None:
         super().__init__(host, port)
         self.build_string: str = ""
+        self.version_minor: int = 0
 
     async def initiate(self, tester) -> None:
-        bs, _ = await asyncio.gather(
+        bs, v_minor, _ = await asyncio.gather(
             tester.build_string.get(),
+            tester.version_no_minor.get(),
             super().initiate(tester)
         )
         self.build_string = bs.build_string
+        self.version_minor = v_minor.chassis_minor_version
+        current_version = float(f"{self.version_major}.{self.version_minor}")
+        if current_version < MIN_SUPPORTED_VERSION:
+            raise UnsupportedFirmwareError(current_version)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/utils/attributes.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/attributes.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,34 +1,33 @@
 from dataclasses import dataclass
 from typing import (
-    Any,
     Callable,
     Type,
     TYPE_CHECKING,
 )
 if TYPE_CHECKING:
-    from xoa_driver.internals.core.protocol.struct_response import Response
+    from xoa_driver.internals.core.transporter.protocol.struct_response import Response
+    from xoa_driver.internals.core.transporter._typings import XoaCommandType
     from xoa_driver.internals.core import interfaces as itf
 
 
 @dataclass
 class Update:
     inst: Type
     property_name: str
     response_key: str
     condition: Callable[["Response"], bool] = lambda _: True
-    format: Callable[[Any], Any] = lambda a: a  # TODO: will be removed in future
 
     # keep it Async just for consistent interface of event_observer
     async def __call__(self, response: "Response") -> None:
         if not self.condition(response):
             return None
         v = getattr(response.values, self.response_key)
-        setattr(self.inst, self.property_name, self.format(v))
+        setattr(self.inst, self.property_name, v)
 
 
-def on_event(self, evt: "itf.CMD_TYPE", callback: "itf.CallbackType") -> None:
+def on_event(self, evt: "XoaCommandType", callback: "itf.CallbackType") -> None:
     async def _f(response: "Response", *args, **kwargs) -> None:
         if not self._check_identity(response):
             return None
         await callback(self, response.values, *args, **kwargs)
     self._conn.subscribe(evt, _f)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/utils/cap_id.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/cap_id.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from typing import (
     NamedTuple,
     Type,
     TypeVar,
 )
-from xoa_driver.internals.core.commands import P_CAPABILITIES
+from xoa_driver.internals.commands import P_CAPABILITIES
 
 T = TypeVar("T", bound="CapID")
 
 
 class CapID(NamedTuple):
     """ID generated based on the port capability"""
 
@@ -28,31 +28,31 @@
     can_link_flap: int
     can_auto_neg_base_r: int
     can_pma_error_pulse: int
 
     @classmethod
     def create_from_capabilities(cls: Type[T], cap: P_CAPABILITIES.GetDataAttr) -> T:
         return cls(
-            int(cap.can_set_autoneg),
-            int(cap.can_eee),
-            int(cap.can_hw_reg_access),
-            int(cap.can_tcvr_mii_reg_access),
-            int(cap.can_adv_phy_man),
-            int(cap.can_mdi_mdix),
-            int(cap.can_dyn_traffic_change),
-            int(cap.can_pcs_pma_config),
-            int(cap.can_fec),
-            int(cap.can_fec_stats),
-            int(cap.can_tx_eq),
-            int(cap.can_rx_retune),
-            int(cap.can_manipulate_preamble),
-            int(cap.can_set_link_train),
-            int(cap.can_link_flap),
-            int(cap.can_auto_neg_base_r),
-            int(cap.can_pma_error_pulse),
+            cap.can_set_autoneg,
+            cap.can_eee,
+            cap.can_hw_reg_access,
+            cap.can_tcvr_mii_reg_access,
+            cap.can_adv_phy_man,
+            cap.can_mdi_mdix,
+            cap.can_dyn_traffic_change,
+            cap.can_pcs_pma_config,
+            cap.can_fec,
+            cap.can_fec_stats,
+            cap.can_tx_eq,
+            cap.can_rx_retune,
+            cap.can_manipulate_preamble,
+            cap.can_set_link_train,
+            cap.can_link_flap,
+            cap.can_auto_neg_base_r,
+            cap.can_pma_error_pulse,
         )
 
     def to_int(self) -> int:
         return int("".join(str(ele) for ele in self), 2)
 
     def __eq__(self, other: "CapID") -> bool:
         if isinstance(other, CapID):
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/utils/indices/_interfaces.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/indices/_interfaces.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/utils/indices/header_modifier_manager.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/indices/header_modifier_manager.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,18 +2,17 @@
     List,
     Type,
     Union,
     Generic,
     TypeVar,
     TYPE_CHECKING,
 )
-import dataclasses
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-    from xoa_driver.internals.core.commands import (
+    from xoa_driver.internals.commands import (
         PS_MODIFIERCOUNT,
         PS_MODIFIEREXTCOUNT
     )
     CT = Union[Type[PS_MODIFIERCOUNT], Type[PS_MODIFIEREXTCOUNT]]
 
 MT = TypeVar("MT")
 
@@ -24,15 +23,15 @@
         self.__kind = kind
         self.__modifier_type = modifier_type
 
         self._count = count_type(self.__conn, *kind)
         self.__items: List[MT] = []
 
     async def _populate(self) -> None:
-        count = dataclasses.astuple(await self._count.get())[0]  # modifier_count or ext_modifier_count
+        count = (await self._count.get()).to_tuple()[0]  # modifier_count or ext_modifier_count
         self.__items = [
             self.__modifier_type(
                 self.__conn,
                 *self.__kind,
                 idx
             )
             for idx in range(count)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/utils/indices/index_manager.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/indices/index_manager.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/utils/modules_manager.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/managers/modules_manager.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,95 +1,117 @@
+from __future__ import annotations
 import asyncio
 import functools
 from typing import (
     TYPE_CHECKING,
+    Awaitable,
+    Iterable,
+    NamedTuple,
     Type,
     TypeVar,
-    List,
     Callable,
     Union,
-
+    cast,
 )
 from collections import OrderedDict
-from dataclasses import dataclass
 
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
-from xoa_driver.internals.core.commands import (
+from xoa_driver.internals.commands import (
     M_REVISION,
     M_MODEL
 )
-from ._base_manager import ResourcesBaseManager
-from xoa_driver.internals import exceptions
+from .abc import AbcResourcesManager
+from .exceptions import (
+    NoSuchModuleError,
+    WrongTesterError
+)
+
+# region Module Init dataset
 
 
-@dataclass
-class ModuleData:
-    """Base module data.
-    """
+class ModuleData(NamedTuple):
+    """Base module data."""
     module_id: int
     ports_count: int
-    revision: str = ""
+    revision: str
 
 
 class L23ModuleData(ModuleData):
-    """L23 module data
-    """
-    async def get_revision(self, conn) -> None:
-        """Return the module name of the L23 module.
-        """
-        r = await M_REVISION(conn, self.module_id).get()
-        self.revision = r.revision
+    """L23 module data"""
+    @classmethod
+    async def create(cls, conn, mid: int, p_cnt: int) -> "L23ModuleData":
+        """Return the module name of the L23 module."""
+        r = await M_REVISION(conn, mid).get()
+        return cls(
+            module_id=mid,
+            ports_count=p_cnt,
+            revision=r.revision
+        )
 
 
 class L47ModuleData(ModuleData):
-    """L47 module data
-    """
-    async def get_revision(self, conn) -> None:
-        """Return the module name of the L47 module.
-        """
-        r = await M_MODEL(conn, self.module_id).get()
-        self.revision = r.model
+    """L47 module data"""
+    @classmethod
+    async def create(cls, conn, mid: int, p_cnt: int) -> "L47ModuleData":
+        """Return the module name of the L47 module."""
+        r = await M_MODEL(conn, mid).get()
+        return cls(
+            module_id=mid,
+            ports_count=p_cnt,
+            revision=r.model
+        )
+
+# endregion
 
 
 MT = TypeVar("MT")
 MTypeObtainer = Callable[[str], Type]
 ModuleDataType = Union[Type["L23ModuleData"], Type["L47ModuleData"]]
 
 
-class ModulesManager(ResourcesBaseManager[MT]):
-    """Module Index Manager
-    """
+class ModulesManager(AbcResourcesManager[MT]):
+    """Modules Manager"""
 
     __slots__ = ("_conn", "__m_types_obtainer")
 
     def __init__(self, conn: "itf.IConnection", m_types_obtainer: MTypeObtainer) -> None:
         super().__init__()
         self._conn = conn
         self.__m_types_obtainer = m_types_obtainer
 
-    async def fill(self, ports_count: List[int], module_type: ModuleDataType) -> None:
+    def obtain(self, key: int) -> MT:
+        try:
+            return super().obtain(key)
+        except KeyError:
+            raise NoSuchModuleError(key)
+
+    def obtain_multiple(self, *keys: int) -> tuple[MT, ...]:
+        try:
+            return super().obtain_multiple(*keys)
+        except KeyError as err:
+            raise NoSuchModuleError(err.args[0])
+
+    async def fill(self, ports_count: list[int], module_type: ModuleDataType) -> None:
         """Method for create and fill in."""
         assert not self._lock, "Method <fill> can be called only once."
-        identities = [
-            module_type(
-                module_id=slot_id,
-                ports_count=p_count
-            )
+        module_builder = (
+            module_type.create(self._conn, slot_id, p_count)
             for slot_id, p_count in enumerate(ports_count)
             if p_count > 0
-        ]
-        await asyncio.gather(*[mi.get_revision(self._conn) for mi in identities])
+        )
+        identities: Iterable[ModuleData] = await asyncio.gather(*module_builder)
+
         self._items = OrderedDict(
             (
                 idnt.module_id,
                 self.__m_types_obtainer(idnt.revision)(self._conn, idnt)
             )
             for idnt in identities
         )
         if len(self) == 0:
-            raise exceptions.WrongTesterError()
-        coros = list(self._items.values())
-        await asyncio.gather(*coros)  # type: ignore
+            raise WrongTesterError()
+        coros = cast(Iterable[Awaitable], self._items.values())
+        await asyncio.gather(*coros)
 
     fill_l23 = functools.partialmethod(fill, module_type=L23ModuleData)
     fill_l47 = functools.partialmethod(fill, module_type=L47ModuleData)
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/utils/ports_manager.py` & `xoa-driver-2.0.0/xoa_driver/internals/utils/managers/ports_manager.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,30 +1,49 @@
+from __future__ import annotations
 import asyncio
 from typing import (
+    Awaitable,
+    Iterable,
     Type,
     TypeVar,
     Protocol,
     TYPE_CHECKING,
+    cast,
 )
 from collections import OrderedDict
 if TYPE_CHECKING:
     from xoa_driver.internals.core import interfaces as itf
 
-from ._base_manager import ResourcesBaseManager
+from .abc import AbcResourcesManager
+from .exceptions import NoSuchPortError
 
 
 class IPort(Protocol):
     def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
         ...
 
 
 PT = TypeVar("PT", bound=IPort)
 
 
-class PortsManager(ResourcesBaseManager[PT]):
+class PortBaseManager(AbcResourcesManager[PT]):
+    def obtain(self, key: int) -> PT:
+        try:
+            return super().obtain(key)
+        except KeyError:
+            raise NoSuchPortError(key)
+
+    def obtain_multiple(self, *keys: int) -> tuple[PT, ...]:
+        try:
+            return super().obtain_multiple(*keys)
+        except KeyError as err:
+            raise NoSuchPortError(err.args[0])
+
+
+class PortsManager(PortBaseManager[PT]):
 
     __slots__ = ("_conn", "_ports_type", "_ports_count", "_module_id", )
 
     def __init__(self, conn: "itf.IConnection", module_id: int, ports_type: Type[PT], ports_count: int) -> None:
         super().__init__()
         self._conn = conn
         self._ports_type = ports_type
@@ -39,46 +58,43 @@
                     port_id=port_id,
                 )
             )
             for port_id in range(self._ports_count)
         )
 
     async def fill(self) -> None:
-        """Method for create and fill in."""
-
         assert not self._lock, "Method <fill> can be called only once."
-        coros = list(self._items.values())
-        await asyncio.gather(*coros)  # type: ignore
+        coros = cast(Iterable[Awaitable], self._items.values())
+        await asyncio.gather(*coros)
 
 
 class PortResolver(Protocol):
     async def __call__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> Type:
         ...
 
 
-class PortsCombiManager(ResourcesBaseManager[PT]):
+class PortsCombiManager(PortBaseManager[PT]):
 
-    __slots__ = ("_conn", "_resolver", "_ports_count", "_module_id", )
+    __slots__ = ("_conn", "_resolver", "_ports_count", "_module_id",)
 
     def __init__(self, conn: "itf.IConnection", module_id: int, resolver: PortResolver, ports_count: int) -> None:
         super().__init__()
         self._conn = conn
         self._resolver = resolver
         self._ports_count = ports_count
         self._module_id = module_id
         self._items: OrderedDict[int, PT] = OrderedDict()
 
     async def fill(self) -> None:
-        """Method for create and fill in."""
         assert not self._lock, "Method <fill> can be called only once."
-        coros = [
+        coros = iter(
             self._resolver(
                 conn=self._conn,
                 module_id=self._module_id,
                 port_id=port_id,
             )
             for port_id in range(self._ports_count)
-        ]
+        )
         ports = await asyncio.gather(*coros)
         self._items = OrderedDict(
             (port.kind.port_id, port) for port in ports
         )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/internals/warn.py` & `xoa-driver-2.0.0/xoa_driver/internals/warn.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/misc.py` & `xoa-driver-2.0.0/xoa_driver/misc.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 #: Other types which are used by ports or as a parameter to attribute set method.
 
 
-from .internals.core.transporter.token import Token
-from .internals.core.commands.subtypes import (
+from .internals.core.token import Token
+from .internals.core.transporter.protocol.payload.types import Hex
+from .internals.commands.subtypes import (
     ArpChunk,
     NdpChunk,
 )
 
 import sys
 
 if "xoa_driver.v2" in sys.modules:
@@ -24,14 +25,15 @@
 from .internals.hli_v1.ports.port_l23.chimera.port_emulation import CFlow as ImpairmentFlow
 from .internals.hli_v1.ports.port_l23.chimera.filter_definition.general import ModeBasic as BasicImpairmentFlowFilter
 from .internals.hli_v1.ports.port_l23.chimera.filter_definition.general import ModeExtended as ExtendedImpairmentFlowFilter
 
 
 __all__ = (
     "Token",
+    "Hex",
     "ArpChunk",
     "NdpChunk",
     "ConnectionGroup",
     "BasePortFilter",
     "GenuinePortFilter",
     "LengthTerm",
     "MatchTerm",
```

### Comparing `xoa-driver-1.3.3/xoa_driver/modules.py` & `xoa-driver-2.0.0/xoa_driver/modules.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/ports.py` & `xoa-driver-2.0.0/xoa_driver/ports.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/testers.py` & `xoa-driver-2.0.0/xoa_driver/testers.py`

 * *Files 13% similar despite different names*

```diff
@@ -5,24 +5,33 @@
     raise ImportError("\33[31mOnly Single interface version is allowed to being use at the same time.\33[0m")
 
 from .internals.hli_v1.testers.l23_tester import L23Tester
 from .internals.hli_v1.testers.l23ve_tester import L23VeTester
 from .internals.hli_v1.testers.l47_tester import L47Tester
 from .internals.hli_v1.testers.l47ve_tester import L47VeTester
 
-import typing
+import typing as t
 
-GenericAnyTester = typing.Union[
+GenericAnyTester = t.Union[
     "L23Tester",
     "L23VeTester",
     "L47Tester",
     "L47VeTester",
 ]
-
+GenericAnyGenuineTester = t.Union[
+    "L23Tester",
+    "L47Tester",
+]
+GenericAnyVirtualTester = t.Union[
+    "L23VeTester",
+    "L47VeTester",
+]
 
 __all__ = (
     "L23Tester",
     "L23VeTester",
     "L47Tester",
     "L47VeTester",
     "GenericAnyTester",
+    "GenericAnyGenuineTester",
+    "GenericAnyVirtualTester",
 )
```

### Comparing `xoa-driver-1.3.3/xoa_driver/v2/misc.py` & `xoa-driver-2.0.0/xoa_driver/v2/misc.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 #: Other types which are used by ports or as a parameter to attribute set method.
 
 
-from xoa_driver.internals.core.transporter.token import Token
-from xoa_driver.internals.core.commands.subtypes import (
+from xoa_driver.internals.core.token import Token
+from xoa_driver.internals.commands.subtypes import (
     ArpChunk,
     NdpChunk,
 )
 
 # indices types
 from xoa_driver.internals.hli_v2.indices.connection_group.cg import ConnectionGroupIdx as ConnectionGroup
 from xoa_driver.internals.hli_v2.indices.filter.base_filter import BaseFilterIdx as BasePortFilter
```

### Comparing `xoa-driver-1.3.3/xoa_driver/v2/modules.py` & `xoa-driver-2.0.0/xoa_driver/v2/modules.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/v2/ports.py` & `xoa-driver-2.0.0/xoa_driver/v2/ports.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver/v2/testers.py` & `xoa-driver-2.0.0/xoa_driver/v2/testers.py`

 * *Files identical despite different names*

### Comparing `xoa-driver-1.3.3/xoa_driver.egg-info/PKG-INFO` & `xoa-driver-2.0.0/xoa_driver.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: xoa-driver
-Version: 1.3.3
+Version: 2.0.0
 Summary: Xena OpenAutomation (XOA) Python API is a driver providing user-friendly communication interfaces to Xena's physical and virtual Traffic Generation and Analysis (TGA) testers. It provides a rich collection of programming interfaces that can be used to either write test scripts or develop applications.
 Home-page: https://github.com/xenanetworks/open-automation-python-api
 Author: Artem Constantinov, Ron Ding, Leonard Yu
 Author-email: aco@xenanetworks.com, rdi@xenanetworks.com, hyu@xenanetworks.com
 Maintainer: Xena Networks
 Maintainer-email: support@xenanetworks.com
 License: Apache 2.0
```

### Comparing `xoa-driver-1.3.3/xoa_driver.egg-info/SOURCES.txt` & `xoa-driver-2.0.0/xoa_driver.egg-info/SOURCES.txt`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,17 @@
 LICENSE
 README.md
 pyproject.toml
 setup.cfg
 setup.py
+tests/test_config_importer.py
+tests/test_hli.py
+tests/test_lli.py
+tests/test_req_parsing.py
+tests/test_resp_parsing.py
 xoa_driver/__init__.py
 xoa_driver/enums.py
 xoa_driver/exceptions.py
 xoa_driver/hlfuncs.py
 xoa_driver/lli.py
 xoa_driver/misc.py
 xoa_driver/modules.py
@@ -17,70 +22,81 @@
 xoa_driver.egg-info/SOURCES.txt
 xoa_driver.egg-info/dependency_links.txt
 xoa_driver.egg-info/requires.txt
 xoa_driver.egg-info/top_level.txt
 xoa_driver/functions/__init__.py
 xoa_driver/functions/anlt.py
 xoa_driver/functions/anlt_ll_debug.py
+xoa_driver/functions/config_cli_convert.py
 xoa_driver/functions/exceptions.py
 xoa_driver/functions/mgmt.py
 xoa_driver/functions/tools.py
 xoa_driver/internals/__init__.py
 xoa_driver/internals/warn.py
+xoa_driver/internals/commands/__init__.py
+xoa_driver/internals/commands/c_commands.py
+xoa_driver/internals/commands/enums.py
+xoa_driver/internals/commands/m4_commands.py
+xoa_driver/internals/commands/m4e_commands.py
+xoa_driver/internals/commands/m_commands.py
+xoa_driver/internals/commands/p4_commands.py
+xoa_driver/internals/commands/p4e_commands.py
+xoa_driver/internals/commands/p4g_commands.py
+xoa_driver/internals/commands/p_commands.py
+xoa_driver/internals/commands/pc_commands.py
+xoa_driver/internals/commands/pd_commands.py
+xoa_driver/internals/commands/pe_commands.py
+xoa_driver/internals/commands/pec_commands.py
+xoa_driver/internals/commands/ped_commands.py
+xoa_driver/internals/commands/pef_commands.py
+xoa_driver/internals/commands/pf_commands.py
+xoa_driver/internals/commands/pl1_commands.py
+xoa_driver/internals/commands/pl_commands.py
+xoa_driver/internals/commands/pm_commands.py
+xoa_driver/internals/commands/pp_commands.py
+xoa_driver/internals/commands/pr_commands.py
+xoa_driver/internals/commands/ps_commands.py
+xoa_driver/internals/commands/pt_commands.py
+xoa_driver/internals/commands/px_commands.py
+xoa_driver/internals/commands/subtypes.py
 xoa_driver/internals/core/__init__.py
+xoa_driver/internals/core/builders.py
+xoa_driver/internals/core/exceptions.py
+xoa_driver/internals/core/funcs.py
 xoa_driver/internals/core/interfaces.py
-xoa_driver/internals/core/registry.py
-xoa_driver/internals/core/commands/__init__.py
-xoa_driver/internals/core/commands/c_commands.py
-xoa_driver/internals/core/commands/enums.py
-xoa_driver/internals/core/commands/m4_commands.py
-xoa_driver/internals/core/commands/m4e_commands.py
-xoa_driver/internals/core/commands/m_commands.py
-xoa_driver/internals/core/commands/p4_commands.py
-xoa_driver/internals/core/commands/p4e_commands.py
-xoa_driver/internals/core/commands/p4g_commands.py
-xoa_driver/internals/core/commands/p_commands.py
-xoa_driver/internals/core/commands/pc_commands.py
-xoa_driver/internals/core/commands/pd_commands.py
-xoa_driver/internals/core/commands/pe_commands.py
-xoa_driver/internals/core/commands/pec_commands.py
-xoa_driver/internals/core/commands/ped_commands.py
-xoa_driver/internals/core/commands/pef_commands.py
-xoa_driver/internals/core/commands/pf_commands.py
-xoa_driver/internals/core/commands/pl1_commands.py
-xoa_driver/internals/core/commands/pl_commands.py
-xoa_driver/internals/core/commands/pm_commands.py
-xoa_driver/internals/core/commands/pp_commands.py
-xoa_driver/internals/core/commands/pr_commands.py
-xoa_driver/internals/core/commands/ps_commands.py
-xoa_driver/internals/core/commands/pt_commands.py
-xoa_driver/internals/core/commands/px_commands.py
-xoa_driver/internals/core/commands/subtypes.py
-xoa_driver/internals/core/protocol/__init__.py
-xoa_driver/internals/core/protocol/command_builders.py
-xoa_driver/internals/core/protocol/constants.py
-xoa_driver/internals/core/protocol/struct_header.py
-xoa_driver/internals/core/protocol/struct_request.py
-xoa_driver/internals/core/protocol/struct_response.py
-xoa_driver/internals/core/protocol/utils.py
-xoa_driver/internals/core/protocol/fields/__init__.py
-xoa_driver/internals/core/protocol/fields/add_on.py
-xoa_driver/internals/core/protocol/fields/data_types.py
-xoa_driver/internals/core/protocol/fields/exceptions.py
-xoa_driver/internals/core/protocol/fields/field.py
-xoa_driver/internals/core/protocol/fields/interfaces.py
+xoa_driver/internals/core/token.py
 xoa_driver/internals/core/transporter/__init__.py
-xoa_driver/internals/core/transporter/commands_manager.py
-xoa_driver/internals/core/transporter/events_observer.py
+xoa_driver/internals/core/transporter/_processor.py
+xoa_driver/internals/core/transporter/_publisher.py
+xoa_driver/internals/core/transporter/_request_id_counter.py
+xoa_driver/internals/core/transporter/_stream.py
+xoa_driver/internals/core/transporter/_typings.py
 xoa_driver/internals/core/transporter/exceptions.py
-xoa_driver/internals/core/transporter/funcs.py
-xoa_driver/internals/core/transporter/logging.py
-xoa_driver/internals/core/transporter/request_id.py
-xoa_driver/internals/core/transporter/token.py
-xoa_driver/internals/core/transporter/transportation_handler.py
+xoa_driver/internals/core/transporter/handler.py
+xoa_driver/internals/core/transporter/registry.py
+xoa_driver/internals/core/transporter/logger/__init__.py
+xoa_driver/internals/core/transporter/logger/__logger.py
+xoa_driver/internals/core/transporter/logger/__state_off.py
+xoa_driver/internals/core/transporter/logger/__state_on_default.py
+xoa_driver/internals/core/transporter/logger/__state_on_loguru.py
+xoa_driver/internals/core/transporter/logger/__state_on_user.py
+xoa_driver/internals/core/transporter/protocol/__init__.py
+xoa_driver/internals/core/transporter/protocol/_constants.py
+xoa_driver/internals/core/transporter/protocol/_utils.py
+xoa_driver/internals/core/transporter/protocol/exceptions.py
+xoa_driver/internals/core/transporter/protocol/struct_header.py
+xoa_driver/internals/core/transporter/protocol/struct_request.py
+xoa_driver/internals/core/transporter/protocol/struct_response.py
+xoa_driver/internals/core/transporter/protocol/payload/__init__.py
+xoa_driver/internals/core/transporter/protocol/payload/base_struct.py
+xoa_driver/internals/core/transporter/protocol/payload/descriptor.py
+xoa_driver/internals/core/transporter/protocol/payload/exceptions.py
+xoa_driver/internals/core/transporter/protocol/payload/field.py
+xoa_driver/internals/core/transporter/protocol/payload/types.py
+xoa_driver/internals/core/transporter/protocol/payload/utils.py
 xoa_driver/internals/exceptions/__init__.py
 xoa_driver/internals/exceptions/modules.py
 xoa_driver/internals/exceptions/testers.py
 xoa_driver/internals/hli_v1/__init__.py
 xoa_driver/internals/hli_v1/revisions.py
 xoa_driver/internals/hli_v1/indices/__init__.py
 xoa_driver/internals/hli_v1/indices/base_index.py
@@ -167,15 +183,14 @@
 xoa_driver/internals/hli_v1/ports/port_l23/chimera/filter_definition/working.py
 xoa_driver/internals/hli_v1/ports/port_l47/__init__.py
 xoa_driver/internals/hli_v1/ports/port_l47/counters.py
 xoa_driver/internals/hli_v1/ports/port_l47/main.py
 xoa_driver/internals/hli_v1/ports/port_l47/packet_engine.py
 xoa_driver/internals/hli_v1/testers/__init__.py
 xoa_driver/internals/hli_v1/testers/_base_tester.py
-xoa_driver/internals/hli_v1/testers/_tester_session.py
 xoa_driver/internals/hli_v1/testers/l23_tester.py
 xoa_driver/internals/hli_v1/testers/l23ve_tester.py
 xoa_driver/internals/hli_v1/testers/l47_tester.py
 xoa_driver/internals/hli_v1/testers/l47ve_tester.py
 xoa_driver/internals/hli_v1/testers/genuine/__init__.py
 xoa_driver/internals/hli_v1/testers/genuine/management_interface.py
 xoa_driver/internals/hli_v1/testers/genuine/l_23/__init__.py
@@ -269,15 +284,14 @@
 xoa_driver/internals/hli_v2/ports/port_l23/chimera/filter_definition/working.py
 xoa_driver/internals/hli_v2/ports/port_l47/__init__.py
 xoa_driver/internals/hli_v2/ports/port_l47/counters.py
 xoa_driver/internals/hli_v2/ports/port_l47/main.py
 xoa_driver/internals/hli_v2/ports/port_l47/packet_engine.py
 xoa_driver/internals/hli_v2/testers/__init__.py
 xoa_driver/internals/hli_v2/testers/_base_tester.py
-xoa_driver/internals/hli_v2/testers/_tester_session.py
 xoa_driver/internals/hli_v2/testers/l23_tester.py
 xoa_driver/internals/hli_v2/testers/l23ve_tester.py
 xoa_driver/internals/hli_v2/testers/l47_tester.py
 xoa_driver/internals/hli_v2/testers/l47ve_tester.py
 xoa_driver/internals/hli_v2/testers/genuine/__init__.py
 xoa_driver/internals/hli_v2/testers/genuine/management_interface.py
 xoa_driver/internals/hli_v2/testers/genuine/l_23/__init__.py
@@ -286,24 +300,27 @@
 xoa_driver/internals/hli_v2/testers/genuine/l_23/upload_file.py
 xoa_driver/internals/state_storage/__init__.py
 xoa_driver/internals/state_storage/_speed_detector.py
 xoa_driver/internals/state_storage/modules_state.py
 xoa_driver/internals/state_storage/ports_state.py
 xoa_driver/internals/state_storage/testers_state.py
 xoa_driver/internals/utils/__init__.py
-xoa_driver/internals/utils/_base_manager.py
 xoa_driver/internals/utils/attributes.py
 xoa_driver/internals/utils/cap_id.py
 xoa_driver/internals/utils/kind.py
-xoa_driver/internals/utils/modules_manager.py
-xoa_driver/internals/utils/ports_manager.py
 xoa_driver/internals/utils/rev_tool.py
+xoa_driver/internals/utils/session.py
 xoa_driver/internals/utils/indices/__init__.py
 xoa_driver/internals/utils/indices/_interfaces.py
 xoa_driver/internals/utils/indices/header_modifier_manager.py
 xoa_driver/internals/utils/indices/index_manager.py
 xoa_driver/internals/utils/indices/observer.py
+xoa_driver/internals/utils/managers/__init__.py
+xoa_driver/internals/utils/managers/abc.py
+xoa_driver/internals/utils/managers/exceptions.py
+xoa_driver/internals/utils/managers/modules_manager.py
+xoa_driver/internals/utils/managers/ports_manager.py
 xoa_driver/v2/__init__.py
 xoa_driver/v2/misc.py
 xoa_driver/v2/modules.py
 xoa_driver/v2/ports.py
 xoa_driver/v2/testers.py
```

