# Comparing `tmp/discord-py-interactions-5.5.1.tar.gz` & `tmp/discord-py-interactions-5.6.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "discord-py-interactions-5.5.1.tar", last modified: Tue May 23 08:20:57 2023, max compression
+gzip compressed data, was "discord-py-interactions-5.6.0.tar", last modified: Fri Jun  2 07:10:27 2023, max compression
```

## Comparing `discord-py-interactions-5.5.1.tar` & `discord-py-interactions-5.6.0.tar`

### file list

```diff
@@ -1,192 +1,192 @@
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.602128 discord-py-interactions-5.5.1/
--rw-rw-rw-   0        0        0     1099 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/LICENSE
--rw-rw-rw-   0        0        0      169 2023-04-15 15:24:39.000000 discord-py-interactions-5.5.1/MANIFEST.in
--rw-rw-rw-   0        0        0     5189 2023-05-23 08:20:57.602128 discord-py-interactions-5.5.1/PKG-INFO
--rw-rw-rw-   0        0        0     3861 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/README.md
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.468503 discord-py-interactions-5.5.1/discord_py_interactions.egg-info/
--rw-rw-rw-   0        0        0     5189 2023-05-23 08:20:57.000000 discord-py-interactions-5.5.1/discord_py_interactions.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     6434 2023-05-23 08:20:57.000000 discord-py-interactions-5.5.1/discord_py_interactions.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-05-23 08:20:57.000000 discord-py-interactions-5.5.1/discord_py_interactions.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0     1141 2023-05-23 08:20:57.000000 discord-py-interactions-5.5.1/discord_py_interactions.egg-info/requires.txt
--rw-rw-rw-   0        0        0       19 2023-05-23 08:20:57.000000 discord-py-interactions-5.5.1/discord_py_interactions.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.470505 discord-py-interactions-5.5.1/interactions/
--rw-rw-rw-   0        0        0    15818 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/__init__.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.471506 discord-py-interactions-5.5.1/interactions/api/
--rw-rw-rw-   0        0        0       47 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/__init__.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.474508 discord-py-interactions-5.5.1/interactions/api/events/
--rw-rw-rw-   0        0        0     3921 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/__init__.py
--rw-rw-rw-   0        0        0     2984 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/api/events/base.py
--rw-rw-rw-   0        0        0    24582 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/discord.py
--rw-rw-rw-   0        0        0     8542 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/internal.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.487520 discord-py-interactions-5.5.1/interactions/api/events/processors/
--rw-rw-rw-   0        0        0      811 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/__init__.py
--rw-rw-rw-   0        0        0     1626 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/_template.py
--rw-rw-rw-   0        0        0      459 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/_template.pyi
--rw-rw-rw-   0        0        0     1590 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/auto_mod.py
--rw-rw-rw-   0        0        0     2135 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/channel_events.py
--rw-rw-rw-   0        0        0     4943 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/guild_events.py
--rw-rw-rw-   0        0        0     1337 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/integrations.py
--rw-rw-rw-   0        0        0     1532 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/member_events.py
--rw-rw-rw-   0        0        0     2878 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/message_events.py
--rw-rw-rw-   0        0        0     3448 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/reaction_events.py
--rw-rw-rw-   0        0        0     1776 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/role_events.py
--rw-rw-rw-   0        0        0      998 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/stage_events.py
--rw-rw-rw-   0        0        0     2335 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/thread_events.py
--rw-rw-rw-   0        0        0     2155 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/user_events.py
--rw-rw-rw-   0        0        0     2002 2023-04-15 15:03:36.000000 discord-py-interactions-5.5.1/interactions/api/events/processors/voice_events.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.490523 discord-py-interactions-5.5.1/interactions/api/gateway/
--rw-rw-rw-   0        0        0       78 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/gateway/__init__.py
--rw-rw-rw-   0        0        0    13930 2023-05-21 18:21:04.000000 discord-py-interactions-5.5.1/interactions/api/gateway/gateway.py
--rw-rw-rw-   0        0        0     8445 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/gateway/state.py
--rw-rw-rw-   0        0        0    11918 2023-05-21 18:21:04.000000 discord-py-interactions-5.5.1/interactions/api/gateway/websocket.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.492525 discord-py-interactions-5.5.1/interactions/api/http/
--rw-rw-rw-   0        0        0        0 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/http/__init__.py
--rw-rw-rw-   0        0        0    22788 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/api/http/http_client.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.505537 discord-py-interactions-5.5.1/interactions/api/http/http_requests/
--rw-rw-rw-   0        0        0      835 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/__init__.py
--rw-rw-rw-   0        0        0     1332 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/bot.py
--rw-rw-rw-   0        0        0    23470 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/channels.py
--rw-rw-rw-   0        0        0     3383 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/emojis.py
--rw-rw-rw-   0        0        0    36406 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/guild.py
--rw-rw-rw-   0        0        0    12410 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/interactions.py
--rw-rw-rw-   0        0        0     7128 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/members.py
--rw-rw-rw-   0        0        0     5688 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/messages.py
--rw-rw-rw-   0        0        0     5083 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/reactions.py
--rw-rw-rw-   0        0        0     5802 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/scheduled_events.py
--rw-rw-rw-   0        0        0     4445 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/stickers.py
--rw-rw-rw-   0        0        0     9318 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/threads.py
--rw-rw-rw-   0        0        0     4485 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/users.py
--rw-rw-rw-   0        0        0     7837 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/http_requests/webhooks.py
--rw-rw-rw-   0        0        0     2960 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/http/route.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.513544 discord-py-interactions-5.5.1/interactions/api/voice/
--rw-rw-rw-   0        0        0        0 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/voice/__init__.py
--rw-rw-rw-   0        0        0    12296 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/api/voice/audio.py
--rw-rw-rw-   0        0        0     9276 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/voice/audio_writer.py
--rw-rw-rw-   0        0        0     3754 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/voice/encryption.py
--rw-rw-rw-   0        0        0    11836 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/voice/opus.py
--rw-rw-rw-   0        0        0     5596 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/voice/player.py
--rw-rw-rw-   0        0        0     8005 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/api/voice/recorder.py
--rw-rw-rw-   0        0        0    15625 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/api/voice/voice_gateway.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.514546 discord-py-interactions-5.5.1/interactions/bin/
--rw-rw-rw-   0        0        0   441856 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/bin/opus-x64.dll
--rw-rw-rw-   0        0        0   366080 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/bin/opus-x86.dll
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.521053 discord-py-interactions-5.5.1/interactions/client/
--rw-rw-rw-   0        0        0     1771 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/__init__.py
--rw-rw-rw-   0        0        0     9799 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/auto_shard_client.py
--rw-rw-rw-   0        0        0    94638 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/client/client.py
--rw-rw-rw-   0        0        0     9066 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/client/const.py
--rw-rw-rw-   0        0        0    13632 2023-04-13 04:51:39.000000 discord-py-interactions-5.5.1/interactions/client/errors.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.524056 discord-py-interactions-5.5.1/interactions/client/mixins/
--rw-rw-rw-   0        0        0      118 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/mixins/__init__.py
--rw-rw-rw-   0        0        0      891 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/mixins/modal.py
--rw-rw-rw-   0        0        0     4313 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/mixins/send.py
--rw-rw-rw-   0        0        0     3746 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/mixins/serialization.py
--rw-rw-rw-   0        0        0    32261 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/client/smart_cache.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.533064 discord-py-interactions-5.5.1/interactions/client/utils/
--rw-rw-rw-   0        0        0     2159 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/__init__.py
--rw-rw-rw-   0        0        0     2436 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/attr_converters.py
--rw-rw-rw-   0        0        0     2285 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/attr_utils.py
--rw-rw-rw-   0        0        0     1210 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/attr_utils.pyi
--rw-rw-rw-   0        0        0     4806 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/cache.py
--rw-rw-rw-   0        0        0     3632 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/deserialise_app_cmds.py
--rw-rw-rw-   0        0        0     3189 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/formatting.py
--rw-rw-rw-   0        0        0     3642 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/input_utils.py
--rw-rw-rw-   0        0        0     7524 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/misc_utils.py
--rw-rw-rw-   0        0        0     4688 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/serializer.py
--rw-rw-rw-   0        0        0     1079 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/client/utils/text_utils.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.537067 discord-py-interactions-5.5.1/interactions/ext/
--rw-rw-rw-   0        0        0        0 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/__init__.py
--rw-rw-rw-   0        0        0     1883 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/console.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.541071 discord-py-interactions-5.5.1/interactions/ext/debug_extension/
--rw-rw-rw-   0        0        0     3300 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/debug_extension/__init__.py
--rw-rw-rw-   0        0        0     8127 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/ext/debug_extension/debug_application_cmd.py
--rw-rw-rw-   0        0        0     4589 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/ext/debug_extension/debug_exec.py
--rw-rw-rw-   0        0        0     1418 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/debug_extension/debug_exts.py
--rw-rw-rw-   0        0        0     6234 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/debug_extension/utils.py
--rw-rw-rw-   0        0        0     8393 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/ext/jurigged.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.542072 discord-py-interactions-5.5.1/interactions/ext/mypy/
--rw-rw-rw-   0        0        0     1085 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/mypy/__init__.py
--rw-rw-rw-   0        0        0    16283 2023-04-12 07:41:04.000000 discord-py-interactions-5.5.1/interactions/ext/paginators.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.547077 discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/
--rw-rw-rw-   0        0        0      554 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/__init__.py
--rw-rw-rw-   0        0        0    28686 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/command.py
--rw-rw-rw-   0        0        0     3516 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/context.py
--rw-rw-rw-   0        0        0     7778 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/help.py
--rw-rw-rw-   0        0        0    14502 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/manager.py
--rw-rw-rw-   0        0        0     1205 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/utils.py
--rw-rw-rw-   0        0        0     3661 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/ext/sentry.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.548077 discord-py-interactions-5.5.1/interactions/models/
--rw-rw-rw-   0        0        0    12961 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/__init__.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.575102 discord-py-interactions-5.5.1/interactions/models/discord/
--rw-rw-rw-   0        0        0     8257 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/__init__.py
--rw-rw-rw-   0        0        0     5628 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/activity.py
--rw-rw-rw-   0        0        0     3105 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/app_perms.py
--rw-rw-rw-   0        0        0     4829 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/application.py
--rw-rw-rw-   0        0        0     4046 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/discord/asset.py
--rw-rw-rw-   0        0        0    13987 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/models/discord/auto_mod.py
--rw-rw-rw-   0        0        0     1779 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/base.py
--rw-rw-rw-   0        0        0   105837 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/models/discord/channel.py
--rw-rw-rw-   0        0        0     8310 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/color.py
--rw-rw-rw-   0        0        0    25482 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/components.py
--rw-rw-rw-   0        0        0    16775 2023-04-12 16:38:08.000000 discord-py-interactions-5.5.1/interactions/models/discord/embed.py
--rw-rw-rw-   0        0        0     9326 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/emoji.py
--rw-rw-rw-   0        0        0    31801 2023-05-21 18:21:04.000000 discord-py-interactions-5.5.1/interactions/models/discord/enums.py
--rw-rw-rw-   0        0        0     2323 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/file.py
--rw-rw-rw-   0        0        0    97974 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/models/discord/guild.py
--rw-rw-rw-   0        0        0     6212 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/invite.py
--rw-rw-rw-   0        0        0    39359 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/models/discord/message.py
--rw-rw-rw-   0        0        0     5139 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/modal.py
--rw-rw-rw-   0        0        0     3609 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/reaction.py
--rw-rw-rw-   0        0        0     8428 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/discord/role.py
--rw-rw-rw-   0        0        0     9712 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/discord/scheduled_event.py
--rw-rw-rw-   0        0        0     5353 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/snowflake.py
--rw-rw-rw-   0        0        0     1479 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/stage_instance.py
--rw-rw-rw-   0        0        0     5602 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/discord/sticker.py
--rw-rw-rw-   0        0        0     2871 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/team.py
--rw-rw-rw-   0        0        0     6052 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/discord/thread.py
--rw-rw-rw-   0        0        0     4429 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/timestamp.py
--rw-rw-rw-   0        0        0    26639 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/models/discord/user.py
--rw-rw-rw-   0        0        0     6907 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/models/discord/user.pyi
--rw-rw-rw-   0        0        0     4971 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/voice_state.py
--rw-rw-rw-   0        0        0    12721 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/discord/webhooks.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.588114 discord-py-interactions-5.5.1/interactions/models/internal/
--rw-rw-rw-   0        0        0     5225 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/internal/__init__.py
--rw-rw-rw-   0        0        0    11584 2023-04-18 11:38:10.000000 discord-py-interactions-5.5.1/interactions/models/internal/active_voice_state.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.589115 discord-py-interactions-5.5.1/interactions/models/internal/annotations/
--rw-rw-rw-   0        0        0      523 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/annotations/__init__.py
--rw-rw-rw-   0        0        0     7673 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/annotations/slash.py
--rw-rw-rw-   0        0        0    57258 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/models/internal/application_commands.py
--rw-rw-rw-   0        0        0     1470 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/auto_defer.py
--rw-rw-rw-   0        0        0     1238 2023-04-15 11:23:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/callback.py
--rw-rw-rw-   0        0        0     2485 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/checks.py
--rw-rw-rw-   0        0        0    12716 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/interactions/models/internal/command.py
--rw-rw-rw-   0        0        0    36903 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/models/internal/context.py
--rw-rw-rw-   0        0        0    19957 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/converters.py
--rw-rw-rw-   0        0        0    18178 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/models/internal/cooldowns.py
--rw-rw-rw-   0        0        0    10446 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/interactions/models/internal/extension.py
--rw-rw-rw-   0        0        0     5271 2023-05-09 07:42:44.000000 discord-py-interactions-5.5.1/interactions/models/internal/listener.py
--rw-rw-rw-   0        0        0     6168 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/localisation.py
--rw-rw-rw-   0        0        0     1405 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/protocols.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.592117 discord-py-interactions-5.5.1/interactions/models/internal/tasks/
--rw-rw-rw-   0        0        0      212 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/tasks/__init__.py
--rw-rw-rw-   0        0        0     5295 2023-04-11 11:01:25.000000 discord-py-interactions-5.5.1/interactions/models/internal/tasks/task.py
--rw-rw-rw-   0        0        0     4194 2023-04-11 11:01:25.000000 discord-py-interactions-5.5.1/interactions/models/internal/tasks/triggers.py
--rw-rw-rw-   0        0        0     1228 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/internal/wait.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.594119 discord-py-interactions-5.5.1/interactions/models/misc/
--rw-rw-rw-   0        0        0      115 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/misc/__init__.py
--rw-rw-rw-   0        0        0      996 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/misc/context_manager.py
--rw-rw-rw-   0        0        0     3216 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/interactions/models/misc/iterator.py
--rw-rw-rw-   0        0        0        0 2023-03-29 13:34:31.000000 discord-py-interactions-5.5.1/interactions/py.typed
--rw-rw-rw-   0        0        0     5707 2023-05-23 08:17:41.000000 discord-py-interactions-5.5.1/pyproject.toml
--rw-rw-rw-   0        0        0       60 2023-05-23 08:17:10.000000 discord-py-interactions-5.5.1/requirements.txt
--rw-rw-rw-   0        0        0      456 2023-05-23 08:20:57.603128 discord-py-interactions-5.5.1/setup.cfg
--rw-rw-rw-   0        0        0     2458 2023-05-23 08:20:48.000000 discord-py-interactions-5.5.1/setup.py
-drwxrwxrwx   0        0        0        0 2023-05-23 08:20:57.601126 discord-py-interactions-5.5.1/tests/
--rw-rw-rw-   0        0        0        0 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/tests/__init__.py
--rw-rw-rw-   0        0        0     4500 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/tests/consts.py
--rw-rw-rw-   0        0        0    17528 2023-04-30 10:09:50.000000 discord-py-interactions-5.5.1/tests/test_bot.py
--rw-rw-rw-   0        0        0     1956 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/tests/test_cache.py
--rw-rw-rw-   0        0        0     2056 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/tests/test_contexts.py
--rw-rw-rw-   0        0        0     2278 2023-04-13 04:51:39.000000 discord-py-interactions-5.5.1/tests/test_cooldowns.py
--rw-rw-rw-   0        0        0     3907 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/tests/test_emoji.py
--rw-rw-rw-   0        0        0     1081 2023-04-11 10:58:23.000000 discord-py-interactions-5.5.1/tests/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/
+-rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      163 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     5030 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     3769 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.785480 discord-py-interactions-5.6.0/discord_py_interactions.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     5030 2023-06-02 07:10:27.000000 discord-py-interactions-5.6.0/discord_py_interactions.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     6434 2023-06-02 07:10:27.000000 discord-py-interactions-5.6.0/discord_py_interactions.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-02 07:10:27.000000 discord-py-interactions-5.6.0/discord_py_interactions.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1141 2023-06-02 07:10:27.000000 discord-py-interactions-5.6.0/discord_py_interactions.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       19 2023-06-02 07:10:27.000000 discord-py-interactions-5.6.0/discord_py_interactions.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.785480 discord-py-interactions-5.6.0/interactions/
+-rw-r--r--   0 runner    (1001) docker     (123)    15269 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.785480 discord-py-interactions-5.6.0/interactions/api/
+-rw-r--r--   0 runner    (1001) docker     (123)       44 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.789480 discord-py-interactions-5.6.0/interactions/api/events/
+-rw-r--r--   0 runner    (1001) docker     (123)     3740 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2894 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/base.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24007 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/discord.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8278 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/internal.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.789480 discord-py-interactions-5.6.0/interactions/api/events/processors/
+-rw-r--r--   0 runner    (1001) docker     (123)      782 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1575 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/_template.py
+-rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/_template.pyi
+-rw-r--r--   0 runner    (1001) docker     (123)     1553 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/auto_mod.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2088 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/channel_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4825 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/guild_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1306 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/integrations.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1493 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/member_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2793 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/message_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3365 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/reaction_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1725 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/role_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)      974 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/stage_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2284 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/thread_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2094 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/user_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1960 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/events/processors/voice_events.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.789480 discord-py-interactions-5.6.0/interactions/api/gateway/
+-rw-r--r--   0 runner    (1001) docker     (123)       74 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/gateway/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13569 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/gateway/gateway.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8218 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/gateway/state.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11590 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/gateway/websocket.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.789480 discord-py-interactions-5.6.0/interactions/api/http/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22204 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_client.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.793480 discord-py-interactions-5.6.0/interactions/api/http/http_requests/
+-rw-r--r--   0 runner    (1001) docker     (123)      806 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1289 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/bot.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22816 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/channels.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3271 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/emojis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35368 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/guild.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12056 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/interactions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6948 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/members.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5511 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/messages.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4925 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/reactions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5623 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/scheduled_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4298 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/stickers.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9054 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/threads.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4341 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/users.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7607 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/http_requests/webhooks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2870 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/http/route.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.793480 discord-py-interactions-5.6.0/interactions/api/voice/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11922 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/audio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9016 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/audio_writer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3646 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/encryption.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11470 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/opus.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5445 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/player.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7775 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/recorder.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15273 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/api/voice/voice_gateway.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.793480 discord-py-interactions-5.6.0/interactions/bin/
+-rw-r--r--   0 runner    (1001) docker     (123)   441856 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/bin/opus-x64.dll
+-rw-r--r--   0 runner    (1001) docker     (123)   366080 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/bin/opus-x86.dll
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.793480 discord-py-interactions-5.6.0/interactions/client/
+-rw-r--r--   0 runner    (1001) docker     (123)     1690 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9537 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/auto_shard_client.py
+-rw-r--r--   0 runner    (1001) docker     (123)    92213 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/client.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8781 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/const.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13209 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/errors.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.793480 discord-py-interactions-5.6.0/interactions/client/mixins/
+-rw-r--r--   0 runner    (1001) docker     (123)      113 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/mixins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      861 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/mixins/modal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4211 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/mixins/send.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3634 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/mixins/serialization.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31356 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/smart_cache.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.797479 discord-py-interactions-5.6.0/interactions/client/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     2053 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2364 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/attr_converters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/attr_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1176 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/attr_utils.pyi
+-rw-r--r--   0 runner    (1001) docker     (123)     4643 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/cache.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3524 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/deserialise_app_cmds.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3051 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/formatting.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3499 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/input_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7259 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/misc_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4504 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/serializer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/client/utils/text_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.797479 discord-py-interactions-5.6.0/interactions/ext/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1835 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/console.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.797479 discord-py-interactions-5.6.0/interactions/ext/debug_extension/
+-rw-r--r--   0 runner    (1001) docker     (123)     3203 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/debug_extension/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7919 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/debug_extension/debug_application_cmd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4450 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/debug_extension/debug_exec.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1379 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/debug_extension/debug_exts.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6062 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/debug_extension/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8179 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/jurigged.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.797479 discord-py-interactions-5.6.0/interactions/ext/mypy/
+-rw-r--r--   0 runner    (1001) docker     (123)     1044 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/mypy/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15840 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/paginators.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.797479 discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/
+-rw-r--r--   0 runner    (1001) docker     (123)      535 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27881 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/command.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3418 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/context.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7591 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/help.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14126 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3583 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/ext/sentry.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.797479 discord-py-interactions-5.6.0/interactions/models/
+-rw-r--r--   0 runner    (1001) docker     (123)    12525 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.801479 discord-py-interactions-5.6.0/interactions/models/discord/
+-rw-r--r--   0 runner    (1001) docker     (123)     8047 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5510 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/activity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3015 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/app_perms.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4742 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/application.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3914 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13612 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/auto_mod.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1726 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/base.py
+-rw-r--r--   0 runner    (1001) docker     (123)   103322 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/channel.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7978 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/color.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24769 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/components.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16286 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/embed.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9124 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/emoji.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30758 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/enums.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2246 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/file.py
+-rw-r--r--   0 runner    (1001) docker     (123)    96247 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/guild.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6078 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/invite.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38399 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/message.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4971 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/modal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3512 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/reaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8191 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/role.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9485 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/scheduled_event.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5187 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/snowflake.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1432 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/stage_instance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5448 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/sticker.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2801 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/team.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8875 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/thread.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4293 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/timestamp.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26138 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/user.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6742 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/user.pyi
+-rw-r--r--   0 runner    (1001) docker     (123)     4860 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/voice_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12406 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/discord/webhooks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/interactions/models/internal/
+-rw-r--r--   0 runner    (1001) docker     (123)     5012 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11266 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/active_voice_state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/interactions/models/internal/annotations/
+-rw-r--r--   0 runner    (1001) docker     (123)      500 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/annotations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7405 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/annotations/slash.py
+-rw-r--r--   0 runner    (1001) docker     (123)    55760 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/application_commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1430 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/auto_defer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1195 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/callback.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2394 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/checks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12390 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/command.py
+-rw-r--r--   0 runner    (1001) docker     (123)    36003 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/context.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19351 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/converters.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17655 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/cooldowns.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10168 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/extension.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5127 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/listener.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6039 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/localisation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1361 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/protocols.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/interactions/models/internal/tasks/
+-rw-r--r--   0 runner    (1001) docker     (123)      208 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/tasks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5127 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/tasks/task.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4064 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/tasks/triggers.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1191 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/internal/wait.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/interactions/models/misc/
+-rw-r--r--   0 runner    (1001) docker     (123)      111 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/misc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      961 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/misc/context_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3119 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/models/misc/iterator.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/interactions/py.typed
+-rw-r--r--   0 runner    (1001) docker     (123)     5506 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       55 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      414 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2389 2023-06-02 07:10:20.000000 discord-py-interactions-5.6.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:27.805479 discord-py-interactions-5.6.0/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4344 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/consts.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16999 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/test_bot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1898 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/test_cache.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1999 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/test_contexts.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2209 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/test_cooldowns.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3767 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/test_emoji.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-02 07:10:10.000000 discord-py-interactions-5.6.0/tests/utils.py
```

### Comparing `discord-py-interactions-5.5.1/LICENSE` & `discord-py-interactions-5.6.0/LICENSE`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-MIT License
-
-Copyright (c) 2023 - Present LordOfPolls
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+MIT License
+
+Copyright (c) 2023 - Present LordOfPolls
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

### Comparing `discord-py-interactions-5.5.1/PKG-INFO` & `discord-py-interactions-5.6.0/PKG-INFO`

 * *Files 22% similar despite different names*

```diff
@@ -1,127 +1,127 @@
-Metadata-Version: 2.1
-Name: discord-py-interactions
-Version: 5.5.1
-Summary: Easy, simple, scalable and modular: a Python API wrapper for interactions.
-Home-page: https://github.com/interactions-py/interactions.py
-Author: LordOfPolls
-Author-email: dev@lordofpolls.com
-Project-URL: Discord, https://discord.gg/KkgMBVuEkx
-Project-URL: Documentation, https://naff-docs.readthedocs.io/en/latest/
-Classifier: Development Status :: 3 - Alpha
-Classifier: Framework :: AsyncIO
-Classifier: Framework :: aiohttp
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Natural Language :: English
-Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Topic :: Software Development :: Libraries
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Classifier: Topic :: Documentation
-Classifier: Typing :: Typed
-Requires-Python: >=3.10
-Description-Content-Type: text/markdown
-Provides-Extra: voice
-Provides-Extra: speedup
-Provides-Extra: sentry
-Provides-Extra: jurigged
-Provides-Extra: console
-Provides-Extra: all
-Provides-Extra: docs
-Provides-Extra: tests
-Provides-Extra: dev
-License-File: LICENSE
-
-<div align="center">
-
-   # Interactions.py
-   <br>
-
-   ![](https://img.shields.io/pypi/v/discord-py-interactions.svg?label=Version&logo=pypi)
-   ![](https://img.shields.io/badge/Python-3.10+-1081c1?logo=python)
-   [![](https://img.shields.io/pypi/dm/discord-py-slash-command.svg?logo=python&label=Downloads)](https://pypi.org/project/discord-py-interactions/)
-
-   [![](https://img.shields.io/badge/Code%20Style-black-000000.svg)](https://github.com/psf/black)
-   [![License](https://img.shields.io/badge/License-GPL-blue)](https://github.com/interactions-py/interactions.py/blob/stable/LICENSE)
-
-   [![](https://img.shields.io/badge/Docs-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/)
-   [![](https://img.shields.io/badge/Guides-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started)
-   [![image](https://discord.com/api/guilds/789032594456576001/embed.png)](https://discord.gg/interactions)
-
-</div>
-
-## A Feature-rich Discord Bot Framework for Python
-
-A highly extensible, easy to use, and feature complete framework for Discord.
-
-`interactions.py` is the culmination of years of experience with Discord's APIs and bot development. This framework has been built from the ground up with community feedback and suggestions in mind. Our framework provides a modern and intuitive set of language bindings for easy interaction with Discord.
-
-## Key Features
-interactions.py offers a wide range of features for building Python-powered Discord bots and web applications alike:
-- âœ… 100% coverage of the Discord API
-- âœ… Dynamic cache with TTL support
-- âœ… Modern and Pythonic API for easy interaction with Discord
-- âœ… Proper rate-limit handling
-- âœ… Feature parity with most other Discord API wrappers
-- âœ… Fully automated command synchronisation
-
-In addition to core functionality, `interactions.py` provides a range of optional extensions, allowing you to further customize your bot and add new features with ease.
-
-## Extensibility
-
-So the base library doesn't do what you want? No problem! With builtin extensions, you are able to extend the functionality of the library. And if none of those pique your interest, there are a myriad of other extension libraries available.
-
-Just type `bot.load("extension")`
-
-<details>
-    <summary>Extensions</summary>
-
-   ### Prefixed Commands
-
-   Prefixed commands, message commands, or legacy commands.
-   Whatever you want to call them, by default the `interactions.py` library will not handle these. But rest assured this extension will get you going
-
-  - âœ… Automatic command registration
-  - âœ… Annotation support
-
-  ### Debug Extension
-
-  A fully featured debug and utilities suite to help you get your bots made
-
-  ### Jurigged
-
-  A hot reloading extension allowing you to automagically update your bot without reboots
-
-  ### Sentry
-
-  Integrates Sentry.io error tracking into your bot with a single line
-
-  ### Console
-
-  Adds `aiomonitor` support with enables cli commands over a web interface
-
-  ### Paginators
-
-  Easily create multi-page embeds without having to implement the UX
-
-</details>
-
-## Where do I start?
-
-Getting started with `interactions.py` is easy! Simply install it via `pip` and start building your Discord application in Python:
-
-`pip install -U discord-py-interactions`
-```python
-import interactions
-
-bot = interactions.Client()
-
-@interactions.listen()
-async def on_startup():
-    print("Bot is ready!")
-
-bot.start("token")
-```
-
-With `interactions.py`, you can quickly and easily build complex Discord applications with Python. Check out our [guides](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started) for more information. Or join our [discord](https://discord.gg/interactions).
+Metadata-Version: 2.1
+Name: discord-py-interactions
+Version: 5.6.0
+Summary: Easy, simple, scalable and modular: a Python API wrapper for interactions.
+Home-page: https://github.com/interactions-py/interactions.py
+Author: LordOfPolls
+Author-email: dev@lordofpolls.com
+Project-URL: Discord, https://discord.gg/KkgMBVuEkx
+Project-URL: Documentation, https://naff-docs.readthedocs.io/en/latest/
+Classifier: Development Status :: 3 - Alpha
+Classifier: Framework :: AsyncIO
+Classifier: Framework :: aiohttp
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Natural Language :: English
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+Classifier: Topic :: Documentation
+Classifier: Typing :: Typed
+Requires-Python: >=3.10
+Description-Content-Type: text/markdown
+Provides-Extra: voice
+Provides-Extra: speedup
+Provides-Extra: sentry
+Provides-Extra: jurigged
+Provides-Extra: console
+Provides-Extra: all
+Provides-Extra: docs
+Provides-Extra: tests
+Provides-Extra: dev
+License-File: LICENSE
+
+<div align="center">
+
+   # Interactions.py
+   <br>
+
+   ![](https://img.shields.io/pypi/v/discord-py-interactions.svg?label=Version&logo=pypi)
+   ![](https://img.shields.io/badge/Python-3.10+-1081c1?logo=python)
+   [![](https://img.shields.io/pypi/dm/discord-py-slash-command.svg?logo=python&label=Downloads)](https://pypi.org/project/discord-py-interactions/)
+
+   [![](https://img.shields.io/badge/Code%20Style-black-000000.svg)](https://github.com/psf/black)
+   [![License](https://img.shields.io/badge/License-GPL-blue)](https://github.com/interactions-py/interactions.py/blob/stable/LICENSE)
+
+   [![](https://img.shields.io/badge/Docs-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/)
+   [![](https://img.shields.io/badge/Guides-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started)
+   [![image](https://discord.com/api/guilds/789032594456576001/embed.png)](https://discord.gg/interactions)
+
+</div>
+
+## A Feature-rich Discord Bot Framework for Python
+
+A highly extensible, easy to use, and feature complete framework for Discord.
+
+`interactions.py` is the culmination of years of experience with Discord's APIs and bot development. This framework has been built from the ground up with community feedback and suggestions in mind. Our framework provides a modern and intuitive set of language bindings for easy interaction with Discord.
+
+## Key Features
+interactions.py offers a wide range of features for building Python-powered Discord bots and web applications alike:
+- ✅ 100% coverage of the Discord API
+- ✅ Dynamic cache with TTL support
+- ✅ Modern and Pythonic API for easy interaction with Discord
+- ✅ Proper rate-limit handling
+- ✅ Feature parity with most other Discord API wrappers
+- ✅ Fully automated command synchronisation
+
+In addition to core functionality, `interactions.py` provides a range of optional extensions, allowing you to further customize your bot and add new features with ease.
+
+## Extensibility
+
+So the base library doesn't do what you want? No problem! With builtin extensions, you are able to extend the functionality of the library. And if none of those pique your interest, there are a myriad of other extension libraries available.
+
+Just type `bot.load("extension")`
+
+<details>
+    <summary>Extensions</summary>
+
+   ### Prefixed Commands
+
+   Prefixed commands, message commands, or legacy commands.
+   Whatever you want to call them, by default the `interactions.py` library will not handle these. But rest assured this extension will get you going
+
+  - ✅ Automatic command registration
+  - ✅ Annotation support
+
+  ### Debug Extension
+
+  A fully featured debug and utilities suite to help you get your bots made
+
+  ### Jurigged
+
+  A hot reloading extension allowing you to automagically update your bot without reboots
+
+  ### Sentry
+
+  Integrates Sentry.io error tracking into your bot with a single line
+
+  ### Console
+
+  Adds `aiomonitor` support with enables cli commands over a web interface
+
+  ### Paginators
+
+  Easily create multi-page embeds without having to implement the UX
+
+</details>
+
+## Where do I start?
+
+Getting started with `interactions.py` is easy! Simply install it via `pip` and start building your Discord application in Python:
+
+`pip install -U discord-py-interactions`
+```python
+import interactions
+
+bot = interactions.Client()
+
+@interactions.listen()
+async def on_startup():
+    print("Bot is ready!")
+
+bot.start("token")
+```
+
+With `interactions.py`, you can quickly and easily build complex Discord applications with Python. Check out our [guides](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started) for more information. Or join our [discord](https://discord.gg/interactions).
```

### Comparing `discord-py-interactions-5.5.1/README.md` & `discord-py-interactions-5.6.0/README.md`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,92 +1,92 @@
-<div align="center">
-
-   # Interactions.py
-   <br>
-
-   ![](https://img.shields.io/pypi/v/discord-py-interactions.svg?label=Version&logo=pypi)
-   ![](https://img.shields.io/badge/Python-3.10+-1081c1?logo=python)
-   [![](https://img.shields.io/pypi/dm/discord-py-slash-command.svg?logo=python&label=Downloads)](https://pypi.org/project/discord-py-interactions/)
-
-   [![](https://img.shields.io/badge/Code%20Style-black-000000.svg)](https://github.com/psf/black)
-   [![License](https://img.shields.io/badge/License-GPL-blue)](https://github.com/interactions-py/interactions.py/blob/stable/LICENSE)
-
-   [![](https://img.shields.io/badge/Docs-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/)
-   [![](https://img.shields.io/badge/Guides-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started)
-   [![image](https://discord.com/api/guilds/789032594456576001/embed.png)](https://discord.gg/interactions)
-
-</div>
-
-## A Feature-rich Discord Bot Framework for Python
-
-A highly extensible, easy to use, and feature complete framework for Discord.
-
-`interactions.py` is the culmination of years of experience with Discord's APIs and bot development. This framework has been built from the ground up with community feedback and suggestions in mind. Our framework provides a modern and intuitive set of language bindings for easy interaction with Discord.
-
-## Key Features
-interactions.py offers a wide range of features for building Python-powered Discord bots and web applications alike:
-- ✅ 100% coverage of the Discord API
-- ✅ Dynamic cache with TTL support
-- ✅ Modern and Pythonic API for easy interaction with Discord
-- ✅ Proper rate-limit handling
-- ✅ Feature parity with most other Discord API wrappers
-- ✅ Fully automated command synchronisation
-
-In addition to core functionality, `interactions.py` provides a range of optional extensions, allowing you to further customize your bot and add new features with ease.
-
-## Extensibility
-
-So the base library doesn't do what you want? No problem! With builtin extensions, you are able to extend the functionality of the library. And if none of those pique your interest, there are a myriad of other extension libraries available.
-
-Just type `bot.load("extension")`
-
-<details>
-    <summary>Extensions</summary>
-
-   ### Prefixed Commands
-
-   Prefixed commands, message commands, or legacy commands.
-   Whatever you want to call them, by default the `interactions.py` library will not handle these. But rest assured this extension will get you going
-
-  - ✅ Automatic command registration
-  - ✅ Annotation support
-
-  ### Debug Extension
-
-  A fully featured debug and utilities suite to help you get your bots made
-
-  ### Jurigged
-
-  A hot reloading extension allowing you to automagically update your bot without reboots
-
-  ### Sentry
-
-  Integrates Sentry.io error tracking into your bot with a single line
-
-  ### Console
-
-  Adds `aiomonitor` support with enables cli commands over a web interface
-
-  ### Paginators
-
-  Easily create multi-page embeds without having to implement the UX
-
-</details>
-
-## Where do I start?
-
-Getting started with `interactions.py` is easy! Simply install it via `pip` and start building your Discord application in Python:
-
-`pip install -U discord-py-interactions`
-```python
-import interactions
-
-bot = interactions.Client()
-
-@interactions.listen()
-async def on_startup():
-    print("Bot is ready!")
-
-bot.start("token")
-```
-
-With `interactions.py`, you can quickly and easily build complex Discord applications with Python. Check out our [guides](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started) for more information. Or join our [discord](https://discord.gg/interactions).
+<div align="center">
+
+   # Interactions.py
+   <br>
+
+   ![](https://img.shields.io/pypi/v/discord-py-interactions.svg?label=Version&logo=pypi)
+   ![](https://img.shields.io/badge/Python-3.10+-1081c1?logo=python)
+   [![](https://img.shields.io/pypi/dm/discord-py-slash-command.svg?logo=python&label=Downloads)](https://pypi.org/project/discord-py-interactions/)
+
+   [![](https://img.shields.io/badge/Code%20Style-black-000000.svg)](https://github.com/psf/black)
+   [![License](https://img.shields.io/badge/License-GPL-blue)](https://github.com/interactions-py/interactions.py/blob/stable/LICENSE)
+
+   [![](https://img.shields.io/badge/Docs-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/)
+   [![](https://img.shields.io/badge/Guides-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started)
+   [![image](https://discord.com/api/guilds/789032594456576001/embed.png)](https://discord.gg/interactions)
+
+</div>
+
+## A Feature-rich Discord Bot Framework for Python
+
+A highly extensible, easy to use, and feature complete framework for Discord.
+
+`interactions.py` is the culmination of years of experience with Discord's APIs and bot development. This framework has been built from the ground up with community feedback and suggestions in mind. Our framework provides a modern and intuitive set of language bindings for easy interaction with Discord.
+
+## Key Features
+interactions.py offers a wide range of features for building Python-powered Discord bots and web applications alike:
+- ✅ 100% coverage of the Discord API
+- ✅ Dynamic cache with TTL support
+- ✅ Modern and Pythonic API for easy interaction with Discord
+- ✅ Proper rate-limit handling
+- ✅ Feature parity with most other Discord API wrappers
+- ✅ Fully automated command synchronisation
+
+In addition to core functionality, `interactions.py` provides a range of optional extensions, allowing you to further customize your bot and add new features with ease.
+
+## Extensibility
+
+So the base library doesn't do what you want? No problem! With builtin extensions, you are able to extend the functionality of the library. And if none of those pique your interest, there are a myriad of other extension libraries available.
+
+Just type `bot.load("extension")`
+
+<details>
+    <summary>Extensions</summary>
+
+   ### Prefixed Commands
+
+   Prefixed commands, message commands, or legacy commands.
+   Whatever you want to call them, by default the `interactions.py` library will not handle these. But rest assured this extension will get you going
+
+  - ✅ Automatic command registration
+  - ✅ Annotation support
+
+  ### Debug Extension
+
+  A fully featured debug and utilities suite to help you get your bots made
+
+  ### Jurigged
+
+  A hot reloading extension allowing you to automagically update your bot without reboots
+
+  ### Sentry
+
+  Integrates Sentry.io error tracking into your bot with a single line
+
+  ### Console
+
+  Adds `aiomonitor` support with enables cli commands over a web interface
+
+  ### Paginators
+
+  Easily create multi-page embeds without having to implement the UX
+
+</details>
+
+## Where do I start?
+
+Getting started with `interactions.py` is easy! Simply install it via `pip` and start building your Discord application in Python:
+
+`pip install -U discord-py-interactions`
+```python
+import interactions
+
+bot = interactions.Client()
+
+@interactions.listen()
+async def on_startup():
+    print("Bot is ready!")
+
+bot.start("token")
+```
+
+With `interactions.py`, you can quickly and easily build complex Discord applications with Python. Check out our [guides](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started) for more information. Or join our [discord](https://discord.gg/interactions).
```

### Comparing `discord-py-interactions-5.5.1/discord_py_interactions.egg-info/PKG-INFO` & `discord-py-interactions-5.6.0/discord_py_interactions.egg-info/PKG-INFO`

 * *Files 22% similar despite different names*

```diff
@@ -1,127 +1,127 @@
-Metadata-Version: 2.1
-Name: discord-py-interactions
-Version: 5.5.1
-Summary: Easy, simple, scalable and modular: a Python API wrapper for interactions.
-Home-page: https://github.com/interactions-py/interactions.py
-Author: LordOfPolls
-Author-email: dev@lordofpolls.com
-Project-URL: Discord, https://discord.gg/KkgMBVuEkx
-Project-URL: Documentation, https://naff-docs.readthedocs.io/en/latest/
-Classifier: Development Status :: 3 - Alpha
-Classifier: Framework :: AsyncIO
-Classifier: Framework :: aiohttp
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Natural Language :: English
-Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Topic :: Software Development :: Libraries
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Classifier: Topic :: Documentation
-Classifier: Typing :: Typed
-Requires-Python: >=3.10
-Description-Content-Type: text/markdown
-Provides-Extra: voice
-Provides-Extra: speedup
-Provides-Extra: sentry
-Provides-Extra: jurigged
-Provides-Extra: console
-Provides-Extra: all
-Provides-Extra: docs
-Provides-Extra: tests
-Provides-Extra: dev
-License-File: LICENSE
-
-<div align="center">
-
-   # Interactions.py
-   <br>
-
-   ![](https://img.shields.io/pypi/v/discord-py-interactions.svg?label=Version&logo=pypi)
-   ![](https://img.shields.io/badge/Python-3.10+-1081c1?logo=python)
-   [![](https://img.shields.io/pypi/dm/discord-py-slash-command.svg?logo=python&label=Downloads)](https://pypi.org/project/discord-py-interactions/)
-
-   [![](https://img.shields.io/badge/Code%20Style-black-000000.svg)](https://github.com/psf/black)
-   [![License](https://img.shields.io/badge/License-GPL-blue)](https://github.com/interactions-py/interactions.py/blob/stable/LICENSE)
-
-   [![](https://img.shields.io/badge/Docs-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/)
-   [![](https://img.shields.io/badge/Guides-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started)
-   [![image](https://discord.com/api/guilds/789032594456576001/embed.png)](https://discord.gg/interactions)
-
-</div>
-
-## A Feature-rich Discord Bot Framework for Python
-
-A highly extensible, easy to use, and feature complete framework for Discord.
-
-`interactions.py` is the culmination of years of experience with Discord's APIs and bot development. This framework has been built from the ground up with community feedback and suggestions in mind. Our framework provides a modern and intuitive set of language bindings for easy interaction with Discord.
-
-## Key Features
-interactions.py offers a wide range of features for building Python-powered Discord bots and web applications alike:
-- âœ… 100% coverage of the Discord API
-- âœ… Dynamic cache with TTL support
-- âœ… Modern and Pythonic API for easy interaction with Discord
-- âœ… Proper rate-limit handling
-- âœ… Feature parity with most other Discord API wrappers
-- âœ… Fully automated command synchronisation
-
-In addition to core functionality, `interactions.py` provides a range of optional extensions, allowing you to further customize your bot and add new features with ease.
-
-## Extensibility
-
-So the base library doesn't do what you want? No problem! With builtin extensions, you are able to extend the functionality of the library. And if none of those pique your interest, there are a myriad of other extension libraries available.
-
-Just type `bot.load("extension")`
-
-<details>
-    <summary>Extensions</summary>
-
-   ### Prefixed Commands
-
-   Prefixed commands, message commands, or legacy commands.
-   Whatever you want to call them, by default the `interactions.py` library will not handle these. But rest assured this extension will get you going
-
-  - âœ… Automatic command registration
-  - âœ… Annotation support
-
-  ### Debug Extension
-
-  A fully featured debug and utilities suite to help you get your bots made
-
-  ### Jurigged
-
-  A hot reloading extension allowing you to automagically update your bot without reboots
-
-  ### Sentry
-
-  Integrates Sentry.io error tracking into your bot with a single line
-
-  ### Console
-
-  Adds `aiomonitor` support with enables cli commands over a web interface
-
-  ### Paginators
-
-  Easily create multi-page embeds without having to implement the UX
-
-</details>
-
-## Where do I start?
-
-Getting started with `interactions.py` is easy! Simply install it via `pip` and start building your Discord application in Python:
-
-`pip install -U discord-py-interactions`
-```python
-import interactions
-
-bot = interactions.Client()
-
-@interactions.listen()
-async def on_startup():
-    print("Bot is ready!")
-
-bot.start("token")
-```
-
-With `interactions.py`, you can quickly and easily build complex Discord applications with Python. Check out our [guides](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started) for more information. Or join our [discord](https://discord.gg/interactions).
+Metadata-Version: 2.1
+Name: discord-py-interactions
+Version: 5.6.0
+Summary: Easy, simple, scalable and modular: a Python API wrapper for interactions.
+Home-page: https://github.com/interactions-py/interactions.py
+Author: LordOfPolls
+Author-email: dev@lordofpolls.com
+Project-URL: Discord, https://discord.gg/KkgMBVuEkx
+Project-URL: Documentation, https://naff-docs.readthedocs.io/en/latest/
+Classifier: Development Status :: 3 - Alpha
+Classifier: Framework :: AsyncIO
+Classifier: Framework :: aiohttp
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Natural Language :: English
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+Classifier: Topic :: Documentation
+Classifier: Typing :: Typed
+Requires-Python: >=3.10
+Description-Content-Type: text/markdown
+Provides-Extra: voice
+Provides-Extra: speedup
+Provides-Extra: sentry
+Provides-Extra: jurigged
+Provides-Extra: console
+Provides-Extra: all
+Provides-Extra: docs
+Provides-Extra: tests
+Provides-Extra: dev
+License-File: LICENSE
+
+<div align="center">
+
+   # Interactions.py
+   <br>
+
+   ![](https://img.shields.io/pypi/v/discord-py-interactions.svg?label=Version&logo=pypi)
+   ![](https://img.shields.io/badge/Python-3.10+-1081c1?logo=python)
+   [![](https://img.shields.io/pypi/dm/discord-py-slash-command.svg?logo=python&label=Downloads)](https://pypi.org/project/discord-py-interactions/)
+
+   [![](https://img.shields.io/badge/Code%20Style-black-000000.svg)](https://github.com/psf/black)
+   [![License](https://img.shields.io/badge/License-GPL-blue)](https://github.com/interactions-py/interactions.py/blob/stable/LICENSE)
+
+   [![](https://img.shields.io/badge/Docs-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/)
+   [![](https://img.shields.io/badge/Guides-latest-x?logo=readthedocs)](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started)
+   [![image](https://discord.com/api/guilds/789032594456576001/embed.png)](https://discord.gg/interactions)
+
+</div>
+
+## A Feature-rich Discord Bot Framework for Python
+
+A highly extensible, easy to use, and feature complete framework for Discord.
+
+`interactions.py` is the culmination of years of experience with Discord's APIs and bot development. This framework has been built from the ground up with community feedback and suggestions in mind. Our framework provides a modern and intuitive set of language bindings for easy interaction with Discord.
+
+## Key Features
+interactions.py offers a wide range of features for building Python-powered Discord bots and web applications alike:
+- ✅ 100% coverage of the Discord API
+- ✅ Dynamic cache with TTL support
+- ✅ Modern and Pythonic API for easy interaction with Discord
+- ✅ Proper rate-limit handling
+- ✅ Feature parity with most other Discord API wrappers
+- ✅ Fully automated command synchronisation
+
+In addition to core functionality, `interactions.py` provides a range of optional extensions, allowing you to further customize your bot and add new features with ease.
+
+## Extensibility
+
+So the base library doesn't do what you want? No problem! With builtin extensions, you are able to extend the functionality of the library. And if none of those pique your interest, there are a myriad of other extension libraries available.
+
+Just type `bot.load("extension")`
+
+<details>
+    <summary>Extensions</summary>
+
+   ### Prefixed Commands
+
+   Prefixed commands, message commands, or legacy commands.
+   Whatever you want to call them, by default the `interactions.py` library will not handle these. But rest assured this extension will get you going
+
+  - ✅ Automatic command registration
+  - ✅ Annotation support
+
+  ### Debug Extension
+
+  A fully featured debug and utilities suite to help you get your bots made
+
+  ### Jurigged
+
+  A hot reloading extension allowing you to automagically update your bot without reboots
+
+  ### Sentry
+
+  Integrates Sentry.io error tracking into your bot with a single line
+
+  ### Console
+
+  Adds `aiomonitor` support with enables cli commands over a web interface
+
+  ### Paginators
+
+  Easily create multi-page embeds without having to implement the UX
+
+</details>
+
+## Where do I start?
+
+Getting started with `interactions.py` is easy! Simply install it via `pip` and start building your Discord application in Python:
+
+`pip install -U discord-py-interactions`
+```python
+import interactions
+
+bot = interactions.Client()
+
+@interactions.listen()
+async def on_startup():
+    print("Bot is ready!")
+
+bot.start("token")
+```
+
+With `interactions.py`, you can quickly and easily build complex Discord applications with Python. Check out our [guides](https://interactions-py.github.io/interactions.py/Guides/01%20Getting%20Started) for more information. Or join our [discord](https://discord.gg/interactions).
```

### Comparing `discord-py-interactions-5.5.1/discord_py_interactions.egg-info/SOURCES.txt` & `discord-py-interactions-5.6.0/discord_py_interactions.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `discord-py-interactions-5.5.1/discord_py_interactions.egg-info/requires.txt` & `discord-py-interactions-5.6.0/discord_py_interactions.egg-info/requires.txt`

 * *Files identical despite different names*

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/base.py` & `discord-py-interactions-5.6.0/interactions/api/events/base.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,90 +1,90 @@
-import re
-from typing import TYPE_CHECKING
-
-import attrs
-
-import interactions.models as models
-from interactions.client.const import MISSING, AsyncCallable
-from interactions.client.utils.attr_utils import docs
-from interactions.models.discord.snowflake import to_snowflake
-
-if TYPE_CHECKING:
-    from interactions import Client
-    from interactions.models.discord.snowflake import Snowflake_Type
-    from interactions.models.discord.guild import Guild
-
-__all__ = ("BaseEvent", "GuildEvent", "RawGatewayEvent")
-
-_event_reg = re.compile("(?<!^)(?=[A-Z])")
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=False)
-class BaseEvent:
-    """A base event that all other events inherit from."""
-
-    override_name: str = attrs.field(repr=False, kw_only=True, default=None)
-    """Custom name of the event to be used when dispatching."""
-    bot: "Client" = attrs.field(repr=False, kw_only=True, default=MISSING)
-    """The client instance that dispatched this event."""
-
-    @property
-    def client(self) -> "Client":
-        """The client instance that dispatched this event."""
-        return self.bot
-
-    @property
-    def resolved_name(self) -> str:
-        """The name of the event, defaults to the class name if not overridden."""
-        name = self.override_name or self.__class__.__name__
-        return _event_reg.sub("_", name).lower()
-
-    @classmethod
-    def listen(cls, coro: AsyncCallable, client: "Client") -> "models.Listener":
-        """
-        A shortcut for creating a listener for this event
-
-        Args:
-            coro: The coroutine to call when the event is triggered.
-            client: The client instance to listen to.
-
-
-        ??? Hint "Example Usage:"
-            ```python
-            class SomeClass:
-                def __init__(self, bot: Client):
-                    Ready.listen(self.some_func, bot)
-
-                async def some_func(self, event):
-                    print(f"{event.resolved_name} triggered")
-            ```
-        Returns:
-            A listener object.
-        """
-        listener = models.Listener.create(cls().resolved_name)(coro)
-        client.add_listener(listener)
-        return listener
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=False)
-class GuildEvent(BaseEvent):
-    """A base event that adds guild_id."""
-
-    guild_id: "Snowflake_Type" = attrs.field(repr=False, metadata=docs("The ID of the guild"), converter=to_snowflake)
-
-    @property
-    def guild(self) -> "Guild":
-        """Guild related to event"""
-        return self.bot.cache.get_guild(self.guild_id)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class RawGatewayEvent(BaseEvent):
-    """
-    An event dispatched from the gateway.
-
-    Holds the raw dict that the gateway dispatches
-
-    """
-
-    data: dict = attrs.field(repr=False, factory=dict)
-    """Raw Data from the gateway"""
+import re
+from typing import TYPE_CHECKING
+
+import attrs
+
+import interactions.models as models
+from interactions.client.const import MISSING, AsyncCallable
+from interactions.client.utils.attr_utils import docs
+from interactions.models.discord.snowflake import to_snowflake
+
+if TYPE_CHECKING:
+    from interactions import Client
+    from interactions.models.discord.snowflake import Snowflake_Type
+    from interactions.models.discord.guild import Guild
+
+__all__ = ("BaseEvent", "GuildEvent", "RawGatewayEvent")
+
+_event_reg = re.compile("(?<!^)(?=[A-Z])")
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=False)
+class BaseEvent:
+    """A base event that all other events inherit from."""
+
+    override_name: str = attrs.field(repr=False, kw_only=True, default=None)
+    """Custom name of the event to be used when dispatching."""
+    bot: "Client" = attrs.field(repr=False, kw_only=True, default=MISSING)
+    """The client instance that dispatched this event."""
+
+    @property
+    def client(self) -> "Client":
+        """The client instance that dispatched this event."""
+        return self.bot
+
+    @property
+    def resolved_name(self) -> str:
+        """The name of the event, defaults to the class name if not overridden."""
+        name = self.override_name or self.__class__.__name__
+        return _event_reg.sub("_", name).lower()
+
+    @classmethod
+    def listen(cls, coro: AsyncCallable, client: "Client") -> "models.Listener":
+        """
+        A shortcut for creating a listener for this event
+
+        Args:
+            coro: The coroutine to call when the event is triggered.
+            client: The client instance to listen to.
+
+
+        ??? Hint "Example Usage:"
+            ```python
+            class SomeClass:
+                def __init__(self, bot: Client):
+                    Ready.listen(self.some_func, bot)
+
+                async def some_func(self, event):
+                    print(f"{event.resolved_name} triggered")
+            ```
+        Returns:
+            A listener object.
+        """
+        listener = models.Listener.create(cls().resolved_name)(coro)
+        client.add_listener(listener)
+        return listener
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=False)
+class GuildEvent(BaseEvent):
+    """A base event that adds guild_id."""
+
+    guild_id: "Snowflake_Type" = attrs.field(repr=False, metadata=docs("The ID of the guild"), converter=to_snowflake)
+
+    @property
+    def guild(self) -> "Guild":
+        """Guild related to event"""
+        return self.bot.cache.get_guild(self.guild_id)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class RawGatewayEvent(BaseEvent):
+    """
+    An event dispatched from the gateway.
+
+    Holds the raw dict that the gateway dispatches
+
+    """
+
+    data: dict = attrs.field(repr=False, factory=dict)
+    """Raw Data from the gateway"""
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/internal.py` & `discord-py-interactions-5.6.0/interactions/api/events/internal.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,264 +1,264 @@
-"""
-These are events dispatched by the client. This is intended as a reference so you know what data to expect for each event.
-
-??? Hint "Example Usage:"
-    The event classes outlined here are in `CamelCase` to comply with Class naming convention, however the event names
-    are actually in `lower_case_with_underscores` so your listeners should be named as following:
-
-    ```python
-    @listen()
-    def on_ready():
-        # ready events pass no data, so dont have params
-        print("Im ready!")
-
-    @listen()
-    def on_guild_join(event):
-        # guild_create events pass a guild object, expect a single param
-        print(f"{event.guild.name} created")
-    ```
-!!! warning
-    While all of these events are documented, not all of them are used, currently.
-
-"""
-import re
-import typing
-from typing import Any, Optional, TYPE_CHECKING, Type
-
-import attrs
-
-from interactions.api.events.base import BaseEvent, RawGatewayEvent
-from interactions.client.utils.attr_utils import docs
-
-if typing.TYPE_CHECKING:
-    from interactions import Extension, BaseCommand, Listener
-
-__all__ = (
-    "ButtonPressed",
-    "Component",
-    "Connect",
-    "Disconnect",
-    "Error",
-    "ShardConnect",
-    "ShardDisconnect",
-    "Login",
-    "Ready",
-    "Resume",
-    "Select",
-    "Startup",
-    "WebsocketReady",
-    "CommandError",
-    "ComponentError",
-    "AutocompleteError",
-    "ModalError",
-    "CommandCompletion",
-    "ComponentCompletion",
-    "AutocompleteCompletion",
-    "ModalCompletion",
-    "ExtensionLoad",
-    "ExtensionUnload",
-    "ExtensionCommandParse",
-    "CallbackAdded",
-)
-
-
-if TYPE_CHECKING:
-    from interactions.models.internal.context import (
-        ComponentContext,
-        BaseContext,
-        AutocompleteContext,
-        ModalContext,
-    )
-
-_event_reg = re.compile("(?<!^)(?=[A-Z])")
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Login(BaseEvent):
-    """The bot has just logged in."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Connect(BaseEvent):
-    """The bot is now connected to the discord Gateway."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Resume(BaseEvent):
-    """The bot has resumed its connection to the discord Gateway."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Disconnect(BaseEvent):
-    """The bot has just disconnected."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class ShardConnect(Connect):
-    """A shard just connected to the discord Gateway."""
-
-    shard_id: int = attrs.field(repr=False, metadata=docs("The ID of the shard"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class ShardDisconnect(Disconnect):
-    """A shard just disconnected."""
-
-    shard_id: int = attrs.field(repr=False, metadata=docs("The ID of the shard"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Startup(BaseEvent):
-    """
-    The client is now ready for the first time.
-
-    Use this for tasks you want to do upon login, instead of ready, as
-    this will only be called once.
-
-    """
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Ready(BaseEvent):
-    """
-    The client is now ready.
-
-    !!! note
-        Don't use this event for things that must only happen once, on startup, as this event may be called multiple times.
-        Instead, use the `Startup` event
-
-    """
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class WebsocketReady(RawGatewayEvent):
-    """The gateway has reported that it is ready."""
-
-    data: dict = attrs.field(repr=False, metadata=docs("The data from the ready event"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Component(BaseEvent):
-    """Dispatched when a user uses a Component."""
-
-    ctx: "ComponentContext" = attrs.field(repr=False, metadata=docs("The context of the interaction"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class ButtonPressed(Component):
-    """Dispatched when a user uses a Button."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Select(Component):
-    """Dispatched when a user uses a Select."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class CommandCompletion(BaseEvent):
-    """Dispatched after the library ran any command callback."""
-
-    ctx: "BaseContext" = attrs.field(repr=False, metadata=docs("The command context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ComponentCompletion(BaseEvent):
-    """Dispatched after the library ran any component callback."""
-
-    ctx: "ComponentContext" = attrs.field(repr=False, metadata=docs("The component context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class AutocompleteCompletion(BaseEvent):
-    """Dispatched after the library ran any autocomplete callback."""
-
-    ctx: "AutocompleteContext" = attrs.field(repr=False, metadata=docs("The autocomplete context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ModalCompletion(BaseEvent):
-    """Dispatched after the library ran any modal callback."""
-
-    ctx: "ModalContext" = attrs.field(repr=False, metadata=docs("The modal context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class _Error(BaseEvent):
-    error: Exception = attrs.field(repr=False, metadata=docs("The error that was encountered"))
-    args: tuple[Any] = attrs.field(repr=False, factory=tuple)
-    kwargs: dict[str, Any] = attrs.field(repr=False, factory=dict)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Error(_Error):
-    """Dispatched when the library encounters an error."""
-
-    source: str = attrs.field(repr=False, metadata=docs("The source of the error"))
-    ctx: Optional["BaseContext"] = attrs.field(
-        repr=False, default=None, metadata=docs("The Context, if one was active")
-    )
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class CommandError(_Error):
-    """Dispatched when the library encounters an error in a command."""
-
-    ctx: "BaseContext" = attrs.field(repr=False, metadata=docs("The command context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ComponentError(_Error):
-    """Dispatched when the library encounters an error in a component."""
-
-    ctx: "ComponentContext" = attrs.field(repr=False, metadata=docs("The component context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class AutocompleteError(_Error):
-    """Dispatched when the library encounters an error in an autocomplete."""
-
-    ctx: "AutocompleteContext" = attrs.field(repr=False, metadata=docs("The autocomplete context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ModalError(_Error):
-    """Dispatched when the library encounters an error in a modal."""
-
-    ctx: "ModalContext" = attrs.field(repr=False, metadata=docs("The modal context"))
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ExtensionLoad(BaseEvent):
-    """Dispatched when an extension is loaded."""
-
-    extension: "Extension" = attrs.field(repr=False)
-    """The extension in question"""
-
-    @property
-    def metadata(self) -> "Type[Extension.Metadata] | None":
-        """The metadata of the extension, if it has any."""
-        return self.extension.Metadata or None
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ExtensionUnload(ExtensionLoad):
-    """Dispatched when an extension is unloaded."""
-
-    ...
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ExtensionCommandParse(ExtensionLoad):
-    """Dispatched when an extension is parsed for commands."""
-
-    callables: list[tuple[str, typing.Callable]] = attrs.field(repr=False, default=None)
-    """The callables that were parsed for commands"""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class CallbackAdded(BaseEvent):
-    """Dispatched when a callback is added to the client."""
-
-    callback: "BaseCommand | Listener" = attrs.field(repr=False)
-    """The callback that was added"""
-    extension: "Extension | None" = attrs.field(repr=False, default=None)
-    """The extension that the command was added from, if any"""
+"""
+These are events dispatched by the client. This is intended as a reference so you know what data to expect for each event.
+
+??? Hint "Example Usage:"
+    The event classes outlined here are in `CamelCase` to comply with Class naming convention, however the event names
+    are actually in `lower_case_with_underscores` so your listeners should be named as following:
+
+    ```python
+    @listen()
+    def on_ready():
+        # ready events pass no data, so dont have params
+        print("Im ready!")
+
+    @listen()
+    def on_guild_join(event):
+        # guild_create events pass a guild object, expect a single param
+        print(f"{event.guild.name} created")
+    ```
+!!! warning
+    While all of these events are documented, not all of them are used, currently.
+
+"""
+import re
+import typing
+from typing import Any, Optional, TYPE_CHECKING, Type
+
+import attrs
+
+from interactions.api.events.base import BaseEvent, RawGatewayEvent
+from interactions.client.utils.attr_utils import docs
+
+if typing.TYPE_CHECKING:
+    from interactions import Extension, BaseCommand, Listener
+
+__all__ = (
+    "ButtonPressed",
+    "Component",
+    "Connect",
+    "Disconnect",
+    "Error",
+    "ShardConnect",
+    "ShardDisconnect",
+    "Login",
+    "Ready",
+    "Resume",
+    "Select",
+    "Startup",
+    "WebsocketReady",
+    "CommandError",
+    "ComponentError",
+    "AutocompleteError",
+    "ModalError",
+    "CommandCompletion",
+    "ComponentCompletion",
+    "AutocompleteCompletion",
+    "ModalCompletion",
+    "ExtensionLoad",
+    "ExtensionUnload",
+    "ExtensionCommandParse",
+    "CallbackAdded",
+)
+
+
+if TYPE_CHECKING:
+    from interactions.models.internal.context import (
+        ComponentContext,
+        BaseContext,
+        AutocompleteContext,
+        ModalContext,
+    )
+
+_event_reg = re.compile("(?<!^)(?=[A-Z])")
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Login(BaseEvent):
+    """The bot has just logged in."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Connect(BaseEvent):
+    """The bot is now connected to the discord Gateway."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Resume(BaseEvent):
+    """The bot has resumed its connection to the discord Gateway."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Disconnect(BaseEvent):
+    """The bot has just disconnected."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class ShardConnect(Connect):
+    """A shard just connected to the discord Gateway."""
+
+    shard_id: int = attrs.field(repr=False, metadata=docs("The ID of the shard"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class ShardDisconnect(Disconnect):
+    """A shard just disconnected."""
+
+    shard_id: int = attrs.field(repr=False, metadata=docs("The ID of the shard"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Startup(BaseEvent):
+    """
+    The client is now ready for the first time.
+
+    Use this for tasks you want to do upon login, instead of ready, as
+    this will only be called once.
+
+    """
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Ready(BaseEvent):
+    """
+    The client is now ready.
+
+    !!! note
+        Don't use this event for things that must only happen once, on startup, as this event may be called multiple times.
+        Instead, use the `Startup` event
+
+    """
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class WebsocketReady(RawGatewayEvent):
+    """The gateway has reported that it is ready."""
+
+    data: dict = attrs.field(repr=False, metadata=docs("The data from the ready event"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Component(BaseEvent):
+    """Dispatched when a user uses a Component."""
+
+    ctx: "ComponentContext" = attrs.field(repr=False, metadata=docs("The context of the interaction"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class ButtonPressed(Component):
+    """Dispatched when a user uses a Button."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Select(Component):
+    """Dispatched when a user uses a Select."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class CommandCompletion(BaseEvent):
+    """Dispatched after the library ran any command callback."""
+
+    ctx: "BaseContext" = attrs.field(repr=False, metadata=docs("The command context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ComponentCompletion(BaseEvent):
+    """Dispatched after the library ran any component callback."""
+
+    ctx: "ComponentContext" = attrs.field(repr=False, metadata=docs("The component context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class AutocompleteCompletion(BaseEvent):
+    """Dispatched after the library ran any autocomplete callback."""
+
+    ctx: "AutocompleteContext" = attrs.field(repr=False, metadata=docs("The autocomplete context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ModalCompletion(BaseEvent):
+    """Dispatched after the library ran any modal callback."""
+
+    ctx: "ModalContext" = attrs.field(repr=False, metadata=docs("The modal context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class _Error(BaseEvent):
+    error: Exception = attrs.field(repr=False, metadata=docs("The error that was encountered"))
+    args: tuple[Any] = attrs.field(repr=False, factory=tuple)
+    kwargs: dict[str, Any] = attrs.field(repr=False, factory=dict)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Error(_Error):
+    """Dispatched when the library encounters an error."""
+
+    source: str = attrs.field(repr=False, metadata=docs("The source of the error"))
+    ctx: Optional["BaseContext"] = attrs.field(
+        repr=False, default=None, metadata=docs("The Context, if one was active")
+    )
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class CommandError(_Error):
+    """Dispatched when the library encounters an error in a command."""
+
+    ctx: "BaseContext" = attrs.field(repr=False, metadata=docs("The command context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ComponentError(_Error):
+    """Dispatched when the library encounters an error in a component."""
+
+    ctx: "ComponentContext" = attrs.field(repr=False, metadata=docs("The component context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class AutocompleteError(_Error):
+    """Dispatched when the library encounters an error in an autocomplete."""
+
+    ctx: "AutocompleteContext" = attrs.field(repr=False, metadata=docs("The autocomplete context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ModalError(_Error):
+    """Dispatched when the library encounters an error in a modal."""
+
+    ctx: "ModalContext" = attrs.field(repr=False, metadata=docs("The modal context"))
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ExtensionLoad(BaseEvent):
+    """Dispatched when an extension is loaded."""
+
+    extension: "Extension" = attrs.field(repr=False)
+    """The extension in question"""
+
+    @property
+    def metadata(self) -> "Type[Extension.Metadata] | None":
+        """The metadata of the extension, if it has any."""
+        return self.extension.Metadata or None
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ExtensionUnload(ExtensionLoad):
+    """Dispatched when an extension is unloaded."""
+
+    ...
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ExtensionCommandParse(ExtensionLoad):
+    """Dispatched when an extension is parsed for commands."""
+
+    callables: list[tuple[str, typing.Callable]] = attrs.field(repr=False, default=None)
+    """The callables that were parsed for commands"""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class CallbackAdded(BaseEvent):
+    """Dispatched when a callback is added to the client."""
+
+    callback: "BaseCommand | Listener" = attrs.field(repr=False)
+    """The callback that was added"""
+    extension: "Extension | None" = attrs.field(repr=False, default=None)
+    """The extension that the command was added from, if any"""
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/_template.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/_template.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-import asyncio
-import functools
-import inspect
-from typing import TYPE_CHECKING, Callable, Coroutine
-
-from interactions.client.const import Absent, MISSING, AsyncCallable
-from interactions.models.discord.user import ClientUser
-
-if TYPE_CHECKING:
-    from interactions.client.smart_cache import GlobalCache
-    from interactions.api.events.internal import BaseEvent
-
-__all__ = ("Processor", "EventMixinTemplate")
-
-
-class Processor:
-    callback: AsyncCallable
-    event_name: str
-
-    def __init__(self, callback: AsyncCallable, name: str) -> None:
-        self.callback = callback
-        self.event_name = name
-
-    @classmethod
-    def define(cls, event_name: Absent[str] = MISSING) -> Callable[[AsyncCallable], "Processor"]:
-        def wrapper(coro: AsyncCallable) -> "Processor":
-            name = event_name
-            if name is MISSING:
-                name = coro.__name__
-            name = name.lstrip("_")
-            name = name.removeprefix("on_")
-
-            return cls(coro, name)
-
-        return wrapper
-
-
-class EventMixinTemplate:
-    """All event mixins inherit from this to keep them uniform."""
-
-    cache: "GlobalCache"
-    dispatch: Callable[["BaseEvent"], None]
-    _init_interactions: Callable[[], Coroutine]
-    synchronise_interactions: Callable[[], Coroutine]
-    _user: ClientUser
-    _guild_event: asyncio.Event
-
-    def __init__(self) -> None:
-        for call in inspect.getmembers(self):
-            if isinstance(call[1], Processor):
-                self.add_event_processor(call[1].event_name)(functools.partial(call[1].callback, self))
+import asyncio
+import functools
+import inspect
+from typing import TYPE_CHECKING, Callable, Coroutine
+
+from interactions.client.const import Absent, MISSING, AsyncCallable
+from interactions.models.discord.user import ClientUser
+
+if TYPE_CHECKING:
+    from interactions.client.smart_cache import GlobalCache
+    from interactions.api.events.internal import BaseEvent
+
+__all__ = ("Processor", "EventMixinTemplate")
+
+
+class Processor:
+    callback: AsyncCallable
+    event_name: str
+
+    def __init__(self, callback: AsyncCallable, name: str) -> None:
+        self.callback = callback
+        self.event_name = name
+
+    @classmethod
+    def define(cls, event_name: Absent[str] = MISSING) -> Callable[[AsyncCallable], "Processor"]:
+        def wrapper(coro: AsyncCallable) -> "Processor":
+            name = event_name
+            if name is MISSING:
+                name = coro.__name__
+            name = name.lstrip("_")
+            name = name.removeprefix("on_")
+
+            return cls(coro, name)
+
+        return wrapper
+
+
+class EventMixinTemplate:
+    """All event mixins inherit from this to keep them uniform."""
+
+    cache: "GlobalCache"
+    dispatch: Callable[["BaseEvent"], None]
+    _init_interactions: Callable[[], Coroutine]
+    synchronise_interactions: Callable[[], Coroutine]
+    _user: ClientUser
+    _guild_event: asyncio.Event
+
+    def __init__(self) -> None:
+        for call in inspect.getmembers(self):
+            if isinstance(call[1], Processor):
+                self.add_event_processor(call[1].event_name)(functools.partial(call[1].callback, self))
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/auto_mod.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/auto_mod.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-from typing import TYPE_CHECKING
-
-from interactions.models.discord.auto_mod import AutoModerationAction, AutoModRule
-from ._template import EventMixinTemplate, Processor
-from ... import events
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("AutoModEvents",)
-
-
-class AutoModEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _raw_auto_moderation_action_execution(self, event: "RawGatewayEvent") -> None:
-        action = AutoModerationAction.from_dict(event.data.copy(), self)
-        channel = self.get_channel(event.data["channel_id"])
-        guild = self.get_guild(event.data["guild_id"])
-        self.dispatch(events.AutoModExec(action, channel, guild))
-
-    @Processor.define()
-    async def raw_auto_moderation_rule_create(self, event: "RawGatewayEvent") -> None:
-        rule = AutoModRule.from_dict(event.data, self)
-        guild = self.get_guild(event.data["guild_id"])
-        self.dispatch(events.AutoModCreated(guild, rule))
-
-    @Processor.define()
-    async def raw_auto_moderation_rule_delete(self, event: "RawGatewayEvent") -> None:
-        rule = AutoModRule.from_dict(event.data, self)
-        guild = self.get_guild(event.data["guild_id"])
-        self.dispatch(events.AutoModUpdated(guild, rule))
-
-    @Processor.define()
-    async def raw_auto_moderation_rule_update(self, event: "RawGatewayEvent") -> None:
-        rule = AutoModRule.from_dict(event.data, self)
-        guild = self.get_guild(event.data["guild_id"])
-        self.dispatch(events.AutoModDeleted(guild, rule))
+from typing import TYPE_CHECKING
+
+from interactions.models.discord.auto_mod import AutoModerationAction, AutoModRule
+from ._template import EventMixinTemplate, Processor
+from ... import events
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("AutoModEvents",)
+
+
+class AutoModEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _raw_auto_moderation_action_execution(self, event: "RawGatewayEvent") -> None:
+        action = AutoModerationAction.from_dict(event.data.copy(), self)
+        channel = self.get_channel(event.data["channel_id"])
+        guild = self.get_guild(event.data["guild_id"])
+        self.dispatch(events.AutoModExec(action, channel, guild))
+
+    @Processor.define()
+    async def raw_auto_moderation_rule_create(self, event: "RawGatewayEvent") -> None:
+        rule = AutoModRule.from_dict(event.data, self)
+        guild = self.get_guild(event.data["guild_id"])
+        self.dispatch(events.AutoModCreated(guild, rule))
+
+    @Processor.define()
+    async def raw_auto_moderation_rule_delete(self, event: "RawGatewayEvent") -> None:
+        rule = AutoModRule.from_dict(event.data, self)
+        guild = self.get_guild(event.data["guild_id"])
+        self.dispatch(events.AutoModUpdated(guild, rule))
+
+    @Processor.define()
+    async def raw_auto_moderation_rule_update(self, event: "RawGatewayEvent") -> None:
+        rule = AutoModRule.from_dict(event.data, self)
+        guild = self.get_guild(event.data["guild_id"])
+        self.dispatch(events.AutoModDeleted(guild, rule))
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/channel_events.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/channel_events.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,47 +1,47 @@
-import copy
-from typing import TYPE_CHECKING
-
-import interactions.api.events as events
-from interactions.client.const import MISSING
-from interactions.models.discord.channel import BaseChannel
-from interactions.models.discord.invite import Invite
-from ._template import EventMixinTemplate, Processor
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("ChannelEvents",)
-
-
-class ChannelEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _on_raw_channel_create(self, event: "RawGatewayEvent") -> None:
-        channel = self.cache.place_channel_data(event.data)
-        self.dispatch(events.ChannelCreate(channel))
-
-    @Processor.define()
-    async def _on_raw_channel_delete(self, event: "RawGatewayEvent") -> None:
-        # for some reason this event returns the deleted channel data?
-        # so we create an object from it
-        channel = BaseChannel.from_dict_factory(event.data, self)
-        self.cache.delete_channel(event.data.get("id"))
-        self.dispatch(events.ChannelDelete(channel))
-
-    @Processor.define()
-    async def _on_raw_channel_update(self, event: "RawGatewayEvent") -> None:
-        before = copy.copy(self.cache.get_channel(event.data.get("id")))
-        self.dispatch(events.ChannelUpdate(before=before or MISSING, after=self.cache.place_channel_data(event.data)))
-
-    @Processor.define()
-    async def _on_raw_channel_pins_update(self, event: "RawGatewayEvent") -> None:
-        channel = await self.cache.fetch_channel(event.data.get("channel_id"))
-        channel.last_pin_timestamp = event.data.get("last_pin_timestamp")
-        self.dispatch(events.ChannelPinsUpdate(channel, channel.last_pin_timestamp))
-
-    @Processor.define()
-    async def _on_raw_invite_create(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(events.InviteCreate(Invite.from_dict(event.data, self)))  # type: ignore
-
-    @Processor.define()
-    async def _on_raw_invite_delete(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(events.InviteDelete(Invite.from_dict(event.data, self)))  # type: ignore
+import copy
+from typing import TYPE_CHECKING
+
+import interactions.api.events as events
+from interactions.client.const import MISSING
+from interactions.models.discord.channel import BaseChannel
+from interactions.models.discord.invite import Invite
+from ._template import EventMixinTemplate, Processor
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("ChannelEvents",)
+
+
+class ChannelEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _on_raw_channel_create(self, event: "RawGatewayEvent") -> None:
+        channel = self.cache.place_channel_data(event.data)
+        self.dispatch(events.ChannelCreate(channel))
+
+    @Processor.define()
+    async def _on_raw_channel_delete(self, event: "RawGatewayEvent") -> None:
+        # for some reason this event returns the deleted channel data?
+        # so we create an object from it
+        channel = BaseChannel.from_dict_factory(event.data, self)
+        self.cache.delete_channel(event.data.get("id"))
+        self.dispatch(events.ChannelDelete(channel))
+
+    @Processor.define()
+    async def _on_raw_channel_update(self, event: "RawGatewayEvent") -> None:
+        before = copy.copy(self.cache.get_channel(event.data.get("id")))
+        self.dispatch(events.ChannelUpdate(before=before or MISSING, after=self.cache.place_channel_data(event.data)))
+
+    @Processor.define()
+    async def _on_raw_channel_pins_update(self, event: "RawGatewayEvent") -> None:
+        channel = await self.cache.fetch_channel(event.data.get("channel_id"))
+        channel.last_pin_timestamp = event.data.get("last_pin_timestamp")
+        self.dispatch(events.ChannelPinsUpdate(channel, channel.last_pin_timestamp))
+
+    @Processor.define()
+    async def _on_raw_invite_create(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(events.InviteCreate(Invite.from_dict(event.data, self)))  # type: ignore
+
+    @Processor.define()
+    async def _on_raw_invite_delete(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(events.InviteDelete(Invite.from_dict(event.data, self)))  # type: ignore
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/guild_events.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/guild_events.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,128 +1,128 @@
-import copy
-from typing import TYPE_CHECKING
-
-import interactions.api.events as events
-from interactions.api.events.discord import (
-    BanCreate,
-    BanRemove,
-    GuildAuditLogEntryCreate,
-    GuildEmojisUpdate,
-    IntegrationCreate,
-    IntegrationUpdate,
-    IntegrationDelete,
-    GuildStickersUpdate,
-    WebhooksUpdate,
-)
-from interactions.client.const import MISSING
-from interactions.models import AuditLogEntry, GuildIntegration, Sticker, to_snowflake
-from ._template import EventMixinTemplate, Processor
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("GuildEvents",)
-
-
-class GuildEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _on_raw_guild_create(self, event: "RawGatewayEvent") -> None:
-        """
-        Automatically cache a guild upon GUILD_CREATE event from gateway.
-
-        Args:
-            event: raw guild create event
-
-        """
-        new_guild = not self.cache.get_guild(event.data["id"])
-        guild = self.cache.place_guild_data(event.data)
-
-        self._user._guild_ids.add(to_snowflake(event.data.get("id")))
-
-        self._guild_event.set()
-
-        if self.fetch_members and not guild.chunked.is_set():
-            # delays events until chunking has completed
-            await guild.chunk()
-
-        if new_guild:
-            self.dispatch(events.GuildJoin(guild.id))
-        else:
-            self.dispatch(events.GuildAvailable(guild.id))
-
-    @Processor.define()
-    async def _on_raw_guild_update(self, event: "RawGatewayEvent") -> None:
-        before = copy.copy(await self.cache.fetch_guild(event.data.get("id")))
-        self.dispatch(events.GuildUpdate(before or MISSING, self.cache.place_guild_data(event.data)))
-
-    @Processor.define()
-    async def _on_raw_guild_delete(self, event: "RawGatewayEvent") -> None:
-        guild_id = int(event.data.get("id"))
-        if event.data.get("unavailable", False):
-            self.dispatch(events.GuildUnavailable(guild_id))
-        else:
-            # noinspection PyProtectedMember
-            if guild_id in self._user._guild_ids:
-                # noinspection PyProtectedMember
-                self._user._guild_ids.remove(guild_id)
-
-            # get the guild right before deleting it
-            guild = self.cache.get_guild(guild_id)
-            self.cache.delete_guild(guild_id)
-
-            self.dispatch(events.GuildLeft(guild))
-
-    @Processor.define()
-    async def _on_raw_guild_ban_add(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(BanCreate(event.data.get("guild_id"), self.cache.place_user_data(event.data.get("user"))))
-
-    @Processor.define()
-    async def _on_raw_guild_ban_remove(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(BanRemove(event.data.get("guild_id"), self.cache.place_user_data(event.data.get("user"))))
-
-    @Processor.define()
-    async def _on_raw_integration_create(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(IntegrationCreate(GuildIntegration.from_dict(event.data, self)))  # type: ignore
-
-    @Processor.define()
-    async def _on_raw_integration_update(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(IntegrationUpdate(GuildIntegration.from_dict(event.data, self)))  # type: ignore
-
-    @Processor.define()
-    async def _on_raw_integration_delete(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(
-            IntegrationDelete(event.data.get("guild_id"), event.data.get("id"), event.data.get("application_id"))
-        )
-
-    @Processor.define()
-    async def _on_raw_guild_emojis_update(self, event: "RawGatewayEvent") -> None:
-        guild_id = event.data.get("guild_id")
-        emojis = event.data.get("emojis")
-
-        if self.cache.emoji_cache:
-            before = [copy.copy(self.cache.get_emoji(emoji["id"])) for emoji in emojis]
-        else:
-            before = []
-
-        after = [self.cache.place_emoji_data(guild_id, emoji) for emoji in emojis]
-
-        self.dispatch(
-            GuildEmojisUpdate(
-                guild_id=guild_id,
-                before=before,
-                after=after,
-            )
-        )
-
-    @Processor.define()
-    async def _on_raw_guild_stickers_update(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(
-            GuildStickersUpdate(event.data.get("guild_id"), Sticker.from_list(event.data.get("stickers", []), self))
-        )
-
-    @Processor.define()
-    async def _on_raw_webhook_update(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(WebhooksUpdate(event.data.get("guild_id"), event.data.get("channel_id")))
-
-    @Processor.define()
-    async def _on_raw_guild_audit_log_entry_create(self, event: "RawGatewayEvent") -> None:
-        self.dispatch(GuildAuditLogEntryCreate(event.data.get("guild_id"), AuditLogEntry.from_dict(event.data, self)))
+import copy
+from typing import TYPE_CHECKING
+
+import interactions.api.events as events
+from interactions.api.events.discord import (
+    BanCreate,
+    BanRemove,
+    GuildAuditLogEntryCreate,
+    GuildEmojisUpdate,
+    IntegrationCreate,
+    IntegrationUpdate,
+    IntegrationDelete,
+    GuildStickersUpdate,
+    WebhooksUpdate,
+)
+from interactions.client.const import MISSING
+from interactions.models import AuditLogEntry, GuildIntegration, Sticker, to_snowflake
+from ._template import EventMixinTemplate, Processor
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("GuildEvents",)
+
+
+class GuildEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _on_raw_guild_create(self, event: "RawGatewayEvent") -> None:
+        """
+        Automatically cache a guild upon GUILD_CREATE event from gateway.
+
+        Args:
+            event: raw guild create event
+
+        """
+        new_guild = not self.cache.get_guild(event.data["id"])
+        guild = self.cache.place_guild_data(event.data)
+
+        self._user._guild_ids.add(to_snowflake(event.data.get("id")))
+
+        self._guild_event.set()
+
+        if self.fetch_members and not guild.chunked.is_set():
+            # delays events until chunking has completed
+            await guild.chunk()
+
+        if new_guild:
+            self.dispatch(events.GuildJoin(guild.id))
+        else:
+            self.dispatch(events.GuildAvailable(guild.id))
+
+    @Processor.define()
+    async def _on_raw_guild_update(self, event: "RawGatewayEvent") -> None:
+        before = copy.copy(await self.cache.fetch_guild(event.data.get("id")))
+        self.dispatch(events.GuildUpdate(before or MISSING, self.cache.place_guild_data(event.data)))
+
+    @Processor.define()
+    async def _on_raw_guild_delete(self, event: "RawGatewayEvent") -> None:
+        guild_id = int(event.data.get("id"))
+        if event.data.get("unavailable", False):
+            self.dispatch(events.GuildUnavailable(guild_id))
+        else:
+            # noinspection PyProtectedMember
+            if guild_id in self._user._guild_ids:
+                # noinspection PyProtectedMember
+                self._user._guild_ids.remove(guild_id)
+
+            # get the guild right before deleting it
+            guild = self.cache.get_guild(guild_id)
+            self.cache.delete_guild(guild_id)
+
+            self.dispatch(events.GuildLeft(guild_id, guild))
+
+    @Processor.define()
+    async def _on_raw_guild_ban_add(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(BanCreate(event.data.get("guild_id"), self.cache.place_user_data(event.data.get("user"))))
+
+    @Processor.define()
+    async def _on_raw_guild_ban_remove(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(BanRemove(event.data.get("guild_id"), self.cache.place_user_data(event.data.get("user"))))
+
+    @Processor.define()
+    async def _on_raw_integration_create(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(IntegrationCreate(GuildIntegration.from_dict(event.data, self)))  # type: ignore
+
+    @Processor.define()
+    async def _on_raw_integration_update(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(IntegrationUpdate(GuildIntegration.from_dict(event.data, self)))  # type: ignore
+
+    @Processor.define()
+    async def _on_raw_integration_delete(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(
+            IntegrationDelete(event.data.get("guild_id"), event.data.get("id"), event.data.get("application_id"))
+        )
+
+    @Processor.define()
+    async def _on_raw_guild_emojis_update(self, event: "RawGatewayEvent") -> None:
+        guild_id = event.data.get("guild_id")
+        emojis = event.data.get("emojis")
+
+        if self.cache.emoji_cache:
+            before = [copy.copy(self.cache.get_emoji(emoji["id"])) for emoji in emojis]
+        else:
+            before = []
+
+        after = [self.cache.place_emoji_data(guild_id, emoji) for emoji in emojis]
+
+        self.dispatch(
+            GuildEmojisUpdate(
+                guild_id=guild_id,
+                before=before,
+                after=after,
+            )
+        )
+
+    @Processor.define()
+    async def _on_raw_guild_stickers_update(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(
+            GuildStickersUpdate(event.data.get("guild_id"), Sticker.from_list(event.data.get("stickers", []), self))
+        )
+
+    @Processor.define()
+    async def _on_raw_webhook_update(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(WebhooksUpdate(event.data.get("guild_id"), event.data.get("channel_id")))
+
+    @Processor.define()
+    async def _on_raw_guild_audit_log_entry_create(self, event: "RawGatewayEvent") -> None:
+        self.dispatch(GuildAuditLogEntryCreate(event.data.get("guild_id"), AuditLogEntry.from_dict(event.data, self)))
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/member_events.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/member_events.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-import copy
-from typing import TYPE_CHECKING
-
-import interactions.api.events as events
-from interactions.client.const import MISSING
-from ._template import EventMixinTemplate, Processor
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("MemberEvents",)
-
-
-class MemberEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _on_raw_guild_member_add(self, event: "RawGatewayEvent") -> None:
-        g_id = event.data.pop("guild_id")
-        member = self.cache.place_member_data(g_id, event.data)
-        if guild := self.cache.get_guild(g_id):
-            guild.member_count += 1
-        self.dispatch(events.MemberAdd(g_id, member))
-
-    @Processor.define()
-    async def _on_raw_guild_member_remove(self, event: "RawGatewayEvent") -> None:
-        g_id = event.data.pop("guild_id")
-        user = self.cache.place_user_data(event.data["user"])
-        member = self.cache.get_member(g_id, user.id)
-
-        self.cache.delete_member(g_id, user.id)
-        if guild := self.cache.get_guild(g_id):
-            guild.member_count -= 1
-
-        self.dispatch(events.MemberRemove(g_id, member or user))
-
-    @Processor.define()
-    async def _on_raw_guild_member_update(self, event: "RawGatewayEvent") -> None:
-        g_id = event.data.pop("guild_id")
-        before = copy.copy(self.cache.get_member(g_id, event.data["user"]["id"])) or MISSING
-        self.dispatch(events.MemberUpdate(g_id, before, self.cache.place_member_data(g_id, event.data)))
+import copy
+from typing import TYPE_CHECKING
+
+import interactions.api.events as events
+from interactions.client.const import MISSING
+from ._template import EventMixinTemplate, Processor
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("MemberEvents",)
+
+
+class MemberEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _on_raw_guild_member_add(self, event: "RawGatewayEvent") -> None:
+        g_id = event.data.pop("guild_id")
+        member = self.cache.place_member_data(g_id, event.data)
+        if guild := self.cache.get_guild(g_id):
+            guild.member_count += 1
+        self.dispatch(events.MemberAdd(g_id, member))
+
+    @Processor.define()
+    async def _on_raw_guild_member_remove(self, event: "RawGatewayEvent") -> None:
+        g_id = event.data.pop("guild_id")
+        user = self.cache.place_user_data(event.data["user"])
+        member = self.cache.get_member(g_id, user.id)
+
+        self.cache.delete_member(g_id, user.id)
+        if guild := self.cache.get_guild(g_id):
+            guild.member_count -= 1
+
+        self.dispatch(events.MemberRemove(g_id, member or user))
+
+    @Processor.define()
+    async def _on_raw_guild_member_update(self, event: "RawGatewayEvent") -> None:
+        g_id = event.data.pop("guild_id")
+        before = copy.copy(self.cache.get_member(g_id, event.data["user"]["id"])) or MISSING
+        self.dispatch(events.MemberUpdate(g_id, before, self.cache.place_member_data(g_id, event.data)))
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/role_events.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/role_events.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-import copy
-from typing import TYPE_CHECKING
-
-import interactions.api.events as events
-from interactions.client.const import MISSING
-from ._template import EventMixinTemplate, Processor
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("RoleEvents",)
-
-
-class RoleEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _on_raw_guild_role_create(self, event: "RawGatewayEvent") -> None:
-        g_id = int(event.data.get("guild_id"))
-        r_id = int(event.data["role"]["id"])
-
-        guild = self.cache.get_guild(g_id)
-        guild._role_ids.add(r_id)
-
-        role = self.cache.place_role_data(g_id, [event.data.get("role")])[r_id]
-        self.dispatch(events.RoleCreate(g_id, role))
-
-    @Processor.define()
-    async def _on_raw_guild_role_update(self, event: "RawGatewayEvent") -> None:
-        g_id = int(event.data.get("guild_id"))
-        r_data = event.data.get("role")
-        before = copy.copy(self.cache.get_role(r_data["id"]) or MISSING)
-
-        after = self.cache.place_role_data(g_id, [r_data])
-        after = after[int(event.data["role"]["id"])]
-
-        self.dispatch(events.RoleUpdate(g_id, before, after))
-
-    @Processor.define()
-    async def _on_raw_guild_role_delete(self, event: "RawGatewayEvent") -> None:
-        g_id = int(event.data.get("guild_id"))
-        r_id = int(event.data.get("role_id"))
-
-        guild = self.cache.get_guild(g_id)
-        role = self.cache.get_role(r_id)
-
-        self.cache.delete_role(r_id)
-
-        role_members = (member for member in guild.members if member.has_role(r_id))
-        for member in role_members:
-            member._role_ids.remove(r_id)
-
-        self.dispatch(events.RoleDelete(g_id, r_id, role))
+import copy
+from typing import TYPE_CHECKING
+
+import interactions.api.events as events
+from interactions.client.const import MISSING
+from ._template import EventMixinTemplate, Processor
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("RoleEvents",)
+
+
+class RoleEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _on_raw_guild_role_create(self, event: "RawGatewayEvent") -> None:
+        g_id = int(event.data.get("guild_id"))
+        r_id = int(event.data["role"]["id"])
+
+        guild = self.cache.get_guild(g_id)
+        guild._role_ids.add(r_id)
+
+        role = self.cache.place_role_data(g_id, [event.data.get("role")])[r_id]
+        self.dispatch(events.RoleCreate(g_id, role))
+
+    @Processor.define()
+    async def _on_raw_guild_role_update(self, event: "RawGatewayEvent") -> None:
+        g_id = int(event.data.get("guild_id"))
+        r_data = event.data.get("role")
+        before = copy.copy(self.cache.get_role(r_data["id"]) or MISSING)
+
+        after = self.cache.place_role_data(g_id, [r_data])
+        after = after[int(event.data["role"]["id"])]
+
+        self.dispatch(events.RoleUpdate(g_id, before, after))
+
+    @Processor.define()
+    async def _on_raw_guild_role_delete(self, event: "RawGatewayEvent") -> None:
+        g_id = int(event.data.get("guild_id"))
+        r_id = int(event.data.get("role_id"))
+
+        guild = self.cache.get_guild(g_id)
+        role = self.cache.get_role(r_id)
+
+        self.cache.delete_role(r_id)
+
+        role_members = (member for member in guild.members if member.has_role(r_id))
+        for member in role_members:
+            member._role_ids.remove(r_id)
+
+        self.dispatch(events.RoleDelete(g_id, r_id, role))
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/thread_events.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/thread_events.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from typing import TYPE_CHECKING
-
-import interactions.api.events as events
-from interactions.models import to_snowflake
-from ._template import EventMixinTemplate, Processor
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("ThreadEvents",)
-
-
-class ThreadEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _on_raw_thread_create(self, event: "RawGatewayEvent") -> None:
-        thread = self.cache.place_channel_data(event.data)
-        if event.data.get("newly_created"):
-            self.dispatch(events.NewThreadCreate(thread))
-        self.dispatch(events.ThreadCreate(thread))
-
-    @Processor.define()
-    async def _on_raw_thread_update(self, event: "RawGatewayEvent") -> None:
-        # todo: Should this also have a before attribute? so you can compare the previous version against this one?
-        self.dispatch(events.ThreadUpdate(self.cache.place_channel_data(event.data)))
-
-    @Processor.define()
-    async def _on_raw_thread_delete(self, event: "RawGatewayEvent") -> None:
-        thread = self.cache.get_channel(event.data.get("id")) or event.data.get("id")
-        self.cache.delete_channel(event.data.get("id"))
-        self.dispatch(events.ThreadDelete(thread))
-
-    @Processor.define()
-    async def _on_raw_thread_list_sync(self, event: "RawGatewayEvent") -> None:
-        # todo: when we decide how to store thread members, deal with that here
-        threads = [self.cache.place_channel_data(t) for t in event.data.get("threads", [])]
-        channel_ids = [to_snowflake(c) for c in event.data.get("channel_ids", [])]
-        members = [self.cache.place_member_data(event.data.get("guild_id"), m) for m in event.data.get("members", [])]
-
-        self.dispatch(events.ThreadListSync(channel_ids, threads, members))
-
-    @Processor.define()
-    async def _on_raw_thread_members_update(self, event: "RawGatewayEvent") -> None:
-        g_id = event.data.get("guild_id")
-        self.dispatch(
-            events.ThreadMembersUpdate(
-                event.data.get("id"),
-                event.data.get("member_count"),
-                [await self.cache.fetch_member(g_id, m["user_id"]) for m in event.data.get("added_members", [])],
-                event.data.get("removed_member_ids", []),
-            )
-        )
+from typing import TYPE_CHECKING
+
+import interactions.api.events as events
+from interactions.models import to_snowflake
+from ._template import EventMixinTemplate, Processor
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("ThreadEvents",)
+
+
+class ThreadEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _on_raw_thread_create(self, event: "RawGatewayEvent") -> None:
+        thread = self.cache.place_channel_data(event.data)
+        if event.data.get("newly_created"):
+            self.dispatch(events.NewThreadCreate(thread))
+        self.dispatch(events.ThreadCreate(thread))
+
+    @Processor.define()
+    async def _on_raw_thread_update(self, event: "RawGatewayEvent") -> None:
+        # todo: Should this also have a before attribute? so you can compare the previous version against this one?
+        self.dispatch(events.ThreadUpdate(self.cache.place_channel_data(event.data)))
+
+    @Processor.define()
+    async def _on_raw_thread_delete(self, event: "RawGatewayEvent") -> None:
+        thread = self.cache.get_channel(event.data.get("id")) or event.data.get("id")
+        self.cache.delete_channel(event.data.get("id"))
+        self.dispatch(events.ThreadDelete(thread))
+
+    @Processor.define()
+    async def _on_raw_thread_list_sync(self, event: "RawGatewayEvent") -> None:
+        # todo: when we decide how to store thread members, deal with that here
+        threads = [self.cache.place_channel_data(t) for t in event.data.get("threads", [])]
+        channel_ids = [to_snowflake(c) for c in event.data.get("channel_ids", [])]
+        members = [self.cache.place_member_data(event.data.get("guild_id"), m) for m in event.data.get("members", [])]
+
+        self.dispatch(events.ThreadListSync(channel_ids, threads, members))
+
+    @Processor.define()
+    async def _on_raw_thread_members_update(self, event: "RawGatewayEvent") -> None:
+        g_id = event.data.get("guild_id")
+        self.dispatch(
+            events.ThreadMembersUpdate(
+                event.data.get("id"),
+                event.data.get("member_count"),
+                [await self.cache.fetch_member(g_id, m["user_id"]) for m in event.data.get("added_members", [])],
+                event.data.get("removed_member_ids", []),
+            )
+        )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/user_events.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/user_events.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,61 +1,61 @@
-from typing import Union, TYPE_CHECKING
-
-import interactions.api.events as events
-from interactions.models import User, Member, BaseChannel, Timestamp, to_snowflake, Activity
-from interactions.models.discord.enums import Status
-from ._template import EventMixinTemplate, Processor
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("UserEvents",)
-
-
-class UserEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _on_raw_typing_start(self, event: "RawGatewayEvent") -> None:
-        """
-        Process raw typing start and dispatch a processed typing event.
-
-        Args:
-            event: raw typing start event
-
-        """
-        author: Union[User, Member]
-        channel: BaseChannel
-        guild = None
-
-        if member := event.data.get("member"):
-            author = self.cache.place_member_data(event.data.get("guild_id"), member)
-            guild = await self.cache.fetch_guild(event.data.get("guild_id"))
-        else:
-            author = await self.cache.fetch_user(event.data.get("user_id"))
-
-        channel = await self.cache.fetch_channel(event.data.get("channel_id"))
-
-        self.dispatch(
-            events.TypingStart(
-                author=author,
-                channel=channel,
-                guild=guild,
-                timestamp=Timestamp.utcfromtimestamp(event.data.get("timestamp")),
-            )
-        )
-
-    @Processor.define()
-    async def _on_raw_presence_update(self, event: "RawGatewayEvent") -> None:
-        """
-        Process raw presence update and dispatch a processed presence update event.
-
-        Args:
-            event: raw presence update event
-
-        """
-        g_id = to_snowflake(event.data["guild_id"])
-        if user := self.cache.get_user(event.data["user"]["id"]):
-            user.status = Status[event.data["status"].upper()]
-            user.activities = Activity.from_list(event.data.get("activities"))
-
-            self.dispatch(
-                events.PresenceUpdate(user, user.status, user.activities, event.data.get("client_status", None), g_id)
-            )
+from typing import Union, TYPE_CHECKING
+
+import interactions.api.events as events
+from interactions.models import User, Member, BaseChannel, Timestamp, to_snowflake, Activity
+from interactions.models.discord.enums import Status
+from ._template import EventMixinTemplate, Processor
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("UserEvents",)
+
+
+class UserEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _on_raw_typing_start(self, event: "RawGatewayEvent") -> None:
+        """
+        Process raw typing start and dispatch a processed typing event.
+
+        Args:
+            event: raw typing start event
+
+        """
+        author: Union[User, Member]
+        channel: BaseChannel
+        guild = None
+
+        if member := event.data.get("member"):
+            author = self.cache.place_member_data(event.data.get("guild_id"), member)
+            guild = await self.cache.fetch_guild(event.data.get("guild_id"))
+        else:
+            author = await self.cache.fetch_user(event.data.get("user_id"))
+
+        channel = await self.cache.fetch_channel(event.data.get("channel_id"))
+
+        self.dispatch(
+            events.TypingStart(
+                author=author,
+                channel=channel,
+                guild=guild,
+                timestamp=Timestamp.utcfromtimestamp(event.data.get("timestamp")),
+            )
+        )
+
+    @Processor.define()
+    async def _on_raw_presence_update(self, event: "RawGatewayEvent") -> None:
+        """
+        Process raw presence update and dispatch a processed presence update event.
+
+        Args:
+            event: raw presence update event
+
+        """
+        g_id = to_snowflake(event.data["guild_id"])
+        if user := self.cache.get_user(event.data["user"]["id"]):
+            user.status = Status[event.data["status"].upper()]
+            user.activities = Activity.from_list(event.data.get("activities"))
+
+            self.dispatch(
+                events.PresenceUpdate(user, user.status, user.activities, event.data.get("client_status", None), g_id)
+            )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/events/processors/voice_events.py` & `discord-py-interactions-5.6.0/interactions/api/events/processors/voice_events.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-import copy
-from typing import TYPE_CHECKING
-
-import interactions.api.events as events
-from ._template import EventMixinTemplate, Processor
-
-if TYPE_CHECKING:
-    from interactions.api.events import RawGatewayEvent
-
-__all__ = ("VoiceEvents",)
-
-
-class VoiceEvents(EventMixinTemplate):
-    @Processor.define()
-    async def _on_raw_voice_state_update(self, event: "RawGatewayEvent") -> None:
-        before = copy.copy(self.cache.get_voice_state(event.data["user_id"])) or None
-        after = await self.cache.place_voice_state_data(event.data)
-
-        self.dispatch(events.VoiceStateUpdate(before, after))
-
-        if before and before.user_id == self.user.id:
-            if vc := self.cache.get_bot_voice_state(event.data["guild_id"]):
-                # noinspection PyProtectedMember
-                await vc._voice_state_update(before, after, event.data)
-
-        if before and after:
-            if (before.mute != after.mute) or (before.self_mute != after.self_mute):
-                self.dispatch(events.VoiceUserMute(after, after.member, after.channel, after.mute or after.self_mute))
-            if (before.deaf != after.deaf) or (before.self_deaf != after.self_deaf):
-                self.dispatch(events.VoiceUserDeafen(after, after.member, after.channel, after.deaf or after.self_deaf))
-            if before.channel != after.channel:
-                self.dispatch(events.VoiceUserMove(after, after.member, before.channel, after.channel))
-        elif not before and after:
-            self.dispatch(events.VoiceUserJoin(after, after.member, after.channel))
-        elif before:
-            self.dispatch(events.VoiceUserLeave(before, before.member, before.channel))
-
-    @Processor.define()
-    async def _on_raw_voice_server_update(self, event: "RawGatewayEvent") -> None:
-        if vc := self.cache.get_bot_voice_state(event.data["guild_id"]):
-            # noinspection PyProtectedMember
-            await vc._voice_server_update(event.data)
+import copy
+from typing import TYPE_CHECKING
+
+import interactions.api.events as events
+from ._template import EventMixinTemplate, Processor
+
+if TYPE_CHECKING:
+    from interactions.api.events import RawGatewayEvent
+
+__all__ = ("VoiceEvents",)
+
+
+class VoiceEvents(EventMixinTemplate):
+    @Processor.define()
+    async def _on_raw_voice_state_update(self, event: "RawGatewayEvent") -> None:
+        before = copy.copy(self.cache.get_voice_state(event.data["user_id"])) or None
+        after = await self.cache.place_voice_state_data(event.data)
+
+        self.dispatch(events.VoiceStateUpdate(before, after))
+
+        if before and before.user_id == self.user.id:
+            if vc := self.cache.get_bot_voice_state(event.data["guild_id"]):
+                # noinspection PyProtectedMember
+                await vc._voice_state_update(before, after, event.data)
+
+        if before and after:
+            if (before.mute != after.mute) or (before.self_mute != after.self_mute):
+                self.dispatch(events.VoiceUserMute(after, after.member, after.channel, after.mute or after.self_mute))
+            if (before.deaf != after.deaf) or (before.self_deaf != after.self_deaf):
+                self.dispatch(events.VoiceUserDeafen(after, after.member, after.channel, after.deaf or after.self_deaf))
+            if before.channel != after.channel:
+                self.dispatch(events.VoiceUserMove(after, after.member, before.channel, after.channel))
+        elif not before and after:
+            self.dispatch(events.VoiceUserJoin(after, after.member, after.channel))
+        elif before:
+            self.dispatch(events.VoiceUserLeave(before, before.member, before.channel))
+
+    @Processor.define()
+    async def _on_raw_voice_server_update(self, event: "RawGatewayEvent") -> None:
+        if vc := self.cache.get_bot_voice_state(event.data["guild_id"]):
+            # noinspection PyProtectedMember
+            await vc._voice_server_update(event.data)
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_client.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_client.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,584 +1,584 @@
-"""This file handles the interaction with discords http endpoints."""
-import asyncio
-import inspect
-import os
-import time
-from logging import Logger
-from typing import Any, cast, Callable
-from urllib.parse import quote as _uriquote
-from weakref import WeakValueDictionary
-
-import aiohttp
-import discord_typings
-from aiohttp import BaseConnector, ClientSession, ClientWebSocketResponse, FormData, BasicAuth
-from multidict import CIMultiDictProxy
-
-import interactions.client.const as constants
-from interactions import models
-from interactions.api.http.http_requests import (
-    BotRequests,
-    ChannelRequests,
-    EmojiRequests,
-    GuildRequests,
-    InteractionRequests,
-    MemberRequests,
-    MessageRequests,
-    ReactionRequests,
-    StickerRequests,
-    ThreadRequests,
-    UserRequests,
-    WebhookRequests,
-    ScheduledEventsRequests,
-)
-from interactions.client.const import (
-    MISSING,
-    __py_version__,
-    __repo_url__,
-    __version__,
-    __api_version__,
-)
-from interactions.client.errors import (
-    DiscordError,
-    Forbidden,
-    GatewayNotFound,
-    HTTPException,
-    NotFound,
-    LoginError,
-)
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.input_utils import response_decode, FastJson
-from interactions.client.utils.serializer import dict_filter, get_file_mimetype
-from interactions.models.discord.file import UPLOADABLE_TYPE
-from .route import Route
-
-__all__ = ("HTTPClient",)
-
-
-class GlobalLock:
-    def __init__(self) -> None:
-        self._lock = asyncio.Lock()
-        self.max_requests = 45
-        self._calls = self.max_requests
-        self._reset_time = 0
-
-    @property
-    def calls_remaining(self) -> int:
-        """Returns the amount of calls remaining."""
-        return self.max_requests - self._calls
-
-    def reset_calls(self) -> None:
-        """Resets the calls to the max amount."""
-        self._calls = self.max_requests
-        self._reset_time = time.perf_counter() + 1
-
-    def set_reset_time(self, delta: float) -> None:
-        """
-        Sets the reset time to the current time + delta.
-
-        To be called if a 429 is received.
-
-        Args:
-            delta: The time to wait before resetting the calls.
-        """
-        self._reset_time = time.perf_counter() + delta
-        self._calls = 0
-
-    async def wait(self) -> None:
-        """Throttles calls to prevent hitting the global rate limit."""
-        async with self._lock:
-            if self._reset_time <= time.perf_counter():
-                self.reset_calls()
-            elif self._calls <= 0:
-                await asyncio.sleep(self._reset_time - time.perf_counter())
-                self.reset_calls()
-        self._calls -= 1
-
-
-class BucketLock:
-    """Manages the rate limit for each bucket."""
-
-    DEFAULT_LIMIT = 1
-    DEFAULT_REMAINING = 1
-    DEFAULT_DELTA = 0.0
-
-    def __init__(self, header: CIMultiDictProxy | None = None) -> None:
-        self._semaphore: asyncio.Semaphore | None = None
-        if header is None:
-            self.bucket_hash: str | None = None
-            self.limit: int = self.DEFAULT_LIMIT
-            self.remaining: int = self.DEFAULT_REMAINING
-            self.delta: float = self.DEFAULT_DELTA
-        else:
-            self.ingest_ratelimit_header(header)
-
-        self.logger = constants.get_logger()
-
-        self._lock: asyncio.Lock = asyncio.Lock()
-
-    def __repr__(self) -> str:
-        return f"<BucketLock: {self.bucket_hash or 'Generic'}, limit: {self.limit}, remaining: {self.remaining}, delta: {self.delta}>"
-
-    @property
-    def locked(self) -> bool:
-        """Returns whether the bucket is locked."""
-        if self._lock.locked():
-            return True
-        return self._semaphore is not None and self._semaphore.locked()
-
-    def ingest_ratelimit_header(self, header: CIMultiDictProxy) -> None:
-        """
-        Ingests the rate limit header.
-
-        Args:
-            header: The header to ingest, containing rate limit information.
-
-        Updates the bucket_hash, limit, remaining, and delta attributes with the information from the header.
-        """
-        self.bucket_hash = header.get("x-ratelimit-bucket")
-        self.limit = int(header.get("x-ratelimit-limit", self.DEFAULT_LIMIT))
-        self.remaining = int(header.get("x-ratelimit-remaining", self.DEFAULT_REMAINING))
-        self.delta = float(header.get("x-ratelimit-reset-after", self.DEFAULT_DELTA))
-
-        if self._semaphore is None or self._semaphore._value != self.limit:
-            self._semaphore = asyncio.Semaphore(self.limit)
-
-    async def acquire(self) -> None:
-        """Acquires the semaphore."""
-        if self._semaphore is None:
-            return
-
-        if self._lock.locked():
-            self.logger.debug(f"Waiting for bucket {self.bucket_hash} to unlock.")
-            async with self._lock:
-                pass
-
-        await self._semaphore.acquire()
-
-    def release(self) -> None:
-        """
-        Releases the semaphore.
-
-        Note: If the bucket has been locked with lock_for_duration, this will not release the lock.
-        """
-        if self._semaphore is None:
-            return
-        self._semaphore.release()
-
-    async def lock_for_duration(self, duration: float, block: bool = False) -> None:
-        """
-        Locks the bucket for a given duration.
-
-        Args:
-            duration: The duration to lock the bucket for.
-            block: Whether to block until the bucket is unlocked.
-
-        Raises:
-            RuntimeError: If the bucket is already locked.
-        """
-        if self._lock.locked():
-            raise RuntimeError("Attempted to lock a bucket that is already locked.")
-
-        async def _release() -> None:
-            await asyncio.sleep(duration)
-            self._lock.release()
-
-        if block:
-            await self._lock.acquire()
-            await _release()
-        else:
-            await self._lock.acquire()
-            _ = asyncio.create_task(_release())
-
-    async def __aenter__(self) -> None:
-        await self.acquire()
-
-    async def __aexit__(self, *args) -> None:
-        self.release()
-
-
-class HTTPClient(
-    BotRequests,
-    ChannelRequests,
-    EmojiRequests,
-    GuildRequests,
-    InteractionRequests,
-    MemberRequests,
-    MessageRequests,
-    ReactionRequests,
-    StickerRequests,
-    ThreadRequests,
-    UserRequests,
-    WebhookRequests,
-    ScheduledEventsRequests,
-):
-    """A http client for sending requests to the Discord API."""
-
-    def __init__(
-        self,
-        connector: BaseConnector | None = None,
-        logger: Logger = MISSING,
-        show_ratelimit_tracebacks: bool = False,
-        proxy: tuple[str, BasicAuth] | None = None,
-    ) -> None:
-        self.connector: BaseConnector | None = connector
-        self.__session: ClientSession | None = None
-        self.token: str | None = None
-        self.global_lock: GlobalLock = GlobalLock()
-        self._max_attempts: int = 3
-
-        self.ratelimit_locks: WeakValueDictionary[str, BucketLock] = WeakValueDictionary()
-        self.show_ratelimit_traceback: bool = show_ratelimit_tracebacks
-        self._endpoints = {}
-
-        self.user_agent: str = (
-            f"DiscordBot ({__repo_url__} {__version__} Python/{__py_version__}) aiohttp/{aiohttp.__version__}"
-        )
-        self.proxy: tuple[str, BasicAuth] | None = proxy
-        self.__proxy_validated: bool = False
-
-        if logger is MISSING:
-            logger = constants.get_logger()
-        self.logger = logger
-
-    def get_ratelimit(self, route: Route) -> BucketLock:
-        """
-        Get a route's rate limit bucket.
-
-        Args:
-            route: The route to fetch the ratelimit bucket for
-
-        Returns:
-            The BucketLock object for this route
-        """
-        if bucket_hash := self._endpoints.get(route.rl_bucket):
-            if lock := self.ratelimit_locks.get(bucket_hash):
-                # if we have an active lock on this route, it'll still be in the cache
-                # return that lock
-                return lock
-        # if no cached lock exists, return a new lock
-        return BucketLock()
-
-    def ingest_ratelimit(self, route: Route, header: CIMultiDictProxy, bucket_lock: BucketLock) -> None:
-        """
-        Ingests a ratelimit header from discord to determine ratelimit.
-
-        Args:
-            route: The route we're ingesting ratelimit for
-            header: The rate limit header in question
-            bucket_lock: The rate limit bucket for this route
-        """
-        bucket_lock.ingest_ratelimit_header(header)
-
-        if bucket_lock.bucket_hash:
-            # We only ever try and cache the bucket if the bucket hash has been set (ignores unlimited endpoints)
-            self.logger.debug(f"Caching ingested rate limit data for: {bucket_lock.bucket_hash}")
-            self._endpoints[route.rl_bucket] = bucket_lock.bucket_hash
-            self.ratelimit_locks[bucket_lock.bucket_hash] = bucket_lock
-
-    @staticmethod
-    def _process_payload(
-        payload: dict | list[dict] | None, files: UPLOADABLE_TYPE | list[UPLOADABLE_TYPE] | None
-    ) -> dict | list[dict] | FormData | None:
-        """
-        Processes a payload into a format safe for discord. Converts the payload into FormData where required
-
-        Args:
-            payload: The payload of the request
-            files: A list of any files to send
-
-        Returns:
-            Either a dictionary or multipart data form
-        """
-        if isinstance(payload, FormData):
-            return payload
-        if payload is None:
-            return None
-
-        if isinstance(payload, dict):
-            payload = dict_filter(payload)
-
-            for k, v in payload.items():
-                if isinstance(v, DictSerializationMixin):
-                    payload[k] = v.to_dict()
-                if isinstance(v, (list, tuple, set)):
-                    payload[k] = [i.to_dict() if isinstance(i, DictSerializationMixin) else i for i in v]
-
-        else:
-            payload = [dict_filter(x) if isinstance(x, dict) else x for x in payload]
-
-        if not files:
-            return payload
-
-        if not isinstance(files, list):
-            files = (files,)
-
-        attachments = []
-
-        form_data = FormData(quote_fields=False)
-
-        for index, file in enumerate(files):
-            file_data = models.open_file(file).read()
-
-            if isinstance(file, models.File):
-                form_data.add_field(
-                    f"files[{index}]",
-                    file_data,
-                    filename=file.file_name,
-                    content_type=file.content_type or get_file_mimetype(file_data),
-                )
-                attachments.append({"id": index, "description": file.description, "filename": file.file_name})
-            else:
-                form_data.add_field(
-                    f"files[{index}]",
-                    file_data,
-                    filename=file.split(os.sep)[-1],
-                    content_type=get_file_mimetype(file_data),
-                )
-        if attachments:
-            payload["attachments"] = attachments
-
-        form_data.add_field("payload_json", FastJson.dumps(payload))
-        return form_data
-
-    async def request(  # noqa: C901
-        self,
-        route: Route,
-        payload: list | dict | None = None,
-        files: list[UPLOADABLE_TYPE] | None = None,
-        reason: str | None = None,
-        params: dict | None = None,
-        **kwargs: dict,
-    ) -> str | dict[str, Any] | None:
-        """
-        Make a request to discord.
-
-        Args:
-            route: The route to take
-            payload: The payload for this request
-            files: The files to send with this request
-            reason: Attach a reason to this request, used for audit logs
-            params: Query string parameters
-
-        """
-        # Assemble headers
-        kwargs["headers"] = {"User-Agent": self.user_agent}
-        if self.token:
-            kwargs["headers"]["Authorization"] = f"Bot {self.token}"
-        if reason:
-            kwargs["headers"]["X-Audit-Log-Reason"] = _uriquote(reason, safe="/ ")
-
-        if isinstance(payload, (list, dict)) and not files:
-            kwargs["headers"]["Content-Type"] = "application/json"
-        if isinstance(params, dict):
-            kwargs["params"] = dict_filter(params)
-
-        lock = self.get_ratelimit(route)
-        # this gets a BucketLock for this route.
-        # If this endpoint has been used before, it will get an existing ratelimit for the respective buckethash
-        # otherwise a brand-new bucket lock will be returned
-
-        for attempt in range(self._max_attempts):
-            async with lock:
-                try:
-                    if self.__session.closed:
-                        await self.login(cast(str, self.token))
-
-                    processed_data = self._process_payload(payload, files)
-                    if isinstance(processed_data, FormData):
-                        kwargs["data"] = processed_data  # pyright: ignore
-                    else:
-                        kwargs["json"] = processed_data  # pyright: ignore
-                    await self.global_lock.wait()
-
-                    if self.proxy:
-                        kwargs["proxy"] = self.proxy[0]
-                        kwargs["proxy_auth"] = self.proxy[1]
-
-                    async with self.__session.request(route.method, route.url, **kwargs) as response:
-                        result = await response_decode(response)
-                        self.ingest_ratelimit(route, response.headers, lock)
-
-                        if response.status == 429:
-                            # ratelimit exceeded
-                            result = cast(dict[str, str], result)
-                            if result.get("global", False):
-                                # global ratelimit is reached
-                                # if we get a global, that's pretty bad, this would usually happen if the user is hitting the api from 2 clients sharing a token
-                                self.log_ratelimit(
-                                    self.logger.warning,
-                                    f"Bot has exceeded global ratelimit, locking REST API for {result['retry_after']} seconds",
-                                )
-                                self.global_lock.set_reset_time(float(result["retry_after"]))
-                            elif result.get("message") == "The resource is being rate limited.":
-                                # resource ratelimit is reached
-                                self.log_ratelimit(
-                                    self.logger.warning,
-                                    f"{route.resolved_endpoint} The resource is being rate limited! "
-                                    f"Reset in {result.get('retry_after')} seconds",
-                                )
-                                # lock this resource and wait for unlock
-                                await lock.lock_for_duration(float(result["retry_after"]), block=True)
-                            else:
-                                # endpoint ratelimit is reached
-                                # 429's are unfortunately unavoidable, but we can attempt to avoid them
-                                # so long as these are infrequent we're doing well
-                                self.log_ratelimit(
-                                    self.logger.warning,
-                                    f"{route.resolved_endpoint} Has exceeded its ratelimit ({lock.limit})! Reset in {lock.delta} seconds",
-                                )
-                                await lock.lock_for_duration(lock.delta, block=True)
-                            continue
-                        if lock.remaining == 0:
-                            # Last call available in the bucket, lock until reset
-                            self.log_ratelimit(
-                                self.logger.debug,
-                                f"{route.resolved_endpoint} Has exhausted its ratelimit ({lock.limit})! Locking route for {lock.delta} seconds",
-                            )
-                            await lock.lock_for_duration(
-                                lock.delta
-                            )  # lock this route, but continue processing the current response
-
-                        elif response.status in {500, 502, 504}:
-                            # Server issues, retry
-                            self.logger.warning(
-                                f"{route.resolved_endpoint} Received {response.status}... retrying in {1 + attempt * 2} seconds"
-                            )
-                            await asyncio.sleep(1 + attempt * 2)
-                            continue
-
-                        if not 300 > response.status >= 200:
-                            await self._raise_exception(response, route, result)
-
-                        self.logger.debug(
-                            f"{route.resolved_endpoint} Received {response.status} :: [{lock.remaining}/{lock.limit} calls remaining]"
-                        )
-                        return result
-                except OSError as e:
-                    if attempt < self._max_attempts - 1 and e.errno in (54, 10054):
-                        await asyncio.sleep(1 + attempt * 2)
-                        continue
-                    raise
-
-    async def _raise_exception(self, response, route, result) -> None:
-        self.logger.error(f"{route.method}::{route.url}: {response.status}")
-
-        if response.status == 403:
-            raise Forbidden(response, response_data=result, route=route)
-        if response.status == 404:
-            raise NotFound(response, response_data=result, route=route)
-        if response.status >= 500:
-            raise DiscordError(response, response_data=result, route=route)
-        raise HTTPException(response, response_data=result, route=route)
-
-    def log_ratelimit(self, log_func: Callable, message: str) -> None:
-        """
-        Logs a ratelimit message, optionally with a traceback if show_ratelimit_traceback is True
-
-        Args:
-            log_func: The logging function to use
-            message: The message to log
-        """
-        if self.show_ratelimit_traceback:
-            if frame := next(
-                (frame for frame in inspect.stack() if constants.LIB_PATH not in frame.filename),
-                None,
-            ):
-                frame_info = inspect.getframeinfo(frame[0])
-                filename = os.path.relpath(frame_info.filename, os.getcwd())
-
-                traceback = (
-                    f"{filename}:{frame_info.lineno} in {frame_info.function}:: {frame_info.code_context[0].strip()}"
-                )
-                message = f"{message} | Caused By: {traceback}"
-
-        log_func(message)
-
-    async def request_cdn(self, url, asset) -> bytes:  # pyright: ignore [reportGeneralTypeIssues]
-        self.logger.debug(f"{asset} requests {url} from CDN")
-        async with self.__session.get(url) as response:
-            if response.status == 200:
-                return await response.read()
-            await self._raise_exception(response, asset, await response_decode(response))
-
-    async def login(self, token: str) -> dict[str, Any]:
-        """
-        "Login" to the gateway, basically validates the token and grabs user data.
-
-        Args:
-            token: the token to use
-
-        Returns:
-            The currently logged in bot's data
-
-        """
-        self.__session = ClientSession(
-            connector=self.connector or aiohttp.TCPConnector(limit=self.global_lock.max_requests),
-            json_serialize=FastJson.dumps,
-        )
-        if not self.__proxy_validated and self.proxy:
-            try:
-                self.logger.info(f"Validating Proxy @ {self.proxy[0]}")
-                async with self.__session.get(
-                    "http://icanhazip.com/", proxy=self.proxy[0], proxy_auth=self.proxy[1]
-                ) as response:
-                    if response.status != 200:
-                        raise RuntimeError("Proxy configuration is invalid")
-                    self.logger.info(f"Proxy Connected @ {(await response.text()).strip()}")
-                    self.__proxy_validated = True
-            except Exception as e:
-                raise RuntimeError("Proxy configuration is invalid") from e
-
-        self.token = token
-        try:
-            result = await self.request(Route("GET", "/users/@me"))
-            return cast(dict[str, Any], result)
-        except HTTPException as e:
-            if e.status == 401:
-                raise LoginError("An improper token was passed") from e
-            raise
-
-    async def close(self) -> None:
-        """Close the session."""
-        if self.__session and not self.__session.closed:
-            await self.__session.close()
-
-    async def get_gateway(self) -> str:
-        """
-        Gets the gateway url.
-
-        Returns:
-            The gateway url
-
-        """
-        try:
-            result = await self.request(Route("GET", "/gateway"))
-            result = cast(dict[str, Any], result)
-        except HTTPException as exc:
-            raise GatewayNotFound from exc
-        return "{0}?encoding={1}&v={2}&compress=zlib-stream".format(result["url"], "json", __api_version__)
-
-    async def get_gateway_bot(self) -> discord_typings.GetGatewayBotData:
-        try:
-            result = await self.request(Route("GET", "/gateway/bot"))
-        except HTTPException as exc:
-            raise GatewayNotFound from exc
-        return cast(discord_typings.GetGatewayBotData, result)
-
-    async def websocket_connect(self, url: str) -> ClientWebSocketResponse:
-        """
-        Connect to the websocket.
-
-        Args:
-            url: the url to connect to
-
-        """
-        return await self.__session.ws_connect(
-            url,
-            timeout=30,
-            max_msg_size=0,
-            autoclose=False,
-            headers={"User-Agent": self.user_agent},
-            compress=0,
-            proxy=self.proxy[0] if self.proxy else None,
-            proxy_auth=self.proxy[1] if self.proxy else None,
-        )
+"""This file handles the interaction with discords http endpoints."""
+import asyncio
+import inspect
+import os
+import time
+from logging import Logger
+from typing import Any, cast, Callable
+from urllib.parse import quote as _uriquote
+from weakref import WeakValueDictionary
+
+import aiohttp
+import discord_typings
+from aiohttp import BaseConnector, ClientSession, ClientWebSocketResponse, FormData, BasicAuth
+from multidict import CIMultiDictProxy
+
+import interactions.client.const as constants
+from interactions import models
+from interactions.api.http.http_requests import (
+    BotRequests,
+    ChannelRequests,
+    EmojiRequests,
+    GuildRequests,
+    InteractionRequests,
+    MemberRequests,
+    MessageRequests,
+    ReactionRequests,
+    StickerRequests,
+    ThreadRequests,
+    UserRequests,
+    WebhookRequests,
+    ScheduledEventsRequests,
+)
+from interactions.client.const import (
+    MISSING,
+    __py_version__,
+    __repo_url__,
+    __version__,
+    __api_version__,
+)
+from interactions.client.errors import (
+    DiscordError,
+    Forbidden,
+    GatewayNotFound,
+    HTTPException,
+    NotFound,
+    LoginError,
+)
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.input_utils import response_decode, FastJson
+from interactions.client.utils.serializer import dict_filter, get_file_mimetype
+from interactions.models.discord.file import UPLOADABLE_TYPE
+from .route import Route
+
+__all__ = ("HTTPClient",)
+
+
+class GlobalLock:
+    def __init__(self) -> None:
+        self._lock = asyncio.Lock()
+        self.max_requests = 45
+        self._calls = self.max_requests
+        self._reset_time = 0
+
+    @property
+    def calls_remaining(self) -> int:
+        """Returns the amount of calls remaining."""
+        return self.max_requests - self._calls
+
+    def reset_calls(self) -> None:
+        """Resets the calls to the max amount."""
+        self._calls = self.max_requests
+        self._reset_time = time.perf_counter() + 1
+
+    def set_reset_time(self, delta: float) -> None:
+        """
+        Sets the reset time to the current time + delta.
+
+        To be called if a 429 is received.
+
+        Args:
+            delta: The time to wait before resetting the calls.
+        """
+        self._reset_time = time.perf_counter() + delta
+        self._calls = 0
+
+    async def wait(self) -> None:
+        """Throttles calls to prevent hitting the global rate limit."""
+        async with self._lock:
+            if self._reset_time <= time.perf_counter():
+                self.reset_calls()
+            elif self._calls <= 0:
+                await asyncio.sleep(self._reset_time - time.perf_counter())
+                self.reset_calls()
+        self._calls -= 1
+
+
+class BucketLock:
+    """Manages the rate limit for each bucket."""
+
+    DEFAULT_LIMIT = 1
+    DEFAULT_REMAINING = 1
+    DEFAULT_DELTA = 0.0
+
+    def __init__(self, header: CIMultiDictProxy | None = None) -> None:
+        self._semaphore: asyncio.Semaphore | None = None
+        if header is None:
+            self.bucket_hash: str | None = None
+            self.limit: int = self.DEFAULT_LIMIT
+            self.remaining: int = self.DEFAULT_REMAINING
+            self.delta: float = self.DEFAULT_DELTA
+        else:
+            self.ingest_ratelimit_header(header)
+
+        self.logger = constants.get_logger()
+
+        self._lock: asyncio.Lock = asyncio.Lock()
+
+    def __repr__(self) -> str:
+        return f"<BucketLock: {self.bucket_hash or 'Generic'}, limit: {self.limit}, remaining: {self.remaining}, delta: {self.delta}>"
+
+    @property
+    def locked(self) -> bool:
+        """Returns whether the bucket is locked."""
+        if self._lock.locked():
+            return True
+        return self._semaphore is not None and self._semaphore.locked()
+
+    def ingest_ratelimit_header(self, header: CIMultiDictProxy) -> None:
+        """
+        Ingests the rate limit header.
+
+        Args:
+            header: The header to ingest, containing rate limit information.
+
+        Updates the bucket_hash, limit, remaining, and delta attributes with the information from the header.
+        """
+        self.bucket_hash = header.get("x-ratelimit-bucket")
+        self.limit = int(header.get("x-ratelimit-limit", self.DEFAULT_LIMIT))
+        self.remaining = int(header.get("x-ratelimit-remaining", self.DEFAULT_REMAINING))
+        self.delta = float(header.get("x-ratelimit-reset-after", self.DEFAULT_DELTA))
+
+        if self._semaphore is None or self._semaphore._value != self.limit:
+            self._semaphore = asyncio.Semaphore(self.limit)
+
+    async def acquire(self) -> None:
+        """Acquires the semaphore."""
+        if self._semaphore is None:
+            return
+
+        if self._lock.locked():
+            self.logger.debug(f"Waiting for bucket {self.bucket_hash} to unlock.")
+            async with self._lock:
+                pass
+
+        await self._semaphore.acquire()
+
+    def release(self) -> None:
+        """
+        Releases the semaphore.
+
+        Note: If the bucket has been locked with lock_for_duration, this will not release the lock.
+        """
+        if self._semaphore is None:
+            return
+        self._semaphore.release()
+
+    async def lock_for_duration(self, duration: float, block: bool = False) -> None:
+        """
+        Locks the bucket for a given duration.
+
+        Args:
+            duration: The duration to lock the bucket for.
+            block: Whether to block until the bucket is unlocked.
+
+        Raises:
+            RuntimeError: If the bucket is already locked.
+        """
+        if self._lock.locked():
+            raise RuntimeError("Attempted to lock a bucket that is already locked.")
+
+        async def _release() -> None:
+            await asyncio.sleep(duration)
+            self._lock.release()
+
+        if block:
+            await self._lock.acquire()
+            await _release()
+        else:
+            await self._lock.acquire()
+            _ = asyncio.create_task(_release())
+
+    async def __aenter__(self) -> None:
+        await self.acquire()
+
+    async def __aexit__(self, *args) -> None:
+        self.release()
+
+
+class HTTPClient(
+    BotRequests,
+    ChannelRequests,
+    EmojiRequests,
+    GuildRequests,
+    InteractionRequests,
+    MemberRequests,
+    MessageRequests,
+    ReactionRequests,
+    StickerRequests,
+    ThreadRequests,
+    UserRequests,
+    WebhookRequests,
+    ScheduledEventsRequests,
+):
+    """A http client for sending requests to the Discord API."""
+
+    def __init__(
+        self,
+        connector: BaseConnector | None = None,
+        logger: Logger = MISSING,
+        show_ratelimit_tracebacks: bool = False,
+        proxy: tuple[str, BasicAuth] | None = None,
+    ) -> None:
+        self.connector: BaseConnector | None = connector
+        self.__session: ClientSession | None = None
+        self.token: str | None = None
+        self.global_lock: GlobalLock = GlobalLock()
+        self._max_attempts: int = 3
+
+        self.ratelimit_locks: WeakValueDictionary[str, BucketLock] = WeakValueDictionary()
+        self.show_ratelimit_traceback: bool = show_ratelimit_tracebacks
+        self._endpoints = {}
+
+        self.user_agent: str = (
+            f"DiscordBot ({__repo_url__} {__version__} Python/{__py_version__}) aiohttp/{aiohttp.__version__}"
+        )
+        self.proxy: tuple[str, BasicAuth] | None = proxy
+        self.__proxy_validated: bool = False
+
+        if logger is MISSING:
+            logger = constants.get_logger()
+        self.logger = logger
+
+    def get_ratelimit(self, route: Route) -> BucketLock:
+        """
+        Get a route's rate limit bucket.
+
+        Args:
+            route: The route to fetch the ratelimit bucket for
+
+        Returns:
+            The BucketLock object for this route
+        """
+        if bucket_hash := self._endpoints.get(route.rl_bucket):
+            if lock := self.ratelimit_locks.get(bucket_hash):
+                # if we have an active lock on this route, it'll still be in the cache
+                # return that lock
+                return lock
+        # if no cached lock exists, return a new lock
+        return BucketLock()
+
+    def ingest_ratelimit(self, route: Route, header: CIMultiDictProxy, bucket_lock: BucketLock) -> None:
+        """
+        Ingests a ratelimit header from discord to determine ratelimit.
+
+        Args:
+            route: The route we're ingesting ratelimit for
+            header: The rate limit header in question
+            bucket_lock: The rate limit bucket for this route
+        """
+        bucket_lock.ingest_ratelimit_header(header)
+
+        if bucket_lock.bucket_hash:
+            # We only ever try and cache the bucket if the bucket hash has been set (ignores unlimited endpoints)
+            self.logger.debug(f"Caching ingested rate limit data for: {bucket_lock.bucket_hash}")
+            self._endpoints[route.rl_bucket] = bucket_lock.bucket_hash
+            self.ratelimit_locks[bucket_lock.bucket_hash] = bucket_lock
+
+    @staticmethod
+    def _process_payload(
+        payload: dict | list[dict] | None, files: UPLOADABLE_TYPE | list[UPLOADABLE_TYPE] | None
+    ) -> dict | list[dict] | FormData | None:
+        """
+        Processes a payload into a format safe for discord. Converts the payload into FormData where required
+
+        Args:
+            payload: The payload of the request
+            files: A list of any files to send
+
+        Returns:
+            Either a dictionary or multipart data form
+        """
+        if isinstance(payload, FormData):
+            return payload
+        if payload is None:
+            return None
+
+        if isinstance(payload, dict):
+            payload = dict_filter(payload)
+
+            for k, v in payload.items():
+                if isinstance(v, DictSerializationMixin):
+                    payload[k] = v.to_dict()
+                if isinstance(v, (list, tuple, set)):
+                    payload[k] = [i.to_dict() if isinstance(i, DictSerializationMixin) else i for i in v]
+
+        else:
+            payload = [dict_filter(x) if isinstance(x, dict) else x for x in payload]
+
+        if not files:
+            return payload
+
+        if not isinstance(files, list):
+            files = (files,)
+
+        attachments = []
+
+        form_data = FormData(quote_fields=False)
+
+        for index, file in enumerate(files):
+            file_data = models.open_file(file).read()
+
+            if isinstance(file, models.File):
+                form_data.add_field(
+                    f"files[{index}]",
+                    file_data,
+                    filename=file.file_name,
+                    content_type=file.content_type or get_file_mimetype(file_data),
+                )
+                attachments.append({"id": index, "description": file.description, "filename": file.file_name})
+            else:
+                form_data.add_field(
+                    f"files[{index}]",
+                    file_data,
+                    filename=file.split(os.sep)[-1],
+                    content_type=get_file_mimetype(file_data),
+                )
+        if attachments:
+            payload["attachments"] = attachments
+
+        form_data.add_field("payload_json", FastJson.dumps(payload))
+        return form_data
+
+    async def request(  # noqa: C901
+        self,
+        route: Route,
+        payload: list | dict | None = None,
+        files: list[UPLOADABLE_TYPE] | None = None,
+        reason: str | None = None,
+        params: dict | None = None,
+        **kwargs: dict,
+    ) -> str | dict[str, Any] | None:
+        """
+        Make a request to discord.
+
+        Args:
+            route: The route to take
+            payload: The payload for this request
+            files: The files to send with this request
+            reason: Attach a reason to this request, used for audit logs
+            params: Query string parameters
+
+        """
+        # Assemble headers
+        kwargs["headers"] = {"User-Agent": self.user_agent}
+        if self.token:
+            kwargs["headers"]["Authorization"] = f"Bot {self.token}"
+        if reason:
+            kwargs["headers"]["X-Audit-Log-Reason"] = _uriquote(reason, safe="/ ")
+
+        if isinstance(payload, (list, dict)) and not files:
+            kwargs["headers"]["Content-Type"] = "application/json"
+        if isinstance(params, dict):
+            kwargs["params"] = dict_filter(params)
+
+        lock = self.get_ratelimit(route)
+        # this gets a BucketLock for this route.
+        # If this endpoint has been used before, it will get an existing ratelimit for the respective buckethash
+        # otherwise a brand-new bucket lock will be returned
+
+        for attempt in range(self._max_attempts):
+            async with lock:
+                try:
+                    if self.__session.closed:
+                        await self.login(cast(str, self.token))
+
+                    processed_data = self._process_payload(payload, files)
+                    if isinstance(processed_data, FormData):
+                        kwargs["data"] = processed_data  # pyright: ignore
+                    else:
+                        kwargs["json"] = processed_data  # pyright: ignore
+                    await self.global_lock.wait()
+
+                    if self.proxy:
+                        kwargs["proxy"] = self.proxy[0]
+                        kwargs["proxy_auth"] = self.proxy[1]
+
+                    async with self.__session.request(route.method, route.url, **kwargs) as response:
+                        result = await response_decode(response)
+                        self.ingest_ratelimit(route, response.headers, lock)
+
+                        if response.status == 429:
+                            # ratelimit exceeded
+                            result = cast(dict[str, str], result)
+                            if result.get("global", False):
+                                # global ratelimit is reached
+                                # if we get a global, that's pretty bad, this would usually happen if the user is hitting the api from 2 clients sharing a token
+                                self.log_ratelimit(
+                                    self.logger.warning,
+                                    f"Bot has exceeded global ratelimit, locking REST API for {result['retry_after']} seconds",
+                                )
+                                self.global_lock.set_reset_time(float(result["retry_after"]))
+                            elif result.get("message") == "The resource is being rate limited.":
+                                # resource ratelimit is reached
+                                self.log_ratelimit(
+                                    self.logger.warning,
+                                    f"{route.resolved_endpoint} The resource is being rate limited! "
+                                    f"Reset in {result.get('retry_after')} seconds",
+                                )
+                                # lock this resource and wait for unlock
+                                await lock.lock_for_duration(float(result["retry_after"]), block=True)
+                            else:
+                                # endpoint ratelimit is reached
+                                # 429's are unfortunately unavoidable, but we can attempt to avoid them
+                                # so long as these are infrequent we're doing well
+                                self.log_ratelimit(
+                                    self.logger.warning,
+                                    f"{route.resolved_endpoint} Has exceeded its ratelimit ({lock.limit})! Reset in {lock.delta} seconds",
+                                )
+                                await lock.lock_for_duration(lock.delta, block=True)
+                            continue
+                        if lock.remaining == 0:
+                            # Last call available in the bucket, lock until reset
+                            self.log_ratelimit(
+                                self.logger.debug,
+                                f"{route.resolved_endpoint} Has exhausted its ratelimit ({lock.limit})! Locking route for {lock.delta} seconds",
+                            )
+                            await lock.lock_for_duration(
+                                lock.delta
+                            )  # lock this route, but continue processing the current response
+
+                        elif response.status in {500, 502, 504}:
+                            # Server issues, retry
+                            self.logger.warning(
+                                f"{route.resolved_endpoint} Received {response.status}... retrying in {1 + attempt * 2} seconds"
+                            )
+                            await asyncio.sleep(1 + attempt * 2)
+                            continue
+
+                        if not 300 > response.status >= 200:
+                            await self._raise_exception(response, route, result)
+
+                        self.logger.debug(
+                            f"{route.resolved_endpoint} Received {response.status} :: [{lock.remaining}/{lock.limit} calls remaining]"
+                        )
+                        return result
+                except OSError as e:
+                    if attempt < self._max_attempts - 1 and e.errno in (54, 10054):
+                        await asyncio.sleep(1 + attempt * 2)
+                        continue
+                    raise
+
+    async def _raise_exception(self, response, route, result) -> None:
+        self.logger.error(f"{route.method}::{route.url}: {response.status}")
+
+        if response.status == 403:
+            raise Forbidden(response, response_data=result, route=route)
+        if response.status == 404:
+            raise NotFound(response, response_data=result, route=route)
+        if response.status >= 500:
+            raise DiscordError(response, response_data=result, route=route)
+        raise HTTPException(response, response_data=result, route=route)
+
+    def log_ratelimit(self, log_func: Callable, message: str) -> None:
+        """
+        Logs a ratelimit message, optionally with a traceback if show_ratelimit_traceback is True
+
+        Args:
+            log_func: The logging function to use
+            message: The message to log
+        """
+        if self.show_ratelimit_traceback:
+            if frame := next(
+                (frame for frame in inspect.stack() if constants.LIB_PATH not in frame.filename),
+                None,
+            ):
+                frame_info = inspect.getframeinfo(frame[0])
+                filename = os.path.relpath(frame_info.filename, os.getcwd())
+
+                traceback = (
+                    f"{filename}:{frame_info.lineno} in {frame_info.function}:: {frame_info.code_context[0].strip()}"
+                )
+                message = f"{message} | Caused By: {traceback}"
+
+        log_func(message)
+
+    async def request_cdn(self, url, asset) -> bytes:  # pyright: ignore [reportGeneralTypeIssues]
+        self.logger.debug(f"{asset} requests {url} from CDN")
+        async with self.__session.get(url) as response:
+            if response.status == 200:
+                return await response.read()
+            await self._raise_exception(response, asset, await response_decode(response))
+
+    async def login(self, token: str) -> dict[str, Any]:
+        """
+        "Login" to the gateway, basically validates the token and grabs user data.
+
+        Args:
+            token: the token to use
+
+        Returns:
+            The currently logged in bot's data
+
+        """
+        self.__session = ClientSession(
+            connector=self.connector or aiohttp.TCPConnector(limit=self.global_lock.max_requests),
+            json_serialize=FastJson.dumps,
+        )
+        if not self.__proxy_validated and self.proxy:
+            try:
+                self.logger.info(f"Validating Proxy @ {self.proxy[0]}")
+                async with self.__session.get(
+                    "http://icanhazip.com/", proxy=self.proxy[0], proxy_auth=self.proxy[1]
+                ) as response:
+                    if response.status != 200:
+                        raise RuntimeError("Proxy configuration is invalid")
+                    self.logger.info(f"Proxy Connected @ {(await response.text()).strip()}")
+                    self.__proxy_validated = True
+            except Exception as e:
+                raise RuntimeError("Proxy configuration is invalid") from e
+
+        self.token = token
+        try:
+            result = await self.request(Route("GET", "/users/@me"))
+            return cast(dict[str, Any], result)
+        except HTTPException as e:
+            if e.status == 401:
+                raise LoginError("An improper token was passed") from e
+            raise
+
+    async def close(self) -> None:
+        """Close the session."""
+        if self.__session and not self.__session.closed:
+            await self.__session.close()
+
+    async def get_gateway(self) -> str:
+        """
+        Gets the gateway url.
+
+        Returns:
+            The gateway url
+
+        """
+        try:
+            result = await self.request(Route("GET", "/gateway"))
+            result = cast(dict[str, Any], result)
+        except HTTPException as exc:
+            raise GatewayNotFound from exc
+        return "{0}?encoding={1}&v={2}&compress=zlib-stream".format(result["url"], "json", __api_version__)
+
+    async def get_gateway_bot(self) -> discord_typings.GetGatewayBotData:
+        try:
+            result = await self.request(Route("GET", "/gateway/bot"))
+        except HTTPException as exc:
+            raise GatewayNotFound from exc
+        return cast(discord_typings.GetGatewayBotData, result)
+
+    async def websocket_connect(self, url: str) -> ClientWebSocketResponse:
+        """
+        Connect to the websocket.
+
+        Args:
+            url: the url to connect to
+
+        """
+        return await self.__session.ws_connect(
+            url,
+            timeout=30,
+            max_msg_size=0,
+            autoclose=False,
+            headers={"User-Agent": self.user_agent},
+            compress=0,
+            proxy=self.proxy[0] if self.proxy else None,
+            proxy_auth=self.proxy[1] if self.proxy else None,
+        )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/__init__.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/__init__.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-from .bot import BotRequests
-from .channels import ChannelRequests
-from .emojis import EmojiRequests
-from .guild import GuildRequests
-from .interactions import InteractionRequests
-from .members import MemberRequests
-from .messages import MessageRequests
-from .reactions import ReactionRequests
-from .scheduled_events import ScheduledEventsRequests
-from .stickers import StickerRequests
-from .threads import ThreadRequests
-from .users import UserRequests
-from .webhooks import WebhookRequests
-
-__all__ = (
-    "BotRequests",
-    "ChannelRequests",
-    "EmojiRequests",
-    "GuildRequests",
-    "InteractionRequests",
-    "MemberRequests",
-    "MessageRequests",
-    "ReactionRequests",
-    "ScheduledEventsRequests",
-    "StickerRequests",
-    "ThreadRequests",
-    "UserRequests",
-    "WebhookRequests",
-)
+from .bot import BotRequests
+from .channels import ChannelRequests
+from .emojis import EmojiRequests
+from .guild import GuildRequests
+from .interactions import InteractionRequests
+from .members import MemberRequests
+from .messages import MessageRequests
+from .reactions import ReactionRequests
+from .scheduled_events import ScheduledEventsRequests
+from .stickers import StickerRequests
+from .threads import ThreadRequests
+from .users import UserRequests
+from .webhooks import WebhookRequests
+
+__all__ = (
+    "BotRequests",
+    "ChannelRequests",
+    "EmojiRequests",
+    "GuildRequests",
+    "InteractionRequests",
+    "MemberRequests",
+    "MessageRequests",
+    "ReactionRequests",
+    "ScheduledEventsRequests",
+    "StickerRequests",
+    "ThreadRequests",
+    "UserRequests",
+    "WebhookRequests",
+)
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/bot.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/bot.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from typing import cast
-
-import discord_typings
-
-from interactions.models.internal.protocols import CanRequest
-from ..route import Route
-
-__all__ = ("BotRequests",)
-
-
-class BotRequests(CanRequest):
-    async def get_current_bot_information(self) -> discord_typings.ApplicationData:
-        """
-        Gets the bot's application object without flags.
-
-        Returns:
-            application object
-
-        """
-        result = await self.request(Route("GET", "/oauth2/applications/@me"))
-        return cast(discord_typings.ApplicationData, result)
-
-    async def get_current_authorisation_information(self) -> dict:  # todo typing?
-        """
-        Gets info about the current authorization.
-
-        Returns:
-            Authorisation information
-
-        """
-        result = await self.request(Route("GET", "/oauth2/@me"))
-        return cast(dict, result)
-
-    async def list_voice_regions(self) -> list[discord_typings.VoiceRegionData]:
-        """
-        Gets an array of voice region objects that can be used when setting a voice or stage channel's `rtc_region`.
-
-        Returns:
-            an array of voice region objects
-
-        """
-        result = await self.request(Route("GET", "/voice/regions"))
-        return cast(list[discord_typings.VoiceRegionData], result)
+from typing import cast
+
+import discord_typings
+
+from interactions.models.internal.protocols import CanRequest
+from ..route import Route
+
+__all__ = ("BotRequests",)
+
+
+class BotRequests(CanRequest):
+    async def get_current_bot_information(self) -> discord_typings.ApplicationData:
+        """
+        Gets the bot's application object without flags.
+
+        Returns:
+            application object
+
+        """
+        result = await self.request(Route("GET", "/oauth2/applications/@me"))
+        return cast(discord_typings.ApplicationData, result)
+
+    async def get_current_authorisation_information(self) -> dict:  # todo typing?
+        """
+        Gets info about the current authorization.
+
+        Returns:
+            Authorisation information
+
+        """
+        result = await self.request(Route("GET", "/oauth2/@me"))
+        return cast(dict, result)
+
+    async def list_voice_regions(self) -> list[discord_typings.VoiceRegionData]:
+        """
+        Gets an array of voice region objects that can be used when setting a voice or stage channel's `rtc_region`.
+
+        Returns:
+            an array of voice region objects
+
+        """
+        result = await self.request(Route("GET", "/voice/regions"))
+        return cast(list[discord_typings.VoiceRegionData], result)
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/channels.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/channels.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,654 +1,654 @@
-from typing import TYPE_CHECKING, Optional, Sequence, cast, overload
-
-import discord_typings
-
-from interactions.models.internal.protocols import CanRequest
-from interactions.models.discord.enums import (
-    ChannelType,
-    StagePrivacyLevel,
-    Permissions,
-    OverwriteType,
-)
-from interactions.client.utils.serializer import dict_filter_none
-
-from ..route import Route, PAYLOAD_TYPE
-
-__all__ = ("ChannelRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.channel import PermissionOverwrite
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-
-class ChannelRequests(CanRequest):
-    async def get_channel(self, channel_id: "Snowflake_Type") -> discord_typings.ChannelData:
-        """
-        Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included.
-
-        Args:
-            channel_id: The id of the channel
-
-        Returns:
-            channel
-
-        """
-        result = await self.request(Route("GET", "/channels/{channel_id}", channel_id=channel_id))
-        return cast(discord_typings.ChannelData, result)
-
-    @overload
-    async def get_channel_messages(
-        self,
-        channel_id: "Snowflake_Type",
-        limit: int = 50,
-    ) -> list[discord_typings.MessageData]:
-        ...
-
-    @overload
-    async def get_channel_messages(
-        self,
-        channel_id: "Snowflake_Type",
-        limit: int = 50,
-        *,
-        around: "Snowflake_Type | None" = None,
-    ) -> list[discord_typings.MessageData]:
-        ...
-
-    @overload
-    async def get_channel_messages(
-        self,
-        channel_id: "Snowflake_Type",
-        limit: int = 50,
-        *,
-        before: "Snowflake_Type | None" = None,
-    ) -> list[discord_typings.MessageData]:
-        ...
-
-    @overload
-    async def get_channel_messages(
-        self,
-        channel_id: "Snowflake_Type",
-        limit: int = 50,
-        *,
-        after: "Snowflake_Type | None" = None,
-    ) -> list[discord_typings.MessageData]:
-        ...
-
-    async def get_channel_messages(
-        self,
-        channel_id: "Snowflake_Type",
-        limit: int = 50,
-        *,
-        around: "Snowflake_Type | None" = None,
-        before: "Snowflake_Type | None" = None,
-        after: "Snowflake_Type | None" = None,
-    ) -> list[discord_typings.MessageData]:
-        """
-        Get the messages for a channel.
-
-        Args:
-            channel_id: The channel to get messages from
-            limit: How many messages to get (default 50, max 100)
-            around: Get messages around this snowflake
-            before: Get messages before this snowflake
-            after: Get messages after this snowflake
-
-        Returns:
-            List of message dicts
-
-        """
-        params_count = sum(bool(param) for param in (before, after, around))
-        if params_count > 1:
-            raise ValueError("`before` `after` and `around` are mutually exclusive, only one may be passed at a time.")
-
-        params: PAYLOAD_TYPE = {
-            "limit": limit,
-            "before": int(before) if before else None,
-            "after": int(after) if after else None,
-            "around": int(around) if around else None,
-        }
-        params = dict_filter_none(params)
-
-        result = await self.request(
-            Route("GET", "/channels/{channel_id}/messages", channel_id=channel_id), params=params
-        )
-        return cast(list[discord_typings.MessageData], result)
-
-    async def create_guild_channel(
-        self,
-        guild_id: "Snowflake_Type",
-        name: str,
-        channel_type: "ChannelType | int",
-        topic: str | None = None,
-        position: int | None = None,
-        permission_overwrites: Sequence["PermissionOverwrite | dict"] | None = None,
-        parent_id: "Snowflake_Type | None" = None,
-        nsfw: bool = False,
-        bitrate: int = 64000,
-        user_limit: int = 0,
-        rate_limit_per_user: int = 0,
-        reason: str | None = None,
-        **kwargs: dict,
-    ) -> discord_typings.ChannelData:
-        """
-        Create a channel in a guild.
-
-        Args:
-            guild_id: The ID of the guild to create the channel in
-            name: The name of the channel
-            channel_type: The type of channel to create
-            topic: The topic of the channel
-            position: The position of the channel in the channel list
-            permission_overwrites: Permission overwrites to apply to the channel
-            parent_id: The category this channel should be within
-            nsfw: Should this channel be marked nsfw
-            bitrate: The bitrate of this channel, only for voice
-            user_limit: The max users that can be in this channel, only for voice
-            rate_limit_per_user: The time users must wait between sending messages
-            reason: The reason for creating this channel
-            kwargs: Additional keyword arguments to pass to the request
-
-        Returns:
-            The created channel object
-
-        """
-        payload: PAYLOAD_TYPE = {
-            "name": name,
-            "type": channel_type,
-            "topic": topic,
-            "position": position,
-            "rate_limit_per_user": rate_limit_per_user,
-            "nsfw": nsfw,
-            "parent_id": int(parent_id) if parent_id else None,
-            "permission_overwrites": list(permission_overwrites) if permission_overwrites else None,
-            **kwargs,
-        }
-        if channel_type in (ChannelType.GUILD_VOICE, ChannelType.GUILD_STAGE_VOICE):
-            payload.update(
-                bitrate=bitrate,
-                user_limit=user_limit,
-            )
-        payload = dict_filter_none(payload)
-
-        result = await self.request(
-            Route("POST", "/guilds/{guild_id}/channels", guild_id=guild_id), payload=payload, reason=reason
-        )
-        return cast(discord_typings.ChannelData, result)
-
-    async def move_channel(
-        self,
-        guild_id: "Snowflake_Type",
-        channel_id: "Snowflake_Type",
-        new_pos: int,
-        parent_id: "Snowflake_Type | None" = None,
-        lock_perms: bool = False,
-        reason: str | None = None,
-    ) -> None:
-        """
-        Move a channel.
-
-        Args:
-            guild_id: The ID of the guild this affects
-            channel_id: The ID of the channel to move
-            new_pos: The new position of this channel
-            parent_id: The parent ID if needed
-            lock_perms: Sync permissions with the new parent
-            reason: An optional reason for the audit log
-
-        """
-        payload: PAYLOAD_TYPE = {
-            "id": int(channel_id),
-            "position": new_pos,
-            "parent_id": int(parent_id) if parent_id else None,
-            "lock_permissions": lock_perms,
-        }
-        payload = dict_filter_none(payload)
-
-        await self.request(
-            Route("PATCH", "/guilds/{guild_id}/channels", guild_id=guild_id), payload=payload, reason=reason
-        )
-
-    async def modify_channel(
-        self, channel_id: "Snowflake_Type", data: dict, reason: str | None = None
-    ) -> discord_typings.ChannelData:
-        """
-        Update a channel's settings, returns the updated channel object on success.
-
-        Args:
-            channel_id: The ID of the channel to update
-            data: The data to update with
-            reason: An optional reason for the audit log
-
-        Returns:
-            Channel object on success
-
-        """
-        result = await self.request(
-            Route("PATCH", "/channels/{channel_id}", channel_id=channel_id), payload=data, reason=reason
-        )
-        return cast(discord_typings.ChannelData, result)
-
-    async def delete_channel(self, channel_id: "Snowflake_Type", reason: str | None = None) -> None:
-        """
-        Delete the channel.
-
-        Args:
-            channel_id: The ID of the channel to delete
-            reason: An optional reason for the audit log
-
-        """
-        await self.request(Route("DELETE", "/channels/{channel_id}", channel_id=channel_id), reason=reason)
-
-    async def get_channel_invites(self, channel_id: "Snowflake_Type") -> list[discord_typings.InviteData]:
-        """
-        Get the invites for the channel.
-
-        Args:
-            channel_id: The ID of the channel to retrieve from
-
-        Returns:
-            List of invite objects
-
-        """
-        result = await self.request(Route("GET", "/channels/{channel_id}/invites", channel_id=channel_id))
-        return cast(list[discord_typings.InviteData], result)
-
-    @overload
-    async def create_channel_invite(
-        self,
-        channel_id: "Snowflake_Type",
-        max_age: int = 86400,
-        max_uses: int = 0,
-        temporary: bool = False,
-        unique: bool = False,
-        *,
-        reason: str | None = None,
-    ) -> discord_typings.InviteData:
-        ...
-
-    @overload
-    async def create_channel_invite(
-        self,
-        channel_id: "Snowflake_Type",
-        max_age: int = 86400,
-        max_uses: int = 0,
-        temporary: bool = False,
-        unique: bool = False,
-        *,
-        target_user_id: "Snowflake_Type | None" = None,
-        reason: str | None = None,
-    ) -> discord_typings.InviteData:
-        ...
-
-    @overload
-    async def create_channel_invite(
-        self,
-        channel_id: "Snowflake_Type",
-        max_age: int = 86400,
-        max_uses: int = 0,
-        temporary: bool = False,
-        unique: bool = False,
-        *,
-        target_application_id: "Snowflake_Type | None" = None,
-        reason: str | None = None,
-    ) -> discord_typings.InviteData:
-        ...
-
-    async def create_channel_invite(
-        self,
-        channel_id: "Snowflake_Type",
-        max_age: int = 86400,
-        max_uses: int = 0,
-        temporary: bool = False,
-        unique: bool = False,
-        *,
-        target_user_id: "Snowflake_Type | None" = None,
-        target_application_id: "Snowflake_Type | None" = None,
-        reason: str | None = None,
-    ) -> discord_typings.InviteData:
-        """
-        Create an invite for the given channel.
-
-        Args:
-            channel_id: The ID of the channel to create an invite for
-            max_age: duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours)
-            max_uses: max number of uses or 0 for unlimited. between 0 and 100
-            temporary: whether this invite only grants temporary membership
-            unique: if true, don't try to reuse a similar invite (useful for creating many unique one time use invites)
-            target_user_id: the id of the user whose stream to display for this invite, the user must be streaming in the channel
-            target_application_id: the id of the embedded application to open for this invite, the application must have the EMBEDDED flag
-            reason: An optional reason for the audit log
-
-        Returns:
-            an invite object
-
-        """
-        params_count = sum(bool(param) for param in (target_user_id, target_application_id))
-        if params_count > 1:
-            raise ValueError(
-                "`target_type` and `target_user_id` are mutually exclusive, only one may be passed at a time."
-            )
-
-        payload: PAYLOAD_TYPE = {
-            "max_age": max_age,
-            "max_uses": max_uses,
-            "temporary": temporary,
-            "unique": unique,
-        }
-        if target_user_id:
-            payload["target_type"] = 1
-            payload["target_user_id"] = int(target_user_id)
-        if target_application_id:
-            payload["target_type"] = 2
-            payload["target_application_id"] = int(target_application_id)
-        payload = dict_filter_none(payload)
-
-        result = await self.request(
-            Route("POST", "/channels/{channel_id}/invites", channel_id=channel_id), payload=payload, reason=reason
-        )
-        return cast(discord_typings.InviteData, result)
-
-    async def get_invite(
-        self,
-        invite_code: str,
-        with_counts: bool = False,
-        with_expiration: bool = True,
-        scheduled_event_id: "Snowflake_Type | None" = None,
-    ) -> discord_typings.InviteData:
-        """
-        Get an invite object for a given code.
-
-        Args:
-            invite_code: The code of the invite
-            with_counts: whether the invite should contain approximate member counts
-            with_expiration: whether the invite should contain the expiration date
-            scheduled_event_id: the guild scheduled event to include with the invite
-
-        Returns:
-            an invite object
-
-        """
-        params: PAYLOAD_TYPE = {
-            "invite_code": invite_code,
-            "with_counts": with_counts,
-            "with_expiration": with_expiration,
-            "guild_scheduled_event_id": int(scheduled_event_id) if scheduled_event_id else None,
-        }
-        params = dict_filter_none(params)
-
-        result = await self.request(Route("GET", "/invites/{invite_code}", invite_code=invite_code, params=params))
-        return cast(discord_typings.InviteData, result)
-
-    async def delete_invite(self, invite_code: str, reason: str | None = None) -> discord_typings.InviteData:
-        """
-        Delete an invite.
-
-        Args:
-            invite_code: The code of the invite to delete
-            reason: The reason to delete the invite
-
-        Returns:
-            The deleted invite object
-
-        """
-        result = await self.request(Route("DELETE", "/invites/{invite_code}", invite_code=invite_code), reason=reason)
-        return cast(discord_typings.InviteData, result)
-
-    async def edit_channel_permission(
-        self,
-        channel_id: "Snowflake_Type",
-        overwrite_id: "Snowflake_Type",
-        perm_type: "OverwriteType | int",
-        allow: "Permissions | int" = 0,
-        deny: "Permissions | int" = 0,
-        reason: str | None = None,
-    ) -> None:
-        """
-        Edit the channel permission overwrites for a user or role in a channel.
-
-        Args:
-            channel_id: The id of the channel
-            overwrite_id: The id of the object to override
-            allow: the bitwise value of all allowed permissions
-            deny: the bitwise value of all disallowed permissions
-            perm_type: 0 for a role or 1 for a member
-            reason: The reason for this action
-
-        """
-        payload: PAYLOAD_TYPE = {"allow": allow, "deny": deny, "type": perm_type}
-
-        await self.request(
-            Route(
-                "PUT",
-                "/channels/{channel_id}/permissions/{overwrite_id}",
-                channel_id=channel_id,
-                overwrite_id=overwrite_id,
-            ),
-            payload=payload,
-            reason=reason,
-        )
-
-    async def delete_channel_permission(
-        self,
-        channel_id: "Snowflake_Type",
-        overwrite_id: "Snowflake_Type",
-        reason: str | None = None,
-    ) -> None:
-        """
-        Delete a channel permission overwrite for a user or role in a channel.
-
-        Args:
-            channel_id: The ID of the channel.
-            overwrite_id: The ID of the overwrite
-            reason: An optional reason for the audit log
-
-        """
-        await self.request(
-            Route("DELETE", "/channels/{channel_id}/{overwrite_id}", channel_id=channel_id, overwrite_id=overwrite_id),
-            reason=reason,
-        )
-
-    async def follow_news_channel(
-        self, channel_id: "Snowflake_Type", webhook_channel_id: "Snowflake_Type"
-    ) -> discord_typings.FollowedChannelData:
-        """
-        Follow a news channel to send messages to the target channel.
-
-        Args:
-            channel_id: The channel to follow
-            webhook_channel_id: ID of the target channel
-
-        Returns:
-            Followed channel object
-
-        """
-        payload = {"webhook_channel_id": int(webhook_channel_id)}
-
-        result = await self.request(
-            Route("POST", "/channels/{channel_id}/followers", channel_id=channel_id), payload=payload
-        )
-        return cast(discord_typings.FollowedChannelData, result)
-
-    async def trigger_typing_indicator(self, channel_id: "Snowflake_Type") -> None:
-        """
-        Post a typing indicator for the specified channel. Generally bots should not implement this route.
-
-        Args:
-            channel_id: The id of the channel to "type" in
-
-        """
-        await self.request(Route("POST", "/channels/{channel_id}/typing", channel_id=channel_id))
-
-    async def get_pinned_messages(self, channel_id: "Snowflake_Type") -> list[discord_typings.MessageData]:
-        """
-        Get all pinned messages from a channel.
-
-        Args:
-            channel_id: The ID of the channel to get pins from
-
-        Returns:
-            A list of pinned message objects
-
-        """
-        result = await self.request(Route("GET", "/channels/{channel_id}/pins", channel_id=channel_id))
-        return cast(list[discord_typings.MessageData], result)
-
-    async def create_stage_instance(
-        self,
-        channel_id: "Snowflake_Type",
-        topic: str,
-        privacy_level: StagePrivacyLevel | int = StagePrivacyLevel.PUBLIC,
-        reason: str | None = None,
-    ) -> discord_typings.StageInstanceData:
-        """
-        Create a new stage instance.
-
-        Args:
-            channel_id: The ID of the stage channel
-            topic: The topic of the stage instance (1-120 characters)
-            privacy_level: Them privacy_level of the stage instance (default guild only)
-            reason: The reason for the creating the stage instance
-
-        Returns:
-            The stage instance
-
-        """
-        payload: PAYLOAD_TYPE = {
-            "channel_id": int(channel_id),
-            "topic": topic,
-            "privacy_level": StagePrivacyLevel(privacy_level),
-        }
-
-        result = await self.request(Route("POST", "/stage-instances"), payload=payload, reason=reason)
-        return cast(discord_typings.StageInstanceData, result)
-
-    async def get_stage_instance(self, channel_id: "Snowflake_Type") -> discord_typings.StageInstanceData:
-        """
-        Get the stage instance associated with a given channel, if it exists.
-
-        Args:
-            channel_id: The ID of the channel to retrieve the instance for.
-
-        Returns:
-            A stage instance.
-
-        """
-        result = await self.request(Route("GET", "/stage-instances/{channel_id}", channel_id=channel_id))
-        return cast(discord_typings.StageInstanceData, result)
-
-    async def modify_stage_instance(
-        self,
-        channel_id: "Snowflake_Type",
-        topic: str | None = None,
-        privacy_level: int | None = None,
-        reason: str | None = None,
-    ) -> discord_typings.StageInstanceData:
-        """
-        Update the fields of a given stage instance.
-
-        Args:
-            channel_id: The id of the stage channel.
-            topic: The new topic for the stage instance
-            privacy_level: The privacy level for the stage instance
-            reason: The reason for the change
-
-        Returns:
-            The updated stage instance.
-
-        """
-        payload: PAYLOAD_TYPE = {"topic": topic, "privacy_level": privacy_level}
-        payload = dict_filter_none(payload)
-        result = await self.request(
-            Route("PATCH", "/stage-instances/{channel_id}", channel_id=channel_id), payload=payload, reason=reason
-        )
-        return cast(discord_typings.StageInstanceData, result)
-
-    async def delete_stage_instance(self, channel_id: "Snowflake_Type", reason: str | None = None) -> None:
-        """
-        Delete a stage instance.
-
-        Args:
-            channel_id: The ID of the channel to delete the stage instance for.
-            reason: The reason for the deletion
-
-        """
-        await self.request(Route("DELETE", "/stage-instances/{channel_id}", channel_id=channel_id), reason=reason)
-
-    async def create_tag(
-        self,
-        channel_id: "Snowflake_Type",
-        name: str,
-        emoji_id: Optional["Snowflake_Type"] = None,
-        emoji_name: Optional[str] = None,
-    ) -> discord_typings.ChannelData:
-        """
-        Create a new tag.
-
-        Args:
-            channel_id: The ID of the forum channel to create tag for.
-            name: The name of the tag
-            emoji_id: The ID of the emoji to use for the tag
-            emoji_name: The name of the emoji to use for the tag
-
-        !!! note
-            Can either have an `emoji_id` or an `emoji_name`, but not both.
-            `emoji_id` is meant for custom emojis, `emoji_name` is meant for unicode emojis.
-        """
-        payload: PAYLOAD_TYPE = {
-            "name": name,
-            "emoji_id": int(emoji_id) if emoji_id else None,
-            "emoji_name": emoji_name or None,
-        }
-        payload = dict_filter_none(payload)
-
-        result = await self.request(
-            Route("POST", "/channels/{channel_id}/tags", channel_id=channel_id), payload=payload
-        )
-        return cast(discord_typings.ChannelData, result)
-
-    async def edit_tag(
-        self,
-        channel_id: "Snowflake_Type",
-        tag_id: "Snowflake_Type",
-        name: str,
-        emoji_id: "Snowflake_Type | None" = None,
-        emoji_name: str | None = None,
-    ) -> discord_typings.ChannelData:
-        """
-        Update a tag.
-
-        Args:
-            channel_id: The ID of the forum channel to edit tag it.
-            tag_id: The ID of the tag to update
-            name: The new name of the tag
-            emoji_id: The ID of the emoji to use for the tag
-            emoji_name: The name of the emoji to use for the tag
-
-        !!! note
-            Can either have an `emoji_id` or an `emoji_name`, but not both.
-            emoji`_id is meant for custom emojis, `emoji_name` is meant for unicode emojis.
-        """
-        payload: PAYLOAD_TYPE = {
-            "name": name,
-            "emoji_id": int(emoji_id) if emoji_id else None,
-            "emoji_name": emoji_name,
-        }
-        payload = dict_filter_none(payload)
-
-        result = await self.request(
-            Route("PUT", "/channels/{channel_id}/tags/{tag_id}", channel_id=channel_id, tag_id=tag_id), payload=payload
-        )
-        return cast(discord_typings.ChannelData, result)
-
-    async def delete_tag(self, channel_id: "Snowflake_Type", tag_id: "Snowflake_Type") -> discord_typings.ChannelData:
-        """
-        Delete a forum tag.
-
-        Args:
-            channel_id: The ID of the forum channel to delete tag it.
-            tag_id: The ID of the tag to delete
-        """
-        result = await self.request(
-            Route("DELETE", "/channels/{channel_id}/tags/{tag_id}", channel_id=channel_id, tag_id=tag_id)
-        )
-        return cast(discord_typings.ChannelData, result)
+from typing import TYPE_CHECKING, Optional, Sequence, cast, overload
+
+import discord_typings
+
+from interactions.models.internal.protocols import CanRequest
+from interactions.models.discord.enums import (
+    ChannelType,
+    StagePrivacyLevel,
+    Permissions,
+    OverwriteType,
+)
+from interactions.client.utils.serializer import dict_filter_none
+
+from ..route import Route, PAYLOAD_TYPE
+
+__all__ = ("ChannelRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.channel import PermissionOverwrite
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+
+class ChannelRequests(CanRequest):
+    async def get_channel(self, channel_id: "Snowflake_Type") -> discord_typings.ChannelData:
+        """
+        Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included.
+
+        Args:
+            channel_id: The id of the channel
+
+        Returns:
+            channel
+
+        """
+        result = await self.request(Route("GET", "/channels/{channel_id}", channel_id=channel_id))
+        return cast(discord_typings.ChannelData, result)
+
+    @overload
+    async def get_channel_messages(
+        self,
+        channel_id: "Snowflake_Type",
+        limit: int = 50,
+    ) -> list[discord_typings.MessageData]:
+        ...
+
+    @overload
+    async def get_channel_messages(
+        self,
+        channel_id: "Snowflake_Type",
+        limit: int = 50,
+        *,
+        around: "Snowflake_Type | None" = None,
+    ) -> list[discord_typings.MessageData]:
+        ...
+
+    @overload
+    async def get_channel_messages(
+        self,
+        channel_id: "Snowflake_Type",
+        limit: int = 50,
+        *,
+        before: "Snowflake_Type | None" = None,
+    ) -> list[discord_typings.MessageData]:
+        ...
+
+    @overload
+    async def get_channel_messages(
+        self,
+        channel_id: "Snowflake_Type",
+        limit: int = 50,
+        *,
+        after: "Snowflake_Type | None" = None,
+    ) -> list[discord_typings.MessageData]:
+        ...
+
+    async def get_channel_messages(
+        self,
+        channel_id: "Snowflake_Type",
+        limit: int = 50,
+        *,
+        around: "Snowflake_Type | None" = None,
+        before: "Snowflake_Type | None" = None,
+        after: "Snowflake_Type | None" = None,
+    ) -> list[discord_typings.MessageData]:
+        """
+        Get the messages for a channel.
+
+        Args:
+            channel_id: The channel to get messages from
+            limit: How many messages to get (default 50, max 100)
+            around: Get messages around this snowflake
+            before: Get messages before this snowflake
+            after: Get messages after this snowflake
+
+        Returns:
+            List of message dicts
+
+        """
+        params_count = sum(bool(param) for param in (before, after, around))
+        if params_count > 1:
+            raise ValueError("`before` `after` and `around` are mutually exclusive, only one may be passed at a time.")
+
+        params: PAYLOAD_TYPE = {
+            "limit": limit,
+            "before": int(before) if before else None,
+            "after": int(after) if after else None,
+            "around": int(around) if around else None,
+        }
+        params = dict_filter_none(params)
+
+        result = await self.request(
+            Route("GET", "/channels/{channel_id}/messages", channel_id=channel_id), params=params
+        )
+        return cast(list[discord_typings.MessageData], result)
+
+    async def create_guild_channel(
+        self,
+        guild_id: "Snowflake_Type",
+        name: str,
+        channel_type: "ChannelType | int",
+        topic: str | None = None,
+        position: int | None = None,
+        permission_overwrites: Sequence["PermissionOverwrite | dict"] | None = None,
+        parent_id: "Snowflake_Type | None" = None,
+        nsfw: bool = False,
+        bitrate: int = 64000,
+        user_limit: int = 0,
+        rate_limit_per_user: int = 0,
+        reason: str | None = None,
+        **kwargs: dict,
+    ) -> discord_typings.ChannelData:
+        """
+        Create a channel in a guild.
+
+        Args:
+            guild_id: The ID of the guild to create the channel in
+            name: The name of the channel
+            channel_type: The type of channel to create
+            topic: The topic of the channel
+            position: The position of the channel in the channel list
+            permission_overwrites: Permission overwrites to apply to the channel
+            parent_id: The category this channel should be within
+            nsfw: Should this channel be marked nsfw
+            bitrate: The bitrate of this channel, only for voice
+            user_limit: The max users that can be in this channel, only for voice
+            rate_limit_per_user: The time users must wait between sending messages
+            reason: The reason for creating this channel
+            kwargs: Additional keyword arguments to pass to the request
+
+        Returns:
+            The created channel object
+
+        """
+        payload: PAYLOAD_TYPE = {
+            "name": name,
+            "type": channel_type,
+            "topic": topic,
+            "position": position,
+            "rate_limit_per_user": rate_limit_per_user,
+            "nsfw": nsfw,
+            "parent_id": int(parent_id) if parent_id else None,
+            "permission_overwrites": list(permission_overwrites) if permission_overwrites else None,
+            **kwargs,
+        }
+        if channel_type in (ChannelType.GUILD_VOICE, ChannelType.GUILD_STAGE_VOICE):
+            payload.update(
+                bitrate=bitrate,
+                user_limit=user_limit,
+            )
+        payload = dict_filter_none(payload)
+
+        result = await self.request(
+            Route("POST", "/guilds/{guild_id}/channels", guild_id=guild_id), payload=payload, reason=reason
+        )
+        return cast(discord_typings.ChannelData, result)
+
+    async def move_channel(
+        self,
+        guild_id: "Snowflake_Type",
+        channel_id: "Snowflake_Type",
+        new_pos: int,
+        parent_id: "Snowflake_Type | None" = None,
+        lock_perms: bool = False,
+        reason: str | None = None,
+    ) -> None:
+        """
+        Move a channel.
+
+        Args:
+            guild_id: The ID of the guild this affects
+            channel_id: The ID of the channel to move
+            new_pos: The new position of this channel
+            parent_id: The parent ID if needed
+            lock_perms: Sync permissions with the new parent
+            reason: An optional reason for the audit log
+
+        """
+        payload: PAYLOAD_TYPE = {
+            "id": int(channel_id),
+            "position": new_pos,
+            "parent_id": int(parent_id) if parent_id else None,
+            "lock_permissions": lock_perms,
+        }
+        payload = dict_filter_none(payload)
+
+        await self.request(
+            Route("PATCH", "/guilds/{guild_id}/channels", guild_id=guild_id), payload=payload, reason=reason
+        )
+
+    async def modify_channel(
+        self, channel_id: "Snowflake_Type", data: dict, reason: str | None = None
+    ) -> discord_typings.ChannelData:
+        """
+        Update a channel's settings, returns the updated channel object on success.
+
+        Args:
+            channel_id: The ID of the channel to update
+            data: The data to update with
+            reason: An optional reason for the audit log
+
+        Returns:
+            Channel object on success
+
+        """
+        result = await self.request(
+            Route("PATCH", "/channels/{channel_id}", channel_id=channel_id), payload=data, reason=reason
+        )
+        return cast(discord_typings.ChannelData, result)
+
+    async def delete_channel(self, channel_id: "Snowflake_Type", reason: str | None = None) -> None:
+        """
+        Delete the channel.
+
+        Args:
+            channel_id: The ID of the channel to delete
+            reason: An optional reason for the audit log
+
+        """
+        await self.request(Route("DELETE", "/channels/{channel_id}", channel_id=channel_id), reason=reason)
+
+    async def get_channel_invites(self, channel_id: "Snowflake_Type") -> list[discord_typings.InviteData]:
+        """
+        Get the invites for the channel.
+
+        Args:
+            channel_id: The ID of the channel to retrieve from
+
+        Returns:
+            List of invite objects
+
+        """
+        result = await self.request(Route("GET", "/channels/{channel_id}/invites", channel_id=channel_id))
+        return cast(list[discord_typings.InviteData], result)
+
+    @overload
+    async def create_channel_invite(
+        self,
+        channel_id: "Snowflake_Type",
+        max_age: int = 86400,
+        max_uses: int = 0,
+        temporary: bool = False,
+        unique: bool = False,
+        *,
+        reason: str | None = None,
+    ) -> discord_typings.InviteData:
+        ...
+
+    @overload
+    async def create_channel_invite(
+        self,
+        channel_id: "Snowflake_Type",
+        max_age: int = 86400,
+        max_uses: int = 0,
+        temporary: bool = False,
+        unique: bool = False,
+        *,
+        target_user_id: "Snowflake_Type | None" = None,
+        reason: str | None = None,
+    ) -> discord_typings.InviteData:
+        ...
+
+    @overload
+    async def create_channel_invite(
+        self,
+        channel_id: "Snowflake_Type",
+        max_age: int = 86400,
+        max_uses: int = 0,
+        temporary: bool = False,
+        unique: bool = False,
+        *,
+        target_application_id: "Snowflake_Type | None" = None,
+        reason: str | None = None,
+    ) -> discord_typings.InviteData:
+        ...
+
+    async def create_channel_invite(
+        self,
+        channel_id: "Snowflake_Type",
+        max_age: int = 86400,
+        max_uses: int = 0,
+        temporary: bool = False,
+        unique: bool = False,
+        *,
+        target_user_id: "Snowflake_Type | None" = None,
+        target_application_id: "Snowflake_Type | None" = None,
+        reason: str | None = None,
+    ) -> discord_typings.InviteData:
+        """
+        Create an invite for the given channel.
+
+        Args:
+            channel_id: The ID of the channel to create an invite for
+            max_age: duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours)
+            max_uses: max number of uses or 0 for unlimited. between 0 and 100
+            temporary: whether this invite only grants temporary membership
+            unique: if true, don't try to reuse a similar invite (useful for creating many unique one time use invites)
+            target_user_id: the id of the user whose stream to display for this invite, the user must be streaming in the channel
+            target_application_id: the id of the embedded application to open for this invite, the application must have the EMBEDDED flag
+            reason: An optional reason for the audit log
+
+        Returns:
+            an invite object
+
+        """
+        params_count = sum(bool(param) for param in (target_user_id, target_application_id))
+        if params_count > 1:
+            raise ValueError(
+                "`target_type` and `target_user_id` are mutually exclusive, only one may be passed at a time."
+            )
+
+        payload: PAYLOAD_TYPE = {
+            "max_age": max_age,
+            "max_uses": max_uses,
+            "temporary": temporary,
+            "unique": unique,
+        }
+        if target_user_id:
+            payload["target_type"] = 1
+            payload["target_user_id"] = int(target_user_id)
+        if target_application_id:
+            payload["target_type"] = 2
+            payload["target_application_id"] = int(target_application_id)
+        payload = dict_filter_none(payload)
+
+        result = await self.request(
+            Route("POST", "/channels/{channel_id}/invites", channel_id=channel_id), payload=payload, reason=reason
+        )
+        return cast(discord_typings.InviteData, result)
+
+    async def get_invite(
+        self,
+        invite_code: str,
+        with_counts: bool = False,
+        with_expiration: bool = True,
+        scheduled_event_id: "Snowflake_Type | None" = None,
+    ) -> discord_typings.InviteData:
+        """
+        Get an invite object for a given code.
+
+        Args:
+            invite_code: The code of the invite
+            with_counts: whether the invite should contain approximate member counts
+            with_expiration: whether the invite should contain the expiration date
+            scheduled_event_id: the guild scheduled event to include with the invite
+
+        Returns:
+            an invite object
+
+        """
+        params: PAYLOAD_TYPE = {
+            "invite_code": invite_code,
+            "with_counts": with_counts,
+            "with_expiration": with_expiration,
+            "guild_scheduled_event_id": int(scheduled_event_id) if scheduled_event_id else None,
+        }
+        params = dict_filter_none(params)
+
+        result = await self.request(Route("GET", "/invites/{invite_code}", invite_code=invite_code, params=params))
+        return cast(discord_typings.InviteData, result)
+
+    async def delete_invite(self, invite_code: str, reason: str | None = None) -> discord_typings.InviteData:
+        """
+        Delete an invite.
+
+        Args:
+            invite_code: The code of the invite to delete
+            reason: The reason to delete the invite
+
+        Returns:
+            The deleted invite object
+
+        """
+        result = await self.request(Route("DELETE", "/invites/{invite_code}", invite_code=invite_code), reason=reason)
+        return cast(discord_typings.InviteData, result)
+
+    async def edit_channel_permission(
+        self,
+        channel_id: "Snowflake_Type",
+        overwrite_id: "Snowflake_Type",
+        perm_type: "OverwriteType | int",
+        allow: "Permissions | int" = 0,
+        deny: "Permissions | int" = 0,
+        reason: str | None = None,
+    ) -> None:
+        """
+        Edit the channel permission overwrites for a user or role in a channel.
+
+        Args:
+            channel_id: The id of the channel
+            overwrite_id: The id of the object to override
+            allow: the bitwise value of all allowed permissions
+            deny: the bitwise value of all disallowed permissions
+            perm_type: 0 for a role or 1 for a member
+            reason: The reason for this action
+
+        """
+        payload: PAYLOAD_TYPE = {"allow": allow, "deny": deny, "type": perm_type}
+
+        await self.request(
+            Route(
+                "PUT",
+                "/channels/{channel_id}/permissions/{overwrite_id}",
+                channel_id=channel_id,
+                overwrite_id=overwrite_id,
+            ),
+            payload=payload,
+            reason=reason,
+        )
+
+    async def delete_channel_permission(
+        self,
+        channel_id: "Snowflake_Type",
+        overwrite_id: "Snowflake_Type",
+        reason: str | None = None,
+    ) -> None:
+        """
+        Delete a channel permission overwrite for a user or role in a channel.
+
+        Args:
+            channel_id: The ID of the channel.
+            overwrite_id: The ID of the overwrite
+            reason: An optional reason for the audit log
+
+        """
+        await self.request(
+            Route("DELETE", "/channels/{channel_id}/{overwrite_id}", channel_id=channel_id, overwrite_id=overwrite_id),
+            reason=reason,
+        )
+
+    async def follow_news_channel(
+        self, channel_id: "Snowflake_Type", webhook_channel_id: "Snowflake_Type"
+    ) -> discord_typings.FollowedChannelData:
+        """
+        Follow a news channel to send messages to the target channel.
+
+        Args:
+            channel_id: The channel to follow
+            webhook_channel_id: ID of the target channel
+
+        Returns:
+            Followed channel object
+
+        """
+        payload = {"webhook_channel_id": int(webhook_channel_id)}
+
+        result = await self.request(
+            Route("POST", "/channels/{channel_id}/followers", channel_id=channel_id), payload=payload
+        )
+        return cast(discord_typings.FollowedChannelData, result)
+
+    async def trigger_typing_indicator(self, channel_id: "Snowflake_Type") -> None:
+        """
+        Post a typing indicator for the specified channel. Generally bots should not implement this route.
+
+        Args:
+            channel_id: The id of the channel to "type" in
+
+        """
+        await self.request(Route("POST", "/channels/{channel_id}/typing", channel_id=channel_id))
+
+    async def get_pinned_messages(self, channel_id: "Snowflake_Type") -> list[discord_typings.MessageData]:
+        """
+        Get all pinned messages from a channel.
+
+        Args:
+            channel_id: The ID of the channel to get pins from
+
+        Returns:
+            A list of pinned message objects
+
+        """
+        result = await self.request(Route("GET", "/channels/{channel_id}/pins", channel_id=channel_id))
+        return cast(list[discord_typings.MessageData], result)
+
+    async def create_stage_instance(
+        self,
+        channel_id: "Snowflake_Type",
+        topic: str,
+        privacy_level: StagePrivacyLevel | int = StagePrivacyLevel.PUBLIC,
+        reason: str | None = None,
+    ) -> discord_typings.StageInstanceData:
+        """
+        Create a new stage instance.
+
+        Args:
+            channel_id: The ID of the stage channel
+            topic: The topic of the stage instance (1-120 characters)
+            privacy_level: Them privacy_level of the stage instance (default guild only)
+            reason: The reason for the creating the stage instance
+
+        Returns:
+            The stage instance
+
+        """
+        payload: PAYLOAD_TYPE = {
+            "channel_id": int(channel_id),
+            "topic": topic,
+            "privacy_level": StagePrivacyLevel(privacy_level),
+        }
+
+        result = await self.request(Route("POST", "/stage-instances"), payload=payload, reason=reason)
+        return cast(discord_typings.StageInstanceData, result)
+
+    async def get_stage_instance(self, channel_id: "Snowflake_Type") -> discord_typings.StageInstanceData:
+        """
+        Get the stage instance associated with a given channel, if it exists.
+
+        Args:
+            channel_id: The ID of the channel to retrieve the instance for.
+
+        Returns:
+            A stage instance.
+
+        """
+        result = await self.request(Route("GET", "/stage-instances/{channel_id}", channel_id=channel_id))
+        return cast(discord_typings.StageInstanceData, result)
+
+    async def modify_stage_instance(
+        self,
+        channel_id: "Snowflake_Type",
+        topic: str | None = None,
+        privacy_level: int | None = None,
+        reason: str | None = None,
+    ) -> discord_typings.StageInstanceData:
+        """
+        Update the fields of a given stage instance.
+
+        Args:
+            channel_id: The id of the stage channel.
+            topic: The new topic for the stage instance
+            privacy_level: The privacy level for the stage instance
+            reason: The reason for the change
+
+        Returns:
+            The updated stage instance.
+
+        """
+        payload: PAYLOAD_TYPE = {"topic": topic, "privacy_level": privacy_level}
+        payload = dict_filter_none(payload)
+        result = await self.request(
+            Route("PATCH", "/stage-instances/{channel_id}", channel_id=channel_id), payload=payload, reason=reason
+        )
+        return cast(discord_typings.StageInstanceData, result)
+
+    async def delete_stage_instance(self, channel_id: "Snowflake_Type", reason: str | None = None) -> None:
+        """
+        Delete a stage instance.
+
+        Args:
+            channel_id: The ID of the channel to delete the stage instance for.
+            reason: The reason for the deletion
+
+        """
+        await self.request(Route("DELETE", "/stage-instances/{channel_id}", channel_id=channel_id), reason=reason)
+
+    async def create_tag(
+        self,
+        channel_id: "Snowflake_Type",
+        name: str,
+        emoji_id: Optional["Snowflake_Type"] = None,
+        emoji_name: Optional[str] = None,
+    ) -> discord_typings.ChannelData:
+        """
+        Create a new tag.
+
+        Args:
+            channel_id: The ID of the forum channel to create tag for.
+            name: The name of the tag
+            emoji_id: The ID of the emoji to use for the tag
+            emoji_name: The name of the emoji to use for the tag
+
+        !!! note
+            Can either have an `emoji_id` or an `emoji_name`, but not both.
+            `emoji_id` is meant for custom emojis, `emoji_name` is meant for unicode emojis.
+        """
+        payload: PAYLOAD_TYPE = {
+            "name": name,
+            "emoji_id": int(emoji_id) if emoji_id else None,
+            "emoji_name": emoji_name or None,
+        }
+        payload = dict_filter_none(payload)
+
+        result = await self.request(
+            Route("POST", "/channels/{channel_id}/tags", channel_id=channel_id), payload=payload
+        )
+        return cast(discord_typings.ChannelData, result)
+
+    async def edit_tag(
+        self,
+        channel_id: "Snowflake_Type",
+        tag_id: "Snowflake_Type",
+        name: str,
+        emoji_id: "Snowflake_Type | None" = None,
+        emoji_name: str | None = None,
+    ) -> discord_typings.ChannelData:
+        """
+        Update a tag.
+
+        Args:
+            channel_id: The ID of the forum channel to edit tag it.
+            tag_id: The ID of the tag to update
+            name: The new name of the tag
+            emoji_id: The ID of the emoji to use for the tag
+            emoji_name: The name of the emoji to use for the tag
+
+        !!! note
+            Can either have an `emoji_id` or an `emoji_name`, but not both.
+            emoji`_id is meant for custom emojis, `emoji_name` is meant for unicode emojis.
+        """
+        payload: PAYLOAD_TYPE = {
+            "name": name,
+            "emoji_id": int(emoji_id) if emoji_id else None,
+            "emoji_name": emoji_name,
+        }
+        payload = dict_filter_none(payload)
+
+        result = await self.request(
+            Route("PUT", "/channels/{channel_id}/tags/{tag_id}", channel_id=channel_id, tag_id=tag_id), payload=payload
+        )
+        return cast(discord_typings.ChannelData, result)
+
+    async def delete_tag(self, channel_id: "Snowflake_Type", tag_id: "Snowflake_Type") -> discord_typings.ChannelData:
+        """
+        Delete a forum tag.
+
+        Args:
+            channel_id: The ID of the forum channel to delete tag it.
+            tag_id: The ID of the tag to delete
+        """
+        result = await self.request(
+            Route("DELETE", "/channels/{channel_id}/tags/{tag_id}", channel_id=channel_id, tag_id=tag_id)
+        )
+        return cast(discord_typings.ChannelData, result)
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/emojis.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/emojis.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,112 +1,112 @@
-from typing import TYPE_CHECKING, cast
-
-import discord_typings
-
-from interactions.models.internal.protocols import CanRequest
-from ..route import Route
-
-__all__ = ("EmojiRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-
-class EmojiRequests(CanRequest):
-    async def get_all_guild_emoji(self, guild_id: "Snowflake_Type") -> list[discord_typings.EmojiData]:
-        """
-        Get all the emoji from a guild.
-
-        Args:
-            guild_id: The ID of the guild to query.
-
-        Returns:
-            List of emoji objects
-
-        """
-        result = await self.request(Route("GET", "/guilds/{guild_id}/emojis", guild_id=guild_id))
-        return cast(list[discord_typings.EmojiData], result)
-
-    async def get_guild_emoji(
-        self, guild_id: "Snowflake_Type", emoji_id: "Snowflake_Type"
-    ) -> discord_typings.EmojiData:
-        """
-        Get a specific guild emoji object.
-
-        Args:
-            guild_id: The ID of the guild to query
-            emoji_id: The ID of the emoji to get
-
-        Returns:
-            PartialEmoji object
-
-        """
-        result = await self.request(
-            Route("GET", "/guilds/{guild_id}/emojis/{emoji_id}", guild_id=guild_id, emoji_id=emoji_id)
-        )
-        return cast(discord_typings.EmojiData, result)
-
-    async def create_guild_emoji(
-        self, payload: dict, guild_id: "Snowflake_Type", reason: str | None = None
-    ) -> discord_typings.EmojiData:
-        """
-        Create a guild emoji.
-
-        Args:
-            payload: The emoji's data
-            guild_id: The ID of the guild
-            reason: The reason for this creation
-
-        Returns:
-            The created emoji object
-
-        """
-        result = await self.request(
-            Route("POST", "/guilds/{guild_id}/emojis", guild_id=guild_id), payload=payload, reason=reason
-        )
-
-        return cast(discord_typings.EmojiData, result)
-
-    async def modify_guild_emoji(
-        self,
-        payload: dict,
-        guild_id: "Snowflake_Type",
-        emoji_id: "Snowflake_Type",
-        reason: str | None = None,
-    ) -> discord_typings.EmojiData:
-        """
-        Modify an existing guild emoji.
-
-        Args:
-            payload: The emoji's data
-            guild_id: The ID of the guild
-            emoji_id: The ID of the emoji to update
-            reason: The reason for this creation
-
-        Returns:
-            The updated emoji object
-
-        """
-        result = await self.request(
-            Route("PATCH", "/guilds/{guild_id}/emojis/{emoji_id}", guild_id=guild_id, emoji_id=emoji_id),
-            payload=payload,
-            reason=reason,
-        )
-        return cast(discord_typings.EmojiData, result)
-
-    async def delete_guild_emoji(
-        self, guild_id: "Snowflake_Type", emoji_id: "Snowflake_Type", reason: str | None = None
-    ) -> None:
-        """
-        Delete a guild emoji.
-
-        Args:
-            guild_id: The ID of the guild
-            emoji_id: The ID of the emoji to update
-            reason: The reason for this deletion
-
-        """
-        await self.request(
-            Route("DELETE", "/guilds/{guild_id}/emojis/{emoji_id}", guild_id=guild_id, emoji_id=emoji_id),
-            reason=reason,
-        )
+from typing import TYPE_CHECKING, cast
+
+import discord_typings
+
+from interactions.models.internal.protocols import CanRequest
+from ..route import Route
+
+__all__ = ("EmojiRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+
+class EmojiRequests(CanRequest):
+    async def get_all_guild_emoji(self, guild_id: "Snowflake_Type") -> list[discord_typings.EmojiData]:
+        """
+        Get all the emoji from a guild.
+
+        Args:
+            guild_id: The ID of the guild to query.
+
+        Returns:
+            List of emoji objects
+
+        """
+        result = await self.request(Route("GET", "/guilds/{guild_id}/emojis", guild_id=guild_id))
+        return cast(list[discord_typings.EmojiData], result)
+
+    async def get_guild_emoji(
+        self, guild_id: "Snowflake_Type", emoji_id: "Snowflake_Type"
+    ) -> discord_typings.EmojiData:
+        """
+        Get a specific guild emoji object.
+
+        Args:
+            guild_id: The ID of the guild to query
+            emoji_id: The ID of the emoji to get
+
+        Returns:
+            PartialEmoji object
+
+        """
+        result = await self.request(
+            Route("GET", "/guilds/{guild_id}/emojis/{emoji_id}", guild_id=guild_id, emoji_id=emoji_id)
+        )
+        return cast(discord_typings.EmojiData, result)
+
+    async def create_guild_emoji(
+        self, payload: dict, guild_id: "Snowflake_Type", reason: str | None = None
+    ) -> discord_typings.EmojiData:
+        """
+        Create a guild emoji.
+
+        Args:
+            payload: The emoji's data
+            guild_id: The ID of the guild
+            reason: The reason for this creation
+
+        Returns:
+            The created emoji object
+
+        """
+        result = await self.request(
+            Route("POST", "/guilds/{guild_id}/emojis", guild_id=guild_id), payload=payload, reason=reason
+        )
+
+        return cast(discord_typings.EmojiData, result)
+
+    async def modify_guild_emoji(
+        self,
+        payload: dict,
+        guild_id: "Snowflake_Type",
+        emoji_id: "Snowflake_Type",
+        reason: str | None = None,
+    ) -> discord_typings.EmojiData:
+        """
+        Modify an existing guild emoji.
+
+        Args:
+            payload: The emoji's data
+            guild_id: The ID of the guild
+            emoji_id: The ID of the emoji to update
+            reason: The reason for this creation
+
+        Returns:
+            The updated emoji object
+
+        """
+        result = await self.request(
+            Route("PATCH", "/guilds/{guild_id}/emojis/{emoji_id}", guild_id=guild_id, emoji_id=emoji_id),
+            payload=payload,
+            reason=reason,
+        )
+        return cast(discord_typings.EmojiData, result)
+
+    async def delete_guild_emoji(
+        self, guild_id: "Snowflake_Type", emoji_id: "Snowflake_Type", reason: str | None = None
+    ) -> None:
+        """
+        Delete a guild emoji.
+
+        Args:
+            guild_id: The ID of the guild
+            emoji_id: The ID of the emoji to update
+            reason: The reason for this deletion
+
+        """
+        await self.request(
+            Route("DELETE", "/guilds/{guild_id}/emojis/{emoji_id}", guild_id=guild_id, emoji_id=emoji_id),
+            reason=reason,
+        )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/interactions.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/interactions.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,354 +1,354 @@
-from typing import TYPE_CHECKING, cast
-
-import discord_typings
-
-from interactions.client.const import GLOBAL_SCOPE
-from interactions.models.internal.protocols import CanRequest
-from ..route import Route
-
-__all__ = ("InteractionRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-    from interactions import UPLOADABLE_TYPE
-
-
-class InteractionRequests(CanRequest):
-    async def delete_application_command(
-        self,
-        application_id: "Snowflake_Type",
-        guild_id: "Snowflake_Type",
-        command_id: "Snowflake_Type",
-    ) -> None:
-        """
-        Delete an existing application command for this application.
-
-        Args:
-            application_id: the what application to delete for
-            guild_id: specify a guild to delete commands from
-            command_id: the command to delete
-
-        """
-        if guild_id == GLOBAL_SCOPE:
-            await self.request(
-                Route(
-                    "DELETE",
-                    "/applications/{application_id}/commands/{command_id}",
-                    application_id=application_id,
-                    command_id=command_id,
-                )
-            )
-        else:
-            await self.request(
-                Route(
-                    "DELETE",
-                    "/applications/{application_id}/guilds/{guild_id}/commands/{command_id}",
-                    application_id=application_id,
-                    guild_id=guild_id,
-                    command_id=command_id,
-                )
-            )
-
-    async def get_application_commands(
-        self,
-        application_id: "Snowflake_Type",
-        guild_id: "Snowflake_Type",
-        with_localisations: bool = True,
-    ) -> list[discord_typings.ApplicationCommandData]:
-        """
-        Get all application commands for this application from discord.
-
-        Args:
-            application_id: the what application to query
-            guild_id: specify a guild to get commands from
-            with_localisations: whether to include all localisations in the response
-
-        Returns:
-            Application command data
-
-        """
-        if guild_id == GLOBAL_SCOPE:
-            return await self.request(
-                Route("GET", "/applications/{application_id}/commands", application_id=application_id),
-                params={"with_localizations": int(with_localisations)},
-            )
-        return await self.request(
-            Route(
-                "GET",
-                "/applications/{application_id}/guilds/{guild_id}/commands",
-                application_id=application_id,
-                guild_id=guild_id,
-            ),
-            params={"with_localizations": int(with_localisations)},
-        )
-
-    async def overwrite_application_commands(
-        self, app_id: "Snowflake_Type", data: list[dict], guild_id: "Snowflake_Type"
-    ) -> list[discord_typings.ApplicationCommandData]:  # todo type "data"
-        """
-        Take a list of commands and overwrite the existing command list within the given scope
-
-        Args:
-            app_id: The application ID of this bot
-            guild_id: The ID of the guild this command is for, if this is a guild command
-            data: List of your interaction data
-
-        """
-        if guild_id == GLOBAL_SCOPE:
-            result = await self.request(Route("PUT", "/applications/{app_id}/commands", app_id=app_id), payload=data)
-        else:
-            result = await self.request(
-                Route("PUT", "/applications/{app_id}/guilds/{guild_id}/commands", app_id=app_id, guild_id=guild_id),
-                payload=data,
-            )
-        return cast(list[discord_typings.ApplicationCommandData], result)
-
-    async def create_application_command(
-        self, app_id: "Snowflake_Type", command: dict, guild_id: "Snowflake_Type"
-    ) -> discord_typings.ApplicationCommandData:
-        """
-        Add a given command to scope.
-
-        Args:
-            app_id: The application ID of this bot
-            command: A dictionary representing a command to be created
-            guild_id: The ID of the guild this command is for, if this is a guild command
-
-        Returns:
-            An application command object
-        """
-        if guild_id == GLOBAL_SCOPE:
-            result = await self.request(
-                Route("POST", "/applications/{app_id}/commands", app_id=app_id), payload=command
-            )
-        else:
-            result = await self.request(
-                Route("POST", "/applications/{app_id}/guilds/{guild_id}/commands", app_id=app_id, guild_id=guild_id),
-                payload=command,
-            )
-        return cast(discord_typings.ApplicationCommandData, result)
-
-    async def post_initial_response(
-        self,
-        payload: dict,
-        interaction_id: str,
-        token: str,
-        files: list["UPLOADABLE_TYPE"] | None = None,
-    ) -> None:
-        """
-        Post an initial response to an interaction.
-
-        Args:
-            payload: the payload to send
-            interaction_id: the id of the interaction
-            token: the token of the interaction
-            files: The files to send in this message
-
-        """
-        return await self.request(
-            Route(
-                "POST",
-                "/interactions/{interaction_id}/{webhook_token}/callback",
-                interaction_id=interaction_id,
-                webhook_token=token,
-            ),
-            payload=payload,
-            files=files,
-        )
-
-    async def post_followup(
-        self,
-        payload: dict,
-        application_id: "Snowflake_Type",
-        token: str,
-        files: list["UPLOADABLE_TYPE"] | None = None,
-    ) -> None:
-        """
-        Send a followup to an interaction.
-
-        Args:
-            payload: the payload to send
-            application_id: the id of the application
-            token: the token of the interaction
-            files: The files to send with this interaction
-
-        """
-        return await self.request(
-            Route(
-                "POST", "/webhooks/{application_id}/{webhook_token}", application_id=application_id, webhook_token=token
-            ),
-            payload=payload,
-            files=files,
-        )
-
-    async def edit_interaction_message(
-        self,
-        payload: dict,
-        application_id: "Snowflake_Type",
-        token: str,
-        message_id: "str|Snowflake_Type" = "@original",
-        files: list["UPLOADABLE_TYPE"] | None = None,
-    ) -> discord_typings.MessageData:
-        """
-        Edits an existing interaction message.
-
-        Args:
-            payload: The payload to send.
-            application_id: The id of the application.
-            token: The token of the interaction.
-            message_id: The target message to edit. Defaults to @original which represents the initial response message.
-            files: The files to send with this interaction
-
-        Returns:
-            The edited message data.
-
-        """
-        result = await self.request(
-            Route(
-                "PATCH",
-                "/webhooks/{application_id}/{webhook_token}/messages/{message_id}",
-                application_id=application_id,
-                webhook_token=token,
-                message_id=message_id,
-            ),
-            payload=payload,
-            files=files,
-        )
-        return cast(discord_typings.MessageData, result)
-
-    async def delete_interaction_message(
-        self,
-        application_id: "Snowflake_Type",
-        token: str,
-        message_id: "str | Snowflake_Type" = "@original",
-    ) -> None:
-        """
-        Deletes an existing interaction message.
-
-        Args:
-            application_id: The id of the application.
-            token: The token of the interaction.
-            message_id: The target message to delete. Defaults to @original which represents the initial response message.
-
-        """
-        return await self.request(
-            Route(
-                "DELETE",
-                "/webhooks/{application_id}/{webhook_token}/messages/{message_id}",
-                application_id=application_id,
-                webhook_token=token,
-                message_id=message_id,
-            )
-        )
-
-    async def get_interaction_message(
-        self, application_id: "Snowflake_Type", token: str, message_id: str = "@original"
-    ) -> discord_typings.MessageData:
-        """
-        Gets an existing interaction message.
-
-        Args:
-            application_id: The id of the application.
-            token: The token of the interaction.
-            message_id: The target message to get. Defaults to @original which represents the initial response message.
-
-        Returns:
-            The message data.
-
-        """
-        result = await self.request(
-            Route(
-                "GET",
-                "/webhooks/{application_id}/{webhook_token}/messages/{message_id}",
-                application_id=application_id,
-                webhook_token=token,
-                message_id=message_id,
-            )
-        )
-        return cast(discord_typings.MessageData, result)
-
-    async def edit_application_command_permissions(
-        self,
-        application_id: "Snowflake_Type",
-        scope: "Snowflake_Type",
-        command_id: "Snowflake_Type",
-        permissions: list[dict],  # todo better typing
-    ) -> discord_typings.ApplicationCommandPermissionsData:
-        """
-        Edits command permissions for a specific command.
-
-        Args:
-            application_id: the id of the application
-            scope: The scope this command is in
-            command_id: The command id to edit
-            permissions: The permissions to set to this command
-
-        Returns:
-            Guild Application Command Permissions
-
-        """
-        result = await self.request(
-            Route(
-                "PUT",
-                "/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions",
-                application_id=application_id,
-                guild_id=scope,
-                command_id=command_id,
-            ),
-            payload=permissions,
-        )
-        return cast(discord_typings.ApplicationCommandPermissionsData, result)
-
-    async def get_application_command_permissions(
-        self,
-        application_id: "Snowflake_Type",
-        scope: "Snowflake_Type",
-        command_id: "Snowflake_Type",
-    ) -> list[discord_typings.ApplicationCommandPermissionsData]:
-        """
-        Get permission data for a command.
-
-        Args:
-            application_id: the id of the application
-            scope: The scope this command is in
-            command_id: The command id to edit
-
-        Returns:
-            guild application command permissions
-
-        """
-        result = await self.request(
-            Route(
-                "GET",
-                "/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions",
-                application_id=application_id,
-                guild_id=scope,
-                command_id=command_id,
-            )
-        )
-        return cast(list[discord_typings.ApplicationCommandPermissionsData], result)
-
-    async def batch_get_application_command_permissions(
-        self, application_id: "Snowflake_Type", scope: "Snowflake_Type"
-    ) -> list[discord_typings.GuildApplicationCommandPermissionData]:
-        """
-        Get permission data for all commands in a scope.
-
-        Args:
-            application_id: the id of the application
-            scope: The scope this command is in
-
-        Returns:
-            list of guild application command permissions
-
-        """
-        result = await self.request(
-            Route(
-                "GET",
-                "/applications/{application_id}/guilds/{guild_id}/commands/permissions",
-                application_id=application_id,
-                guild_id=scope,
-            )
-        )
-        return cast(list[discord_typings.GuildApplicationCommandPermissionData], result)
+from typing import TYPE_CHECKING, cast
+
+import discord_typings
+
+from interactions.client.const import GLOBAL_SCOPE
+from interactions.models.internal.protocols import CanRequest
+from ..route import Route
+
+__all__ = ("InteractionRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+    from interactions import UPLOADABLE_TYPE
+
+
+class InteractionRequests(CanRequest):
+    async def delete_application_command(
+        self,
+        application_id: "Snowflake_Type",
+        guild_id: "Snowflake_Type",
+        command_id: "Snowflake_Type",
+    ) -> None:
+        """
+        Delete an existing application command for this application.
+
+        Args:
+            application_id: the what application to delete for
+            guild_id: specify a guild to delete commands from
+            command_id: the command to delete
+
+        """
+        if guild_id == GLOBAL_SCOPE:
+            await self.request(
+                Route(
+                    "DELETE",
+                    "/applications/{application_id}/commands/{command_id}",
+                    application_id=application_id,
+                    command_id=command_id,
+                )
+            )
+        else:
+            await self.request(
+                Route(
+                    "DELETE",
+                    "/applications/{application_id}/guilds/{guild_id}/commands/{command_id}",
+                    application_id=application_id,
+                    guild_id=guild_id,
+                    command_id=command_id,
+                )
+            )
+
+    async def get_application_commands(
+        self,
+        application_id: "Snowflake_Type",
+        guild_id: "Snowflake_Type",
+        with_localisations: bool = True,
+    ) -> list[discord_typings.ApplicationCommandData]:
+        """
+        Get all application commands for this application from discord.
+
+        Args:
+            application_id: the what application to query
+            guild_id: specify a guild to get commands from
+            with_localisations: whether to include all localisations in the response
+
+        Returns:
+            Application command data
+
+        """
+        if guild_id == GLOBAL_SCOPE:
+            return await self.request(
+                Route("GET", "/applications/{application_id}/commands", application_id=application_id),
+                params={"with_localizations": int(with_localisations)},
+            )
+        return await self.request(
+            Route(
+                "GET",
+                "/applications/{application_id}/guilds/{guild_id}/commands",
+                application_id=application_id,
+                guild_id=guild_id,
+            ),
+            params={"with_localizations": int(with_localisations)},
+        )
+
+    async def overwrite_application_commands(
+        self, app_id: "Snowflake_Type", data: list[dict], guild_id: "Snowflake_Type"
+    ) -> list[discord_typings.ApplicationCommandData]:  # todo type "data"
+        """
+        Take a list of commands and overwrite the existing command list within the given scope
+
+        Args:
+            app_id: The application ID of this bot
+            guild_id: The ID of the guild this command is for, if this is a guild command
+            data: List of your interaction data
+
+        """
+        if guild_id == GLOBAL_SCOPE:
+            result = await self.request(Route("PUT", "/applications/{app_id}/commands", app_id=app_id), payload=data)
+        else:
+            result = await self.request(
+                Route("PUT", "/applications/{app_id}/guilds/{guild_id}/commands", app_id=app_id, guild_id=guild_id),
+                payload=data,
+            )
+        return cast(list[discord_typings.ApplicationCommandData], result)
+
+    async def create_application_command(
+        self, app_id: "Snowflake_Type", command: dict, guild_id: "Snowflake_Type"
+    ) -> discord_typings.ApplicationCommandData:
+        """
+        Add a given command to scope.
+
+        Args:
+            app_id: The application ID of this bot
+            command: A dictionary representing a command to be created
+            guild_id: The ID of the guild this command is for, if this is a guild command
+
+        Returns:
+            An application command object
+        """
+        if guild_id == GLOBAL_SCOPE:
+            result = await self.request(
+                Route("POST", "/applications/{app_id}/commands", app_id=app_id), payload=command
+            )
+        else:
+            result = await self.request(
+                Route("POST", "/applications/{app_id}/guilds/{guild_id}/commands", app_id=app_id, guild_id=guild_id),
+                payload=command,
+            )
+        return cast(discord_typings.ApplicationCommandData, result)
+
+    async def post_initial_response(
+        self,
+        payload: dict,
+        interaction_id: str,
+        token: str,
+        files: list["UPLOADABLE_TYPE"] | None = None,
+    ) -> None:
+        """
+        Post an initial response to an interaction.
+
+        Args:
+            payload: the payload to send
+            interaction_id: the id of the interaction
+            token: the token of the interaction
+            files: The files to send in this message
+
+        """
+        return await self.request(
+            Route(
+                "POST",
+                "/interactions/{interaction_id}/{webhook_token}/callback",
+                interaction_id=interaction_id,
+                webhook_token=token,
+            ),
+            payload=payload,
+            files=files,
+        )
+
+    async def post_followup(
+        self,
+        payload: dict,
+        application_id: "Snowflake_Type",
+        token: str,
+        files: list["UPLOADABLE_TYPE"] | None = None,
+    ) -> None:
+        """
+        Send a followup to an interaction.
+
+        Args:
+            payload: the payload to send
+            application_id: the id of the application
+            token: the token of the interaction
+            files: The files to send with this interaction
+
+        """
+        return await self.request(
+            Route(
+                "POST", "/webhooks/{application_id}/{webhook_token}", application_id=application_id, webhook_token=token
+            ),
+            payload=payload,
+            files=files,
+        )
+
+    async def edit_interaction_message(
+        self,
+        payload: dict,
+        application_id: "Snowflake_Type",
+        token: str,
+        message_id: "str|Snowflake_Type" = "@original",
+        files: list["UPLOADABLE_TYPE"] | None = None,
+    ) -> discord_typings.MessageData:
+        """
+        Edits an existing interaction message.
+
+        Args:
+            payload: The payload to send.
+            application_id: The id of the application.
+            token: The token of the interaction.
+            message_id: The target message to edit. Defaults to @original which represents the initial response message.
+            files: The files to send with this interaction
+
+        Returns:
+            The edited message data.
+
+        """
+        result = await self.request(
+            Route(
+                "PATCH",
+                "/webhooks/{application_id}/{webhook_token}/messages/{message_id}",
+                application_id=application_id,
+                webhook_token=token,
+                message_id=message_id,
+            ),
+            payload=payload,
+            files=files,
+        )
+        return cast(discord_typings.MessageData, result)
+
+    async def delete_interaction_message(
+        self,
+        application_id: "Snowflake_Type",
+        token: str,
+        message_id: "str | Snowflake_Type" = "@original",
+    ) -> None:
+        """
+        Deletes an existing interaction message.
+
+        Args:
+            application_id: The id of the application.
+            token: The token of the interaction.
+            message_id: The target message to delete. Defaults to @original which represents the initial response message.
+
+        """
+        return await self.request(
+            Route(
+                "DELETE",
+                "/webhooks/{application_id}/{webhook_token}/messages/{message_id}",
+                application_id=application_id,
+                webhook_token=token,
+                message_id=message_id,
+            )
+        )
+
+    async def get_interaction_message(
+        self, application_id: "Snowflake_Type", token: str, message_id: str = "@original"
+    ) -> discord_typings.MessageData:
+        """
+        Gets an existing interaction message.
+
+        Args:
+            application_id: The id of the application.
+            token: The token of the interaction.
+            message_id: The target message to get. Defaults to @original which represents the initial response message.
+
+        Returns:
+            The message data.
+
+        """
+        result = await self.request(
+            Route(
+                "GET",
+                "/webhooks/{application_id}/{webhook_token}/messages/{message_id}",
+                application_id=application_id,
+                webhook_token=token,
+                message_id=message_id,
+            )
+        )
+        return cast(discord_typings.MessageData, result)
+
+    async def edit_application_command_permissions(
+        self,
+        application_id: "Snowflake_Type",
+        scope: "Snowflake_Type",
+        command_id: "Snowflake_Type",
+        permissions: list[dict],  # todo better typing
+    ) -> discord_typings.ApplicationCommandPermissionsData:
+        """
+        Edits command permissions for a specific command.
+
+        Args:
+            application_id: the id of the application
+            scope: The scope this command is in
+            command_id: The command id to edit
+            permissions: The permissions to set to this command
+
+        Returns:
+            Guild Application Command Permissions
+
+        """
+        result = await self.request(
+            Route(
+                "PUT",
+                "/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions",
+                application_id=application_id,
+                guild_id=scope,
+                command_id=command_id,
+            ),
+            payload=permissions,
+        )
+        return cast(discord_typings.ApplicationCommandPermissionsData, result)
+
+    async def get_application_command_permissions(
+        self,
+        application_id: "Snowflake_Type",
+        scope: "Snowflake_Type",
+        command_id: "Snowflake_Type",
+    ) -> list[discord_typings.ApplicationCommandPermissionsData]:
+        """
+        Get permission data for a command.
+
+        Args:
+            application_id: the id of the application
+            scope: The scope this command is in
+            command_id: The command id to edit
+
+        Returns:
+            guild application command permissions
+
+        """
+        result = await self.request(
+            Route(
+                "GET",
+                "/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions",
+                application_id=application_id,
+                guild_id=scope,
+                command_id=command_id,
+            )
+        )
+        return cast(list[discord_typings.ApplicationCommandPermissionsData], result)
+
+    async def batch_get_application_command_permissions(
+        self, application_id: "Snowflake_Type", scope: "Snowflake_Type"
+    ) -> list[discord_typings.GuildApplicationCommandPermissionData]:
+        """
+        Get permission data for all commands in a scope.
+
+        Args:
+            application_id: the id of the application
+            scope: The scope this command is in
+
+        Returns:
+            list of guild application command permissions
+
+        """
+        result = await self.request(
+            Route(
+                "GET",
+                "/applications/{application_id}/guilds/{guild_id}/commands/permissions",
+                application_id=application_id,
+                guild_id=scope,
+            )
+        )
+        return cast(list[discord_typings.GuildApplicationCommandPermissionData], result)
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/members.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/members.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,204 +1,205 @@
-from datetime import datetime
-from typing import TYPE_CHECKING, cast
-
-import discord_typings
-
-from interactions.client.const import Missing, MISSING
-from interactions.client.utils.serializer import dict_filter_none
-from interactions.models.discord.timestamp import Timestamp
-from interactions.models.internal.protocols import CanRequest
-from ..route import Route, PAYLOAD_TYPE
-
-__all__ = ("MemberRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-
-class MemberRequests(CanRequest):
-    async def get_member(
-        self, guild_id: "Snowflake_Type", user_id: "Snowflake_Type"
-    ) -> discord_typings.GuildMemberData:
-        """
-        Get a member of a guild by ID.
-
-        Args:
-            guild_id: The id of the guild
-            user_id: The user id to grab
-
-        """
-        result = await self.request(
-            Route("GET", "/guilds/{guild_id}/members/{user_id}", guild_id=guild_id, user_id=user_id)
-        )
-        return cast(discord_typings.GuildMemberData, result)
-
-    async def list_members(
-        self, guild_id: "Snowflake_Type", limit: int = 1, after: "Snowflake_Type | None" = None
-    ) -> list[discord_typings.GuildMemberData]:
-        """
-        List the members of a guild.
-
-        Args:
-            guild_id: The ID of the guild
-            limit: How many members to get (max 1000)
-            after: Get IDs after this snowflake
-
-        """
-        payload: PAYLOAD_TYPE = {
-            "limit": limit,
-            "after": int(after) if after else None,
-        }
-        payload = dict_filter_none(payload)
-
-        result = await self.request(Route("GET", "/guilds/{guild_id}/members", guild_id=guild_id), params=payload)
-        return cast(list[discord_typings.GuildMemberData], result)
-
-    async def search_guild_members(
-        self, guild_id: "Snowflake_Type", query: str, limit: int = 1
-    ) -> list[discord_typings.GuildMemberData]:
-        """
-        Search a guild for members who's username or nickname starts with provided string.
-
-        Args:
-            guild_id: The ID of the guild to search
-            query: The string to search for
-            limit: The number of members to return
-
-        """
-        result = await self.request(
-            Route("GET", "/guilds/{guild_id}/members/search", guild_id=guild_id),
-            params={"query": query, "limit": limit},
-        )
-        return cast(list[discord_typings.GuildMemberData], result)
-
-    async def modify_guild_member(
-        self,
-        guild_id: "Snowflake_Type",
-        user_id: "Snowflake_Type",
-        nickname: str | None | Missing = MISSING,
-        roles: list["Snowflake_Type"] | None = None,
-        mute: bool | None = None,
-        deaf: bool | None = None,
-        channel_id: "Snowflake_Type | None" = None,
-        communication_disabled_until: str | datetime | Timestamp | None | Missing = MISSING,
-        reason: str | None = None,
-    ) -> discord_typings.GuildMemberData:
-        """
-        Modify attributes of a guild member.
-
-        Args:
-            guild_id: The ID of the guild
-            user_id: The ID of the user we're modifying
-            nickname: Value to set users nickname to
-            roles: Array of role ids the member is assigned
-            mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel
-            deaf: Whether the user is deafened in voice channels
-            channel_id: id of channel to move user to (if they are connected to voice)
-            communication_disabled_until: 	when the user's timeout will expire and the user will be able to communicate in the guild again
-            reason: An optional reason for the audit log
-
-        Returns:
-            The updated member object
-
-        """
-        if isinstance(communication_disabled_until, datetime):
-            communication_disabled_until = communication_disabled_until.isoformat()
-
-        payload: PAYLOAD_TYPE = {
-            "roles": roles,
-            "mute": mute,
-            "deaf": deaf,
-            "channel_id": int(channel_id) if channel_id else None,
-        }
-        payload = dict_filter_none(payload)
-
-        if not isinstance(nickname, Missing):
-            payload["nick"] = nickname
-        if not isinstance(communication_disabled_until, Missing):
-            payload["communication_disabled_until"] = communication_disabled_until
-
-        result = await self.request(
-            Route("PATCH", "/guilds/{guild_id}/members/{user_id}", guild_id=guild_id, user_id=user_id),
-            payload=payload,
-            reason=reason,
-        )
-        return cast(discord_typings.GuildMemberData, result)
-
-    async def modify_current_member(
-        self,
-        guild_id: "Snowflake_Type",
-        nickname: str | None | Missing = MISSING,
-        reason: str | None = None,
-    ) -> None:
-        """
-        Modify attributes of the user
-
-        Args:
-            guild_id: The ID of the guild to modify current member in
-            nickname: The new nickname to apply
-            reason: An optional reason for the audit log
-
-        """
-        payload: PAYLOAD_TYPE = {"nick": None if isinstance(nickname, Missing) else nickname}
-        await self.request(
-            Route("PATCH", "/guilds/{guild_id}/members/@me", guild_id=guild_id),
-            payload=payload,
-            reason=reason,
-        )
-
-    async def add_guild_member_role(
-        self,
-        guild_id: "Snowflake_Type",
-        user_id: "Snowflake_Type",
-        role_id: "Snowflake_Type",
-        reason: str | None = None,
-    ) -> None:
-        """
-        Adds a role to a guild member.
-
-        Args:
-            guild_id: The ID of the guild
-            user_id: The ID of the user
-            role_id: The ID of the role to add
-            reason: The reason for this action
-
-        """
-        await self.request(
-            Route(
-                "PUT",
-                "/guilds/{guild_id}/members/{user_id}/roles/{role_id}",
-                guild_id=guild_id,
-                user_id=user_id,
-                role_id=role_id,
-            ),
-            reason=reason,
-        )
-
-    async def remove_guild_member_role(
-        self,
-        guild_id: "Snowflake_Type",
-        user_id: "Snowflake_Type",
-        role_id: "Snowflake_Type",
-        reason: str | None = None,
-    ) -> None:
-        """
-        Remove a role from a guild member.
-
-        Args:
-            guild_id: The ID of the guild
-            user_id: The ID of the user
-            role_id: The ID of the role to remove
-            reason: The reason for this action
-
-        """
-        await self.request(
-            Route(
-                "DELETE",
-                "/guilds/{guild_id}/members/{user_id}/roles/{role_id}",
-                guild_id=guild_id,
-                user_id=user_id,
-                role_id=role_id,
-            ),
-            reason=reason,
-        )
+from datetime import datetime
+from typing import TYPE_CHECKING, cast
+
+import discord_typings
+
+from interactions.client.const import Missing, MISSING
+from interactions.client.utils.serializer import dict_filter_none
+from interactions.models.discord.timestamp import Timestamp
+from interactions.models.internal.protocols import CanRequest
+from ..route import Route, PAYLOAD_TYPE
+
+__all__ = ("MemberRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+
+class MemberRequests(CanRequest):
+    async def get_member(
+        self, guild_id: "Snowflake_Type", user_id: "Snowflake_Type"
+    ) -> discord_typings.GuildMemberData:
+        """
+        Get a member of a guild by ID.
+
+        Args:
+            guild_id: The id of the guild
+            user_id: The user id to grab
+
+        """
+        result = await self.request(
+            Route("GET", "/guilds/{guild_id}/members/{user_id}", guild_id=guild_id, user_id=user_id)
+        )
+        return cast(discord_typings.GuildMemberData, result)
+
+    async def list_members(
+        self, guild_id: "Snowflake_Type", limit: int = 1, after: "Snowflake_Type | None" = None
+    ) -> list[discord_typings.GuildMemberData]:
+        """
+        List the members of a guild.
+
+        Args:
+            guild_id: The ID of the guild
+            limit: How many members to get (max 1000)
+            after: Get IDs after this snowflake
+
+        """
+        payload: PAYLOAD_TYPE = {
+            "limit": limit,
+            "after": int(after) if after else None,
+        }
+        payload = dict_filter_none(payload)
+
+        result = await self.request(Route("GET", "/guilds/{guild_id}/members", guild_id=guild_id), params=payload)
+        return cast(list[discord_typings.GuildMemberData], result)
+
+    async def search_guild_members(
+        self, guild_id: "Snowflake_Type", query: str, limit: int = 1
+    ) -> list[discord_typings.GuildMemberData]:
+        """
+        Search a guild for members who's username or nickname starts with provided string.
+
+        Args:
+            guild_id: The ID of the guild to search
+            query: The string to search for
+            limit: The number of members to return
+
+        """
+        result = await self.request(
+            Route("GET", "/guilds/{guild_id}/members/search", guild_id=guild_id),
+            params={"query": query, "limit": limit},
+        )
+        return cast(list[discord_typings.GuildMemberData], result)
+
+    async def modify_guild_member(
+        self,
+        guild_id: "Snowflake_Type",
+        user_id: "Snowflake_Type",
+        nickname: str | None | Missing = MISSING,
+        roles: list["Snowflake_Type"] | None = None,
+        mute: bool | None = None,
+        deaf: bool | None = None,
+        channel_id: "Snowflake_Type | MISSING" = MISSING,
+        communication_disabled_until: str | datetime | Timestamp | None | Missing = MISSING,
+        reason: str | None = None,
+    ) -> discord_typings.GuildMemberData:
+        """
+        Modify attributes of a guild member.
+
+        Args:
+            guild_id: The ID of the guild
+            user_id: The ID of the user we're modifying
+            nickname: Value to set users nickname to
+            roles: Array of role ids the member is assigned
+            mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel
+            deaf: Whether the user is deafened in voice channels
+            channel_id: id of channel to move user to (if they are connected to voice)
+            communication_disabled_until: 	when the user's timeout will expire and the user will be able to communicate in the guild again
+            reason: An optional reason for the audit log
+
+        Returns:
+            The updated member object
+
+        """
+        if isinstance(communication_disabled_until, datetime):
+            communication_disabled_until = communication_disabled_until.isoformat()
+
+        payload: PAYLOAD_TYPE = {
+            "roles": roles,
+            "mute": mute,
+            "deaf": deaf,
+        }
+        payload = dict_filter_none(payload)
+        if channel_id is not MISSING:
+            payload["channel_id"] = channel_id
+
+        if not isinstance(nickname, Missing):
+            payload["nick"] = nickname
+        if not isinstance(communication_disabled_until, Missing):
+            payload["communication_disabled_until"] = communication_disabled_until
+
+        result = await self.request(
+            Route("PATCH", "/guilds/{guild_id}/members/{user_id}", guild_id=guild_id, user_id=user_id),
+            payload=payload,
+            reason=reason,
+        )
+        return cast(discord_typings.GuildMemberData, result)
+
+    async def modify_current_member(
+        self,
+        guild_id: "Snowflake_Type",
+        nickname: str | None | Missing = MISSING,
+        reason: str | None = None,
+    ) -> None:
+        """
+        Modify attributes of the user
+
+        Args:
+            guild_id: The ID of the guild to modify current member in
+            nickname: The new nickname to apply
+            reason: An optional reason for the audit log
+
+        """
+        payload: PAYLOAD_TYPE = {"nick": None if isinstance(nickname, Missing) else nickname}
+        await self.request(
+            Route("PATCH", "/guilds/{guild_id}/members/@me", guild_id=guild_id),
+            payload=payload,
+            reason=reason,
+        )
+
+    async def add_guild_member_role(
+        self,
+        guild_id: "Snowflake_Type",
+        user_id: "Snowflake_Type",
+        role_id: "Snowflake_Type",
+        reason: str | None = None,
+    ) -> None:
+        """
+        Adds a role to a guild member.
+
+        Args:
+            guild_id: The ID of the guild
+            user_id: The ID of the user
+            role_id: The ID of the role to add
+            reason: The reason for this action
+
+        """
+        await self.request(
+            Route(
+                "PUT",
+                "/guilds/{guild_id}/members/{user_id}/roles/{role_id}",
+                guild_id=guild_id,
+                user_id=user_id,
+                role_id=role_id,
+            ),
+            reason=reason,
+        )
+
+    async def remove_guild_member_role(
+        self,
+        guild_id: "Snowflake_Type",
+        user_id: "Snowflake_Type",
+        role_id: "Snowflake_Type",
+        reason: str | None = None,
+    ) -> None:
+        """
+        Remove a role from a guild member.
+
+        Args:
+            guild_id: The ID of the guild
+            user_id: The ID of the user
+            role_id: The ID of the role to remove
+            reason: The reason for this action
+
+        """
+        await self.request(
+            Route(
+                "DELETE",
+                "/guilds/{guild_id}/members/{user_id}/roles/{role_id}",
+                guild_id=guild_id,
+                user_id=user_id,
+                role_id=role_id,
+            ),
+            reason=reason,
+        )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/messages.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/messages.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,177 +1,177 @@
-from typing import TYPE_CHECKING, cast
-
-import discord_typings
-
-from interactions.models.internal.protocols import CanRequest
-from ..route import Route
-
-__all__ = ("MessageRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-    from interactions import UPLOADABLE_TYPE
-
-
-class MessageRequests(CanRequest):
-    async def create_message(
-        self,
-        payload: dict,
-        channel_id: "Snowflake_Type",
-        files: list["UPLOADABLE_TYPE"] | None = None,  # todo type payload
-    ) -> discord_typings.MessageData:
-        """
-        Send a message to the specified channel.
-
-        Args:
-            payload: The message to send
-            channel_id: id of the channel to send message in
-            files: Any files to send with this message
-
-        Returns:
-            The resulting message object
-
-        """
-        result = await self.request(
-            Route("POST", "/channels/{channel_id}/messages", channel_id=channel_id), payload=payload, files=files
-        )
-        return cast(discord_typings.MessageData, result)
-
-    async def delete_message(
-        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", reason: str | None = None
-    ) -> None:
-        """
-        Deletes a message from the specified channel.
-
-        Args:
-            channel_id: The id of the channel to delete the message from
-            message_id: The id of the message to delete
-            reason: The reason for this action
-
-        """
-        await self.request(
-            Route(
-                "DELETE", "/channels/{channel_id}/messages/{message_id}", channel_id=channel_id, message_id=message_id
-            ),
-            reason=reason,
-        )
-
-    async def bulk_delete_messages(
-        self,
-        channel_id: "Snowflake_Type",
-        message_ids: list["Snowflake_Type"],
-        reason: str | None = None,
-    ) -> None:
-        """
-        Delete multiple messages in a single request.
-
-        Args:
-            channel_id: The id of the channel these messages are in
-            message_ids: A list of message ids to delete
-            reason: The reason for this action
-
-        """
-        payload = {"messages": [int(message_id) for message_id in message_ids]}
-
-        await self.request(
-            Route("POST", "/channels/{channel_id}/messages/bulk-delete", channel_id=channel_id),
-            payload=payload,
-            reason=reason,
-        )
-
-    async def get_message(
-        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type"
-    ) -> discord_typings.MessageData:
-        """
-        Get a specific message in the channel. Returns a message object on success.
-
-        Args:
-            channel_id: the channel this message belongs to
-            message_id: the id of the message
-
-        Returns:
-            message or None
-
-        """
-        result = await self.request(
-            Route("GET", "/channels/{channel_id}/messages/{message_id}", channel_id=channel_id, message_id=message_id)
-        )
-        return cast(discord_typings.MessageData, result)
-
-    async def pin_message(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type") -> None:
-        """
-        Pin a message to a channel.
-
-        Args:
-            channel_id: Channel to pin message to
-            message_id: Message to pin
-
-        """
-        await self.request(
-            Route("PUT", "/channels/{channel_id}/pins/{message_id}", channel_id=channel_id, message_id=message_id)
-        )
-
-    async def unpin_message(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type") -> None:
-        """
-        Unpin a message to a channel.
-
-        Args:
-            channel_id: Channel to unpin message to
-            message_id: Message to unpin
-
-        """
-        await self.request(
-            Route("DELETE", "/channels/{channel_id}/pins/{message_id}", channel_id=channel_id, message_id=message_id)
-        )
-
-    async def edit_message(
-        self,
-        payload: dict,
-        channel_id: "Snowflake_Type",
-        message_id: "Snowflake_Type",
-        files: list["UPLOADABLE_TYPE"] | None = None,
-    ) -> discord_typings.MessageData:
-        """
-        Edit an existing message.
-
-        Args:
-            payload:
-            channel_id: Channel of message to edit.
-            message_id: Message to edit.
-            files: Any files to send with this message
-
-        Returns:
-            Message object of edited message
-
-        """
-        result = await self.request(
-            Route(
-                "PATCH", "/channels/{channel_id}/messages/{message_id}", channel_id=channel_id, message_id=message_id
-            ),
-            payload=payload,
-            files=files,
-        )
-        return cast(discord_typings.MessageData, result)
-
-    async def crosspost_message(
-        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type"
-    ) -> discord_typings.MessageData:
-        """
-        Crosspost a message in a News Channel to following channels.
-
-        Args:
-            channel_id: Channel the message is in
-            message_id: The id of the message to crosspost
-        Returns:
-            message object
-
-        """
-        result = await self.request(
-            Route(
-                "POST",
-                "/channels/{channel_id}/messages/{message_id}/crosspost",
-                channel_id=channel_id,
-                message_id=message_id,
-            )
-        )
-        return cast(discord_typings.MessageData, result)
+from typing import TYPE_CHECKING, cast
+
+import discord_typings
+
+from interactions.models.internal.protocols import CanRequest
+from ..route import Route
+
+__all__ = ("MessageRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+    from interactions import UPLOADABLE_TYPE
+
+
+class MessageRequests(CanRequest):
+    async def create_message(
+        self,
+        payload: dict,
+        channel_id: "Snowflake_Type",
+        files: list["UPLOADABLE_TYPE"] | None = None,  # todo type payload
+    ) -> discord_typings.MessageData:
+        """
+        Send a message to the specified channel.
+
+        Args:
+            payload: The message to send
+            channel_id: id of the channel to send message in
+            files: Any files to send with this message
+
+        Returns:
+            The resulting message object
+
+        """
+        result = await self.request(
+            Route("POST", "/channels/{channel_id}/messages", channel_id=channel_id), payload=payload, files=files
+        )
+        return cast(discord_typings.MessageData, result)
+
+    async def delete_message(
+        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", reason: str | None = None
+    ) -> None:
+        """
+        Deletes a message from the specified channel.
+
+        Args:
+            channel_id: The id of the channel to delete the message from
+            message_id: The id of the message to delete
+            reason: The reason for this action
+
+        """
+        await self.request(
+            Route(
+                "DELETE", "/channels/{channel_id}/messages/{message_id}", channel_id=channel_id, message_id=message_id
+            ),
+            reason=reason,
+        )
+
+    async def bulk_delete_messages(
+        self,
+        channel_id: "Snowflake_Type",
+        message_ids: list["Snowflake_Type"],
+        reason: str | None = None,
+    ) -> None:
+        """
+        Delete multiple messages in a single request.
+
+        Args:
+            channel_id: The id of the channel these messages are in
+            message_ids: A list of message ids to delete
+            reason: The reason for this action
+
+        """
+        payload = {"messages": [int(message_id) for message_id in message_ids]}
+
+        await self.request(
+            Route("POST", "/channels/{channel_id}/messages/bulk-delete", channel_id=channel_id),
+            payload=payload,
+            reason=reason,
+        )
+
+    async def get_message(
+        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type"
+    ) -> discord_typings.MessageData:
+        """
+        Get a specific message in the channel. Returns a message object on success.
+
+        Args:
+            channel_id: the channel this message belongs to
+            message_id: the id of the message
+
+        Returns:
+            message or None
+
+        """
+        result = await self.request(
+            Route("GET", "/channels/{channel_id}/messages/{message_id}", channel_id=channel_id, message_id=message_id)
+        )
+        return cast(discord_typings.MessageData, result)
+
+    async def pin_message(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type") -> None:
+        """
+        Pin a message to a channel.
+
+        Args:
+            channel_id: Channel to pin message to
+            message_id: Message to pin
+
+        """
+        await self.request(
+            Route("PUT", "/channels/{channel_id}/pins/{message_id}", channel_id=channel_id, message_id=message_id)
+        )
+
+    async def unpin_message(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type") -> None:
+        """
+        Unpin a message to a channel.
+
+        Args:
+            channel_id: Channel to unpin message to
+            message_id: Message to unpin
+
+        """
+        await self.request(
+            Route("DELETE", "/channels/{channel_id}/pins/{message_id}", channel_id=channel_id, message_id=message_id)
+        )
+
+    async def edit_message(
+        self,
+        payload: dict,
+        channel_id: "Snowflake_Type",
+        message_id: "Snowflake_Type",
+        files: list["UPLOADABLE_TYPE"] | None = None,
+    ) -> discord_typings.MessageData:
+        """
+        Edit an existing message.
+
+        Args:
+            payload:
+            channel_id: Channel of message to edit.
+            message_id: Message to edit.
+            files: Any files to send with this message
+
+        Returns:
+            Message object of edited message
+
+        """
+        result = await self.request(
+            Route(
+                "PATCH", "/channels/{channel_id}/messages/{message_id}", channel_id=channel_id, message_id=message_id
+            ),
+            payload=payload,
+            files=files,
+        )
+        return cast(discord_typings.MessageData, result)
+
+    async def crosspost_message(
+        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type"
+    ) -> discord_typings.MessageData:
+        """
+        Crosspost a message in a News Channel to following channels.
+
+        Args:
+            channel_id: Channel the message is in
+            message_id: The id of the message to crosspost
+        Returns:
+            message object
+
+        """
+        result = await self.request(
+            Route(
+                "POST",
+                "/channels/{channel_id}/messages/{message_id}/crosspost",
+                channel_id=channel_id,
+                message_id=message_id,
+            )
+        )
+        return cast(discord_typings.MessageData, result)
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/reactions.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/reactions.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,158 +1,158 @@
-from typing import TYPE_CHECKING, Any, List
-
-import discord_typings
-
-from interactions.client.const import MISSING, Absent
-from interactions.models.discord.snowflake import to_snowflake
-from ..route import Route
-
-__all__ = ("ReactionRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-
-class ReactionRequests:
-    request: Any
-
-    async def create_reaction(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", emoji: str) -> None:
-        """
-        Create a reaction for a message.
-
-        Args:
-            channel_id: The channel this is taking place in
-            message_id: The message to create a a reaction on
-            emoji: The emoji to use (format: `name:id`)
-
-        """
-        return await self.request(
-            Route(
-                "PUT",
-                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me",
-                channel_id=channel_id,
-                message_id=message_id,
-                emoji=emoji,
-            )
-        )
-
-    async def remove_self_reaction(
-        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", emoji: str
-    ) -> None:
-        """
-        Remove client's reaction from a message.
-
-        Args:
-            channel_id: The channel this is taking place in.
-            message_id: The message to remove the reaction on.
-            emoji: The emoji to remove. (format: `name:id`)
-
-        """
-        return await self.request(
-            Route(
-                "DELETE",
-                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me",
-                channel_id=channel_id,
-                message_id=message_id,
-                emoji=emoji,
-            )
-        )
-
-    async def remove_user_reaction(
-        self,
-        channel_id: "Snowflake_Type",
-        message_id: "Snowflake_Type",
-        emoji: str,
-        user_id: "Snowflake_Type",
-    ) -> None:
-        """
-        Remove user's reaction from a message.
-
-        Args:
-            channel_id: The channel this is taking place in
-            message_id: The message to remove the reaction on.
-            emoji: The emoji to remove. (format: `name:id`)
-            user_id: The user to remove reaction of.
-
-        """
-        return await self.request(
-            Route(
-                "DELETE",
-                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/{user_id}",
-                channel_id=channel_id,
-                message_id=message_id,
-                emoji=emoji,
-                user_id=user_id,
-            )
-        )
-
-    async def clear_reaction(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", emoji: str) -> None:
-        """
-        Remove specific reaction from a message.
-
-        Args:
-            channel_id: The channel this is taking place in.
-            message_id: The message to remove the reaction on.
-            emoji: The emoji to remove. (format: `name:id`)
-
-        """
-        return await self.request(
-            Route(
-                "DELETE",
-                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}",
-                channel_id=channel_id,
-                message_id=message_id,
-                emoji=emoji,
-            )
-        )
-
-    async def clear_reactions(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type") -> None:
-        """
-        Remove reactions from a message.
-
-        Args:
-            channel_id: The channel this is taking place in.
-            message_id: The message to clear reactions from.
-
-        """
-        return await self.request(
-            Route(
-                "DELETE",
-                "/channels/{channel_id}/messages/{message_id}/reactions",
-                channel_id=channel_id,
-                message_id=message_id,
-            )
-        )
-
-    async def get_reactions(
-        self,
-        channel_id: "Snowflake_Type",
-        message_id: "Snowflake_Type",
-        emoji: str,
-        limit: Absent[int] = MISSING,
-        after: "Snowflake_Type" = MISSING,
-    ) -> List[discord_typings.UserData]:
-        """
-        Gets specific reaction from a message.
-
-        Args:
-            channel_id: The channel this is taking place in.
-            message_id: The message to get the reaction.
-            emoji: The emoji to get. (format: `name:id`)
-            limit: max number of entries to get
-            after: snowflake to get entries after
-
-        Returns:
-            List of users who reacted with the emoji.
-
-        """
-        return await self.request(
-            Route(
-                "GET",
-                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}",
-                channel_id=to_snowflake(channel_id),
-                message_id=to_snowflake(message_id),
-                emoji=emoji,
-            ),
-            params={"limit": limit, "after": after},
-        )
+from typing import TYPE_CHECKING, Any, List
+
+import discord_typings
+
+from interactions.client.const import MISSING, Absent
+from interactions.models.discord.snowflake import to_snowflake
+from ..route import Route
+
+__all__ = ("ReactionRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+
+class ReactionRequests:
+    request: Any
+
+    async def create_reaction(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", emoji: str) -> None:
+        """
+        Create a reaction for a message.
+
+        Args:
+            channel_id: The channel this is taking place in
+            message_id: The message to create a a reaction on
+            emoji: The emoji to use (format: `name:id`)
+
+        """
+        return await self.request(
+            Route(
+                "PUT",
+                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me",
+                channel_id=channel_id,
+                message_id=message_id,
+                emoji=emoji,
+            )
+        )
+
+    async def remove_self_reaction(
+        self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", emoji: str
+    ) -> None:
+        """
+        Remove client's reaction from a message.
+
+        Args:
+            channel_id: The channel this is taking place in.
+            message_id: The message to remove the reaction on.
+            emoji: The emoji to remove. (format: `name:id`)
+
+        """
+        return await self.request(
+            Route(
+                "DELETE",
+                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me",
+                channel_id=channel_id,
+                message_id=message_id,
+                emoji=emoji,
+            )
+        )
+
+    async def remove_user_reaction(
+        self,
+        channel_id: "Snowflake_Type",
+        message_id: "Snowflake_Type",
+        emoji: str,
+        user_id: "Snowflake_Type",
+    ) -> None:
+        """
+        Remove user's reaction from a message.
+
+        Args:
+            channel_id: The channel this is taking place in
+            message_id: The message to remove the reaction on.
+            emoji: The emoji to remove. (format: `name:id`)
+            user_id: The user to remove reaction of.
+
+        """
+        return await self.request(
+            Route(
+                "DELETE",
+                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/{user_id}",
+                channel_id=channel_id,
+                message_id=message_id,
+                emoji=emoji,
+                user_id=user_id,
+            )
+        )
+
+    async def clear_reaction(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type", emoji: str) -> None:
+        """
+        Remove specific reaction from a message.
+
+        Args:
+            channel_id: The channel this is taking place in.
+            message_id: The message to remove the reaction on.
+            emoji: The emoji to remove. (format: `name:id`)
+
+        """
+        return await self.request(
+            Route(
+                "DELETE",
+                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}",
+                channel_id=channel_id,
+                message_id=message_id,
+                emoji=emoji,
+            )
+        )
+
+    async def clear_reactions(self, channel_id: "Snowflake_Type", message_id: "Snowflake_Type") -> None:
+        """
+        Remove reactions from a message.
+
+        Args:
+            channel_id: The channel this is taking place in.
+            message_id: The message to clear reactions from.
+
+        """
+        return await self.request(
+            Route(
+                "DELETE",
+                "/channels/{channel_id}/messages/{message_id}/reactions",
+                channel_id=channel_id,
+                message_id=message_id,
+            )
+        )
+
+    async def get_reactions(
+        self,
+        channel_id: "Snowflake_Type",
+        message_id: "Snowflake_Type",
+        emoji: str,
+        limit: Absent[int] = MISSING,
+        after: "Snowflake_Type" = MISSING,
+    ) -> List[discord_typings.UserData]:
+        """
+        Gets specific reaction from a message.
+
+        Args:
+            channel_id: The channel this is taking place in.
+            message_id: The message to get the reaction.
+            emoji: The emoji to get. (format: `name:id`)
+            limit: max number of entries to get
+            after: snowflake to get entries after
+
+        Returns:
+            List of users who reacted with the emoji.
+
+        """
+        return await self.request(
+            Route(
+                "GET",
+                "/channels/{channel_id}/messages/{message_id}/reactions/{emoji}",
+                channel_id=to_snowflake(channel_id),
+                message_id=to_snowflake(message_id),
+                emoji=emoji,
+            ),
+            params={"limit": limit, "after": after},
+        )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/scheduled_events.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/scheduled_events.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,179 +1,179 @@
-from typing import Any, TYPE_CHECKING, List
-
-import discord_typings
-
-from interactions.client.const import MISSING, Absent
-from ..route import Route
-
-__all__ = ("ScheduledEventsRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-
-class ScheduledEventsRequests:
-    request: Any
-
-    async def list_schedules_events(
-        self, guild_id: "Snowflake_Type", with_user_count: bool = False
-    ) -> List[discord_typings.GuildScheduledEventData]:
-        """
-        Get the scheduled events for a guild.
-
-        Args:
-            guild_id: The guild to get scheduled events from
-            with_user_count: Whether to include the user count in the response
-        Returns:
-            List of Scheduled Events or None
-
-        """
-        return await self.request(
-            Route(
-                "GET",
-                "/guilds/{guild_id}/scheduled-events?with_user_count={with_user_count}",
-                guild_id=guild_id,
-                with_user_count=with_user_count,
-            )
-        )
-
-    async def get_scheduled_event(
-        self,
-        guild_id: "Snowflake_Type",
-        scheduled_event_id: "Snowflake_Type",
-        with_user_count: bool = False,
-    ) -> discord_typings.GuildScheduledEventData:
-        """
-        Get a scheduled event for a guild.
-
-        Args:
-            guild_id: The guild to get scheduled event from
-            scheduled_event_id: The target scheduled event to fetch
-            with_user_count: Whether to include the user count in the response
-
-        Returns:
-            Scheduled Event or None
-
-        """
-        return await self.request(
-            Route(
-                "GET",
-                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}",
-                guild_id=guild_id,
-                scheduled_event_id=scheduled_event_id,
-            ),
-            params={"with_user_count": with_user_count},
-        )
-
-    async def create_scheduled_event(
-        self,
-        guild_id: "Snowflake_Type",
-        payload: dict,
-        reason: Absent[str] = MISSING,
-    ) -> discord_typings.GuildScheduledEventData:
-        """
-        Create a scheduled event for a guild.
-
-        Args:
-            guild_id: The guild to create scheduled event from
-            payload: The scheduled event payload
-            reason: The reason to be displayed in audit logs
-
-        Returns:
-            Scheduled Event or None
-
-        """
-        return await self.request(
-            Route("POST", "/guilds/{guild_id}/scheduled-events", guild_id=guild_id), payload=payload, reason=reason
-        )
-
-    async def modify_scheduled_event(
-        self,
-        guild_id: "Snowflake_Type",
-        scheduled_event_id: "Snowflake_Type",
-        payload: dict,
-        reason: Absent[str] = MISSING,
-    ) -> discord_typings.GuildScheduledEventData:
-        """
-        Modify a scheduled event for a guild.
-
-        Args:
-            guild_id: The guild to modify scheduled event from
-            scheduled_event_id: The scheduled event to modify
-            payload: The payload to modify the scheduled event with
-            reason: The reason to be displayed in audit logs
-
-        Returns:
-            Scheduled Event or None
-
-        """
-        return await self.request(
-            Route(
-                "PATCH",
-                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}",
-                guild_id=guild_id,
-                scheduled_event_id=scheduled_event_id,
-            ),
-            payload=payload,
-            reason=reason,
-        )
-
-    async def delete_scheduled_event(
-        self,
-        guild_id: "Snowflake_Type",
-        scheduled_event_id: "Snowflake_Type",
-        reason: Absent[str] = MISSING,
-    ) -> None:
-        """
-        Delete a scheduled event for a guild.
-
-        Args:
-            guild_id: The guild to delete scheduled event from
-            scheduled_event_id: The scheduled event to delete
-            reason: The reason to be displayed in audit logs
-
-        """
-        return await self.request(
-            Route(
-                "DELETE",
-                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}",
-                guild_id=guild_id,
-                scheduled_event_id=scheduled_event_id,
-            ),
-            reason=reason,
-        )
-
-    async def get_scheduled_event_users(
-        self,
-        guild_id: "Snowflake_Type",
-        scheduled_event_id: "Snowflake_Type",
-        limit: int = 100,
-        with_member: bool = False,
-        before: "Snowflake_Type" = MISSING,
-        after: "Snowflake_Type" = MISSING,
-    ) -> List[discord_typings.GuildScheduledEventUserData]:
-        """
-        Get the users for a scheduled event.
-
-        Args:
-            guild_id: The guild to get scheduled event users from
-            scheduled_event_id: The scheduled event to get users from
-            limit: how many users to receive from the event
-            with_member: include guild member data if it exists
-            before: consider only users before given user id
-            after: consider only users after given user id
-
-        Returns:
-            List of Scheduled Event Users or None
-
-        """
-        params = {"limit": limit, "with_member": with_member, "before": before, "after": after}
-        return await self.request(
-            Route(
-                "GET",
-                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}/users",
-                guild_id=guild_id,
-                scheduled_event_id=scheduled_event_id,
-            ),
-            params=params,
-        )
+from typing import Any, TYPE_CHECKING, List
+
+import discord_typings
+
+from interactions.client.const import MISSING, Absent
+from ..route import Route
+
+__all__ = ("ScheduledEventsRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+
+class ScheduledEventsRequests:
+    request: Any
+
+    async def list_schedules_events(
+        self, guild_id: "Snowflake_Type", with_user_count: bool = False
+    ) -> List[discord_typings.GuildScheduledEventData]:
+        """
+        Get the scheduled events for a guild.
+
+        Args:
+            guild_id: The guild to get scheduled events from
+            with_user_count: Whether to include the user count in the response
+        Returns:
+            List of Scheduled Events or None
+
+        """
+        return await self.request(
+            Route(
+                "GET",
+                "/guilds/{guild_id}/scheduled-events?with_user_count={with_user_count}",
+                guild_id=guild_id,
+                with_user_count=with_user_count,
+            )
+        )
+
+    async def get_scheduled_event(
+        self,
+        guild_id: "Snowflake_Type",
+        scheduled_event_id: "Snowflake_Type",
+        with_user_count: bool = False,
+    ) -> discord_typings.GuildScheduledEventData:
+        """
+        Get a scheduled event for a guild.
+
+        Args:
+            guild_id: The guild to get scheduled event from
+            scheduled_event_id: The target scheduled event to fetch
+            with_user_count: Whether to include the user count in the response
+
+        Returns:
+            Scheduled Event or None
+
+        """
+        return await self.request(
+            Route(
+                "GET",
+                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}",
+                guild_id=guild_id,
+                scheduled_event_id=scheduled_event_id,
+            ),
+            params={"with_user_count": with_user_count},
+        )
+
+    async def create_scheduled_event(
+        self,
+        guild_id: "Snowflake_Type",
+        payload: dict,
+        reason: Absent[str] = MISSING,
+    ) -> discord_typings.GuildScheduledEventData:
+        """
+        Create a scheduled event for a guild.
+
+        Args:
+            guild_id: The guild to create scheduled event from
+            payload: The scheduled event payload
+            reason: The reason to be displayed in audit logs
+
+        Returns:
+            Scheduled Event or None
+
+        """
+        return await self.request(
+            Route("POST", "/guilds/{guild_id}/scheduled-events", guild_id=guild_id), payload=payload, reason=reason
+        )
+
+    async def modify_scheduled_event(
+        self,
+        guild_id: "Snowflake_Type",
+        scheduled_event_id: "Snowflake_Type",
+        payload: dict,
+        reason: Absent[str] = MISSING,
+    ) -> discord_typings.GuildScheduledEventData:
+        """
+        Modify a scheduled event for a guild.
+
+        Args:
+            guild_id: The guild to modify scheduled event from
+            scheduled_event_id: The scheduled event to modify
+            payload: The payload to modify the scheduled event with
+            reason: The reason to be displayed in audit logs
+
+        Returns:
+            Scheduled Event or None
+
+        """
+        return await self.request(
+            Route(
+                "PATCH",
+                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}",
+                guild_id=guild_id,
+                scheduled_event_id=scheduled_event_id,
+            ),
+            payload=payload,
+            reason=reason,
+        )
+
+    async def delete_scheduled_event(
+        self,
+        guild_id: "Snowflake_Type",
+        scheduled_event_id: "Snowflake_Type",
+        reason: Absent[str] = MISSING,
+    ) -> None:
+        """
+        Delete a scheduled event for a guild.
+
+        Args:
+            guild_id: The guild to delete scheduled event from
+            scheduled_event_id: The scheduled event to delete
+            reason: The reason to be displayed in audit logs
+
+        """
+        return await self.request(
+            Route(
+                "DELETE",
+                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}",
+                guild_id=guild_id,
+                scheduled_event_id=scheduled_event_id,
+            ),
+            reason=reason,
+        )
+
+    async def get_scheduled_event_users(
+        self,
+        guild_id: "Snowflake_Type",
+        scheduled_event_id: "Snowflake_Type",
+        limit: int = 100,
+        with_member: bool = False,
+        before: "Snowflake_Type" = MISSING,
+        after: "Snowflake_Type" = MISSING,
+    ) -> List[discord_typings.GuildScheduledEventUserData]:
+        """
+        Get the users for a scheduled event.
+
+        Args:
+            guild_id: The guild to get scheduled event users from
+            scheduled_event_id: The scheduled event to get users from
+            limit: how many users to receive from the event
+            with_member: include guild member data if it exists
+            before: consider only users before given user id
+            after: consider only users after given user id
+
+        Returns:
+            List of Scheduled Event Users or None
+
+        """
+        params = {"limit": limit, "with_member": with_member, "before": before, "after": after}
+        return await self.request(
+            Route(
+                "GET",
+                "/guilds/{guild_id}/scheduled-events/{scheduled_event_id}/users",
+                guild_id=guild_id,
+                scheduled_event_id=scheduled_event_id,
+            ),
+            params=params,
+        )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/http_requests/users.py` & `discord-py-interactions-5.6.0/interactions/api/http/http_requests/users.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,144 +1,144 @@
-from typing import TYPE_CHECKING, Any, List
-
-import discord_typings
-
-from ..route import Route
-
-__all__ = ("UserRequests",)
-
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-
-class UserRequests:
-    request: Any
-
-    async def get_current_user(self) -> discord_typings.UserData:
-        """
-        Shortcut to get requester's user.
-
-        Returns:
-            The user object.
-
-        """
-        return await self.get_user("@me")
-
-    async def get_user(self, user_id: "Snowflake_Type") -> discord_typings.UserData:
-        """
-        Get a user object for a given user ID.
-
-        Args:
-            user_id: The user to get.
-
-        Returns:
-            The user object.
-
-        """
-        return await self.request(Route("GET", "/users/{user_id}", user_id=user_id))
-
-    async def modify_client_user(self, payload: dict) -> discord_typings.UserData:
-        """
-        Modify the user account settings.
-
-        Args:
-            payload: The data to send.
-
-        """
-        return await self.request(Route("PATCH", "/users/@me"), payload=payload)
-
-    async def get_user_guilds(self) -> List[discord_typings.GuildData]:
-        """
-        Returns a list of partial guild objects the current user is a member of.
-
-        Requires the guilds OAuth2 scope.
-
-        """
-        return await self.request(Route("GET", "/users/@me/guilds"))
-
-    async def leave_guild(self, guild_id: "Snowflake_Type") -> None:
-        """
-        Leave a guild. Returns a 204 empty response on success.
-
-        Args:
-            guild_id: The guild to leave from.
-
-        """
-        return await self.request(Route("DELETE", "/users/@me/guilds/{guild_id}", guild_id=guild_id))
-
-    async def create_dm(self, recipient_id: "Snowflake_Type") -> discord_typings.DMChannelData:
-        """
-        Create a new DM channel with a user. Returns a DM channel object.
-
-        Args:
-            recipient_id: The recipient to open a DM channel with.
-
-        """
-        return await self.request(Route("POST", "/users/@me/channels"), payload={"recipient_id": recipient_id})
-
-    async def create_group_dm(self, payload: dict) -> discord_typings.GroupDMChannelData:
-        """
-        Create a new group DM channel with multiple users.
-
-        Args:
-            payload: The data to send.
-
-        """
-        return await self.request(Route("POST", "/users/@me/channels"), payload=payload)
-
-    async def get_user_connections(self) -> list:
-        """
-        Returns a list of connection objects.
-
-        Requires the connections OAuth2 scope.
-
-        """
-        return await self.request(Route("GET", "/users/@me/connections"))
-
-    async def group_dm_add_recipient(
-        self,
-        channel_id: "Snowflake_Type",
-        user_id: "Snowflake_Type",
-        access_token: str,
-        nick: str = None,
-    ) -> None:
-        """
-        Adds a recipient to a Group DM using their access token.
-
-        Args:
-            channel_id: The ID of the group dm
-            user_id: The ID of the user to add
-            access_token: Access token of a user that has granted your app the gdm.join scope
-            nick: Nickname of the user being added
-
-        """
-        return await self.request(
-            Route("PUT", "/channels/{channel_id}/recipients/{user_id}", channel_id=channel_id, user_id=user_id),
-            payload={"access_token": access_token, "nick": nick},
-        )
-
-    async def group_dm_remove_recipient(self, channel_id: "Snowflake_Type", user_id: "Snowflake_Type") -> None:
-        """
-        Remove a recipient from the group dm.
-
-        Args:
-            channel_id: The ID of the group dm
-            user_id: The ID of the user to remove
-
-        """
-        return await self.request(
-            Route("DELETE", "/channels/{channel_id}/recipients/{user_id}", channel_id=channel_id, user_id=user_id)
-        )
-
-    async def modify_current_user_nick(self, guild_id: "Snowflake_Type", nickname: str = None) -> None:
-        """
-        Modifies the nickname of the current user in a guild.
-
-        Args:
-            guild_id: The ID of the guild
-            nickname: The new nickname to use
-
-        """
-        return await self.request(
-            Route("PATCH", "/guilds/{guild_id}/members/@me/nick", guild_id=guild_id), payload={"nick": nickname}
-        )
+from typing import TYPE_CHECKING, Any, List
+
+import discord_typings
+
+from ..route import Route
+
+__all__ = ("UserRequests",)
+
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+
+class UserRequests:
+    request: Any
+
+    async def get_current_user(self) -> discord_typings.UserData:
+        """
+        Shortcut to get requester's user.
+
+        Returns:
+            The user object.
+
+        """
+        return await self.get_user("@me")
+
+    async def get_user(self, user_id: "Snowflake_Type") -> discord_typings.UserData:
+        """
+        Get a user object for a given user ID.
+
+        Args:
+            user_id: The user to get.
+
+        Returns:
+            The user object.
+
+        """
+        return await self.request(Route("GET", "/users/{user_id}", user_id=user_id))
+
+    async def modify_client_user(self, payload: dict) -> discord_typings.UserData:
+        """
+        Modify the user account settings.
+
+        Args:
+            payload: The data to send.
+
+        """
+        return await self.request(Route("PATCH", "/users/@me"), payload=payload)
+
+    async def get_user_guilds(self) -> List[discord_typings.GuildData]:
+        """
+        Returns a list of partial guild objects the current user is a member of.
+
+        Requires the guilds OAuth2 scope.
+
+        """
+        return await self.request(Route("GET", "/users/@me/guilds"))
+
+    async def leave_guild(self, guild_id: "Snowflake_Type") -> None:
+        """
+        Leave a guild. Returns a 204 empty response on success.
+
+        Args:
+            guild_id: The guild to leave from.
+
+        """
+        return await self.request(Route("DELETE", "/users/@me/guilds/{guild_id}", guild_id=guild_id))
+
+    async def create_dm(self, recipient_id: "Snowflake_Type") -> discord_typings.DMChannelData:
+        """
+        Create a new DM channel with a user. Returns a DM channel object.
+
+        Args:
+            recipient_id: The recipient to open a DM channel with.
+
+        """
+        return await self.request(Route("POST", "/users/@me/channels"), payload={"recipient_id": recipient_id})
+
+    async def create_group_dm(self, payload: dict) -> discord_typings.GroupDMChannelData:
+        """
+        Create a new group DM channel with multiple users.
+
+        Args:
+            payload: The data to send.
+
+        """
+        return await self.request(Route("POST", "/users/@me/channels"), payload=payload)
+
+    async def get_user_connections(self) -> list:
+        """
+        Returns a list of connection objects.
+
+        Requires the connections OAuth2 scope.
+
+        """
+        return await self.request(Route("GET", "/users/@me/connections"))
+
+    async def group_dm_add_recipient(
+        self,
+        channel_id: "Snowflake_Type",
+        user_id: "Snowflake_Type",
+        access_token: str,
+        nick: str = None,
+    ) -> None:
+        """
+        Adds a recipient to a Group DM using their access token.
+
+        Args:
+            channel_id: The ID of the group dm
+            user_id: The ID of the user to add
+            access_token: Access token of a user that has granted your app the gdm.join scope
+            nick: Nickname of the user being added
+
+        """
+        return await self.request(
+            Route("PUT", "/channels/{channel_id}/recipients/{user_id}", channel_id=channel_id, user_id=user_id),
+            payload={"access_token": access_token, "nick": nick},
+        )
+
+    async def group_dm_remove_recipient(self, channel_id: "Snowflake_Type", user_id: "Snowflake_Type") -> None:
+        """
+        Remove a recipient from the group dm.
+
+        Args:
+            channel_id: The ID of the group dm
+            user_id: The ID of the user to remove
+
+        """
+        return await self.request(
+            Route("DELETE", "/channels/{channel_id}/recipients/{user_id}", channel_id=channel_id, user_id=user_id)
+        )
+
+    async def modify_current_user_nick(self, guild_id: "Snowflake_Type", nickname: str = None) -> None:
+        """
+        Modifies the nickname of the current user in a guild.
+
+        Args:
+            guild_id: The ID of the guild
+            nickname: The new nickname to use
+
+        """
+        return await self.request(
+            Route("PATCH", "/guilds/{guild_id}/members/@me/nick", guild_id=guild_id), payload={"nick": nickname}
+        )
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/http/route.py` & `discord-py-interactions-5.6.0/interactions/api/http/route.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,90 +1,90 @@
-from typing import TYPE_CHECKING, Any, ClassVar, Optional
-from urllib.parse import quote as _uriquote
-
-from interactions.client.const import __api_version__
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-__all__ = ("Route", "PAYLOAD_TYPE")
-
-PAYLOAD_TYPE = dict[str, int | str | bool | list | None]
-
-
-class Route:
-    BASE: ClassVar[str] = f"https://discord.com/api/v{__api_version__}"
-    path: str
-    params: dict[str, str | int]
-
-    webhook_id: Optional["Snowflake_Type"]
-    webhook_token: Optional[str]
-
-    def __init__(self, method: str, path: str, **parameters: Any) -> None:
-        self.path: str = path
-        self.method: str = method
-        self.params = parameters
-
-        self.channel_id = parameters.get("channel_id")
-        self.guild_id = parameters.get("guild_id")
-        self.webhook_id = parameters.get("webhook_id")
-        self.webhook_token = parameters.get("webhook_token")
-
-        self.known_bucket: Optional[str] = None
-
-    def __eq__(self, other: "Route") -> bool:
-        if isinstance(other, Route):
-            return self.rl_bucket == other.rl_bucket
-        return NotImplemented
-
-    def __hash__(self) -> int:
-        return hash(self.rl_bucket)
-
-    def __repr__(self) -> str:
-        return f"<Route {self.endpoint}>"
-
-    def __str__(self) -> str:
-        return self.endpoint
-
-    @property
-    def rl_bucket(self) -> str:
-        """This route's full rate limit bucket"""
-        if self.known_bucket:
-            return self.known_bucket
-
-        if self.webhook_token:
-            return f"{self.webhook_id}{self.webhook_token}:{self.channel_id}:{self.guild_id}:{self.endpoint}"
-        return f"{self.channel_id}:{self.guild_id}:{self.endpoint}"
-
-    @property
-    def major_params(self) -> dict[str, str | int]:
-        """The major parameters for this route"""
-        return {
-            "channel_id": self.channel_id,
-            "guild_id": self.guild_id,
-            "webhook_id": self.webhook_id,
-            "webhook_token": self.webhook_token,
-        }
-
-    @property
-    def resolved_path(self) -> str:
-        """The endpoint for this route, with all parameters resolved"""
-        return self.path.format_map({k: _uriquote(v) if isinstance(v, str) else v for k, v in self.params.items()})
-
-    @property
-    def endpoint(self) -> str:
-        """The endpoint for this route"""
-        return f"{self.method} {self.path}"
-
-    @property
-    def resolved_endpoint(self) -> str:
-        """The endpoint for this route, with all major parameters resolved"""
-        path = self.path
-        for key, value in self.major_params.items():
-            path = path.replace(f"{{{key}}}", str(value))
-
-        return f"{self.method} {path}"
-
-    @property
-    def url(self) -> str:
-        """The full url for this route"""
-        return f"{self.BASE}{self.resolved_path}"
+from typing import TYPE_CHECKING, Any, ClassVar, Optional
+from urllib.parse import quote as _uriquote
+
+from interactions.client.const import __api_version__
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+__all__ = ("Route", "PAYLOAD_TYPE")
+
+PAYLOAD_TYPE = dict[str, int | str | bool | list | None]
+
+
+class Route:
+    BASE: ClassVar[str] = f"https://discord.com/api/v{__api_version__}"
+    path: str
+    params: dict[str, str | int]
+
+    webhook_id: Optional["Snowflake_Type"]
+    webhook_token: Optional[str]
+
+    def __init__(self, method: str, path: str, **parameters: Any) -> None:
+        self.path: str = path
+        self.method: str = method
+        self.params = parameters
+
+        self.channel_id = parameters.get("channel_id")
+        self.guild_id = parameters.get("guild_id")
+        self.webhook_id = parameters.get("webhook_id")
+        self.webhook_token = parameters.get("webhook_token")
+
+        self.known_bucket: Optional[str] = None
+
+    def __eq__(self, other: "Route") -> bool:
+        if isinstance(other, Route):
+            return self.rl_bucket == other.rl_bucket
+        return NotImplemented
+
+    def __hash__(self) -> int:
+        return hash(self.rl_bucket)
+
+    def __repr__(self) -> str:
+        return f"<Route {self.endpoint}>"
+
+    def __str__(self) -> str:
+        return self.endpoint
+
+    @property
+    def rl_bucket(self) -> str:
+        """This route's full rate limit bucket"""
+        if self.known_bucket:
+            return self.known_bucket
+
+        if self.webhook_token:
+            return f"{self.webhook_id}{self.webhook_token}:{self.channel_id}:{self.guild_id}:{self.endpoint}"
+        return f"{self.channel_id}:{self.guild_id}:{self.endpoint}"
+
+    @property
+    def major_params(self) -> dict[str, str | int]:
+        """The major parameters for this route"""
+        return {
+            "channel_id": self.channel_id,
+            "guild_id": self.guild_id,
+            "webhook_id": self.webhook_id,
+            "webhook_token": self.webhook_token,
+        }
+
+    @property
+    def resolved_path(self) -> str:
+        """The endpoint for this route, with all parameters resolved"""
+        return self.path.format_map({k: _uriquote(v) if isinstance(v, str) else v for k, v in self.params.items()})
+
+    @property
+    def endpoint(self) -> str:
+        """The endpoint for this route"""
+        return f"{self.method} {self.path}"
+
+    @property
+    def resolved_endpoint(self) -> str:
+        """The endpoint for this route, with all major parameters resolved"""
+        path = self.path
+        for key, value in self.major_params.items():
+            path = path.replace(f"{{{key}}}", str(value))
+
+        return f"{self.method} {path}"
+
+    @property
+    def url(self) -> str:
+        """The full url for this route"""
+        return f"{self.BASE}{self.resolved_path}"
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/voice/encryption.py` & `discord-py-interactions-5.6.0/interactions/api/voice/encryption.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,108 +1,108 @@
-import struct
-
-__all__ = ("Encryption",)
-
-from abc import ABC, abstractmethod
-
-try:
-    from nacl import secret, utils
-
-    nacl_imported = True
-except ImportError:
-    nacl_imported = False
-
-
-class Crypt(ABC):
-    SUPPORTED = (
-        "xsalsa20_poly1305_lite",
-        "xsalsa20_poly1305_suffix",
-        "xsalsa20_poly1305",
-    )
-
-    def __init__(self, secret_key) -> None:
-        if not nacl_imported:
-            raise RuntimeError("Please install interactions[voice] to use voice components.")
-        self.box: secret.SecretBox = secret.SecretBox(bytes(secret_key))
-
-        self._xsalsa20_poly1305_lite_nonce: int = 0
-
-    @abstractmethod
-    def xsalsa20_poly1305_lite(self, header: bytes, data) -> bytes:
-        raise NotImplementedError
-
-    @abstractmethod
-    def xsalsa20_poly1305_suffix(self, header: bytes, data) -> bytes:
-        raise NotImplementedError
-
-    @abstractmethod
-    def xsalsa20_poly1305(self, header: bytes, data) -> bytes:
-        raise NotImplementedError
-
-
-class Encryption(Crypt):
-    def encrypt(self, mode: str, header: bytes, data) -> bytes:
-        match mode:
-            case "xsalsa20_poly1305_lite":
-                return self.xsalsa20_poly1305_lite(header, data)
-            case "xsalsa20_poly1305_suffix":
-                return self.xsalsa20_poly1305_suffix(header, data)
-            case "xsalsa20_poly1305":
-                return self.xsalsa20_poly1305(header, data)
-            case _:
-                raise RuntimeError(f"Unsupported encryption type requested: {mode}")
-
-    def xsalsa20_poly1305_lite(self, header: bytes, data) -> bytes:
-        nonce = bytearray(24)
-        nonce[:4] = struct.pack(">I", self._xsalsa20_poly1305_lite_nonce)
-
-        self._xsalsa20_poly1305_lite_nonce += 1
-        if self._xsalsa20_poly1305_lite_nonce > 2**32:
-            self._xsalsa20_poly1305_lite_nonce = 0
-
-        return header + self.box.encrypt(bytes(data), bytes(nonce)).ciphertext + nonce[:4]
-
-    def xsalsa20_poly1305_suffix(self, header: bytes, data) -> bytes:
-        nonce = utils.random(secret.SecretBox.NONCE_SIZE)
-        return header + self.box.encrypt(bytes(data), nonce).ciphertext + nonce
-
-    def xsalsa20_poly1305(self, header: bytes, data) -> bytes:
-        nonce = bytearray(24)
-        nonce[:12] = header
-
-        return header + self.box.encrypt(bytes(data), bytes(nonce)).ciphertext
-
-
-class Decryption(Crypt):
-    def decrypt(self, mode: str, header: bytes, data) -> bytes:
-        match mode:
-            case "xsalsa20_poly1305_lite":
-                return self.xsalsa20_poly1305_lite(header, data)
-            case "xsalsa20_poly1305_suffix":
-                return self.xsalsa20_poly1305_suffix(header, data)
-            case "xsalsa20_poly1305":
-                return self.xsalsa20_poly1305(header, data)
-            case _:
-                raise RuntimeError(f"Unsupported decryption type requested: {mode}")
-
-    def xsalsa20_poly1305_lite(self, header: bytes, data) -> bytes:
-        nonce = bytearray(24)
-        nonce[:4] = data[-4:]
-        data = data[:-4]
-
-        if data[0] == 0xBE and data[1] == 0xDE and len(data) > 4:
-            _, length = struct.unpack_from(">HH", data)
-            offset = 4 + length * 4
-            data = data[offset:]
-
-        return self.box.decrypt(bytes(data), bytes(nonce))
-
-    def xsalsa20_poly1305_suffix(self, header: bytes, data) -> bytes:
-        nonce = data[-24:]
-
-        return self.box.decrypt(bytes(data[:-24]), bytes(nonce))
-
-    def xsalsa20_poly1305(self, header: bytes, data) -> bytes:
-        nonce = bytearray(24)
-        nonce[:12] = header
-
-        return self.box.decrypt(bytes(data), bytes(nonce))
+import struct
+
+__all__ = ("Encryption",)
+
+from abc import ABC, abstractmethod
+
+try:
+    from nacl import secret, utils
+
+    nacl_imported = True
+except ImportError:
+    nacl_imported = False
+
+
+class Crypt(ABC):
+    SUPPORTED = (
+        "xsalsa20_poly1305_lite",
+        "xsalsa20_poly1305_suffix",
+        "xsalsa20_poly1305",
+    )
+
+    def __init__(self, secret_key) -> None:
+        if not nacl_imported:
+            raise RuntimeError("Please install interactions[voice] to use voice components.")
+        self.box: secret.SecretBox = secret.SecretBox(bytes(secret_key))
+
+        self._xsalsa20_poly1305_lite_nonce: int = 0
+
+    @abstractmethod
+    def xsalsa20_poly1305_lite(self, header: bytes, data) -> bytes:
+        raise NotImplementedError
+
+    @abstractmethod
+    def xsalsa20_poly1305_suffix(self, header: bytes, data) -> bytes:
+        raise NotImplementedError
+
+    @abstractmethod
+    def xsalsa20_poly1305(self, header: bytes, data) -> bytes:
+        raise NotImplementedError
+
+
+class Encryption(Crypt):
+    def encrypt(self, mode: str, header: bytes, data) -> bytes:
+        match mode:
+            case "xsalsa20_poly1305_lite":
+                return self.xsalsa20_poly1305_lite(header, data)
+            case "xsalsa20_poly1305_suffix":
+                return self.xsalsa20_poly1305_suffix(header, data)
+            case "xsalsa20_poly1305":
+                return self.xsalsa20_poly1305(header, data)
+            case _:
+                raise RuntimeError(f"Unsupported encryption type requested: {mode}")
+
+    def xsalsa20_poly1305_lite(self, header: bytes, data) -> bytes:
+        nonce = bytearray(24)
+        nonce[:4] = struct.pack(">I", self._xsalsa20_poly1305_lite_nonce)
+
+        self._xsalsa20_poly1305_lite_nonce += 1
+        if self._xsalsa20_poly1305_lite_nonce > 2**32:
+            self._xsalsa20_poly1305_lite_nonce = 0
+
+        return header + self.box.encrypt(bytes(data), bytes(nonce)).ciphertext + nonce[:4]
+
+    def xsalsa20_poly1305_suffix(self, header: bytes, data) -> bytes:
+        nonce = utils.random(secret.SecretBox.NONCE_SIZE)
+        return header + self.box.encrypt(bytes(data), nonce).ciphertext + nonce
+
+    def xsalsa20_poly1305(self, header: bytes, data) -> bytes:
+        nonce = bytearray(24)
+        nonce[:12] = header
+
+        return header + self.box.encrypt(bytes(data), bytes(nonce)).ciphertext
+
+
+class Decryption(Crypt):
+    def decrypt(self, mode: str, header: bytes, data) -> bytes:
+        match mode:
+            case "xsalsa20_poly1305_lite":
+                return self.xsalsa20_poly1305_lite(header, data)
+            case "xsalsa20_poly1305_suffix":
+                return self.xsalsa20_poly1305_suffix(header, data)
+            case "xsalsa20_poly1305":
+                return self.xsalsa20_poly1305(header, data)
+            case _:
+                raise RuntimeError(f"Unsupported decryption type requested: {mode}")
+
+    def xsalsa20_poly1305_lite(self, header: bytes, data) -> bytes:
+        nonce = bytearray(24)
+        nonce[:4] = data[-4:]
+        data = data[:-4]
+
+        if data[0] == 0xBE and data[1] == 0xDE and len(data) > 4:
+            _, length = struct.unpack_from(">HH", data)
+            offset = 4 + length * 4
+            data = data[offset:]
+
+        return self.box.decrypt(bytes(data), bytes(nonce))
+
+    def xsalsa20_poly1305_suffix(self, header: bytes, data) -> bytes:
+        nonce = data[-24:]
+
+        return self.box.decrypt(bytes(data[:-24]), bytes(nonce))
+
+    def xsalsa20_poly1305(self, header: bytes, data) -> bytes:
+        nonce = bytearray(24)
+        nonce[:12] = header
+
+        return self.box.decrypt(bytes(data), bytes(nonce))
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/voice/player.py` & `discord-py-interactions-5.6.0/interactions/api/voice/player.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,151 +1,151 @@
-import asyncio
-import contextlib
-import shutil
-import subprocess
-import threading
-from asyncio import AbstractEventLoop, run_coroutine_threadsafe
-from logging import Logger
-from time import sleep, perf_counter
-from typing import Optional, TYPE_CHECKING
-
-from interactions.api.voice.audio import BaseAudio, AudioVolume
-from interactions.api.voice.opus import Encoder
-
-if TYPE_CHECKING:
-    from interactions.models.internal.active_voice_state import ActiveVoiceState
-__all__ = ("Player",)
-
-
-class Player(threading.Thread):
-    def __init__(self, audio, v_state, loop) -> None:
-        super().__init__()
-        self.daemon = True
-
-        self.current_audio: Optional[BaseAudio] = audio
-        self.state: "ActiveVoiceState" = v_state
-        self.loop: AbstractEventLoop = loop
-        self.logger: Logger = self.state.ws.logger
-
-        self._encoder: Encoder = Encoder()
-
-        self._resume: threading.Event = threading.Event()
-
-        self._stop_event: threading.Event = threading.Event()
-        self._stopped: asyncio.Event = asyncio.Event()
-
-        self._sent_payloads: int = 0
-
-        self._cond = threading.Condition()
-
-        if not shutil.which("ffmpeg"):
-            raise RuntimeError(
-                "Unable to start player. FFmpeg was not found. Please add it to your project directory or PATH. (https://ffmpeg.org/)"
-            )
-        ffmpeg_version = subprocess.check_output(["ffmpeg", "-version"], stderr=subprocess.DEVNULL)
-        ffmpeg_version = ffmpeg_version.decode("utf-8").splitlines()[0].split(" ")[2]
-        self.logger.debug(f"Detected ffmpeg version: {ffmpeg_version}")
-
-    def __enter__(self) -> "Player":
-        self.state.ws.cond = self._cond
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
-        with contextlib.suppress(AttributeError):
-            self.state.ws.cond = None
-
-    def stop(self) -> None:
-        """Stop playing completely."""
-        self._stop_event.set()
-        with self._cond:
-            self._cond.notify()
-
-    def resume(self) -> None:
-        """Resume playing."""
-        self._resume.set()
-        with self._cond:
-            self._cond.notify()
-
-    @property
-    def paused(self) -> bool:
-        """Is the player paused"""
-        return not self._resume.is_set()
-
-    def pause(self) -> None:
-        """Pause the player."""
-        self._resume.clear()
-
-    @property
-    def stopped(self) -> bool:
-        """Is the player currently stopped?"""
-        return self._stopped.is_set()
-
-    @property
-    def elapsed_time(self) -> float:
-        """How many seconds of audio the player has sent."""
-        return self._sent_payloads * self._encoder.delay
-
-    def play(self) -> None:
-        """Start playing."""
-        self._stop_event.clear()
-        self._resume.set()
-        self.start()
-
-    def run(self) -> None:
-        """The main player loop to send audio to the voice websocket."""
-        loops = 0
-
-        if isinstance(self.current_audio, AudioVolume):
-            # noinspection PyProtectedMember
-            self.current_audio.volume = self.state._volume
-
-        self.current_audio.encoder = self._encoder
-        self._encoder.set_bitrate(getattr(self.current_audio, "bitrate", self.state.channel.bitrate))
-
-        self._stopped.clear()
-
-        asyncio.run_coroutine_threadsafe(self.state.ws.speaking(True), self.loop)
-        self.logger.debug(f"Now playing {self.current_audio!r}")
-        start = None
-
-        try:
-            while not self._stop_event.is_set():
-                if not self.state.ws.ready.is_set() or not self._resume.is_set():
-                    run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)
-                    self.logger.debug("Voice playback has been suspended!")
-
-                    wait_for = []
-
-                    if not self.state.ws.ready.is_set():
-                        wait_for.append(self.state.ws.ready)
-                    if not self._resume.is_set():
-                        wait_for.append(self._resume)
-
-                    with self._cond:
-                        while not (self._stop_event.is_set() or all(x.is_set() for x in wait_for)):
-                            self._cond.wait()
-                    if self._stop_event.is_set():
-                        continue
-
-                    run_coroutine_threadsafe(self.state.ws.speaking(), self.loop)
-                    self.logger.debug("Voice playback has been resumed!")
-                    start = None
-                    loops = 0
-
-                if data := self.current_audio.read(self._encoder.frame_size):
-                    self.state.ws.send_packet(data, self._encoder, needs_encode=self.current_audio.needs_encode)
-                elif self.current_audio.locked_stream or not self.current_audio.audio_complete:
-                    # if more audio is expected
-                    self.state.ws.send_packet(b"\xF8\xFF\xFE", self._encoder, needs_encode=False)
-                else:
-                    break
-
-                if not start:
-                    start = perf_counter()
-
-                loops += 1
-                self._sent_payloads += 1  # used for duration calc
-                sleep(max(0.0, start + (self._encoder.delay * loops) - perf_counter()))
-        finally:
-            asyncio.run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)
-            self.current_audio.cleanup()
-            self.loop.call_soon_threadsafe(self._stopped.set)
+import asyncio
+import contextlib
+import shutil
+import subprocess
+import threading
+from asyncio import AbstractEventLoop, run_coroutine_threadsafe
+from logging import Logger
+from time import sleep, perf_counter
+from typing import Optional, TYPE_CHECKING
+
+from interactions.api.voice.audio import BaseAudio, AudioVolume
+from interactions.api.voice.opus import Encoder
+
+if TYPE_CHECKING:
+    from interactions.models.internal.active_voice_state import ActiveVoiceState
+__all__ = ("Player",)
+
+
+class Player(threading.Thread):
+    def __init__(self, audio, v_state, loop) -> None:
+        super().__init__()
+        self.daemon = True
+
+        self.current_audio: Optional[BaseAudio] = audio
+        self.state: "ActiveVoiceState" = v_state
+        self.loop: AbstractEventLoop = loop
+        self.logger: Logger = self.state.ws.logger
+
+        self._encoder: Encoder = Encoder()
+
+        self._resume: threading.Event = threading.Event()
+
+        self._stop_event: threading.Event = threading.Event()
+        self._stopped: asyncio.Event = asyncio.Event()
+
+        self._sent_payloads: int = 0
+
+        self._cond = threading.Condition()
+
+        if not shutil.which("ffmpeg"):
+            raise RuntimeError(
+                "Unable to start player. FFmpeg was not found. Please add it to your project directory or PATH. (https://ffmpeg.org/)"
+            )
+        ffmpeg_version = subprocess.check_output(["ffmpeg", "-version"], stderr=subprocess.DEVNULL)
+        ffmpeg_version = ffmpeg_version.decode("utf-8").splitlines()[0].split(" ")[2]
+        self.logger.debug(f"Detected ffmpeg version: {ffmpeg_version}")
+
+    def __enter__(self) -> "Player":
+        self.state.ws.cond = self._cond
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
+        with contextlib.suppress(AttributeError):
+            self.state.ws.cond = None
+
+    def stop(self) -> None:
+        """Stop playing completely."""
+        self._stop_event.set()
+        with self._cond:
+            self._cond.notify()
+
+    def resume(self) -> None:
+        """Resume playing."""
+        self._resume.set()
+        with self._cond:
+            self._cond.notify()
+
+    @property
+    def paused(self) -> bool:
+        """Is the player paused"""
+        return not self._resume.is_set()
+
+    def pause(self) -> None:
+        """Pause the player."""
+        self._resume.clear()
+
+    @property
+    def stopped(self) -> bool:
+        """Is the player currently stopped?"""
+        return self._stopped.is_set()
+
+    @property
+    def elapsed_time(self) -> float:
+        """How many seconds of audio the player has sent."""
+        return self._sent_payloads * self._encoder.delay
+
+    def play(self) -> None:
+        """Start playing."""
+        self._stop_event.clear()
+        self._resume.set()
+        self.start()
+
+    def run(self) -> None:
+        """The main player loop to send audio to the voice websocket."""
+        loops = 0
+
+        if isinstance(self.current_audio, AudioVolume):
+            # noinspection PyProtectedMember
+            self.current_audio.volume = self.state._volume
+
+        self.current_audio.encoder = self._encoder
+        self._encoder.set_bitrate(getattr(self.current_audio, "bitrate", self.state.channel.bitrate))
+
+        self._stopped.clear()
+
+        asyncio.run_coroutine_threadsafe(self.state.ws.speaking(True), self.loop)
+        self.logger.debug(f"Now playing {self.current_audio!r}")
+        start = None
+
+        try:
+            while not self._stop_event.is_set():
+                if not self.state.ws.ready.is_set() or not self._resume.is_set():
+                    run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)
+                    self.logger.debug("Voice playback has been suspended!")
+
+                    wait_for = []
+
+                    if not self.state.ws.ready.is_set():
+                        wait_for.append(self.state.ws.ready)
+                    if not self._resume.is_set():
+                        wait_for.append(self._resume)
+
+                    with self._cond:
+                        while not (self._stop_event.is_set() or all(x.is_set() for x in wait_for)):
+                            self._cond.wait()
+                    if self._stop_event.is_set():
+                        continue
+
+                    run_coroutine_threadsafe(self.state.ws.speaking(), self.loop)
+                    self.logger.debug("Voice playback has been resumed!")
+                    start = None
+                    loops = 0
+
+                if data := self.current_audio.read(self._encoder.frame_size):
+                    self.state.ws.send_packet(data, self._encoder, needs_encode=self.current_audio.needs_encode)
+                elif self.current_audio.locked_stream or not self.current_audio.audio_complete:
+                    # if more audio is expected
+                    self.state.ws.send_packet(b"\xF8\xFF\xFE", self._encoder, needs_encode=False)
+                else:
+                    break
+
+                if not start:
+                    start = perf_counter()
+
+                loops += 1
+                self._sent_payloads += 1  # used for duration calc
+                sleep(max(0.0, start + (self._encoder.delay * loops) - perf_counter()))
+        finally:
+            asyncio.run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)
+            self.current_audio.cleanup()
+            self.loop.call_soon_threadsafe(self._stopped.set)
```

### Comparing `discord-py-interactions-5.5.1/interactions/api/voice/voice_gateway.py` & `discord-py-interactions-5.6.0/interactions/api/voice/voice_gateway.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,410 +1,412 @@
-import asyncio
-import random
-import socket
-import struct
-import threading
-import time
-from enum import IntEnum
-from threading import Event
-
-import select
-from aiohttp import WSMsgType
-
-from interactions.api.gateway.websocket import WebsocketClient
-from interactions.api.voice.encryption import Encryption
-from interactions.client.const import MISSING
-from interactions.client.errors import VoiceWebSocketClosed
-from interactions.client.utils.input_utils import FastJson
-
-__all__ = ("VoiceGateway",)
-
-
-class OP(IntEnum):
-    IDENTIFY = 0
-    SELECT_PROTOCOL = 1
-    READY = 2
-    HEARTBEAT = 3
-    SESSION_DESCRIPTION = 4
-    SPEAKING = 5
-    HEARTBEAT_ACK = 6
-    RESUME = 7
-    HELLO = 8
-    RESUMED = 9
-    CLIENT_DISCONNECT = 13
-
-
-class VoiceGateway(WebsocketClient):
-    guild_id: str
-    heartbeat_interval: int
-    session_id: str
-    token: str
-    encryptor: Encryption
-
-    ssrc: int
-    me_ip: str
-    me_port: int
-    voice_ip: str
-    voice_port: int
-    voice_modes: list[str]
-    selected_mode: str
-    socket: socket.socket
-    ready: Event
-
-    def __init__(self, state, voice_state: dict, voice_server: dict) -> None:
-        super().__init__(state)
-
-        self._voice_server_update = asyncio.Event()
-        self.ws_url = f"wss://{voice_server['endpoint']}?v=4"
-        self.session_id = voice_state["session_id"]
-        self.token = voice_server["token"]
-        self.secret: str | None = None
-        self.guild_id = voice_server["guild_id"]
-
-        self.sock_sequence = 0
-        self.timestamp = 0
-        self.ready = Event()
-        self.user_ssrc_map = {}
-        self.cond = None
-
-        self._udp_ka = threading.Thread(target=self._udp_keep_alive, daemon=True)
-
-    async def wait_until_ready(self) -> None:
-        await asyncio.to_thread(self.ready.wait)
-
-    async def run(self) -> None:
-        """Start receiving events from the websocket."""
-        while True:
-            if self._stopping is None:
-                self._stopping = asyncio.create_task(self._close_gateway.wait())
-            receiving = asyncio.create_task(self.receive())
-            done, _ = await asyncio.wait({self._stopping, receiving}, return_when=asyncio.FIRST_COMPLETED)
-
-            if receiving in done:
-                # Note that we check for a received message first, because if both completed at
-                # the same time, we don't want to discard that message.
-                msg = await receiving
-            else:
-                # This has to be the stopping task, which we join into the current task (even
-                # though that doesn't give any meaningful value in the return).
-                await self._stopping
-                receiving.cancel()
-                return
-
-            op = msg.get("op")
-            data = msg.get("d")
-            if seq := msg.get("s"):
-                self.sequence = seq
-
-            # This may try to reconnect the connection so it is best to wait
-            # for it to complete before receiving more - that way there's less
-            # possible race conditions to consider.
-            await self.dispatch_opcode(data, op)
-
-    async def receive(self, force=False) -> str:  # noqa: C901
-        buffer = bytearray()
-
-        while True:
-            if not force:
-                await self._closed.wait()
-
-            resp = await self.ws.receive()
-
-            if resp.type == WSMsgType.CLOSE:
-                self.logger.debug(f"Disconnecting from voice gateway! Reason: {resp.data}::{resp.extra}")
-                if resp.data in (4006, 4009, 4014, 4015):
-                    # these are all recoverable close codes, anything else means we're foobared
-                    # codes: session expired, session timeout, disconnected, server crash
-                    self.ready.clear()
-                    # docs state only resume on 4015
-                    await self.reconnect(resume=resp.data == 4015)
-                    continue
-                raise VoiceWebSocketClosed(resp.data)
-
-            if resp.type is WSMsgType.CLOSED:
-                if force:
-                    raise RuntimeError("Discord unexpectedly closed the underlying socket during force receive!")
-
-                if not self._closed.is_set():
-                    # Because we are waiting for the even before we receive, this shouldn't be
-                    # possible - the CLOSING message should be returned instead. Either way, if this
-                    # is possible after all we can just wait for the event to be set.
-                    await self._closed.wait()
-                else:
-                    # This is an odd corner-case where the underlying socket connection was closed
-                    # unexpectedly without communicating the WebSocket closing handshake. We'll have
-                    # to reconnect ourselves.
-                    await self.reconnect(resume=True)
-
-            elif resp.type is WSMsgType.CLOSING:
-                if force:
-                    raise RuntimeError("WebSocket is unexpectedly closing during force receive!")
-
-                # This happens when the keep-alive handler is reconnecting the connection even
-                # though we waited for the event before hand, because it got to run while we waited
-                # for data to come in. We can just wait for the event again.
-                await self._closed.wait()
-                continue
-
-            if resp.data is None:
-                continue
-
-            if isinstance(resp.data, bytes):
-                buffer.extend(resp.data)
-
-                if len(resp.data) < 4 or resp.data[-4:] != b"\x00\x00\xff\xff":
-                    # message isn't complete yet, wait
-                    continue
-
-                msg = self._zlib.decompress(buffer)
-                msg = msg.decode("utf-8")
-            else:
-                msg = resp.data
-
-            try:
-                msg = FastJson.loads(msg)
-            except Exception as e:
-                self.logger.error(e)
-
-            return msg
-
-    async def dispatch_opcode(self, data, op) -> None:
-        match op:
-            case OP.HEARTBEAT_ACK:
-                self._latency.append(time.perf_counter() - self._last_heartbeat)
-
-                if self._last_heartbeat != 0 and self._latency[-1] >= 15:
-                    self.logger.warning(
-                        f"High Latency! Voice heartbeat took {self._latency[-1]:.1f}s to be acknowledged!"
-                    )
-                else:
-                    self.logger.debug(f"❤ Heartbeat acknowledged after {self._latency[-1]:.5f} seconds")
-
-                return self._acknowledged.set()
-
-            case OP.READY:
-                self.logger.debug("Discord send VC Ready! Establishing a socket connection...")
-                self.voice_ip = data["ip"]
-                self.voice_port = data["port"]
-                self.ssrc = data["ssrc"]
-                self.voice_modes = [mode for mode in data["modes"] if mode in Encryption.SUPPORTED]
-
-                if not self.voice_modes:
-                    self.logger.critical("NO VOICE ENCRYPTION MODES SHARED WITH GATEWAY!")
-
-                await self.establish_voice_socket()
-
-            case OP.SESSION_DESCRIPTION:
-                self.logger.info(f"Voice connection established; using {data['mode']}")
-                self.selected_mode = data["mode"]
-                self.secret = data["secret_key"]
-                self.encryptor = Encryption(self.secret)
-                self.ready.set()
-                if self.cond:
-                    with self.cond:
-                        self.cond.notify()
-            case OP.SPEAKING:
-                self.user_ssrc_map[data["ssrc"]] = {"user_id": int(data["user_id"]), "speaking": data["speaking"]}
-            case OP.CLIENT_DISCONNECT:
-                self.logger.debug(
-                    f"User {data['user_id']} has disconnected from voice, ssrc ({self.user_ssrc_map.pop(data['user_id'], MISSING)}) invalidated"
-                )
-
-            case _:
-                return self.logger.debug(f"Unhandled OPCODE: {op} = {data = }")
-
-    async def reconnect(self, *, resume: bool = False, code: int = 1012) -> None:
-        async with self._race_lock:
-            self._closed.clear()
-
-            if self.ws is not None:
-                await self.ws.close(code=code)
-
-            self.ws = None
-
-            if not resume:
-                self.logger.debug("Waiting for updated server information...")
-                try:
-                    await asyncio.wait_for(self._voice_server_update.wait(), timeout=5)
-                except asyncio.TimeoutError:
-                    self._kill_bee_gees.set()
-                    self.close()
-                    self.logger.debug("Terminating VoiceGateway due to disconnection")
-                    return None
-
-                self._voice_server_update.clear()
-
-            self.ws = await self.state.client.http.websocket_connect(self.ws_url)
-
-            try:
-                hello = await self.receive(force=True)
-                self.heartbeat_interval = hello["d"]["heartbeat_interval"] / 1000
-            except RuntimeError:
-                # sometimes the initial connection fails with voice gateways, handle that
-                return await self.reconnect(resume=resume, code=code)
-
-            if not resume:
-                await self._identify()
-            else:
-                await self._resume_connection()
-
-            self._closed.set()
-            self._acknowledged.set()
-
-    async def _resume_connection(self) -> None:
-        if self.ws is None:
-            raise RuntimeError
-
-        payload = {
-            "op": OP.RESUME,
-            "d": {"server_id": self.guild_id, "session_id": self.session_id, "token": self.token},
-        }
-        await self.ws.send_json(payload)
-
-        if not self._udp_ka.is_alive():
-            self._udp_ka = threading.Thread(target=self._udp_keep_alive, daemon=True)
-            self._udp_ka.start()
-
-    def _udp_keep_alive(self) -> None:
-        keep_alive = b"\xc9\x00\x00\x00\x00\x00\x00\x00\x00"
-
-        self.logger.debug("Starting UDP Keep Alive")
-        while not self.socket._closed and not self.ws.closed:
-            try:
-                _, writable, _ = select.select([], [self.socket], [], 0)
-                while not writable:
-                    _, writable, _ = select.select([], [self.socket], [], 0)
-
-                # discord will never respond to this, but it helps maintain the hole punch
-                self.socket.sendto(keep_alive, (self.voice_ip, self.voice_port))
-                time.sleep(5)
-            except socket.error as e:
-                self.logger.warning(f"Ending Keep Alive due to {e}")
-                return
-            except Exception as e:
-                self.logger.debug("Keep Alive Error: ", exc_info=e)
-        self.logger.debug("Ending UDP Keep Alive")
-
-    async def establish_voice_socket(self) -> None:
-        """Establish the socket connection to discord"""
-        self.logger.debug("IP Discovery in progress...")
-
-        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
-        self.socket.setblocking(False)
-
-        packet = bytearray(74)
-        struct.pack_into(">H", packet, 0, 1)  # 1 = Send
-        struct.pack_into(">H", packet, 2, 70)  # 70 = Length
-        struct.pack_into(">I", packet, 4, self.ssrc)
-
-        self.socket.sendto(packet, (self.voice_ip, self.voice_port))
-        resp = await self.loop.sock_recv(self.socket, 74)
-        self.logger.debug(f"Voice Initial Response Received: {resp}")
-
-        ip_start = 8
-        ip_end = resp.index(0, ip_start)
-        self.me_ip = resp[ip_start:ip_end].decode("ascii")
-
-        self.me_port = struct.unpack_from(">H", resp, len(resp) - 2)[0]
-        self.logger.debug(f"IP Discovered: {self.me_ip} #{self.me_port}")
-
-        await self._select_protocol()
-
-        if not self._udp_ka.is_alive():
-            self._udp_ka = threading.Thread(target=self._udp_keep_alive, daemon=True)
-            self._udp_ka.start()
-
-    def generate_packet(self, data: bytes) -> bytes:
-        """Generate a packet to be sent to the voice socket."""
-        header = bytearray(12)
-        header[0] = 0x80
-        header[1] = 0x78
-
-        struct.pack_into(">H", header, 2, self.sock_sequence)
-        struct.pack_into(">I", header, 4, self.timestamp)
-        struct.pack_into(">I", header, 8, self.ssrc)
-
-        return self.encryptor.encrypt(self.voice_modes[0], header, data)
-
-    def send_packet(self, data: bytes, encoder, needs_encode=True) -> None:
-        """Send a packet to the voice socket"""
-        self.sock_sequence += 1
-        if self.sock_sequence > 0xFFFF:
-            self.sock_sequence = 0
-
-        if self.timestamp > 0xFFFFFFFF:
-            self.timestamp = 0
-
-        if needs_encode:
-            data = encoder.encode(data)
-        packet = self.generate_packet(data)
-
-        _, writable, _ = select.select([], [self.socket], [], 0)
-        while not writable:
-            _, writable, errored = select.select([], [self.socket], [], 0)
-            if errored:
-                self.logger.error(f"Socket errored: {errored}")
-            continue
-        self.socket.sendto(packet, (self.voice_ip, self.voice_port))
-        self.timestamp += encoder.samples_per_frame
-
-    async def send_heartbeat(self) -> None:
-        await self.send_json({"op": OP.HEARTBEAT, "d": random.uniform(0.0, 1.0)})
-        self.logger.debug("❤ Voice Connection is sending Heartbeat")
-
-    async def _identify(self) -> None:
-        """Send an identify payload to the voice gateway."""
-        payload = {
-            "op": OP.IDENTIFY,
-            "d": {
-                "server_id": self.guild_id,
-                "user_id": self.state.client.user.id,
-                "session_id": self.session_id,
-                "token": self.token,
-            },
-        }
-        serialized = FastJson.dumps(payload)
-        await self.ws.send_str(serialized)
-
-        self.logger.debug("Voice Connection has identified itself to Voice Gateway")
-
-    async def _select_protocol(self) -> None:
-        """Inform Discord of our chosen protocol."""
-        payload = {
-            "op": OP.SELECT_PROTOCOL,
-            "d": {
-                "protocol": "udp",
-                "data": {"address": self.me_ip, "port": self.me_port, "mode": self.voice_modes[0]},
-            },
-        }
-        await self.send_json(payload)
-
-    async def speaking(self, is_speaking: bool = True) -> None:
-        """
-        Tell the gateway if we're sending audio or not.
-
-        Args:
-            is_speaking: If we're sending audio or not
-
-        """
-        payload = {
-            "op": OP.SPEAKING,
-            "d": {
-                "speaking": 1 << 0 if is_speaking else 0,
-                "delay": 0,
-                "ssrc": self.ssrc,
-            },
-        }
-        await self.ws.send_json(payload)
-
-    def set_new_voice_server(self, payload: dict) -> None:
-        """
-        Set a new voice server to connect to.
-
-        Args:
-            payload: New voice server connection data
-
-        """
-        self.ws_url = f"wss://{payload['endpoint']}?v=4"
-        self.token = payload["token"]
-        self.guild_id = payload["guild_id"]
-        self._voice_server_update.set()
+import asyncio
+import random
+import socket
+import struct
+import threading
+import time
+from enum import IntEnum
+from threading import Event
+
+import select
+from aiohttp import WSMsgType
+
+from interactions.api.gateway.websocket import WebsocketClient
+from interactions.api.voice.encryption import Encryption
+from interactions.client.const import MISSING
+from interactions.client.errors import VoiceWebSocketClosed
+from interactions.client.utils.input_utils import FastJson
+
+__all__ = ("VoiceGateway",)
+
+
+class OP(IntEnum):
+    IDENTIFY = 0
+    SELECT_PROTOCOL = 1
+    READY = 2
+    HEARTBEAT = 3
+    SESSION_DESCRIPTION = 4
+    SPEAKING = 5
+    HEARTBEAT_ACK = 6
+    RESUME = 7
+    HELLO = 8
+    RESUMED = 9
+    CLIENT_DISCONNECT = 13
+
+
+class VoiceGateway(WebsocketClient):
+    guild_id: str
+    heartbeat_interval: int
+    session_id: str
+    token: str
+    encryptor: Encryption
+
+    ssrc: int
+    me_ip: str
+    me_port: int
+    voice_ip: str
+    voice_port: int
+    voice_modes: list[str]
+    selected_mode: str
+    socket: socket.socket
+    ready: Event
+
+    def __init__(self, state, voice_state: dict, voice_server: dict) -> None:
+        super().__init__(state)
+
+        self._voice_server_update = asyncio.Event()
+        self.ws_url = f"wss://{voice_server['endpoint']}?v=4"
+        self.session_id = voice_state["session_id"]
+        self.token = voice_server["token"]
+        self.secret: str | None = None
+        self.guild_id = voice_server["guild_id"]
+
+        self.sock_sequence = 0
+        self.timestamp = 0
+        self.ready = Event()
+        self.user_ssrc_map = {}
+        self.cond = None
+
+        self._udp_ka = threading.Thread(target=self._udp_keep_alive, daemon=True)
+
+    async def wait_until_ready(self) -> None:
+        await asyncio.to_thread(self.ready.wait)
+
+    async def run(self) -> None:
+        """Start receiving events from the websocket."""
+        while True:
+            if self._stopping is None:
+                self._stopping = asyncio.create_task(self._close_gateway.wait())
+            receiving = asyncio.create_task(self.receive())
+            done, _ = await asyncio.wait({self._stopping, receiving}, return_when=asyncio.FIRST_COMPLETED)
+
+            if receiving in done:
+                # Note that we check for a received message first, because if both completed at
+                # the same time, we don't want to discard that message.
+                msg = await receiving
+            else:
+                # This has to be the stopping task, which we join into the current task (even
+                # though that doesn't give any meaningful value in the return).
+                await self._stopping
+                receiving.cancel()
+                return
+
+            op = msg.get("op")
+            data = msg.get("d")
+            if seq := msg.get("s"):
+                self.sequence = seq
+
+            # This may try to reconnect the connection so it is best to wait
+            # for it to complete before receiving more - that way there's less
+            # possible race conditions to consider.
+            await self.dispatch_opcode(data, op)
+
+    async def receive(self, force=False) -> str:  # noqa: C901
+        buffer = bytearray()
+
+        while True:
+            if not force:
+                await self._closed.wait()
+
+            resp = await self.ws.receive()
+
+            if resp.type == WSMsgType.CLOSE:
+                self.logger.debug(f"Disconnecting from voice gateway! Reason: {resp.data}::{resp.extra}")
+                if resp.data in (4006, 4009, 4014, 4015):
+                    # these are all recoverable close codes, anything else means we're foobared
+                    # codes: session expired, session timeout, disconnected, server crash
+                    self.ready.clear()
+                    # docs state only resume on 4015
+                    await self.reconnect(resume=resp.data == 4015)
+                    continue
+                raise VoiceWebSocketClosed(resp.data)
+
+            if resp.type is WSMsgType.CLOSED:
+                if force:
+                    raise RuntimeError("Discord unexpectedly closed the underlying socket during force receive!")
+
+                if not self._closed.is_set():
+                    # Because we are waiting for the even before we receive, this shouldn't be
+                    # possible - the CLOSING message should be returned instead. Either way, if this
+                    # is possible after all we can just wait for the event to be set.
+                    await self._closed.wait()
+                else:
+                    # This is an odd corner-case where the underlying socket connection was closed
+                    # unexpectedly without communicating the WebSocket closing handshake. We'll have
+                    # to reconnect ourselves.
+                    await self.reconnect(resume=True)
+
+            elif resp.type is WSMsgType.CLOSING:
+                if force:
+                    raise RuntimeError("WebSocket is unexpectedly closing during force receive!")
+
+                # This happens when the keep-alive handler is reconnecting the connection even
+                # though we waited for the event before hand, because it got to run while we waited
+                # for data to come in. We can just wait for the event again.
+                await self._closed.wait()
+                continue
+
+            if resp.data is None:
+                continue
+
+            if isinstance(resp.data, bytes):
+                buffer.extend(resp.data)
+
+                if len(resp.data) < 4 or resp.data[-4:] != b"\x00\x00\xff\xff":
+                    # message isn't complete yet, wait
+                    continue
+
+                msg = self._zlib.decompress(buffer)
+                msg = msg.decode("utf-8")
+            else:
+                msg = resp.data
+
+            try:
+                msg = FastJson.loads(msg)
+            except Exception as e:
+                self.logger.error(e)
+
+            return msg
+
+    async def dispatch_opcode(self, data, op) -> None:
+        match op:
+            case OP.HEARTBEAT_ACK:
+                self._latency.append(time.perf_counter() - self._last_heartbeat)
+
+                if self._last_heartbeat != 0 and self._latency[-1] >= 15:
+                    self.logger.warning(
+                        f"High Latency! Voice heartbeat took {self._latency[-1]:.1f}s to be acknowledged!"
+                    )
+                else:
+                    self.logger.debug(f"❤ Heartbeat acknowledged after {self._latency[-1]:.5f} seconds")
+
+                return self._acknowledged.set()
+
+            case OP.READY:
+                self.logger.debug("Discord send VC Ready! Establishing a socket connection...")
+                self.voice_ip = data["ip"]
+                self.voice_port = data["port"]
+                self.ssrc = data["ssrc"]
+                self.voice_modes = [mode for mode in data["modes"] if mode in Encryption.SUPPORTED]
+
+                if not self.voice_modes:
+                    self.logger.critical("NO VOICE ENCRYPTION MODES SHARED WITH GATEWAY!")
+
+                await self.establish_voice_socket()
+
+            case OP.SESSION_DESCRIPTION:
+                self.logger.info(f"Voice connection established; using {data['mode']}")
+                self.selected_mode = data["mode"]
+                self.secret = data["secret_key"]
+                self.encryptor = Encryption(self.secret)
+                self.ready.set()
+                if self.cond:
+                    with self.cond:
+                        self.cond.notify()
+            case OP.SPEAKING:
+                self.user_ssrc_map[data["ssrc"]] = {"user_id": int(data["user_id"]), "speaking": data["speaking"]}
+            case OP.CLIENT_DISCONNECT:
+                self.logger.debug(
+                    f"User {data['user_id']} has disconnected from voice, ssrc ({self.user_ssrc_map.pop(data['user_id'], MISSING)}) invalidated"
+                )
+
+            case _:
+                return self.logger.debug(f"Unhandled OPCODE: {op} = {data = }")
+
+    async def reconnect(self, *, resume: bool = False, code: int = 1012) -> None:
+        async with self._race_lock:
+            self._closed.clear()
+
+            if self.ws is not None:
+                await self.ws.close(code=code)
+
+            self.ws = None
+
+            if not resume:
+                self.logger.debug("Waiting for updated server information...")
+                try:
+                    await asyncio.wait_for(self._voice_server_update.wait(), timeout=5)
+                except asyncio.TimeoutError:
+                    self._kill_bee_gees.set()
+                    self.close()
+                    self.logger.debug("Terminating VoiceGateway due to disconnection")
+                    return None
+
+                self._voice_server_update.clear()
+
+            self.ws = await self.state.client.http.websocket_connect(self.ws_url)
+
+            try:
+                hello = await self.receive(force=True)
+                self.heartbeat_interval = hello["d"]["heartbeat_interval"] / 1000
+            except RuntimeError:
+                # sometimes the initial connection fails with voice gateways, handle that
+                return await self.reconnect(resume=resume, code=code)
+
+            if not resume:
+                await self._identify()
+            else:
+                await self._resume_connection()
+
+            self._closed.set()
+            self._acknowledged.set()
+
+    async def _resume_connection(self) -> None:
+        if self.ws is None:
+            raise RuntimeError
+
+        payload = {
+            "op": OP.RESUME,
+            "d": {"server_id": self.guild_id, "session_id": self.session_id, "token": self.token},
+        }
+        await self.ws.send_json(payload)
+
+        if not self._udp_ka.is_alive():
+            self._udp_ka = threading.Thread(target=self._udp_keep_alive, daemon=True)
+            self._udp_ka.start()
+
+    def _udp_keep_alive(self) -> None:
+        keep_alive = b"\xc9\x00\x00\x00\x00\x00\x00\x00\x00"
+
+        self.logger.debug("Starting UDP Keep Alive")
+        while not self.socket._closed and not self.ws.closed:
+            try:
+                _, writable, _ = select.select([], [self.socket], [], 0)
+                while not writable:
+                    _, writable, _ = select.select([], [self.socket], [], 0)
+
+                # discord will never respond to this, but it helps maintain the hole punch
+                self.socket.sendto(keep_alive, (self.voice_ip, self.voice_port))
+                time.sleep(5)
+            except socket.error as e:
+                self.logger.warning(f"Ending Keep Alive due to {e}")
+                return
+            except AttributeError:
+                return
+            except Exception as e:
+                self.logger.debug("Keep Alive Error: ", exc_info=e)
+        self.logger.debug("Ending UDP Keep Alive")
+
+    async def establish_voice_socket(self) -> None:
+        """Establish the socket connection to discord"""
+        self.logger.debug("IP Discovery in progress...")
+
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        self.socket.setblocking(False)
+
+        packet = bytearray(74)
+        struct.pack_into(">H", packet, 0, 1)  # 1 = Send
+        struct.pack_into(">H", packet, 2, 70)  # 70 = Length
+        struct.pack_into(">I", packet, 4, self.ssrc)
+
+        self.socket.sendto(packet, (self.voice_ip, self.voice_port))
+        resp = await self.loop.sock_recv(self.socket, 74)
+        self.logger.debug(f"Voice Initial Response Received: {resp}")
+
+        ip_start = 8
+        ip_end = resp.index(0, ip_start)
+        self.me_ip = resp[ip_start:ip_end].decode("ascii")
+
+        self.me_port = struct.unpack_from(">H", resp, len(resp) - 2)[0]
+        self.logger.debug(f"IP Discovered: {self.me_ip} #{self.me_port}")
+
+        await self._select_protocol()
+
+        if not self._udp_ka.is_alive():
+            self._udp_ka = threading.Thread(target=self._udp_keep_alive, daemon=True)
+            self._udp_ka.start()
+
+    def generate_packet(self, data: bytes) -> bytes:
+        """Generate a packet to be sent to the voice socket."""
+        header = bytearray(12)
+        header[0] = 0x80
+        header[1] = 0x78
+
+        struct.pack_into(">H", header, 2, self.sock_sequence)
+        struct.pack_into(">I", header, 4, self.timestamp)
+        struct.pack_into(">I", header, 8, self.ssrc)
+
+        return self.encryptor.encrypt(self.voice_modes[0], header, data)
+
+    def send_packet(self, data: bytes, encoder, needs_encode=True) -> None:
+        """Send a packet to the voice socket"""
+        self.sock_sequence += 1
+        if self.sock_sequence > 0xFFFF:
+            self.sock_sequence = 0
+
+        if self.timestamp > 0xFFFFFFFF:
+            self.timestamp = 0
+
+        if needs_encode:
+            data = encoder.encode(data)
+        packet = self.generate_packet(data)
+
+        _, writable, _ = select.select([], [self.socket], [], 0)
+        while not writable:
+            _, writable, errored = select.select([], [self.socket], [], 0)
+            if errored:
+                self.logger.error(f"Socket errored: {errored}")
+            continue
+        self.socket.sendto(packet, (self.voice_ip, self.voice_port))
+        self.timestamp += encoder.samples_per_frame
+
+    async def send_heartbeat(self) -> None:
+        await self.send_json({"op": OP.HEARTBEAT, "d": random.uniform(0.0, 1.0)})
+        self.logger.debug("❤ Voice Connection is sending Heartbeat")
+
+    async def _identify(self) -> None:
+        """Send an identify payload to the voice gateway."""
+        payload = {
+            "op": OP.IDENTIFY,
+            "d": {
+                "server_id": self.guild_id,
+                "user_id": self.state.client.user.id,
+                "session_id": self.session_id,
+                "token": self.token,
+            },
+        }
+        serialized = FastJson.dumps(payload)
+        await self.ws.send_str(serialized)
+
+        self.logger.debug("Voice Connection has identified itself to Voice Gateway")
+
+    async def _select_protocol(self) -> None:
+        """Inform Discord of our chosen protocol."""
+        payload = {
+            "op": OP.SELECT_PROTOCOL,
+            "d": {
+                "protocol": "udp",
+                "data": {"address": self.me_ip, "port": self.me_port, "mode": self.voice_modes[0]},
+            },
+        }
+        await self.send_json(payload)
+
+    async def speaking(self, is_speaking: bool = True) -> None:
+        """
+        Tell the gateway if we're sending audio or not.
+
+        Args:
+            is_speaking: If we're sending audio or not
+
+        """
+        payload = {
+            "op": OP.SPEAKING,
+            "d": {
+                "speaking": 1 << 0 if is_speaking else 0,
+                "delay": 0,
+                "ssrc": self.ssrc,
+            },
+        }
+        await self.ws.send_json(payload)
+
+    def set_new_voice_server(self, payload: dict) -> None:
+        """
+        Set a new voice server to connect to.
+
+        Args:
+            payload: New voice server connection data
+
+        """
+        self.ws_url = f"wss://{payload['endpoint']}?v=4"
+        self.token = payload["token"]
+        self.guild_id = payload["guild_id"]
+        self._voice_server_update.set()
```

### Comparing `discord-py-interactions-5.5.1/interactions/bin/opus-x64.dll` & `discord-py-interactions-5.6.0/interactions/bin/opus-x64.dll`

 * *Files identical despite different names*

### Comparing `discord-py-interactions-5.5.1/interactions/bin/opus-x86.dll` & `discord-py-interactions-5.6.0/interactions/bin/opus-x86.dll`

 * *Files identical despite different names*

### Comparing `discord-py-interactions-5.5.1/interactions/client/const.py` & `discord-py-interactions-5.6.0/interactions/client/const.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,285 +1,285 @@
-"""
-Constants used throughout interactions.py.
-
-Attributes:
-    __version__ str: The version of the library.
-    __repo_url__ str: The URL of the repository.
-    __py_version__ str: The python version in use.
-    logger_name str: The name of interactions.py's default logger. Invalid if a custom logger is passed to `Client` to replace the default logger.
-    logger logging.Logger: The logger used throughout interactions.py. If a custom logger is passed to `Client`, this obj is replaced with the new logger.
-    kwarg_spam bool: Should ``unused kwargs`` be logged.
-
-    ACTION_ROW_MAX_ITEMS int: The maximum number of items in an action row.
-    SELECTS_MAX_OPTIONS int: The maximum number of options a select may have.
-    SELECT_MAX_NAME_LENGTH int: The max length of a select's name.
-
-    CONTEXT_MENU_NAME_LENGTH int: The max length of a context menu's name.
-    SLASH_CMD_NAME_LENGTH int: The max length of a slash command's name.
-    SLASH_CMD_MAX_DESC_LENGTH int: The maximum length of a slash command's description.
-    SLASH_CMD_MAX_OPTIONS int: The maximum number of options a slash command may have.
-    SLASH_OPTION_NAME_LENGTH int: The maximum length of a slash option's name.
-
-    EMBED_MAX_NAME_LENGTH int: The maximum length for an embed title
-    EMBED_MAX_DESC_LENGTH int: The maximum length for an embed description
-    EMBED_MAX_FIELDS int: The maximum number of fields for an embed
-    EMBED_TOTAL_MAX int: The total combined number of characters for an embed
-    PREMIUM_GUILD_LIMITS dict: Limits granted per premium level of a guild
-
-    GLOBAL_SCOPE _sentinel: A sentinel that represents a global scope for application commands.
-    MENTION_PREFIX _sentinel: A sentinel representing the bot will be mentioned for a prefix
-    MISSING _sentinel: A sentinel value that indicates something has not been set
-
-    T TypeVar: A type variable used for generic typing.
-    Absent Union[T, Missing]: A type hint for a value that may be MISSING.
-
-    CLIENT_FEATURE_FLAGS dict: A dict of feature flags that can be enabled or disabled for the client.
-    has_feature_flag Callable[[str], bool]: A function that returns whether a feature flag is enabled.
-
-"""
-import inspect
-import logging
-import os
-import sys
-from collections import defaultdict
-from importlib.metadata import version as _v, PackageNotFoundError
-from typing import TypeVar, Union, Callable, Coroutine
-
-__all__ = (
-    "__version__",
-    "__repo_url__",
-    "__py_version__",
-    "__api_version__",
-    "get_logger",
-    "logger_name",
-    "kwarg_spam",
-    "DISCORD_EPOCH",
-    "ACTION_ROW_MAX_ITEMS",
-    "SELECTS_MAX_OPTIONS",
-    "SELECT_MAX_NAME_LENGTH",
-    "CONTEXT_MENU_NAME_LENGTH",
-    "SLASH_CMD_NAME_LENGTH",
-    "SLASH_CMD_MAX_DESC_LENGTH",
-    "SLASH_CMD_MAX_OPTIONS",
-    "SLASH_OPTION_NAME_LENGTH",
-    "EMBED_MAX_NAME_LENGTH",
-    "EMBED_MAX_DESC_LENGTH",
-    "EMBED_MAX_FIELDS",
-    "EMBED_TOTAL_MAX",
-    "EMBED_FIELD_VALUE_LENGTH",
-    "Singleton",
-    "Sentinel",
-    "GlobalScope",
-    "Missing",
-    "MentionPrefix",
-    "GLOBAL_SCOPE",
-    "MISSING",
-    "MENTION_PREFIX",
-    "PREMIUM_GUILD_LIMITS",
-    "Absent",
-    "T",
-    "T_co",
-    "LIB_PATH",
-    "RECOVERABLE_WEBSOCKET_CLOSE_CODES",
-    "NON_RESUMABLE_WEBSOCKET_CLOSE_CODES",
-    "CLIENT_FEATURE_FLAGS",
-    "has_client_feature",
-)
-
-_ver_info = sys.version_info
-
-repo_names = ("interactions.py", "discord-py-interactions")
-for repo_name in repo_names:
-    try:
-        __version__ = _v(repo_name)
-        break
-    except PackageNotFoundError:
-        __version__ = "0.0.0"
-
-
-__repo_url__ = "https://github.com/interactions-py/interactions.py"
-__py_version__ = f"{_ver_info[0]}.{_ver_info[1]}"
-__api_version__ = 10
-logger_name = "interactions"
-_logger = logging.getLogger(logger_name)
-
-
-def get_logger() -> logging.Logger:
-    global _logger
-    return _logger
-
-
-default_locale = "english_us"
-kwarg_spam = False
-
-DISCORD_EPOCH = 1420070400000
-
-ACTION_ROW_MAX_ITEMS = 5
-SELECTS_MAX_OPTIONS = 25
-SELECT_MAX_NAME_LENGTH = 100
-
-CONTEXT_MENU_NAME_LENGTH = 32
-SLASH_CMD_NAME_LENGTH = 32
-SLASH_CMD_MAX_DESC_LENGTH = 100
-SLASH_CMD_MAX_OPTIONS = 25
-SLASH_OPTION_NAME_LENGTH = 100
-
-EMBED_MAX_NAME_LENGTH = 256
-EMBED_MAX_DESC_LENGTH = 4096
-EMBED_MAX_FIELDS = 25
-EMBED_TOTAL_MAX = 6000
-EMBED_FIELD_VALUE_LENGTH = 1024
-
-
-class Singleton(type):
-    _instances = {}
-
-    def __call__(self, *args, **kwargs) -> "Singleton":
-        if self not in self._instances:
-            self._instances[self] = super(Singleton, self).__call__(*args, **kwargs)
-        return self._instances[self]
-
-
-class Sentinel(metaclass=Singleton):
-    @staticmethod
-    def _get_caller_module() -> str:
-        stack = inspect.stack()
-
-        caller = stack[2][0]
-        return caller.f_globals.get("__name__")
-
-    def __init__(self) -> None:
-        self.__module__ = self._get_caller_module()
-        self.name = type(self).__name__
-
-    def __repr__(self) -> str:
-        return self.name
-
-    def __reduce__(self) -> str:
-        return self.name
-
-    def __copy__(self) -> "Sentinel":
-        return self
-
-    def __deepcopy__(self, _) -> "Sentinel":
-        return self
-
-
-class GlobalScope(Sentinel, int):
-    def __getattr__(self, _) -> "GlobalScope":
-        return 0  # type: ignore
-
-    def __hash__(self) -> int:
-        return 0
-
-    def __bool__(self) -> bool:
-        return False
-
-
-class Missing(Sentinel):
-    def __getattr__(self, *_) -> None:
-        return None
-
-    def __bool__(self) -> bool:
-        return False
-
-
-class MentionPrefix(Sentinel):
-    ...
-
-
-GLOBAL_SCOPE = GlobalScope()
-MISSING = Missing()
-MENTION_PREFIX = MentionPrefix()
-
-PREMIUM_GUILD_LIMITS = defaultdict(
-    lambda: {"emoji": 50, "stickers": 5, "bitrate": 96000, "filesize": 26214400},
-    {
-        1: {"emoji": 100, "stickers": 15, "bitrate": 128000, "filesize": 26214400},
-        2: {"emoji": 150, "stickers": 30, "bitrate": 256000, "filesize": 52428800},
-        3: {"emoji": 250, "stickers": 60, "bitrate": 384000, "filesize": 104857600},
-    },
-)
-
-CLIENT_FEATURE_FLAGS = {
-    "FOLLOWUP_INTERACTIONS_FOR_IMAGES": False,  # Experimental fix to bypass Discord's broken image proxy
-}
-
-
-def has_client_feature(feature: str) -> bool:
-    """Checks if a feature is enabled for the client."""
-    if feature.upper() not in CLIENT_FEATURE_FLAGS:
-        get_logger().warning(f"Unknown feature {feature!r} - Known features: {list(CLIENT_FEATURE_FLAGS)}")
-        return False
-    return CLIENT_FEATURE_FLAGS[feature.upper()]
-
-
-GUILD_WELCOME_MESSAGES = (
-    "{0} joined the party.",
-    "{0} is here.",
-    "Welcome, {0}. We hope you brought pizza.",
-    "A wild {0} appeared.",
-    "{0} just landed.",
-    "{0} just slid into the server.",
-    "{0} just showed up!",
-    "Welcome {0}. Say hi!",
-    "{0} hopped into the server.",
-    "Everyone welcome {0}!",
-    "Glad you're here, {0}.",
-    "Good to see you, {0}.",
-    "Yay you made it, {0}!",
-)
-
-T = TypeVar("T")
-T_co = TypeVar("T_co", covariant=True)
-Absent = Union[T, Missing]
-AsyncCallable = Callable[..., Coroutine]
-
-LIB_PATH = os.sep.join(__file__.split(os.sep)[:-2])
-"""The path to the library folder."""
-
-# fmt: off
-RECOVERABLE_WEBSOCKET_CLOSE_CODES = (  # Codes that are recoverable, and the bot will reconnect
-    1000,  # Normal closure
-    1001,  # Server going away
-    1003,  # Unsupported Data
-    1005,  # No status code
-    1006,  # Abnormal closure
-    1008,  # Policy Violation
-    1009,  # Message too big
-    1011,  # Server error
-    1012,  # Server is restarting
-    1014,  # Handshake failed
-    1015,  # TLS error
-    4000,  # Unknown error
-    4001,  # Unknown opcode
-    4002,  # Decode error
-    4003,  # Not authenticated
-    4005,  # Already authenticated
-    4007,  # Invalid seq
-    4008,  # Rate limited
-    4009,  # Session timed out
-)
-NON_RESUMABLE_WEBSOCKET_CLOSE_CODES = (  # Codes that are recoverable, but the bot won't be able to resume the session
-    1000,  # Normal closure
-    1003,  # Unsupported Data
-    1008,  # Policy Violation
-    1009,  # Message too big
-    1011,  # Server error
-    1012,  # Server is restarting
-    1014,  # Handshake failed
-    1015,  # TLS error
-    4007,  # Invalid seq
-)
-# Any close code not in the above two tuples is a non-recoverable close code, and will result in the bot shutting down
-# fmt: on
-
-
-# Sanity check the above constants - only useful during development, but doesn't hurt to leave in
-try:
-    assert set(NON_RESUMABLE_WEBSOCKET_CLOSE_CODES).issubset(set(RECOVERABLE_WEBSOCKET_CLOSE_CODES))
-except AssertionError as e:
-    # find the difference between the two sets
-    diff = set(NON_RESUMABLE_WEBSOCKET_CLOSE_CODES) - set(RECOVERABLE_WEBSOCKET_CLOSE_CODES)
-    raise RuntimeError(
-        f"NON_RESUMABLE_WEBSOCKET_CLOSE_CODES contains codes that are not in RECOVERABLE_WEBSOCKET_CLOSE_CODES: {diff}"
-    ) from e
+"""
+Constants used throughout interactions.py.
+
+Attributes:
+    __version__ str: The version of the library.
+    __repo_url__ str: The URL of the repository.
+    __py_version__ str: The python version in use.
+    logger_name str: The name of interactions.py's default logger. Invalid if a custom logger is passed to `Client` to replace the default logger.
+    logger logging.Logger: The logger used throughout interactions.py. If a custom logger is passed to `Client`, this obj is replaced with the new logger.
+    kwarg_spam bool: Should ``unused kwargs`` be logged.
+
+    ACTION_ROW_MAX_ITEMS int: The maximum number of items in an action row.
+    SELECTS_MAX_OPTIONS int: The maximum number of options a select may have.
+    SELECT_MAX_NAME_LENGTH int: The max length of a select's name.
+
+    CONTEXT_MENU_NAME_LENGTH int: The max length of a context menu's name.
+    SLASH_CMD_NAME_LENGTH int: The max length of a slash command's name.
+    SLASH_CMD_MAX_DESC_LENGTH int: The maximum length of a slash command's description.
+    SLASH_CMD_MAX_OPTIONS int: The maximum number of options a slash command may have.
+    SLASH_OPTION_NAME_LENGTH int: The maximum length of a slash option's name.
+
+    EMBED_MAX_NAME_LENGTH int: The maximum length for an embed title
+    EMBED_MAX_DESC_LENGTH int: The maximum length for an embed description
+    EMBED_MAX_FIELDS int: The maximum number of fields for an embed
+    EMBED_TOTAL_MAX int: The total combined number of characters for an embed
+    PREMIUM_GUILD_LIMITS dict: Limits granted per premium level of a guild
+
+    GLOBAL_SCOPE _sentinel: A sentinel that represents a global scope for application commands.
+    MENTION_PREFIX _sentinel: A sentinel representing the bot will be mentioned for a prefix
+    MISSING _sentinel: A sentinel value that indicates something has not been set
+
+    T TypeVar: A type variable used for generic typing.
+    Absent Union[T, Missing]: A type hint for a value that may be MISSING.
+
+    CLIENT_FEATURE_FLAGS dict: A dict of feature flags that can be enabled or disabled for the client.
+    has_feature_flag Callable[[str], bool]: A function that returns whether a feature flag is enabled.
+
+"""
+import inspect
+import logging
+import os
+import sys
+from collections import defaultdict
+from importlib.metadata import version as _v, PackageNotFoundError
+from typing import TypeVar, Union, Callable, Coroutine
+
+__all__ = (
+    "__version__",
+    "__repo_url__",
+    "__py_version__",
+    "__api_version__",
+    "get_logger",
+    "logger_name",
+    "kwarg_spam",
+    "DISCORD_EPOCH",
+    "ACTION_ROW_MAX_ITEMS",
+    "SELECTS_MAX_OPTIONS",
+    "SELECT_MAX_NAME_LENGTH",
+    "CONTEXT_MENU_NAME_LENGTH",
+    "SLASH_CMD_NAME_LENGTH",
+    "SLASH_CMD_MAX_DESC_LENGTH",
+    "SLASH_CMD_MAX_OPTIONS",
+    "SLASH_OPTION_NAME_LENGTH",
+    "EMBED_MAX_NAME_LENGTH",
+    "EMBED_MAX_DESC_LENGTH",
+    "EMBED_MAX_FIELDS",
+    "EMBED_TOTAL_MAX",
+    "EMBED_FIELD_VALUE_LENGTH",
+    "Singleton",
+    "Sentinel",
+    "GlobalScope",
+    "Missing",
+    "MentionPrefix",
+    "GLOBAL_SCOPE",
+    "MISSING",
+    "MENTION_PREFIX",
+    "PREMIUM_GUILD_LIMITS",
+    "Absent",
+    "T",
+    "T_co",
+    "LIB_PATH",
+    "RECOVERABLE_WEBSOCKET_CLOSE_CODES",
+    "NON_RESUMABLE_WEBSOCKET_CLOSE_CODES",
+    "CLIENT_FEATURE_FLAGS",
+    "has_client_feature",
+)
+
+_ver_info = sys.version_info
+
+repo_names = ("interactions.py", "discord-py-interactions")
+for repo_name in repo_names:
+    try:
+        __version__ = _v(repo_name)
+        break
+    except PackageNotFoundError:
+        __version__ = "0.0.0"
+
+
+__repo_url__ = "https://github.com/interactions-py/interactions.py"
+__py_version__ = f"{_ver_info[0]}.{_ver_info[1]}"
+__api_version__ = 10
+logger_name = "interactions"
+_logger = logging.getLogger(logger_name)
+
+
+def get_logger() -> logging.Logger:
+    global _logger
+    return _logger
+
+
+default_locale = "english_us"
+kwarg_spam = False
+
+DISCORD_EPOCH = 1420070400000
+
+ACTION_ROW_MAX_ITEMS = 5
+SELECTS_MAX_OPTIONS = 25
+SELECT_MAX_NAME_LENGTH = 100
+
+CONTEXT_MENU_NAME_LENGTH = 32
+SLASH_CMD_NAME_LENGTH = 32
+SLASH_CMD_MAX_DESC_LENGTH = 100
+SLASH_CMD_MAX_OPTIONS = 25
+SLASH_OPTION_NAME_LENGTH = 100
+
+EMBED_MAX_NAME_LENGTH = 256
+EMBED_MAX_DESC_LENGTH = 4096
+EMBED_MAX_FIELDS = 25
+EMBED_TOTAL_MAX = 6000
+EMBED_FIELD_VALUE_LENGTH = 1024
+
+
+class Singleton(type):
+    _instances = {}
+
+    def __call__(self, *args, **kwargs) -> "Singleton":
+        if self not in self._instances:
+            self._instances[self] = super(Singleton, self).__call__(*args, **kwargs)
+        return self._instances[self]
+
+
+class Sentinel(metaclass=Singleton):
+    @staticmethod
+    def _get_caller_module() -> str:
+        stack = inspect.stack()
+
+        caller = stack[2][0]
+        return caller.f_globals.get("__name__")
+
+    def __init__(self) -> None:
+        self.__module__ = self._get_caller_module()
+        self.name = type(self).__name__
+
+    def __repr__(self) -> str:
+        return self.name
+
+    def __reduce__(self) -> str:
+        return self.name
+
+    def __copy__(self) -> "Sentinel":
+        return self
+
+    def __deepcopy__(self, _) -> "Sentinel":
+        return self
+
+
+class GlobalScope(Sentinel, int):
+    def __getattr__(self, _) -> "GlobalScope":
+        return 0  # type: ignore
+
+    def __hash__(self) -> int:
+        return 0
+
+    def __bool__(self) -> bool:
+        return False
+
+
+class Missing(Sentinel):
+    def __getattr__(self, *_) -> None:
+        return None
+
+    def __bool__(self) -> bool:
+        return False
+
+
+class MentionPrefix(Sentinel):
+    ...
+
+
+GLOBAL_SCOPE = GlobalScope()
+MISSING = Missing()
+MENTION_PREFIX = MentionPrefix()
+
+PREMIUM_GUILD_LIMITS = defaultdict(
+    lambda: {"emoji": 50, "stickers": 5, "bitrate": 96000, "filesize": 26214400},
+    {
+        1: {"emoji": 100, "stickers": 15, "bitrate": 128000, "filesize": 26214400},
+        2: {"emoji": 150, "stickers": 30, "bitrate": 256000, "filesize": 52428800},
+        3: {"emoji": 250, "stickers": 60, "bitrate": 384000, "filesize": 104857600},
+    },
+)
+
+CLIENT_FEATURE_FLAGS = {
+    "FOLLOWUP_INTERACTIONS_FOR_IMAGES": False,  # Experimental fix to bypass Discord's broken image proxy
+}
+
+
+def has_client_feature(feature: str) -> bool:
+    """Checks if a feature is enabled for the client."""
+    if feature.upper() not in CLIENT_FEATURE_FLAGS:
+        get_logger().warning(f"Unknown feature {feature!r} - Known features: {list(CLIENT_FEATURE_FLAGS)}")
+        return False
+    return CLIENT_FEATURE_FLAGS[feature.upper()]
+
+
+GUILD_WELCOME_MESSAGES = (
+    "{0} joined the party.",
+    "{0} is here.",
+    "Welcome, {0}. We hope you brought pizza.",
+    "A wild {0} appeared.",
+    "{0} just landed.",
+    "{0} just slid into the server.",
+    "{0} just showed up!",
+    "Welcome {0}. Say hi!",
+    "{0} hopped into the server.",
+    "Everyone welcome {0}!",
+    "Glad you're here, {0}.",
+    "Good to see you, {0}.",
+    "Yay you made it, {0}!",
+)
+
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+Absent = Union[T, Missing]
+AsyncCallable = Callable[..., Coroutine]
+
+LIB_PATH = os.sep.join(__file__.split(os.sep)[:-2])
+"""The path to the library folder."""
+
+# fmt: off
+RECOVERABLE_WEBSOCKET_CLOSE_CODES = (  # Codes that are recoverable, and the bot will reconnect
+    1000,  # Normal closure
+    1001,  # Server going away
+    1003,  # Unsupported Data
+    1005,  # No status code
+    1006,  # Abnormal closure
+    1008,  # Policy Violation
+    1009,  # Message too big
+    1011,  # Server error
+    1012,  # Server is restarting
+    1014,  # Handshake failed
+    1015,  # TLS error
+    4000,  # Unknown error
+    4001,  # Unknown opcode
+    4002,  # Decode error
+    4003,  # Not authenticated
+    4005,  # Already authenticated
+    4007,  # Invalid seq
+    4008,  # Rate limited
+    4009,  # Session timed out
+)
+NON_RESUMABLE_WEBSOCKET_CLOSE_CODES = (  # Codes that are recoverable, but the bot won't be able to resume the session
+    1000,  # Normal closure
+    1003,  # Unsupported Data
+    1008,  # Policy Violation
+    1009,  # Message too big
+    1011,  # Server error
+    1012,  # Server is restarting
+    1014,  # Handshake failed
+    1015,  # TLS error
+    4007,  # Invalid seq
+)
+# Any close code not in the above two tuples is a non-recoverable close code, and will result in the bot shutting down
+# fmt: on
+
+
+# Sanity check the above constants - only useful during development, but doesn't hurt to leave in
+try:
+    assert set(NON_RESUMABLE_WEBSOCKET_CLOSE_CODES).issubset(set(RECOVERABLE_WEBSOCKET_CLOSE_CODES))
+except AssertionError as e:
+    # find the difference between the two sets
+    diff = set(NON_RESUMABLE_WEBSOCKET_CLOSE_CODES) - set(RECOVERABLE_WEBSOCKET_CLOSE_CODES)
+    raise RuntimeError(
+        f"NON_RESUMABLE_WEBSOCKET_CLOSE_CODES contains codes that are not in RECOVERABLE_WEBSOCKET_CLOSE_CODES: {diff}"
+    ) from e
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/errors.py` & `discord-py-interactions-5.6.0/interactions/client/errors.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,423 +1,423 @@
-from typing import Dict, Any, TYPE_CHECKING, Callable, Coroutine, List, Optional, SupportsInt, Union
-
-import aiohttp
-
-from interactions.client.utils.misc_utils import escape_mentions
-from . import const
-
-if TYPE_CHECKING:
-    from interactions.models.internal.command import BaseCommand
-    from interactions.models.internal.context import BaseContext
-    from interactions.models.internal.cooldowns import CooldownSystem, MaxConcurrency
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-__all__ = (
-    "LibraryException",
-    "BotException",
-    "GatewayNotFound",
-    "LoginError",
-    "HTTPException",
-    "DiscordError",
-    "BadRequest",
-    "Forbidden",
-    "NotFound",
-    "RateLimited",
-    "TooManyChanges",
-    "WebSocketClosed",
-    "VoiceWebSocketClosed",
-    "WebSocketRestart",
-    "ExtensionException",
-    "ExtensionNotFound",
-    "ExtensionLoadException",
-    "CommandException",
-    "CommandOnCooldown",
-    "MaxConcurrencyReached",
-    "CommandCheckFailure",
-    "BadArgument",
-    "MessageException",
-    "EmptyMessageException",
-    "EphemeralEditException",
-    "ThreadException",
-    "ThreadOutsideOfGuild",
-    "InteractionException",
-    "InteractionMissingAccess",
-    "AlreadyDeferred",
-    "AlreadyResponded",
-    "ForeignWebhookException",
-    "EventLocationNotProvided",
-    "VoiceAlreadyConnected",
-    "VoiceConnectionTimeout",
-)
-
-
-class LibraryException(Exception):
-    """Base Exception of i.py."""
-
-
-class BotException(LibraryException):
-    """An issue occurred in the client, likely user error."""
-
-
-class GatewayNotFound(LibraryException):
-    """An exception that is raised when the gateway for Discord could not be found."""
-
-    def __init__(self) -> None:
-        super().__init__("Unable to find discord gateway!")
-
-
-class LoginError(BotException):
-    """The bot failed to login, check your token."""
-
-
-class HTTPException(LibraryException):
-    """
-    A HTTP request resulted in an exception.
-
-    Attributes:
-        response aiohttp.ClientResponse: The response of the HTTP request
-        text str: The text of the exception, could be None
-        status int: The HTTP status code
-        code int: The discord error code, if one is provided
-        route Route: The HTTP route that was used
-
-    """
-
-    def __init__(
-        self,
-        response: aiohttp.ClientResponse,
-        text: const.Absent[str] = const.MISSING,
-        discord_code: const.Absent[int] = const.MISSING,
-        **kwargs,
-    ) -> None:
-        self.response: aiohttp.ClientResponse = response
-        self.status: int = response.status
-        self.code: const.Absent[int] = discord_code
-        self.text: const.Absent[str] = text
-        self.errors: const.Absent[Any] = const.MISSING
-        self.route = kwargs.get("route", const.MISSING)
-
-        if data := kwargs.get("response_data"):
-            if isinstance(data, dict):
-                self.text = data.get("message", const.MISSING)
-                self.code = data.get("code", const.MISSING)
-                self.errors = data.get("errors", const.MISSING)
-            else:
-                self.text = data
-        super().__init__(f"{self.status}|{self.response.reason}: {f'({self.code}) ' if self.code else ''}{self.text}")
-
-    def __str__(self) -> str:
-        if not self.errors:
-            return f"HTTPException: {self.status}|{self.response.reason} || {self.text}"
-        try:
-            errors = self.search_for_message(self.errors)
-        except (KeyError, ValueError, TypeError):
-            errors = [self.text]
-        return f"HTTPException: {self.status}|{self.response.reason}: " + "\n".join(errors)
-
-    def __repr__(self) -> str:
-        return str(self)
-
-    @staticmethod
-    def search_for_message(errors: dict, lookup: Optional[dict] = None) -> list[str]:
-        """
-        Search the exceptions error dictionary for a message explaining the issue.
-
-        Args:
-            errors: The error dictionary of the http exception
-            lookup: A lookup dictionary to use to convert indexes into named items
-
-        Returns:
-            A list of parsed error strings found
-
-        """
-        messages: List[str] = []
-        errors = errors.get("errors", errors)
-
-        def maybe_int(x: SupportsInt | Any) -> Union[int, Any]:
-            """If something can be an integer, convert it to one, otherwise return its normal value"""
-            try:
-                return int(x)
-            except ValueError:
-                return x
-
-        def _parse(_errors: dict, keys: Optional[List[str]] = None) -> None:
-            """Search through the entire dictionary for any errors defined"""
-            for key, val in _errors.items():
-                if key == "_errors":
-                    key_out = []
-                    if keys:
-                        if lookup:
-                            # this code simply substitutes keys for attribute names
-                            _lookup = lookup
-                            for _key in keys:
-                                _lookup = _lookup[maybe_int(_key)]
-
-                                if isinstance(_lookup, dict):
-                                    key_out.append(_lookup.get("name", _key))
-                                else:
-                                    key_out.append(_key)
-                        else:
-                            key_out = keys
-
-                    for msg in val:
-                        messages.append(f"{'->'.join(key_out)} {msg['code']}: {msg['message']}")
-                else:
-                    if keys:
-                        keys.append(key)
-                    else:
-                        keys = [key]
-                    _parse(val, keys)
-
-        _parse(errors)
-
-        return messages
-
-
-class DiscordError(HTTPException):
-    """A discord-side error."""
-
-
-class BadRequest(HTTPException):
-    """A bad request was made."""
-
-
-class Forbidden(HTTPException):
-    """You do not have access to this."""
-
-
-class NotFound(HTTPException):
-    """This resource could not be found."""
-
-
-class RateLimited(HTTPException):
-    """Discord is rate limiting this application."""
-
-
-class TooManyChanges(LibraryException):
-    """You have changed something too frequently."""
-
-
-class WebSocketClosed(LibraryException):
-    """The websocket was closed."""
-
-    code: int = 0
-    codes: Dict[int, str] = {
-        1000: "Normal Closure",
-        4000: "Unknown Error",
-        4001: "Unknown OpCode",
-        4002: "Decode Error",
-        4003: "Not Authenticated",
-        4004: "Authentication Failed",
-        4005: "Already Authenticated",
-        4007: "Invalid seq",
-        4008: "Rate limited",
-        4009: "Session Timed Out",
-        4010: "Invalid Shard",
-        4011: "Sharding Required",
-        4012: "Invalid API Version",
-        4013: "Invalid Intents",
-        4014: "Disallowed Intents",
-    }
-
-    def __init__(self, code: int) -> None:
-        self.code = code
-        super().__init__(f"The Websocket closed with code: {code} - {self.codes.get(code, 'Unknown Error')}")
-
-
-class VoiceWebSocketClosed(LibraryException):
-    """The voice websocket was closed."""
-
-    code: int = 0
-    codes: Dict[int, str] = {
-        1000: "Normal Closure",
-        4000: "Unknown Error",
-        4001: "Unknown OpCode",
-        4002: "Decode Error",
-        4003: "Not Authenticated",
-        4004: "Authentication Failed",
-        4005: "Already Authenticated",
-        4006: "Session no longer valid",
-        4007: "Invalid seq",
-        4009: "Session Timed Out",
-        4011: "Server not found",
-        4012: "Unknown protocol",
-        4014: "Disconnected",
-        4015: "Voice Server Crashed",
-        4016: "Unknown encryption mode",
-    }
-
-    def __init__(self, code: int) -> None:
-        self.code = code
-        super().__init__(f"The Websocket closed with code: {code} - {self.codes.get(code, 'Unknown Error')}")
-
-
-class WebSocketRestart(LibraryException):
-    """The websocket closed, and is safe to restart."""
-
-    resume: bool = False
-
-    def __init__(self, resume: bool = False) -> None:
-        self.resume = resume
-        super().__init__("Websocket connection closed... reconnecting")
-
-
-class ExtensionException(BotException):
-    """An error occurred with an extension."""
-
-
-class ExtensionNotFound(ExtensionException):
-    """The desired extension was not found."""
-
-
-class ExtensionLoadException(ExtensionException):
-    """An error occurred loading an extension."""
-
-
-class CommandException(BotException):
-    """An error occurred trying to execute a command."""
-
-
-class CommandOnCooldown(CommandException):
-    """
-    A command is on cooldown, and was attempted to be executed.
-
-    Attributes:
-        command BaseCommand: The command that is on cooldown
-        cooldown CooldownSystem: The cooldown system
-
-    """
-
-    def __init__(self, command: "BaseCommand", cooldown: "CooldownSystem") -> None:
-        self.command: "BaseCommand" = command
-        self.cooldown: "CooldownSystem" = cooldown
-
-        super().__init__(f"Command on cooldown... {cooldown.get_cooldown_time():.2f} seconds until reset")
-
-
-class MaxConcurrencyReached(CommandException):
-    """A command has exhausted the max concurrent requests."""
-
-    def __init__(self, command: "BaseCommand", max_conc: "MaxConcurrency") -> None:
-        self.command: "BaseCommand" = command
-        self.max_conc: "MaxConcurrency" = max_conc
-
-        super().__init__(f"Command has exhausted the max concurrent requests. ({max_conc.concurrent} simultaneously)")
-
-
-class CommandCheckFailure(CommandException):
-    """
-    A command check failed.
-
-    Attributes:
-        command BaseCommand: The command that's check failed
-        check Callable[..., Coroutine]: The check that failed
-
-    """
-
-    def __init__(self, command: "BaseCommand", check: Callable[..., Coroutine], context: "BaseContext") -> None:
-        self.command: "BaseCommand" = command
-        self.check: Callable[..., Coroutine] = check
-        self.ctx = context
-
-
-class BadArgument(CommandException):
-    """A prefixed command encountered an invalid argument."""
-
-    def __init__(self, message: Optional[str] = None, *args: Any) -> None:
-        if message is not None:
-            message = escape_mentions(message)
-            super().__init__(message, *args)
-        else:
-            super().__init__(*args)
-
-
-class MessageException(BotException):
-    """A message operation encountered an exception."""
-
-
-class EmptyMessageException(MessageException):
-    """You have attempted to send a message without any content or embeds"""
-
-
-class EphemeralEditException(MessageException):
-    """
-    Your bot attempted to edit an ephemeral message. This is not possible.
-
-    Its worth noting you can edit an ephemeral message with component's
-    `edit_origin` method.
-
-    """
-
-    def __init__(self) -> None:
-        super().__init__(
-            "Ephemeral messages can only be edited with component's `edit_origin` method or using InteractionContext"
-        )
-
-
-class ThreadException(BotException):
-    """A thread operation encountered an exception."""
-
-
-class ThreadOutsideOfGuild(ThreadException):
-    """A thread was attempted to be created outside of a guild."""
-
-    def __init__(self) -> None:
-        super().__init__("Threads cannot be created outside of guilds")
-
-
-class InteractionException(BotException):
-    """An error occurred with an interaction."""
-
-
-class InteractionMissingAccess(InteractionException):
-    """The bot does not have access to the specified scope."""
-
-    def __init__(self, scope: "Snowflake_Type") -> None:
-        self.scope: "Snowflake_Type" = scope
-
-        if scope == const.GLOBAL_SCOPE:
-            err_msg = "Unable to sync commands global commands"
-        else:
-            err_msg = (
-                f"Unable to sync commands for guild `{scope}` -- Ensure the bot properly added to that guild "
-                f"with `application.commands` scope. "
-            )
-
-        super().__init__(err_msg)
-
-
-class AlreadyDeferred(InteractionException):
-    """An interaction was already deferred, and you attempted to defer it again."""
-
-
-class AlreadyResponded(AlreadyDeferred):
-    """An interaction was already responded to, and you attempted to defer it"""
-
-
-class ForeignWebhookException(LibraryException):
-    """Raised when you attempt to send using a webhook you did not create."""
-
-
-class EventLocationNotProvided(BotException):
-    """Raised when you have entity_type external and no location is provided."""
-
-
-class VoiceAlreadyConnected(BotException):
-    """Raised when you attempt to connect a voice channel that is already connected."""
-
-    def __init__(self) -> None:
-        super().__init__("Bot already connected to the voice channel")
-
-
-class VoiceNotConnected(BotException):
-    """Raised when you attempt to connect a voice channel that is not connected."""
-
-    def __init__(self) -> None:
-        super().__init__("Bot is not connected to any voice channels in given guild")
-
-
-class VoiceConnectionTimeout(LibraryException):
-    """Raised when the bot fails to connect to a voice channel."""
-
-    def __init__(self) -> None:
-        super().__init__("Failed to connect to voice channel. Did not receive a response from Discord")
+from typing import Dict, Any, TYPE_CHECKING, Callable, Coroutine, List, Optional, SupportsInt, Union
+
+import aiohttp
+
+from interactions.client.utils.misc_utils import escape_mentions
+from . import const
+
+if TYPE_CHECKING:
+    from interactions.models.internal.command import BaseCommand
+    from interactions.models.internal.context import BaseContext
+    from interactions.models.internal.cooldowns import CooldownSystem, MaxConcurrency
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+__all__ = (
+    "LibraryException",
+    "BotException",
+    "GatewayNotFound",
+    "LoginError",
+    "HTTPException",
+    "DiscordError",
+    "BadRequest",
+    "Forbidden",
+    "NotFound",
+    "RateLimited",
+    "TooManyChanges",
+    "WebSocketClosed",
+    "VoiceWebSocketClosed",
+    "WebSocketRestart",
+    "ExtensionException",
+    "ExtensionNotFound",
+    "ExtensionLoadException",
+    "CommandException",
+    "CommandOnCooldown",
+    "MaxConcurrencyReached",
+    "CommandCheckFailure",
+    "BadArgument",
+    "MessageException",
+    "EmptyMessageException",
+    "EphemeralEditException",
+    "ThreadException",
+    "ThreadOutsideOfGuild",
+    "InteractionException",
+    "InteractionMissingAccess",
+    "AlreadyDeferred",
+    "AlreadyResponded",
+    "ForeignWebhookException",
+    "EventLocationNotProvided",
+    "VoiceAlreadyConnected",
+    "VoiceConnectionTimeout",
+)
+
+
+class LibraryException(Exception):
+    """Base Exception of i.py."""
+
+
+class BotException(LibraryException):
+    """An issue occurred in the client, likely user error."""
+
+
+class GatewayNotFound(LibraryException):
+    """An exception that is raised when the gateway for Discord could not be found."""
+
+    def __init__(self) -> None:
+        super().__init__("Unable to find discord gateway!")
+
+
+class LoginError(BotException):
+    """The bot failed to login, check your token."""
+
+
+class HTTPException(LibraryException):
+    """
+    A HTTP request resulted in an exception.
+
+    Attributes:
+        response aiohttp.ClientResponse: The response of the HTTP request
+        text str: The text of the exception, could be None
+        status int: The HTTP status code
+        code int: The discord error code, if one is provided
+        route Route: The HTTP route that was used
+
+    """
+
+    def __init__(
+        self,
+        response: aiohttp.ClientResponse,
+        text: const.Absent[str] = const.MISSING,
+        discord_code: const.Absent[int] = const.MISSING,
+        **kwargs,
+    ) -> None:
+        self.response: aiohttp.ClientResponse = response
+        self.status: int = response.status
+        self.code: const.Absent[int] = discord_code
+        self.text: const.Absent[str] = text
+        self.errors: const.Absent[Any] = const.MISSING
+        self.route = kwargs.get("route", const.MISSING)
+
+        if data := kwargs.get("response_data"):
+            if isinstance(data, dict):
+                self.text = data.get("message", const.MISSING)
+                self.code = data.get("code", const.MISSING)
+                self.errors = data.get("errors", const.MISSING)
+            else:
+                self.text = data
+        super().__init__(f"{self.status}|{self.response.reason}: {f'({self.code}) ' if self.code else ''}{self.text}")
+
+    def __str__(self) -> str:
+        if not self.errors:
+            return f"HTTPException: {self.status}|{self.response.reason} || {self.text}"
+        try:
+            errors = self.search_for_message(self.errors)
+        except (KeyError, ValueError, TypeError):
+            errors = [self.text]
+        return f"HTTPException: {self.status}|{self.response.reason}: " + "\n".join(errors)
+
+    def __repr__(self) -> str:
+        return str(self)
+
+    @staticmethod
+    def search_for_message(errors: dict, lookup: Optional[dict] = None) -> list[str]:
+        """
+        Search the exceptions error dictionary for a message explaining the issue.
+
+        Args:
+            errors: The error dictionary of the http exception
+            lookup: A lookup dictionary to use to convert indexes into named items
+
+        Returns:
+            A list of parsed error strings found
+
+        """
+        messages: List[str] = []
+        errors = errors.get("errors", errors)
+
+        def maybe_int(x: SupportsInt | Any) -> Union[int, Any]:
+            """If something can be an integer, convert it to one, otherwise return its normal value"""
+            try:
+                return int(x)
+            except ValueError:
+                return x
+
+        def _parse(_errors: dict, keys: Optional[List[str]] = None) -> None:
+            """Search through the entire dictionary for any errors defined"""
+            for key, val in _errors.items():
+                if key == "_errors":
+                    key_out = []
+                    if keys:
+                        if lookup:
+                            # this code simply substitutes keys for attribute names
+                            _lookup = lookup
+                            for _key in keys:
+                                _lookup = _lookup[maybe_int(_key)]
+
+                                if isinstance(_lookup, dict):
+                                    key_out.append(_lookup.get("name", _key))
+                                else:
+                                    key_out.append(_key)
+                        else:
+                            key_out = keys
+
+                    for msg in val:
+                        messages.append(f"{'->'.join(key_out)} {msg['code']}: {msg['message']}")
+                else:
+                    if keys:
+                        keys.append(key)
+                    else:
+                        keys = [key]
+                    _parse(val, keys)
+
+        _parse(errors)
+
+        return messages
+
+
+class DiscordError(HTTPException):
+    """A discord-side error."""
+
+
+class BadRequest(HTTPException):
+    """A bad request was made."""
+
+
+class Forbidden(HTTPException):
+    """You do not have access to this."""
+
+
+class NotFound(HTTPException):
+    """This resource could not be found."""
+
+
+class RateLimited(HTTPException):
+    """Discord is rate limiting this application."""
+
+
+class TooManyChanges(LibraryException):
+    """You have changed something too frequently."""
+
+
+class WebSocketClosed(LibraryException):
+    """The websocket was closed."""
+
+    code: int = 0
+    codes: Dict[int, str] = {
+        1000: "Normal Closure",
+        4000: "Unknown Error",
+        4001: "Unknown OpCode",
+        4002: "Decode Error",
+        4003: "Not Authenticated",
+        4004: "Authentication Failed",
+        4005: "Already Authenticated",
+        4007: "Invalid seq",
+        4008: "Rate limited",
+        4009: "Session Timed Out",
+        4010: "Invalid Shard",
+        4011: "Sharding Required",
+        4012: "Invalid API Version",
+        4013: "Invalid Intents",
+        4014: "Disallowed Intents",
+    }
+
+    def __init__(self, code: int) -> None:
+        self.code = code
+        super().__init__(f"The Websocket closed with code: {code} - {self.codes.get(code, 'Unknown Error')}")
+
+
+class VoiceWebSocketClosed(LibraryException):
+    """The voice websocket was closed."""
+
+    code: int = 0
+    codes: Dict[int, str] = {
+        1000: "Normal Closure",
+        4000: "Unknown Error",
+        4001: "Unknown OpCode",
+        4002: "Decode Error",
+        4003: "Not Authenticated",
+        4004: "Authentication Failed",
+        4005: "Already Authenticated",
+        4006: "Session no longer valid",
+        4007: "Invalid seq",
+        4009: "Session Timed Out",
+        4011: "Server not found",
+        4012: "Unknown protocol",
+        4014: "Disconnected",
+        4015: "Voice Server Crashed",
+        4016: "Unknown encryption mode",
+    }
+
+    def __init__(self, code: int) -> None:
+        self.code = code
+        super().__init__(f"The Websocket closed with code: {code} - {self.codes.get(code, 'Unknown Error')}")
+
+
+class WebSocketRestart(LibraryException):
+    """The websocket closed, and is safe to restart."""
+
+    resume: bool = False
+
+    def __init__(self, resume: bool = False) -> None:
+        self.resume = resume
+        super().__init__("Websocket connection closed... reconnecting")
+
+
+class ExtensionException(BotException):
+    """An error occurred with an extension."""
+
+
+class ExtensionNotFound(ExtensionException):
+    """The desired extension was not found."""
+
+
+class ExtensionLoadException(ExtensionException):
+    """An error occurred loading an extension."""
+
+
+class CommandException(BotException):
+    """An error occurred trying to execute a command."""
+
+
+class CommandOnCooldown(CommandException):
+    """
+    A command is on cooldown, and was attempted to be executed.
+
+    Attributes:
+        command BaseCommand: The command that is on cooldown
+        cooldown CooldownSystem: The cooldown system
+
+    """
+
+    def __init__(self, command: "BaseCommand", cooldown: "CooldownSystem") -> None:
+        self.command: "BaseCommand" = command
+        self.cooldown: "CooldownSystem" = cooldown
+
+        super().__init__(f"Command on cooldown... {cooldown.get_cooldown_time():.2f} seconds until reset")
+
+
+class MaxConcurrencyReached(CommandException):
+    """A command has exhausted the max concurrent requests."""
+
+    def __init__(self, command: "BaseCommand", max_conc: "MaxConcurrency") -> None:
+        self.command: "BaseCommand" = command
+        self.max_conc: "MaxConcurrency" = max_conc
+
+        super().__init__(f"Command has exhausted the max concurrent requests. ({max_conc.concurrent} simultaneously)")
+
+
+class CommandCheckFailure(CommandException):
+    """
+    A command check failed.
+
+    Attributes:
+        command BaseCommand: The command that's check failed
+        check Callable[..., Coroutine]: The check that failed
+
+    """
+
+    def __init__(self, command: "BaseCommand", check: Callable[..., Coroutine], context: "BaseContext") -> None:
+        self.command: "BaseCommand" = command
+        self.check: Callable[..., Coroutine] = check
+        self.ctx = context
+
+
+class BadArgument(CommandException):
+    """A prefixed command encountered an invalid argument."""
+
+    def __init__(self, message: Optional[str] = None, *args: Any) -> None:
+        if message is not None:
+            message = escape_mentions(message)
+            super().__init__(message, *args)
+        else:
+            super().__init__(*args)
+
+
+class MessageException(BotException):
+    """A message operation encountered an exception."""
+
+
+class EmptyMessageException(MessageException):
+    """You have attempted to send a message without any content or embeds"""
+
+
+class EphemeralEditException(MessageException):
+    """
+    Your bot attempted to edit an ephemeral message. This is not possible.
+
+    Its worth noting you can edit an ephemeral message with component's
+    `edit_origin` method.
+
+    """
+
+    def __init__(self) -> None:
+        super().__init__(
+            "Ephemeral messages can only be edited with component's `edit_origin` method or using InteractionContext"
+        )
+
+
+class ThreadException(BotException):
+    """A thread operation encountered an exception."""
+
+
+class ThreadOutsideOfGuild(ThreadException):
+    """A thread was attempted to be created outside of a guild."""
+
+    def __init__(self) -> None:
+        super().__init__("Threads cannot be created outside of guilds")
+
+
+class InteractionException(BotException):
+    """An error occurred with an interaction."""
+
+
+class InteractionMissingAccess(InteractionException):
+    """The bot does not have access to the specified scope."""
+
+    def __init__(self, scope: "Snowflake_Type") -> None:
+        self.scope: "Snowflake_Type" = scope
+
+        if scope == const.GLOBAL_SCOPE:
+            err_msg = "Unable to sync commands global commands"
+        else:
+            err_msg = (
+                f"Unable to sync commands for guild `{scope}` -- Ensure the bot properly added to that guild "
+                f"with `application.commands` scope. "
+            )
+
+        super().__init__(err_msg)
+
+
+class AlreadyDeferred(InteractionException):
+    """An interaction was already deferred, and you attempted to defer it again."""
+
+
+class AlreadyResponded(AlreadyDeferred):
+    """An interaction was already responded to, and you attempted to defer it"""
+
+
+class ForeignWebhookException(LibraryException):
+    """Raised when you attempt to send using a webhook you did not create."""
+
+
+class EventLocationNotProvided(BotException):
+    """Raised when you have entity_type external and no location is provided."""
+
+
+class VoiceAlreadyConnected(BotException):
+    """Raised when you attempt to connect a voice channel that is already connected."""
+
+    def __init__(self) -> None:
+        super().__init__("Bot already connected to the voice channel")
+
+
+class VoiceNotConnected(BotException):
+    """Raised when you attempt to connect a voice channel that is not connected."""
+
+    def __init__(self) -> None:
+        super().__init__("Bot is not connected to any voice channels in given guild")
+
+
+class VoiceConnectionTimeout(LibraryException):
+    """Raised when the bot fails to connect to a voice channel."""
+
+    def __init__(self) -> None:
+        super().__init__("Failed to connect to voice channel. Did not receive a response from Discord")
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/mixins/modal.py` & `discord-py-interactions-5.6.0/interactions/client/mixins/modal.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-import typing
-
-from interactions.models.discord.snowflake import Snowflake
-
-if typing.TYPE_CHECKING:
-    import interactions
-
-__all__ = ("ModalMixin",)
-
-
-class ModalMixin:
-    client: "interactions.Client"
-    """The client that created this context."""
-    responded: bool
-    """Whether this context has been responded to."""
-    id: Snowflake
-    """The interaction ID."""
-    token: str
-    """The interaction token."""
-
-    async def send_modal(self, modal: "interactions.Modal") -> "dict | interactions.Modal":
-        """Send a modal to the user."""
-        if self.responded:
-            raise RuntimeError("Cannot send modal after responding")
-        payload = modal if isinstance(modal, dict) else modal.to_dict()
-
-        await self.client.http.post_initial_response(payload, self.id, self.token)
-
-        self.responded = True
-        return modal
+import typing
+
+from interactions.models.discord.snowflake import Snowflake
+
+if typing.TYPE_CHECKING:
+    import interactions
+
+__all__ = ("ModalMixin",)
+
+
+class ModalMixin:
+    client: "interactions.Client"
+    """The client that created this context."""
+    responded: bool
+    """Whether this context has been responded to."""
+    id: Snowflake
+    """The interaction ID."""
+    token: str
+    """The interaction token."""
+
+    async def send_modal(self, modal: "interactions.Modal") -> "dict | interactions.Modal":
+        """Send a modal to the user."""
+        if self.responded:
+            raise RuntimeError("Cannot send modal after responding")
+        payload = modal if isinstance(modal, dict) else modal.to_dict()
+
+        await self.client.http.post_initial_response(payload, self.id, self.token)
+
+        self.responded = True
+        return modal
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/mixins/serialization.py` & `discord-py-interactions-5.6.0/interactions/client/mixins/serialization.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,112 +1,112 @@
-from logging import Logger
-from typing import Any, Dict, List, Type
-
-import attrs
-
-import interactions.client.const as const
-import interactions.client.utils.serializer as serializer
-
-__all__ = ("DictSerializationMixin",)
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False)
-class DictSerializationMixin:
-    logger: Logger = attrs.field(init=False, factory=const.get_logger, metadata=serializer.no_export_meta, repr=False)
-
-    @classmethod
-    def _get_keys(cls) -> frozenset:
-        if (keys := getattr(cls, "_keys", None)) is None:
-            keys = frozenset(field.name for field in attrs.fields(cls))
-            setattr(cls, "_keys", keys)
-        return keys
-
-    @classmethod
-    def _get_init_keys(cls) -> frozenset:
-        name = f"_init_keys_{cls.__name__}"
-        if (init_keys := getattr(cls, name, None)) is None:
-            init_keys = frozenset(field.name.removeprefix("_") for field in attrs.fields(cls) if field.init)
-            setattr(cls, name, init_keys)
-        return init_keys
-
-    @classmethod
-    def _filter_kwargs(cls, kwargs_dict: dict, keys: frozenset) -> dict:
-        if const.kwarg_spam:
-            unused = {k: v for k, v in kwargs_dict.items() if k not in keys}
-            const.get_logger().debug(f"Unused kwargs: {cls.__name__}: {unused}")  # for debug
-        return {k: v for k, v in kwargs_dict.items() if k in keys}
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any]) -> Dict[str, Any]:
-        """
-        Process dictionary data received from discord api. Does cleanup and other checks to data.
-
-        Args:
-            data: The dictionary data received from discord api.
-
-        Returns:
-            The processed dictionary. Ready to be converted into object class.
-
-        """
-        return data
-
-    @classmethod
-    def from_dict(cls: Type[const.T], data: Dict[str, Any]) -> const.T:
-        """
-        Process and converts dictionary data received from discord api to object class instance.
-
-        Args:
-            data: The json data received from discord api.
-
-        Returns:
-            The object class instance.
-
-        """
-        if isinstance(data, cls):
-            return data
-        data = cls._process_dict(data)
-        return cls(**cls._filter_kwargs(data, cls._get_init_keys()))
-
-    @classmethod
-    def from_list(cls: Type[const.T], datas: List[Dict[str, Any]]) -> List[const.T]:
-        """
-        Process and converts list data received from discord api to object class instances.
-
-        Args:
-            datas: The json data received from discord api.
-
-        Returns:
-            List of object class instances.
-
-        """
-        return [cls.from_dict(data) for data in datas]
-
-    def update_from_dict(self: Type[const.T], data: Dict[str, Any]) -> const.T:
-        """
-        Updates object attribute(s) with new json data received from discord api.
-
-        Args:
-            data: The json data received from discord api.
-
-        Returns:
-            The updated object class instance.
-
-        """
-        data = self._process_dict(data)
-        for key, value in self._filter_kwargs(data, self._get_keys()).items():
-            setattr(self, key, value)
-
-        return self
-
-    def _check_object(self) -> None:
-        """Logic to check object properties just before export to json data for sending to discord api."""
-
-    def to_dict(self) -> Dict[str, Any]:
-        """
-        Exports object into dictionary representation, ready to be sent to discord api.
-
-        Returns:
-            The exported dictionary.
-
-        """
-        self._check_object()
-        return serializer.to_dict(self)
+from logging import Logger
+from typing import Any, Dict, List, Type
+
+import attrs
+
+import interactions.client.const as const
+import interactions.client.utils.serializer as serializer
+
+__all__ = ("DictSerializationMixin",)
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False)
+class DictSerializationMixin:
+    logger: Logger = attrs.field(init=False, factory=const.get_logger, metadata=serializer.no_export_meta, repr=False)
+
+    @classmethod
+    def _get_keys(cls) -> frozenset:
+        if (keys := getattr(cls, "_keys", None)) is None:
+            keys = frozenset(field.name for field in attrs.fields(cls))
+            setattr(cls, "_keys", keys)
+        return keys
+
+    @classmethod
+    def _get_init_keys(cls) -> frozenset:
+        name = f"_init_keys_{cls.__name__}"
+        if (init_keys := getattr(cls, name, None)) is None:
+            init_keys = frozenset(field.name.removeprefix("_") for field in attrs.fields(cls) if field.init)
+            setattr(cls, name, init_keys)
+        return init_keys
+
+    @classmethod
+    def _filter_kwargs(cls, kwargs_dict: dict, keys: frozenset) -> dict:
+        if const.kwarg_spam:
+            unused = {k: v for k, v in kwargs_dict.items() if k not in keys}
+            const.get_logger().debug(f"Unused kwargs: {cls.__name__}: {unused}")  # for debug
+        return {k: v for k, v in kwargs_dict.items() if k in keys}
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any]) -> Dict[str, Any]:
+        """
+        Process dictionary data received from discord api. Does cleanup and other checks to data.
+
+        Args:
+            data: The dictionary data received from discord api.
+
+        Returns:
+            The processed dictionary. Ready to be converted into object class.
+
+        """
+        return data
+
+    @classmethod
+    def from_dict(cls: Type[const.T], data: Dict[str, Any]) -> const.T:
+        """
+        Process and converts dictionary data received from discord api to object class instance.
+
+        Args:
+            data: The json data received from discord api.
+
+        Returns:
+            The object class instance.
+
+        """
+        if isinstance(data, cls):
+            return data
+        data = cls._process_dict(data)
+        return cls(**cls._filter_kwargs(data, cls._get_init_keys()))
+
+    @classmethod
+    def from_list(cls: Type[const.T], datas: List[Dict[str, Any]]) -> List[const.T]:
+        """
+        Process and converts list data received from discord api to object class instances.
+
+        Args:
+            datas: The json data received from discord api.
+
+        Returns:
+            List of object class instances.
+
+        """
+        return [cls.from_dict(data) for data in datas]
+
+    def update_from_dict(self: Type[const.T], data: Dict[str, Any]) -> const.T:
+        """
+        Updates object attribute(s) with new json data received from discord api.
+
+        Args:
+            data: The json data received from discord api.
+
+        Returns:
+            The updated object class instance.
+
+        """
+        data = self._process_dict(data)
+        for key, value in self._filter_kwargs(data, self._get_keys()).items():
+            setattr(self, key, value)
+
+        return self
+
+    def _check_object(self) -> None:
+        """Logic to check object properties just before export to json data for sending to discord api."""
+
+    def to_dict(self) -> Dict[str, Any]:
+        """
+        Exports object into dictionary representation, ready to be sent to discord api.
+
+        Returns:
+            The exported dictionary.
+
+        """
+        self._check_object()
+        return serializer.to_dict(self)
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/utils/attr_converters.py` & `discord-py-interactions-5.6.0/interactions/client/utils/attr_converters.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,72 +1,72 @@
-import inspect
-import typing
-from datetime import datetime
-from typing import Callable, Union, Any
-
-from interactions.client.const import MISSING
-from interactions.models.discord.timestamp import Timestamp
-
-__all__ = ("timestamp_converter", "list_converter", "optional")
-
-
-def timestamp_converter(value: Union[datetime, int, float, str]) -> Timestamp:
-    """
-    Converts a datetime, int, float, or str to a Timestamp object
-
-    Args:
-        value: The time value to convert
-
-    Returns:
-        A Timestamp object
-
-    """
-    if isinstance(value, str):
-        return Timestamp.fromisoformat(value)
-    if isinstance(value, (float, int)):
-        return Timestamp.fromtimestamp(float(value))
-    if isinstance(value, datetime):
-        return Timestamp.fromdatetime(value)
-    raise TypeError("Timestamp must be one of: datetime, int, float, ISO8601 str")
-
-
-def list_converter(converter) -> Callable[[list], list]:
-    """Converts a list of values to a list of converted values"""
-
-    def convert_action(value: Union[list, Any]) -> list:
-        if not isinstance(value, list):
-            """If only one single item was passed (without a list), then we only convert that one item instead of throwing an exception."""
-            return [converter(value)]
-
-        return [converter(element) for element in value]
-
-    return convert_action
-
-
-def optional(converter: typing.Callable) -> typing.Any:
-    """
-    A modified version of attrs optional converter that supports both `None` and `MISSING`
-
-    Type annotations will be inferred from the wrapped converter's, if it
-    has any.
-
-    Args:
-        converter: The convertor that is used for the non-None or MISSING
-
-    """
-
-    def optional_converter(val) -> typing.Any:
-        return val if val is None or val is MISSING else converter(val)
-
-    sig = None
-    try:
-        sig = inspect.signature(converter)
-    except (ValueError, TypeError):  # inspect failed
-        pass
-    if sig:
-        params = list(sig.parameters.values())
-        if params and params[0].annotation is not inspect.Parameter.empty:
-            optional_converter.__annotations__["val"] = typing.Optional[params[0].annotation]
-        if sig.return_annotation is not inspect.Signature.empty:
-            optional_converter.__annotations__["return"] = typing.Optional[sig.return_annotation]
-
-    return optional_converter
+import inspect
+import typing
+from datetime import datetime
+from typing import Callable, Union, Any
+
+from interactions.client.const import MISSING
+from interactions.models.discord.timestamp import Timestamp
+
+__all__ = ("timestamp_converter", "list_converter", "optional")
+
+
+def timestamp_converter(value: Union[datetime, int, float, str]) -> Timestamp:
+    """
+    Converts a datetime, int, float, or str to a Timestamp object
+
+    Args:
+        value: The time value to convert
+
+    Returns:
+        A Timestamp object
+
+    """
+    if isinstance(value, str):
+        return Timestamp.fromisoformat(value)
+    if isinstance(value, (float, int)):
+        return Timestamp.fromtimestamp(float(value))
+    if isinstance(value, datetime):
+        return Timestamp.fromdatetime(value)
+    raise TypeError("Timestamp must be one of: datetime, int, float, ISO8601 str")
+
+
+def list_converter(converter) -> Callable[[list], list]:
+    """Converts a list of values to a list of converted values"""
+
+    def convert_action(value: Union[list, Any]) -> list:
+        if not isinstance(value, list):
+            """If only one single item was passed (without a list), then we only convert that one item instead of throwing an exception."""
+            return [converter(value)]
+
+        return [converter(element) for element in value]
+
+    return convert_action
+
+
+def optional(converter: typing.Callable) -> typing.Any:
+    """
+    A modified version of attrs optional converter that supports both `None` and `MISSING`
+
+    Type annotations will be inferred from the wrapped converter's, if it
+    has any.
+
+    Args:
+        converter: The convertor that is used for the non-None or MISSING
+
+    """
+
+    def optional_converter(val) -> typing.Any:
+        return val if val is None or val is MISSING else converter(val)
+
+    sig = None
+    try:
+        sig = inspect.signature(converter)
+    except (ValueError, TypeError):  # inspect failed
+        pass
+    if sig:
+        params = list(sig.parameters.values())
+        if params and params[0].annotation is not inspect.Parameter.empty:
+            optional_converter.__annotations__["val"] = typing.Optional[params[0].annotation]
+        if sig.return_annotation is not inspect.Signature.empty:
+            optional_converter.__annotations__["return"] = typing.Optional[sig.return_annotation]
+
+    return optional_converter
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/utils/attr_utils.py` & `discord-py-interactions-5.6.0/interactions/client/utils/attr_utils.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,82 +1,82 @@
-from functools import partial
-from typing import Any, Dict, Callable
-
-import attrs
-from attr import Attribute
-
-from interactions.client.const import MISSING, get_logger
-
-__all__ = ("define", "field", "docs", "str_validator")
-
-
-class_defaults = {
-    "eq": False,
-    "order": False,
-    "hash": False,
-    "slots": True,
-    "kw_only": True,
-}
-field_defaults = {"repr": False}
-
-
-define = partial(attrs.define, **class_defaults)  # type: ignore
-field = partial(attrs.field, **field_defaults)  # type: ignore
-
-
-def docs(doc_string: str) -> Dict[str, str]:
-    """
-    Makes it easier to quickly type attr documentation.
-
-    Args:
-        doc_string: The documentation string.
-
-    Returns:
-        The processed metadata dict
-    """
-    return {"docs": doc_string}
-
-
-def str_validator(self: Any, attribute: attrs.Attribute, value: Any) -> None:
-    """
-    Validates that the value is a string. Helps convert and ives a warning if it isn't.
-
-    Args:
-        self: The instance of the class.
-        attribute: The attr attribute being validated.
-        value: The value being validated.
-
-    """
-    if not isinstance(value, str):
-        if value is MISSING:
-            return
-        setattr(self, attribute.name, str(value))
-        get_logger().warning(
-            f"Value of {attribute.name} has been automatically converted to a string. Please use strings in future.\n"
-            "Note: Discord will always return value as a string"
-        )
-
-
-def attrs_validator(
-    validator: Callable, skip_fields: list[str] | None = None
-) -> Callable[[Any, list[Attribute]], list[Attribute]]:
-    """
-    Sets a validator to all fields of an attrs-dataclass.
-
-    Args:
-        validator: The validator to set
-        skip_fields: A list of fields to skip adding the validator to
-
-    Returns:
-        The new fields for the attrs class
-    """
-
-    def operation(_, attributes: list[Attribute]) -> list[Attribute]:
-        new_attrs = []
-        for attr in attributes:
-            if skip_fields and attr.name in skip_fields:
-                new_attrs.append(attr)
-            else:
-                new_attrs.append(attr.evolve(validator=validator))
-        return new_attrs
-
-    return operation
+from functools import partial
+from typing import Any, Dict, Callable
+
+import attrs
+from attr import Attribute
+
+from interactions.client.const import MISSING, get_logger
+
+__all__ = ("define", "field", "docs", "str_validator")
+
+
+class_defaults = {
+    "eq": False,
+    "order": False,
+    "hash": False,
+    "slots": True,
+    "kw_only": True,
+}
+field_defaults = {"repr": False}
+
+
+define = partial(attrs.define, **class_defaults)  # type: ignore
+field = partial(attrs.field, **field_defaults)  # type: ignore
+
+
+def docs(doc_string: str) -> Dict[str, str]:
+    """
+    Makes it easier to quickly type attr documentation.
+
+    Args:
+        doc_string: The documentation string.
+
+    Returns:
+        The processed metadata dict
+    """
+    return {"docs": doc_string}
+
+
+def str_validator(self: Any, attribute: attrs.Attribute, value: Any) -> None:
+    """
+    Validates that the value is a string. Helps convert and ives a warning if it isn't.
+
+    Args:
+        self: The instance of the class.
+        attribute: The attr attribute being validated.
+        value: The value being validated.
+
+    """
+    if not isinstance(value, str):
+        if value is MISSING:
+            return
+        setattr(self, attribute.name, str(value))
+        get_logger().warning(
+            f"Value of {attribute.name} has been automatically converted to a string. Please use strings in future.\n"
+            "Note: Discord will always return value as a string"
+        )
+
+
+def attrs_validator(
+    validator: Callable, skip_fields: list[str] | None = None
+) -> Callable[[Any, list[Attribute]], list[Attribute]]:
+    """
+    Sets a validator to all fields of an attrs-dataclass.
+
+    Args:
+        validator: The validator to set
+        skip_fields: A list of fields to skip adding the validator to
+
+    Returns:
+        The new fields for the attrs class
+    """
+
+    def operation(_, attributes: list[Attribute]) -> list[Attribute]:
+        new_attrs = []
+        for attr in attributes:
+            if skip_fields and attr.name in skip_fields:
+                new_attrs.append(attr)
+            else:
+                new_attrs.append(attr.evolve(validator=validator))
+        return new_attrs
+
+    return operation
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/utils/deserialise_app_cmds.py` & `discord-py-interactions-5.6.0/interactions/client/utils/deserialise_app_cmds.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,108 +1,108 @@
-from typing import TYPE_CHECKING
-
-import interactions.client.const as const
-import interactions.models as models
-from interactions.models.discord.enums import CommandType
-
-if TYPE_CHECKING:
-    from interactions import InteractionCommand, SlashCommand, SlashCommandOption
-
-__all__ = ("deserialize_app_cmds",)
-
-
-def deserialize_app_cmds(data: list[dict]) -> list["InteractionCommand"]:
-    """
-    Deserializes the application_commands field of the audit log.
-
-    Args:
-        data: The application commands data
-
-    Returns:
-        A list of interaction command objects
-    """
-    out = []
-    command_mapping = {
-        CommandType.CHAT_INPUT: models.internal.SlashCommand,
-        CommandType.USER: models.internal.ContextMenu,
-        CommandType.MESSAGE: models.internal.ContextMenu,
-    }
-
-    for cmd_dict in data:
-        options = cmd_dict.pop("options", [])
-        cmd_type = cmd_dict["type"]
-
-        if cmd_type == CommandType.CHAT_INPUT:
-            del cmd_dict["type"]
-        else:
-            del cmd_dict["description"]
-
-        cmd_dict["cmd_id"] = cmd_dict.pop("id")
-        cmd_dict["scopes"] = [cmd_dict.pop("guild_id", const.GLOBAL_SCOPE)]
-
-        del cmd_dict["version"]
-        del cmd_dict["default_permission"]
-        cmd = command_mapping[cmd_type](**cmd_dict)  # type: ignore
-
-        if options:
-            if subcommands := deserialize_subcommands(cmd, options):
-                out += subcommands
-                continue
-            cmd.options = deserialize_options(options)
-
-        out.append(cmd)
-    return out
-
-
-def deserialize_subcommands(
-    base_cmd: "SlashCommand", options: list[dict], parent_group: dict | None = None
-) -> list["SlashCommand"]:
-    """
-    Deserializes subcommands.
-
-    Args:
-        base_cmd: The subcommands base command
-        options: The options from the parent
-        parent_group: The parent group, if any
-
-    Returns:
-        A list of slashcommand (subcommand) objects
-    """
-    out = []
-    for opt in options:
-        if opt["type"] == models.internal.OptionType.SUB_COMMAND_GROUP:
-            out += deserialize_subcommands(
-                base_cmd, opt["options"], {"name": opt["name"], "description": opt["description"]}
-            )
-        elif opt["type"] == models.internal.OptionType.SUB_COMMAND:
-            out.append(
-                models.internal.SlashCommand(
-                    name=base_cmd.name,
-                    description=base_cmd.description,
-                    group_name=parent_group["name"] if parent_group else None,
-                    group_description=parent_group["description"] if parent_group else None,
-                    options=deserialize_options(opt.get("options", [])),
-                    sub_cmd_name=opt["name"],
-                    sub_cmd_description=opt["description"],
-                    default_member_permissions=base_cmd.default_member_permissions,
-                    dm_permission=base_cmd.dm_permission,
-                    scopes=base_cmd.scopes,
-                )
-            )
-    return out
-
-
-def deserialize_options(options: list[dict]) -> list["SlashCommandOption"]:
-    """
-    Deserializes the options of a slash command
-
-    Args:
-        options: The list of options provided by discord
-
-    Returns:
-        list of SlashCommandOption objects
-    """
-    return [
-        models.internal.SlashCommandOption(**opt)
-        for opt in options
-        if opt["type"] not in (models.internal.OptionType.SUB_COMMAND_GROUP, models.internal.OptionType.SUB_COMMAND)
-    ]
+from typing import TYPE_CHECKING
+
+import interactions.client.const as const
+import interactions.models as models
+from interactions.models.discord.enums import CommandType
+
+if TYPE_CHECKING:
+    from interactions import InteractionCommand, SlashCommand, SlashCommandOption
+
+__all__ = ("deserialize_app_cmds",)
+
+
+def deserialize_app_cmds(data: list[dict]) -> list["InteractionCommand"]:
+    """
+    Deserializes the application_commands field of the audit log.
+
+    Args:
+        data: The application commands data
+
+    Returns:
+        A list of interaction command objects
+    """
+    out = []
+    command_mapping = {
+        CommandType.CHAT_INPUT: models.internal.SlashCommand,
+        CommandType.USER: models.internal.ContextMenu,
+        CommandType.MESSAGE: models.internal.ContextMenu,
+    }
+
+    for cmd_dict in data:
+        options = cmd_dict.pop("options", [])
+        cmd_type = cmd_dict["type"]
+
+        if cmd_type == CommandType.CHAT_INPUT:
+            del cmd_dict["type"]
+        else:
+            del cmd_dict["description"]
+
+        cmd_dict["cmd_id"] = cmd_dict.pop("id")
+        cmd_dict["scopes"] = [cmd_dict.pop("guild_id", const.GLOBAL_SCOPE)]
+
+        del cmd_dict["version"]
+        del cmd_dict["default_permission"]
+        cmd = command_mapping[cmd_type](**cmd_dict)  # type: ignore
+
+        if options:
+            if subcommands := deserialize_subcommands(cmd, options):
+                out += subcommands
+                continue
+            cmd.options = deserialize_options(options)
+
+        out.append(cmd)
+    return out
+
+
+def deserialize_subcommands(
+    base_cmd: "SlashCommand", options: list[dict], parent_group: dict | None = None
+) -> list["SlashCommand"]:
+    """
+    Deserializes subcommands.
+
+    Args:
+        base_cmd: The subcommands base command
+        options: The options from the parent
+        parent_group: The parent group, if any
+
+    Returns:
+        A list of slashcommand (subcommand) objects
+    """
+    out = []
+    for opt in options:
+        if opt["type"] == models.internal.OptionType.SUB_COMMAND_GROUP:
+            out += deserialize_subcommands(
+                base_cmd, opt["options"], {"name": opt["name"], "description": opt["description"]}
+            )
+        elif opt["type"] == models.internal.OptionType.SUB_COMMAND:
+            out.append(
+                models.internal.SlashCommand(
+                    name=base_cmd.name,
+                    description=base_cmd.description,
+                    group_name=parent_group["name"] if parent_group else None,
+                    group_description=parent_group["description"] if parent_group else None,
+                    options=deserialize_options(opt.get("options", [])),
+                    sub_cmd_name=opt["name"],
+                    sub_cmd_description=opt["description"],
+                    default_member_permissions=base_cmd.default_member_permissions,
+                    dm_permission=base_cmd.dm_permission,
+                    scopes=base_cmd.scopes,
+                )
+            )
+    return out
+
+
+def deserialize_options(options: list[dict]) -> list["SlashCommandOption"]:
+    """
+    Deserializes the options of a slash command
+
+    Args:
+        options: The list of options provided by discord
+
+    Returns:
+        list of SlashCommandOption objects
+    """
+    return [
+        models.internal.SlashCommandOption(**opt)
+        for opt in options
+        if opt["type"] not in (models.internal.OptionType.SUB_COMMAND_GROUP, models.internal.OptionType.SUB_COMMAND)
+    ]
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/utils/serializer.py` & `discord-py-interactions-5.6.0/interactions/client/utils/serializer.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,184 +1,184 @@
-from base64 import b64encode
-from datetime import datetime, timezone
-from io import IOBase
-from pathlib import Path
-from typing import Optional
-
-from attr import fields, has
-
-from interactions.client.const import MISSING, T
-from interactions.models.discord.file import UPLOADABLE_TYPE, File
-
-__all__ = (
-    "no_export_meta",
-    "export_converter",
-    "to_dict",
-    "dict_filter_none",
-    "dict_filter",
-    "to_image_data",
-    "get_file_mimetype",
-)
-
-no_export_meta = {"no_export": True}
-
-
-def export_converter(converter) -> dict:
-    """Makes it easier to quickly type attr export converter metadata."""
-    return {"export_converter": converter}
-
-
-def to_dict(inst) -> dict:
-    """
-    Converts an instance to a dict.
-
-    Args:
-        inst: The instance to convert.
-
-    Returns:
-        The processed dict.
-
-    """
-    attrs = fields(inst.__class__)
-
-    if (converter := getattr(inst, "as_dict", None)) is not None:
-        d = converter()
-        for a in attrs:
-            if a.metadata.get("no_export", False):
-                d.pop(a.name, None)
-        return d
-
-    d = {}
-
-    for a in attrs:
-        if a.metadata.get("no_export", False):
-            continue
-
-        raw_value = getattr(inst, a.name)
-        if raw_value is MISSING:
-            continue
-
-        if (c := a.metadata.get("export_converter", None)) is not None:
-            value = c(raw_value)
-        else:
-            value = _to_dict_any(raw_value)
-
-        if isinstance(value, (bool, int)) or value:
-            d[a.name] = value
-
-    return d
-
-
-def _to_dict_any(inst: T) -> dict | list | str | T:
-    """
-    Converts any type to a dict.
-
-    Args:
-        inst: The instance to convert.
-
-    Returns:
-        The processed dict.
-
-    """
-    if has(inst.__class__):
-        return to_dict(inst)
-    if isinstance(inst, dict):
-        return {key: _to_dict_any(value) for key, value in inst.items()}
-    if isinstance(inst, (list, tuple, set, frozenset)):
-        return [_to_dict_any(item) for item in inst]
-    if isinstance(inst, datetime):
-        if inst.tzinfo:
-            return inst.isoformat()
-        return inst.replace(tzinfo=timezone.utc).isoformat()
-    return inst
-
-
-def dict_filter_none(data: dict) -> dict:
-    """
-    Filters out all values that are None.
-
-    Args:
-        data: The dict data to filter.
-
-    Returns:
-        The filtered dict data.
-
-    """
-    return {k: v for k, v in data.items() if v is not None}
-
-
-def dict_filter(data: dict) -> dict:
-    """
-    Filters out all values that are MISSING sentinel and converts all sets to lists.
-
-    Args:
-        data: The dict data to filter.
-
-    Returns:
-        The filtered dict data.
-
-    """
-    filtered = data.copy()
-    for k, v in data.items():
-        if v is MISSING:
-            filtered.pop(k)
-        elif isinstance(v, set):
-            filtered[k] = list(v)
-    return filtered
-
-
-def to_image_data(imagefile: Optional["UPLOADABLE_TYPE"]) -> Optional[str]:
-    """
-    Converts an image file to base64 encoded image data for discord api.
-
-    Args:
-        imagefile: The target image file to encode.
-
-    Returns:
-        The base64 encoded image data.
-
-    """
-    match imagefile:
-        case bytes():
-            image_data = imagefile
-        case IOBase():
-            image_data = imagefile.read()
-        case Path() | str():
-            with open(str(imagefile), "rb") as image_buffer:
-                image_data = image_buffer.read()
-        case File():
-            data = imagefile.open_file()
-            image_data = data.read() if hasattr(data, "read") else data
-        case _:
-            return imagefile
-
-    mimetype = get_file_mimetype(image_data)
-    encoded_image = b64encode(image_data).decode("ascii")
-
-    return f"data:{mimetype};base64,{encoded_image}"
-
-
-def get_file_mimetype(file_data: bytes) -> str:
-    """
-    Gets the mimetype of a file based on file signature.
-
-    Args:
-        file_data: The file data to process.
-
-    Returns:
-        The mimetype of the file.
-
-    """
-    if isinstance(file_data, str):
-        return "text/plain"
-
-    if file_data.startswith(b"{"):
-        return "application/json"
-    if file_data.startswith((b"GIF87a", b"GIF89a")):
-        return "image/gif"
-    if file_data.startswith(b"\x89PNG\x0D\x0A\x1A\x0A"):
-        return "image/png"
-    if file_data.startswith(b"\xff\xd8\xff"):
-        return "image/jpeg"
-    if file_data[:4] == b"RIFF" and file_data[8:12] == b"WEBP":
-        return "image/webp"
-    return "application/octet-stream"
+from base64 import b64encode
+from datetime import datetime, timezone
+from io import IOBase
+from pathlib import Path
+from typing import Optional
+
+from attr import fields, has
+
+from interactions.client.const import MISSING, T
+from interactions.models.discord.file import UPLOADABLE_TYPE, File
+
+__all__ = (
+    "no_export_meta",
+    "export_converter",
+    "to_dict",
+    "dict_filter_none",
+    "dict_filter",
+    "to_image_data",
+    "get_file_mimetype",
+)
+
+no_export_meta = {"no_export": True}
+
+
+def export_converter(converter) -> dict:
+    """Makes it easier to quickly type attr export converter metadata."""
+    return {"export_converter": converter}
+
+
+def to_dict(inst) -> dict:
+    """
+    Converts an instance to a dict.
+
+    Args:
+        inst: The instance to convert.
+
+    Returns:
+        The processed dict.
+
+    """
+    attrs = fields(inst.__class__)
+
+    if (converter := getattr(inst, "as_dict", None)) is not None:
+        d = converter()
+        for a in attrs:
+            if a.metadata.get("no_export", False):
+                d.pop(a.name, None)
+        return d
+
+    d = {}
+
+    for a in attrs:
+        if a.metadata.get("no_export", False):
+            continue
+
+        raw_value = getattr(inst, a.name)
+        if raw_value is MISSING:
+            continue
+
+        if (c := a.metadata.get("export_converter", None)) is not None:
+            value = c(raw_value)
+        else:
+            value = _to_dict_any(raw_value)
+
+        if isinstance(value, (bool, int)) or value:
+            d[a.name] = value
+
+    return d
+
+
+def _to_dict_any(inst: T) -> dict | list | str | T:
+    """
+    Converts any type to a dict.
+
+    Args:
+        inst: The instance to convert.
+
+    Returns:
+        The processed dict.
+
+    """
+    if has(inst.__class__):
+        return to_dict(inst)
+    if isinstance(inst, dict):
+        return {key: _to_dict_any(value) for key, value in inst.items()}
+    if isinstance(inst, (list, tuple, set, frozenset)):
+        return [_to_dict_any(item) for item in inst]
+    if isinstance(inst, datetime):
+        if inst.tzinfo:
+            return inst.isoformat()
+        return inst.replace(tzinfo=timezone.utc).isoformat()
+    return inst
+
+
+def dict_filter_none(data: dict) -> dict:
+    """
+    Filters out all values that are None.
+
+    Args:
+        data: The dict data to filter.
+
+    Returns:
+        The filtered dict data.
+
+    """
+    return {k: v for k, v in data.items() if v is not None}
+
+
+def dict_filter(data: dict) -> dict:
+    """
+    Filters out all values that are MISSING sentinel and converts all sets to lists.
+
+    Args:
+        data: The dict data to filter.
+
+    Returns:
+        The filtered dict data.
+
+    """
+    filtered = data.copy()
+    for k, v in data.items():
+        if v is MISSING:
+            filtered.pop(k)
+        elif isinstance(v, set):
+            filtered[k] = list(v)
+    return filtered
+
+
+def to_image_data(imagefile: Optional["UPLOADABLE_TYPE"]) -> Optional[str]:
+    """
+    Converts an image file to base64 encoded image data for discord api.
+
+    Args:
+        imagefile: The target image file to encode.
+
+    Returns:
+        The base64 encoded image data.
+
+    """
+    match imagefile:
+        case bytes():
+            image_data = imagefile
+        case IOBase():
+            image_data = imagefile.read()
+        case Path() | str():
+            with open(str(imagefile), "rb") as image_buffer:
+                image_data = image_buffer.read()
+        case File():
+            data = imagefile.open_file()
+            image_data = data.read() if hasattr(data, "read") else data
+        case _:
+            return imagefile
+
+    mimetype = get_file_mimetype(image_data)
+    encoded_image = b64encode(image_data).decode("ascii")
+
+    return f"data:{mimetype};base64,{encoded_image}"
+
+
+def get_file_mimetype(file_data: bytes) -> str:
+    """
+    Gets the mimetype of a file based on file signature.
+
+    Args:
+        file_data: The file data to process.
+
+    Returns:
+        The mimetype of the file.
+
+    """
+    if isinstance(file_data, str):
+        return "text/plain"
+
+    if file_data.startswith(b"{"):
+        return "application/json"
+    if file_data.startswith((b"GIF87a", b"GIF89a")):
+        return "image/gif"
+    if file_data.startswith(b"\x89PNG\x0D\x0A\x1A\x0A"):
+        return "image/png"
+    if file_data.startswith(b"\xff\xd8\xff"):
+        return "image/jpeg"
+    if file_data[:4] == b"RIFF" and file_data[8:12] == b"WEBP":
+        return "image/webp"
+    return "application/octet-stream"
```

### Comparing `discord-py-interactions-5.5.1/interactions/client/utils/text_utils.py` & `discord-py-interactions-5.6.0/interactions/client/utils/text_utils.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-import re
-import interactions.models as models
-
-__all__ = ("mentions",)
-
-
-def mentions(
-    text: str,
-    query: "str | re.Pattern[str] | models.BaseUser | models.BaseChannel | models.Role",
-    *,
-    tag_as_mention: bool = False,
-) -> bool:
-    """
-    Checks whether a query is present in a text.
-
-    Args:
-        text: The text to search in
-        query: The query to search for
-        tag_as_mention: Should `BaseUser.tag` be checked *(only if query is an instance of BaseUser)*
-
-    Returns:
-        Whether the query could be found in the text
-    """
-    if isinstance(query, str):
-        return query in text
-    if isinstance(query, re.Pattern):
-        return query.match(text) is not None
-    if isinstance(query, models.BaseUser):
-        # mentions with <@!ID> aren't detected without the replacement
-        return (query.mention in text.replace("@!", "@")) or (query.tag in text if tag_as_mention else False)
-    if isinstance(query, (models.BaseChannel, models.Role)):
-        return query.mention in text
-    return False
+import re
+import interactions.models as models
+
+__all__ = ("mentions",)
+
+
+def mentions(
+    text: str,
+    query: "str | re.Pattern[str] | models.BaseUser | models.BaseChannel | models.Role",
+    *,
+    tag_as_mention: bool = False,
+) -> bool:
+    """
+    Checks whether a query is present in a text.
+
+    Args:
+        text: The text to search in
+        query: The query to search for
+        tag_as_mention: Should `BaseUser.tag` be checked *(only if query is an instance of BaseUser)*
+
+    Returns:
+        Whether the query could be found in the text
+    """
+    if isinstance(query, str):
+        return query in text
+    if isinstance(query, re.Pattern):
+        return query.match(text) is not None
+    if isinstance(query, models.BaseUser):
+        # mentions with <@!ID> aren't detected without the replacement
+        return (query.mention in text.replace("@!", "@")) or (query.tag in text if tag_as_mention else False)
+    if isinstance(query, (models.BaseChannel, models.Role)):
+        return query.mention in text
+    return False
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/console.py` & `discord-py-interactions-5.6.0/interactions/ext/console.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-import asyncio
-
-import aiomonitor as aiomonitor
-
-import interactions
-from interactions import Extension
-
-__all__ = ("Console",)
-
-
-class Console(Extension):
-    """
-    Extension that starts the bot with the aiomonitor console active - notably giving you REPL for the bot
-
-    To access the console, you need to connect to the port specified in the constructor, by default 501.
-    On linux, you can do this with `nc localhost 501`, on windows you can use `telnet localhost 501`.
-
-    For both platforms you can also use "python -m aiomonitor.cli -p 501" as a replacement for the above commands.
-
-    Args:
-        port: The port to start the aiomonitor on
-        console_port: The port to start the aiomonitor console on
-        **kwargs: The locals to make available in the console, by default this includes `client`, `bot` and `interactions`
-
-    """
-
-    def __init__(self, client: interactions.Client, port: int = 501, console_port: int = 502, **kwargs) -> None:
-        self.client.astart = self.async_start_bot
-        self.port = port  # 501 was chosen as windows throws a massive fit if you try to use the default port
-        self.console_port = console_port
-        self.locals = kwargs
-
-    async def async_start_bot(self, token: str | None = None) -> None:
-        """Starts the bot with the console active"""
-        old_start = interactions.Client.astart
-
-        _locals = self.locals | {
-            "client": self.client,
-            "bot": self.client,
-            "interactions": interactions,
-        }
-
-        with aiomonitor.start_monitor(
-            loop=asyncio.get_event_loop(), port=self.port, console_port=self.console_port, locals=_locals
-        ) as monitor:
-            self.client.logger.info(f"Started aiomonitor on {monitor._host}:{monitor._port}")
-
-            await old_start(self.client, token)
+import asyncio
+
+import aiomonitor as aiomonitor
+
+import interactions
+from interactions import Extension
+
+__all__ = ("Console",)
+
+
+class Console(Extension):
+    """
+    Extension that starts the bot with the aiomonitor console active - notably giving you REPL for the bot
+
+    To access the console, you need to connect to the port specified in the constructor, by default 501.
+    On linux, you can do this with `nc localhost 501`, on windows you can use `telnet localhost 501`.
+
+    For both platforms you can also use "python -m aiomonitor.cli -p 501" as a replacement for the above commands.
+
+    Args:
+        port: The port to start the aiomonitor on
+        console_port: The port to start the aiomonitor console on
+        **kwargs: The locals to make available in the console, by default this includes `client`, `bot` and `interactions`
+
+    """
+
+    def __init__(self, client: interactions.Client, port: int = 501, console_port: int = 502, **kwargs) -> None:
+        self.client.astart = self.async_start_bot
+        self.port = port  # 501 was chosen as windows throws a massive fit if you try to use the default port
+        self.console_port = console_port
+        self.locals = kwargs
+
+    async def async_start_bot(self, token: str | None = None) -> None:
+        """Starts the bot with the console active"""
+        old_start = interactions.Client.astart
+
+        _locals = self.locals | {
+            "client": self.client,
+            "bot": self.client,
+            "interactions": interactions,
+        }
+
+        with aiomonitor.start_monitor(
+            loop=asyncio.get_event_loop(), port=self.port, console_port=self.console_port, locals=_locals
+        ) as monitor:
+            self.client.logger.info(f"Started aiomonitor on {monitor._host}:{monitor._port}")
+
+            await old_start(self.client, token)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/debug_extension/__init__.py` & `discord-py-interactions-5.6.0/interactions/ext/debug_extension/__init__.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,97 +1,97 @@
-import asyncio
-import platform
-import tracemalloc
-
-from interactions import (
-    Client,
-    Extension,
-    listen,
-    slash_command,
-    InteractionContext,
-    Timestamp,
-    TimestampStyles,
-    Intents,
-)
-from interactions.client.const import __version__, __py_version__
-from interactions.models.internal import checks
-from .debug_application_cmd import DebugAppCMD
-from .debug_exec import DebugExec
-from .debug_exts import DebugExts
-from .utils import get_cache_state, debug_embed
-
-__all__ = ("DebugExtension",)
-
-
-class DebugExtension(DebugExec, DebugAppCMD, DebugExts, Extension):
-    class Metadata(Extension.Metadata):
-        name = "Debug Extension"
-        description = "Debugging utilities for interactions.py"
-        version = "1.0.0"
-        url = "https://github.com/interactions-py/interactions.py"
-        requirements = ["interactions>=5.0.0"]
-
-    def __init__(self, bot: Client) -> None:
-        bot.logger.info("Debug Extension is mounting!")
-
-        super().__init__(bot)
-        self.add_ext_check(checks.is_owner())
-
-        tracemalloc.start()
-        bot.logger.warning("Tracemalloc started")
-
-        self.client.http.show_ratelimit_traceback = True
-        bot.logger.warning("Ratelimit tracebacks enabled")
-
-    async def async_start(self) -> None:
-        loop = asyncio.get_running_loop()
-        loop.set_debug(True)
-        self.bot.logger.warning("Asyncio debug mode enabled")
-
-    @listen()
-    async def on_startup(self) -> None:
-        self.bot.logger.info(f"Started {self.bot.user.tag} [{self.bot.user.id}] in Debug Mode")
-
-        self.bot.logger.info(f"Caching System State: \n{get_cache_state(self.bot)}")
-
-    @slash_command(
-        "debug",
-        sub_cmd_name="info",
-        sub_cmd_description="Get basic information about the bot",
-    )
-    async def debug_info(self, ctx: InteractionContext) -> None:
-        await ctx.defer()
-
-        uptime = Timestamp.fromdatetime(self.bot.start_time)
-        e = debug_embed("General")
-        e.set_thumbnail(self.bot.user.avatar.url)
-        e.add_field("Operating System", platform.platform())
-
-        e.add_field("Version Info", f"I.py@{__version__} | Py@{__py_version__}")
-
-        e.add_field("Start Time", f"{uptime.format(TimestampStyles.RelativeTime)}")
-
-        if privileged_intents := [i.name for i in self.bot.intents if i in Intents.PRIVILEGED]:
-            e.add_field("Privileged Intents", " | ".join(privileged_intents))
-
-        e.add_field("Loaded Exts", ", ".join(self.bot.ext))
-
-        e.add_field("Guilds", str(len(self.bot.guilds)))
-
-        await ctx.send(embeds=[e])
-
-    @debug_info.subcommand("cache", sub_cmd_description="Get information about the current cache state")
-    async def cache_info(self, ctx: InteractionContext) -> None:
-        await ctx.defer()
-        e = debug_embed("Cache")
-
-        e.description = f"```prolog\n{get_cache_state(self.bot)}\n```"
-        await ctx.send(embeds=[e])
-
-    @debug_info.subcommand("shutdown", sub_cmd_description="Shutdown the bot.")
-    async def shutdown(self, ctx: InteractionContext) -> None:
-        await ctx.send("Shutting down 😴")
-        await self.bot.stop()
-
-
-def setup(bot: Client) -> None:
-    DebugExtension(bot)
+import asyncio
+import platform
+import tracemalloc
+
+from interactions import (
+    Client,
+    Extension,
+    listen,
+    slash_command,
+    InteractionContext,
+    Timestamp,
+    TimestampStyles,
+    Intents,
+)
+from interactions.client.const import __version__, __py_version__
+from interactions.models.internal import checks
+from .debug_application_cmd import DebugAppCMD
+from .debug_exec import DebugExec
+from .debug_exts import DebugExts
+from .utils import get_cache_state, debug_embed
+
+__all__ = ("DebugExtension",)
+
+
+class DebugExtension(DebugExec, DebugAppCMD, DebugExts, Extension):
+    class Metadata(Extension.Metadata):
+        name = "Debug Extension"
+        description = "Debugging utilities for interactions.py"
+        version = "1.0.0"
+        url = "https://github.com/interactions-py/interactions.py"
+        requirements = ["interactions>=5.0.0"]
+
+    def __init__(self, bot: Client) -> None:
+        bot.logger.info("Debug Extension is mounting!")
+
+        super().__init__(bot)
+        self.add_ext_check(checks.is_owner())
+
+        tracemalloc.start()
+        bot.logger.warning("Tracemalloc started")
+
+        self.client.http.show_ratelimit_traceback = True
+        bot.logger.warning("Ratelimit tracebacks enabled")
+
+    async def async_start(self) -> None:
+        loop = asyncio.get_running_loop()
+        loop.set_debug(True)
+        self.bot.logger.warning("Asyncio debug mode enabled")
+
+    @listen()
+    async def on_startup(self) -> None:
+        self.bot.logger.info(f"Started {self.bot.user.tag} [{self.bot.user.id}] in Debug Mode")
+
+        self.bot.logger.info(f"Caching System State: \n{get_cache_state(self.bot)}")
+
+    @slash_command(
+        "debug",
+        sub_cmd_name="info",
+        sub_cmd_description="Get basic information about the bot",
+    )
+    async def debug_info(self, ctx: InteractionContext) -> None:
+        await ctx.defer()
+
+        uptime = Timestamp.fromdatetime(self.bot.start_time)
+        e = debug_embed("General")
+        e.set_thumbnail(self.bot.user.avatar.url)
+        e.add_field("Operating System", platform.platform())
+
+        e.add_field("Version Info", f"I.py@{__version__} | Py@{__py_version__}")
+
+        e.add_field("Start Time", f"{uptime.format(TimestampStyles.RelativeTime)}")
+
+        if privileged_intents := [i.name for i in self.bot.intents if i in Intents.PRIVILEGED]:
+            e.add_field("Privileged Intents", " | ".join(privileged_intents))
+
+        e.add_field("Loaded Exts", ", ".join(self.bot.ext))
+
+        e.add_field("Guilds", str(len(self.bot.guilds)))
+
+        await ctx.send(embeds=[e])
+
+    @debug_info.subcommand("cache", sub_cmd_description="Get information about the current cache state")
+    async def cache_info(self, ctx: InteractionContext) -> None:
+        await ctx.defer()
+        e = debug_embed("Cache")
+
+        e.description = f"```prolog\n{get_cache_state(self.bot)}\n```"
+        await ctx.send(embeds=[e])
+
+    @debug_info.subcommand("shutdown", sub_cmd_description="Shutdown the bot.")
+    async def shutdown(self, ctx: InteractionContext) -> None:
+        await ctx.send("Shutting down 😴")
+        await self.bot.stop()
+
+
+def setup(bot: Client) -> None:
+    DebugExtension(bot)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/debug_extension/debug_application_cmd.py` & `discord-py-interactions-5.6.0/interactions/ext/debug_extension/debug_application_cmd.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,208 +1,208 @@
-import io
-import pprint
-from typing import Optional
-
-from interactions import Extension, AutocompleteContext, Snowflake
-from interactions.client.client import Client
-from interactions.client.const import GLOBAL_SCOPE
-from interactions.client.errors import HTTPException
-from interactions.models import (
-    slash_command,
-    InteractionContext,
-    File,
-    Message,
-    slash_option,
-    OptionType,
-    application_commands_to_dict,
-)
-from interactions.models.internal import checks
-from .utils import debug_embed
-
-try:
-    from thefuzz import process
-
-    has_thefuzz = True
-except ImportError:
-    has_thefuzz = False
-
-__all__ = ("DebugAppCMD",)
-
-app_cmds_def = {
-    "group_name": "app_cmds",
-    "group_description": "Debug for application commands",
-}
-
-
-class DebugAppCMD(Extension):
-    def __init__(self, bot: Client) -> None:
-        self.add_ext_check(checks.is_owner())
-
-    @slash_command(
-        "debug",
-        sub_cmd_name="internal_info",
-        sub_cmd_description="Get Information about registered app commands",
-        **app_cmds_def,
-    )
-    async def app_cmd(self, ctx: InteractionContext) -> None:
-        await ctx.defer()
-        e = debug_embed("Application-Commands Cache")
-
-        cmds = len(self.bot._interaction_lookup)
-        e.add_field("Local application cmds (incld. Subcommands)", str(cmds))
-        e.add_field("Component callbacks", str(len(self.bot._component_callbacks)))
-        e.add_field("Tracked Scopes", str(len(self.client.interactions_by_scope)))
-
-        await ctx.send(embeds=[e])
-
-    @app_cmd.subcommand(
-        "lookup",
-        sub_cmd_description="Search for a specified command and get its json representation",
-        **app_cmds_def,
-    )
-    @slash_option(
-        "cmd_id",
-        "The ID of the command you want to lookup",
-        opt_type=OptionType.STRING,
-        required=True,
-    )
-    @slash_option(
-        "scope",
-        "The scope ID of the command, if you want to search for the cmd on remote",
-        opt_type=OptionType.STRING,
-        required=True,
-    )
-    @slash_option(
-        "remote",
-        "Should we search locally or remote for this command (default local)",
-        opt_type=OptionType.BOOLEAN,
-        required=False,
-    )
-    async def cmd_lookup(
-        self, ctx: InteractionContext, cmd_id: str, scope: str, remote: bool = False
-    ) -> Optional[Message]:
-        await ctx.defer()
-        try:
-            cmd_id = int(cmd_id.strip())
-            scope = int(scope.strip())
-
-            # search internal registers for command
-
-            async def send(cmd_json: dict) -> None:
-                await ctx.send(
-                    file=File(
-                        io.BytesIO(pprint.pformat(cmd_json, 2).encode("utf-8")),
-                        f"{cmd_json.get('name')}.json",
-                    )
-                )
-
-            if not remote:
-                data = application_commands_to_dict(self.bot.interactions_by_scope, self.bot)[scope]
-                cmd_obj = self.bot.get_application_cmd_by_id(cmd_id)
-                cmd_data = next((c for c in data if c["name"] == str(cmd_obj.name)), None)
-                if cmd_data:
-                    return await send(cmd_data)
-            else:
-                data = await self.bot.http.get_application_commands(self.bot.app.id, scope)
-                try:
-                    perm_scope = scope
-                    if scope == GLOBAL_SCOPE:
-                        perm_scope = ctx.guild_id
-                    perms = await self.bot.http.get_application_command_permissions(self.bot.app.id, perm_scope, cmd_id)
-                except HTTPException:
-                    perms = None
-                for cmd in data:
-                    if int(cmd["id"]) == cmd_id:
-                        if perms:
-                            cmd["permissions"] = perms.get("permissions")
-                        return await send(cmd)
-        except Exception:
-            pass
-        return await ctx.send(f"Unable to locate any commands in {scope} with ID {cmd_id}!")
-
-    @app_cmd.subcommand(
-        "list_scope",
-        sub_cmd_description="List all synced commands in a specified scope",
-        **app_cmds_def,
-    )
-    @slash_option(
-        "scope",
-        "The scope ID of the command, if it is not registered in the bot (0 for global)",
-        opt_type=OptionType.STRING,
-        required=True,
-    )
-    async def list_scope(self, ctx: InteractionContext, scope: str) -> Message:
-        await ctx.defer()
-        try:
-            cmds = await self.bot.http.get_application_commands(self.bot.app.id, int(scope.strip()))
-            if cmds:
-                e = debug_embed("Application Command Information")
-
-                e.description = f"**Listing Commands Registered in {scope}**\n\n" + "\n".join(
-                    [f"`{c['id']}` : `{c['name']}`" for c in cmds]
-                )
-                return await ctx.send(embeds=e)
-            return await ctx.send(f"No commands found in `{scope.strip()}`")
-        except Exception:
-            return await ctx.send(f"No commands found in `{scope.strip()}`")
-
-    @app_cmd.subcommand("delete_cmd", sub_cmd_description="Delete a command", **app_cmds_def)
-    @slash_option("scope", "The scope ID of the command (0 for global)", opt_type=OptionType.STRING, required=True)
-    @slash_option(
-        "cmd_id",
-        "The ID of the command you want to delete",
-        opt_type=OptionType.STRING,
-        required=True,
-        autocomplete=True,
-    )
-    async def delete_cmd(self, ctx: InteractionContext, scope: str, cmd_id: str) -> Message:
-        await ctx.defer()
-        try:
-            scope = int(scope.strip())
-            cmd_id = int(cmd_id.strip())
-            await self.bot.http.delete_application_command(self.bot.app.id, scope, cmd_id)
-            return await ctx.send(f"Successfully deleted command with ID `{cmd_id}` in scope `{scope}`!")
-        except Exception:
-            return await ctx.send(f"Unable to delete command with ID `{cmd_id}` in scope `{scope}`!")
-
-    @app_cmd.subcommand("delete_all", sub_cmd_description="Delete all commands from a scope", **app_cmds_def)
-    @slash_option("scope", "The scope ID of the command (0 for global)", opt_type=OptionType.STRING, required=True)
-    async def delete_all(self, ctx: InteractionContext, scope: str) -> Message:
-        await ctx.defer()
-        try:
-            scope = scope.strip()
-            scope = GLOBAL_SCOPE if scope == "0" else Snowflake(scope)
-
-            await self.bot.http.overwrite_application_commands(self.bot.app.id, [], scope)
-
-            return await ctx.send(f"Successfully deleted all commands in scope `{scope}`!")
-        except ValueError:
-            return await ctx.send(f"{scope} is not a valid scope ID!")
-        except Exception:
-            return await ctx.send(f"Unable to delete all commands in scope `{scope}`!")
-
-    @delete_cmd.autocomplete("cmd_id")
-    async def cmd_id_autocomplete(self, ctx: AutocompleteContext) -> None:
-        try:
-            scope = ctx.kwargs["scope"].strip()
-            scope = GLOBAL_SCOPE if scope == "0" else Snowflake(scope)
-            cmds = await self.bot.http.get_application_commands(self.bot.app.id, scope)
-
-            if not ctx.input_text:
-                await ctx.send([{"name": c["name"], "value": c["id"]} for c in cmds][:25])
-                return None
-
-            if has_thefuzz:
-                results = process.extract(ctx.input_text, {c["id"]: c["name"] for c in cmds}, limit=25)
-                return await ctx.send([{"name": c[0], "value": c[2]} for c in results if c[1] > 80])
-
-            await ctx.send(
-                [{"name": c["name"], "value": c["id"]} for c in cmds if ctx.input_text.lower() in c["name"].lower()][
-                    :25
-                ]
-            )
-        except ValueError:
-            return await ctx.send([])
-
-
-def setup(bot: Client) -> None:
-    DebugAppCMD(bot)
+import io
+import pprint
+from typing import Optional
+
+from interactions import Extension, AutocompleteContext, Snowflake
+from interactions.client.client import Client
+from interactions.client.const import GLOBAL_SCOPE
+from interactions.client.errors import HTTPException
+from interactions.models import (
+    slash_command,
+    InteractionContext,
+    File,
+    Message,
+    slash_option,
+    OptionType,
+    application_commands_to_dict,
+)
+from interactions.models.internal import checks
+from .utils import debug_embed
+
+try:
+    from thefuzz import process
+
+    has_thefuzz = True
+except ImportError:
+    has_thefuzz = False
+
+__all__ = ("DebugAppCMD",)
+
+app_cmds_def = {
+    "group_name": "app_cmds",
+    "group_description": "Debug for application commands",
+}
+
+
+class DebugAppCMD(Extension):
+    def __init__(self, bot: Client) -> None:
+        self.add_ext_check(checks.is_owner())
+
+    @slash_command(
+        "debug",
+        sub_cmd_name="internal_info",
+        sub_cmd_description="Get Information about registered app commands",
+        **app_cmds_def,
+    )
+    async def app_cmd(self, ctx: InteractionContext) -> None:
+        await ctx.defer()
+        e = debug_embed("Application-Commands Cache")
+
+        cmds = len(self.bot._interaction_lookup)
+        e.add_field("Local application cmds (incld. Subcommands)", str(cmds))
+        e.add_field("Component callbacks", str(len(self.bot._component_callbacks)))
+        e.add_field("Tracked Scopes", str(len(self.client.interactions_by_scope)))
+
+        await ctx.send(embeds=[e])
+
+    @app_cmd.subcommand(
+        "lookup",
+        sub_cmd_description="Search for a specified command and get its json representation",
+        **app_cmds_def,
+    )
+    @slash_option(
+        "cmd_id",
+        "The ID of the command you want to lookup",
+        opt_type=OptionType.STRING,
+        required=True,
+    )
+    @slash_option(
+        "scope",
+        "The scope ID of the command, if you want to search for the cmd on remote",
+        opt_type=OptionType.STRING,
+        required=True,
+    )
+    @slash_option(
+        "remote",
+        "Should we search locally or remote for this command (default local)",
+        opt_type=OptionType.BOOLEAN,
+        required=False,
+    )
+    async def cmd_lookup(
+        self, ctx: InteractionContext, cmd_id: str, scope: str, remote: bool = False
+    ) -> Optional[Message]:
+        await ctx.defer()
+        try:
+            cmd_id = int(cmd_id.strip())
+            scope = int(scope.strip())
+
+            # search internal registers for command
+
+            async def send(cmd_json: dict) -> None:
+                await ctx.send(
+                    file=File(
+                        io.BytesIO(pprint.pformat(cmd_json, 2).encode("utf-8")),
+                        f"{cmd_json.get('name')}.json",
+                    )
+                )
+
+            if not remote:
+                data = application_commands_to_dict(self.bot.interactions_by_scope, self.bot)[scope]
+                cmd_obj = self.bot.get_application_cmd_by_id(cmd_id)
+                cmd_data = next((c for c in data if c["name"] == str(cmd_obj.name)), None)
+                if cmd_data:
+                    return await send(cmd_data)
+            else:
+                data = await self.bot.http.get_application_commands(self.bot.app.id, scope)
+                try:
+                    perm_scope = scope
+                    if scope == GLOBAL_SCOPE:
+                        perm_scope = ctx.guild_id
+                    perms = await self.bot.http.get_application_command_permissions(self.bot.app.id, perm_scope, cmd_id)
+                except HTTPException:
+                    perms = None
+                for cmd in data:
+                    if int(cmd["id"]) == cmd_id:
+                        if perms:
+                            cmd["permissions"] = perms.get("permissions")
+                        return await send(cmd)
+        except Exception:
+            pass
+        return await ctx.send(f"Unable to locate any commands in {scope} with ID {cmd_id}!")
+
+    @app_cmd.subcommand(
+        "list_scope",
+        sub_cmd_description="List all synced commands in a specified scope",
+        **app_cmds_def,
+    )
+    @slash_option(
+        "scope",
+        "The scope ID of the command, if it is not registered in the bot (0 for global)",
+        opt_type=OptionType.STRING,
+        required=True,
+    )
+    async def list_scope(self, ctx: InteractionContext, scope: str) -> Message:
+        await ctx.defer()
+        try:
+            cmds = await self.bot.http.get_application_commands(self.bot.app.id, int(scope.strip()))
+            if cmds:
+                e = debug_embed("Application Command Information")
+
+                e.description = f"**Listing Commands Registered in {scope}**\n\n" + "\n".join(
+                    [f"`{c['id']}` : `{c['name']}`" for c in cmds]
+                )
+                return await ctx.send(embeds=e)
+            return await ctx.send(f"No commands found in `{scope.strip()}`")
+        except Exception:
+            return await ctx.send(f"No commands found in `{scope.strip()}`")
+
+    @app_cmd.subcommand("delete_cmd", sub_cmd_description="Delete a command", **app_cmds_def)
+    @slash_option("scope", "The scope ID of the command (0 for global)", opt_type=OptionType.STRING, required=True)
+    @slash_option(
+        "cmd_id",
+        "The ID of the command you want to delete",
+        opt_type=OptionType.STRING,
+        required=True,
+        autocomplete=True,
+    )
+    async def delete_cmd(self, ctx: InteractionContext, scope: str, cmd_id: str) -> Message:
+        await ctx.defer()
+        try:
+            scope = int(scope.strip())
+            cmd_id = int(cmd_id.strip())
+            await self.bot.http.delete_application_command(self.bot.app.id, scope, cmd_id)
+            return await ctx.send(f"Successfully deleted command with ID `{cmd_id}` in scope `{scope}`!")
+        except Exception:
+            return await ctx.send(f"Unable to delete command with ID `{cmd_id}` in scope `{scope}`!")
+
+    @app_cmd.subcommand("delete_all", sub_cmd_description="Delete all commands from a scope", **app_cmds_def)
+    @slash_option("scope", "The scope ID of the command (0 for global)", opt_type=OptionType.STRING, required=True)
+    async def delete_all(self, ctx: InteractionContext, scope: str) -> Message:
+        await ctx.defer()
+        try:
+            scope = scope.strip()
+            scope = GLOBAL_SCOPE if scope == "0" else Snowflake(scope)
+
+            await self.bot.http.overwrite_application_commands(self.bot.app.id, [], scope)
+
+            return await ctx.send(f"Successfully deleted all commands in scope `{scope}`!")
+        except ValueError:
+            return await ctx.send(f"{scope} is not a valid scope ID!")
+        except Exception:
+            return await ctx.send(f"Unable to delete all commands in scope `{scope}`!")
+
+    @delete_cmd.autocomplete("cmd_id")
+    async def cmd_id_autocomplete(self, ctx: AutocompleteContext) -> None:
+        try:
+            scope = ctx.kwargs["scope"].strip()
+            scope = GLOBAL_SCOPE if scope == "0" else Snowflake(scope)
+            cmds = await self.bot.http.get_application_commands(self.bot.app.id, scope)
+
+            if not ctx.input_text:
+                await ctx.send([{"name": c["name"], "value": c["id"]} for c in cmds][:25])
+                return None
+
+            if has_thefuzz:
+                results = process.extract(ctx.input_text, {c["id"]: c["name"] for c in cmds}, limit=25)
+                return await ctx.send([{"name": c[0], "value": c[2]} for c in results if c[1] > 80])
+
+            await ctx.send(
+                [{"name": c["name"], "value": c["id"]} for c in cmds if ctx.input_text.lower() in c["name"].lower()][
+                    :25
+                ]
+            )
+        except ValueError:
+            return await ctx.send([])
+
+
+def setup(bot: Client) -> None:
+    DebugAppCMD(bot)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/debug_extension/debug_exts.py` & `discord-py-interactions-5.6.0/interactions/ext/debug_extension/debug_exts.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-from interactions import Extension
-from interactions.client.errors import CommandCheckFailure, ExtensionLoadException
-from interactions.ext.prefixed_commands import prefixed_command, PrefixedContext
-
-__all__ = ("DebugExts",)
-
-
-class DebugExts(Extension):
-    @prefixed_command("debug_reload")
-    async def reload(self, ctx: PrefixedContext, module: str) -> None:
-        try:
-            await self.drop_ext.callback(ctx, module)
-        except ExtensionLoadException:
-            pass
-        await self.load_ext.callback(ctx, module)
-
-    @prefixed_command("debug_load")
-    async def load_ext(self, ctx: PrefixedContext, module: str) -> None:
-        self.bot.load_extension(module)
-        await ctx.message.add_reaction("🪴")
-
-    @prefixed_command("debug_drop")
-    async def drop_ext(self, ctx: PrefixedContext, module: str) -> None:
-        self.bot.unload_extension(module)
-        await ctx.message.add_reaction("💥")
-
-    @reload.error
-    @load_ext.error
-    @drop_ext.error
-    async def reload_error(self, error: Exception, ctx: PrefixedContext, *args) -> None:
-        if isinstance(error, CommandCheckFailure):
-            return await ctx.send("You do not have permission to execute this command")
-        if isinstance(error, ExtensionLoadException):
-            return await ctx.send(str(error))
-        raise
-
-
-def setup(bot) -> None:
-    DebugExts(bot)
+from interactions import Extension
+from interactions.client.errors import CommandCheckFailure, ExtensionLoadException
+from interactions.ext.prefixed_commands import prefixed_command, PrefixedContext
+
+__all__ = ("DebugExts",)
+
+
+class DebugExts(Extension):
+    @prefixed_command("debug_reload")
+    async def reload(self, ctx: PrefixedContext, module: str) -> None:
+        try:
+            await self.drop_ext.callback(ctx, module)
+        except ExtensionLoadException:
+            pass
+        await self.load_ext.callback(ctx, module)
+
+    @prefixed_command("debug_load")
+    async def load_ext(self, ctx: PrefixedContext, module: str) -> None:
+        self.bot.load_extension(module)
+        await ctx.message.add_reaction("🪴")
+
+    @prefixed_command("debug_drop")
+    async def drop_ext(self, ctx: PrefixedContext, module: str) -> None:
+        self.bot.unload_extension(module)
+        await ctx.message.add_reaction("💥")
+
+    @reload.error
+    @load_ext.error
+    @drop_ext.error
+    async def reload_error(self, error: Exception, ctx: PrefixedContext, *args) -> None:
+        if isinstance(error, CommandCheckFailure):
+            return await ctx.send("You do not have permission to execute this command")
+        if isinstance(error, ExtensionLoadException):
+            return await ctx.send(str(error))
+        raise
+
+
+def setup(bot) -> None:
+    DebugExts(bot)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/debug_extension/utils.py` & `discord-py-interactions-5.6.0/interactions/ext/debug_extension/utils.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,169 +1,169 @@
-import datetime
-import inspect
-import weakref
-from typing import TYPE_CHECKING, Any, Optional, Union
-
-from interactions.client.utils.cache import TTLCache, NullCache
-from interactions.models import Embed, MaterialColors
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-
-__all__ = ("debug_embed", "get_cache_state", "strf_delta")
-
-
-def debug_embed(title: str, **kwargs) -> Embed:
-    """Create a debug embed with a standard header and footer."""
-    e = Embed(
-        f"I.py Debug: {title}",
-        url="https://github.com/interactions-py/interactions.py",
-        color=MaterialColors.BLUE_GREY,
-        **kwargs,
-    )
-    e.set_footer(
-        "I.py Debug Extension",
-        icon_url="https://media.discordapp.net/attachments/907639005070377020/918600896433238097/sparkle-snekCUnetnoise_scaleLevel0x2.500000.png",
-    )
-    return e
-
-
-def get_cache_state(bot: "Client") -> str:
-    """Create a nicely formatted table of internal cache state."""
-    caches = {
-        c[0]: getattr(bot.cache, c[0])
-        for c in inspect.getmembers(bot.cache, predicate=lambda x: isinstance(x, dict))
-        if not c[0].startswith("__")
-    }
-    caches["endpoints"] = bot.http._endpoints
-    caches["rate_limits"] = bot.http.ratelimit_locks
-    table = []
-
-    for cache, val in caches.items():
-        if isinstance(val, TTLCache):
-            amount = [len(val), f"{val.hard_limit}({val.soft_limit})"]
-            expire = f"{val.ttl}s"
-        elif isinstance(val, NullCache):
-            amount = ("DISABLED",)
-            expire = "N/A"
-        elif isinstance(val, (weakref.WeakValueDictionary, weakref.WeakKeyDictionary)):
-            amount = [len(val), "∞"]
-            expire = "w_ref"
-        else:
-            amount = [len(val), "∞"]
-            expire = "none"
-
-        row = [cache.removesuffix("_cache"), amount, expire]
-        table.append(row)
-
-    adjust_subcolumn(table, 1, aligns=[">", "<"])
-
-    labels = ["Cache", "Amount", "Expire"]
-    return make_table(table, labels)
-
-
-def strf_delta(time_delta: datetime.timedelta, show_seconds: bool = True) -> str:
-    """Formats timedelta into a human readable string."""
-    years, days = divmod(time_delta.days, 365)
-    hours, rem = divmod(time_delta.seconds, 3600)
-    minutes, seconds = divmod(rem, 60)
-
-    years_fmt = f"{years} year{'s' if years > 1 or years == 0 else ''}"
-    days_fmt = f"{days} day{'s' if days > 1 or days == 0 else ''}"
-    hours_fmt = f"{hours} hour{'s' if hours > 1 or hours == 0 else ''}"
-    minutes_fmt = f"{minutes} minute{'s' if minutes > 1 or minutes == 0 else ''}"
-    seconds_fmt = f"{seconds} second{'s' if seconds > 1 or seconds == 0 else ''}"
-
-    if years >= 1:
-        return f"{years_fmt} and {days_fmt}"
-    if days >= 1:
-        return f"{days_fmt} and {hours_fmt}"
-    if hours >= 1:
-        return f"{hours_fmt} and {minutes_fmt}"
-    return f"{minutes_fmt} and {seconds_fmt}" if show_seconds else f"{minutes_fmt}"
-
-
-def _make_solid_line(
-    column_widths: list[int],
-    left_char: str,
-    middle_char: str,
-    right_char: str,
-) -> str:
-    """
-    Internal helper function.
-
-    Constructs a "solid" line for the table (top, bottom, line between labels and table)
-    """
-    return f"{left_char}{middle_char.join('─' * (width + 2) for width in column_widths)}{right_char}"
-
-
-def _make_data_line(
-    column_widths: list[int],
-    line: list[Any],
-    left_char: str,
-    middle_char: str,
-    right_char: str,
-    aligns: Union[list[str], str] = "<",
-) -> str:
-    """
-    Internal helper function.
-
-    Constructs a line with data for the table
-    """
-    if isinstance(aligns, str):
-        aligns = [aligns for _ in column_widths]
-
-    line = (f"{str(value): {align}{width}}" for width, align, value in zip(column_widths, aligns, line, strict=False))
-    return f"{left_char}{f'{middle_char}'.join(line)}{right_char}"
-
-
-def _get_column_widths(columns) -> list[int]:
-    """
-    Internal helper function.
-
-    Calculates max width of each column
-    """
-    return [max(len(str(value)) for value in column) for column in columns]
-
-
-def adjust_subcolumn(
-    rows: list[list[Any]],
-    column_index: int,
-    separator: str = "/",
-    aligns: Union[list[str], str] = "<",
-) -> None:
-    """Converts column composed of list of subcolumns into aligned str representation."""
-    column = list(zip(*rows, strict=False))[column_index]
-    subcolumn_widths = _get_column_widths(zip(*column, strict=False))
-    if isinstance(aligns, str):
-        aligns = [aligns for _ in subcolumn_widths]
-
-    column = [_make_data_line(subcolumn_widths, row, "", separator, "", aligns) for row in column]
-    for row, new_item in zip(rows, column, strict=False):
-        row[column_index] = new_item
-
-
-def make_table(rows: list[list[Any]], labels: Optional[list[Any]] = None, centered: bool = False) -> str:
-    """
-    Converts 2D list to str representation as table
-
-    :param rows: 2D list containing objects that have a single-line representation (via `str`). All rows must be of the same length.
-    :param labels: List containing the column labels. If present, the length must equal to that of each row.
-    :param centered: If the items should be aligned to the center, else they are left aligned.
-    :return: A table representing the rows passed in.
-    """
-    columns = zip(*rows, strict=False) if labels is None else zip(*rows, labels, strict=False)
-    column_widths = _get_column_widths(columns)
-    align = "^" if centered else "<"
-    align = [align for _ in column_widths]
-
-    lines = [_make_solid_line(column_widths, "╭", "┬", "╮")]
-
-    data_left = "│ "
-    data_middle = " │ "
-    data_right = " │"
-    if labels is not None:
-        lines.append(_make_data_line(column_widths, labels, data_left, data_middle, data_right, align))
-        lines.append(_make_solid_line(column_widths, "├", "┼", "┤"))
-    lines.extend(_make_data_line(column_widths, row, data_left, data_middle, data_right, align) for row in rows)
-    lines.append(_make_solid_line(column_widths, "╰", "┴", "╯"))
-    return "\n".join(lines)
+import datetime
+import inspect
+import weakref
+from typing import TYPE_CHECKING, Any, Optional, Union
+
+from interactions.client.utils.cache import TTLCache, NullCache
+from interactions.models import Embed, MaterialColors
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+
+__all__ = ("debug_embed", "get_cache_state", "strf_delta")
+
+
+def debug_embed(title: str, **kwargs) -> Embed:
+    """Create a debug embed with a standard header and footer."""
+    e = Embed(
+        f"I.py Debug: {title}",
+        url="https://github.com/interactions-py/interactions.py",
+        color=MaterialColors.BLUE_GREY,
+        **kwargs,
+    )
+    e.set_footer(
+        "I.py Debug Extension",
+        icon_url="https://media.discordapp.net/attachments/907639005070377020/918600896433238097/sparkle-snekCUnetnoise_scaleLevel0x2.500000.png",
+    )
+    return e
+
+
+def get_cache_state(bot: "Client") -> str:
+    """Create a nicely formatted table of internal cache state."""
+    caches = {
+        c[0]: getattr(bot.cache, c[0])
+        for c in inspect.getmembers(bot.cache, predicate=lambda x: isinstance(x, dict))
+        if not c[0].startswith("__")
+    }
+    caches["endpoints"] = bot.http._endpoints
+    caches["rate_limits"] = bot.http.ratelimit_locks
+    table = []
+
+    for cache, val in caches.items():
+        if isinstance(val, TTLCache):
+            amount = [len(val), f"{val.hard_limit}({val.soft_limit})"]
+            expire = f"{val.ttl}s"
+        elif isinstance(val, NullCache):
+            amount = ("DISABLED",)
+            expire = "N/A"
+        elif isinstance(val, (weakref.WeakValueDictionary, weakref.WeakKeyDictionary)):
+            amount = [len(val), "∞"]
+            expire = "w_ref"
+        else:
+            amount = [len(val), "∞"]
+            expire = "none"
+
+        row = [cache.removesuffix("_cache"), amount, expire]
+        table.append(row)
+
+    adjust_subcolumn(table, 1, aligns=[">", "<"])
+
+    labels = ["Cache", "Amount", "Expire"]
+    return make_table(table, labels)
+
+
+def strf_delta(time_delta: datetime.timedelta, show_seconds: bool = True) -> str:
+    """Formats timedelta into a human readable string."""
+    years, days = divmod(time_delta.days, 365)
+    hours, rem = divmod(time_delta.seconds, 3600)
+    minutes, seconds = divmod(rem, 60)
+
+    years_fmt = f"{years} year{'s' if years > 1 or years == 0 else ''}"
+    days_fmt = f"{days} day{'s' if days > 1 or days == 0 else ''}"
+    hours_fmt = f"{hours} hour{'s' if hours > 1 or hours == 0 else ''}"
+    minutes_fmt = f"{minutes} minute{'s' if minutes > 1 or minutes == 0 else ''}"
+    seconds_fmt = f"{seconds} second{'s' if seconds > 1 or seconds == 0 else ''}"
+
+    if years >= 1:
+        return f"{years_fmt} and {days_fmt}"
+    if days >= 1:
+        return f"{days_fmt} and {hours_fmt}"
+    if hours >= 1:
+        return f"{hours_fmt} and {minutes_fmt}"
+    return f"{minutes_fmt} and {seconds_fmt}" if show_seconds else f"{minutes_fmt}"
+
+
+def _make_solid_line(
+    column_widths: list[int],
+    left_char: str,
+    middle_char: str,
+    right_char: str,
+) -> str:
+    """
+    Internal helper function.
+
+    Constructs a "solid" line for the table (top, bottom, line between labels and table)
+    """
+    return f"{left_char}{middle_char.join('─' * (width + 2) for width in column_widths)}{right_char}"
+
+
+def _make_data_line(
+    column_widths: list[int],
+    line: list[Any],
+    left_char: str,
+    middle_char: str,
+    right_char: str,
+    aligns: Union[list[str], str] = "<",
+) -> str:
+    """
+    Internal helper function.
+
+    Constructs a line with data for the table
+    """
+    if isinstance(aligns, str):
+        aligns = [aligns for _ in column_widths]
+
+    line = (f"{value!s: {align}{width}}" for width, align, value in zip(column_widths, aligns, line, strict=False))
+    return f"{left_char}{f'{middle_char}'.join(line)}{right_char}"
+
+
+def _get_column_widths(columns) -> list[int]:
+    """
+    Internal helper function.
+
+    Calculates max width of each column
+    """
+    return [max(len(str(value)) for value in column) for column in columns]
+
+
+def adjust_subcolumn(
+    rows: list[list[Any]],
+    column_index: int,
+    separator: str = "/",
+    aligns: Union[list[str], str] = "<",
+) -> None:
+    """Converts column composed of list of subcolumns into aligned str representation."""
+    column = list(zip(*rows, strict=False))[column_index]
+    subcolumn_widths = _get_column_widths(zip(*column, strict=False))
+    if isinstance(aligns, str):
+        aligns = [aligns for _ in subcolumn_widths]
+
+    column = [_make_data_line(subcolumn_widths, row, "", separator, "", aligns) for row in column]
+    for row, new_item in zip(rows, column, strict=False):
+        row[column_index] = new_item
+
+
+def make_table(rows: list[list[Any]], labels: Optional[list[Any]] = None, centered: bool = False) -> str:
+    """
+    Converts 2D list to str representation as table
+
+    :param rows: 2D list containing objects that have a single-line representation (via `str`). All rows must be of the same length.
+    :param labels: List containing the column labels. If present, the length must equal to that of each row.
+    :param centered: If the items should be aligned to the center, else they are left aligned.
+    :return: A table representing the rows passed in.
+    """
+    columns = zip(*rows, strict=False) if labels is None else zip(*rows, labels, strict=False)
+    column_widths = _get_column_widths(columns)
+    align = "^" if centered else "<"
+    align = [align for _ in column_widths]
+
+    lines = [_make_solid_line(column_widths, "╭", "┬", "╮")]
+
+    data_left = "│ "
+    data_middle = " │ "
+    data_right = " │"
+    if labels is not None:
+        lines.append(_make_data_line(column_widths, labels, data_left, data_middle, data_right, align))
+        lines.append(_make_solid_line(column_widths, "├", "┼", "┤"))
+    lines.extend(_make_data_line(column_widths, row, data_left, data_middle, data_right, align) for row in rows)
+    lines.append(_make_solid_line(column_widths, "╰", "┴", "╯"))
+    return "\n".join(lines)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/jurigged.py` & `discord-py-interactions-5.6.0/interactions/ext/jurigged.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,214 +1,214 @@
-import inspect
-from pathlib import Path
-from types import ModuleType
-from typing import Callable, Dict
-
-from interactions import Extension, SlashCommand, Client
-from interactions.client.errors import ExtensionLoadException, ExtensionNotFound
-from interactions.client.utils.misc_utils import find
-from interactions.client.const import get_logger
-
-try:
-    from jurigged import watch, CodeFile
-    from jurigged.live import WatchOperation
-    from jurigged.codetools import (
-        AddOperation,
-        DeleteOperation,
-        UpdateOperation,
-        LineDefinition,
-    )
-except ModuleNotFoundError:
-    get_logger().error(
-        "jurigged not installed, cannot enable jurigged integration.  Install with `pip install interactions[jurigged]`"
-    )
-    raise
-
-
-__all__ = ("Jurigged", "setup")
-
-
-def get_all_commands(module: ModuleType) -> Dict[str, Callable]:
-    """
-    Get all SlashCommands from a specified module.
-
-    Args:
-        module: Module to extract commands from
-    """
-    commands = {}
-
-    def is_extension(e) -> bool:
-        """Check that an object is an extension."""
-        return inspect.isclass(e) and issubclass(e, Extension) and e is not Extension
-
-    def is_slashcommand(e) -> bool:
-        """Check that an object is a slash command."""
-        return isinstance(e, SlashCommand)
-
-    for _name, item in inspect.getmembers(module, is_extension):
-        inspect_result = inspect.getmembers(item, is_slashcommand)
-        exts = []
-        for _, val in inspect_result:
-            exts.append(val)
-        commands[f"{module.__name__}"] = exts
-
-    return {k: v for k, v in commands.items() if v is not None}
-
-
-class Jurigged(Extension):
-    def __init__(self, *_, poll=False) -> None:
-        self.poll = poll
-        self.command_cache = {}
-        self.watcher = None
-
-    async def async_start(self) -> None:
-        """Jurigged starting utility."""
-        self.bot.logger.warning("Setting sync_ext to True by default for syncing changes")
-        self.bot.sync_ext = True
-
-        self.bot.logger.info("Loading jurigged")
-        path = Path().resolve()
-        self.watcher = watch(f"{path}/[!.]*.py", logger=self.jurigged_log, poll=self.poll)
-        self.watcher.prerun.register(self.jurigged_prerun)
-        self.watcher.postrun.register(self.jurigged_postrun)
-
-    def jurigged_log(self, event: WatchOperation | AddOperation | DeleteOperation | UpdateOperation) -> None:
-        """
-        Log a jurigged event
-
-        Args:
-            event: jurigged event
-        """
-        if isinstance(event, WatchOperation):
-            self.bot.logger.debug(f"Watch {event.filename}")
-        elif isinstance(event, (Exception, SyntaxError)):
-            self.bot.logger.exception("Jurigged encountered an error", exc_info=True)
-        else:
-            action = None
-            lineno = event.defn.stashed.lineno
-            dotpath = event.defn.dotpath()
-            extra = ""
-
-            if isinstance(event.defn, LineDefinition):
-                dotpath = event.defn.parent.dotpath()
-                extra = f" | {event.defn.text}"
-
-            if isinstance(event, AddOperation):
-                action = "Run" if isinstance(event.defn, LineDefinition) else "Add"
-            elif isinstance(event, UpdateOperation):
-                action = "Update"
-            elif isinstance(event, DeleteOperation):
-                action = "Delete"
-            if not action:
-                self.bot.logger.debug(event)
-            else:
-                event_str = "{action} {dotpath}:{lineno}{extra}"
-                self.bot.logger.debug(event_str.format(action=action, dotpath=dotpath, lineno=lineno, extra=extra))
-
-    def jurigged_prerun(self, _path: str, cf: CodeFile) -> None:
-        """
-        Jurigged prerun event.
-
-        Args:
-            _path: Path to file
-            cf: File information
-        """
-        if self.bot.get_ext(cf.module_name):
-            self.bot.logger.debug(f"Caching {cf.module_name}")
-            self.command_cache = get_all_commands(cf.module)
-
-    def jurigged_postrun(self, _path: str, cf: CodeFile) -> None:  # noqa: C901
-        """
-        Jurigged postrun event.
-
-        Args:
-            _path: Path to file
-            cf: File information
-        """
-        if not self.bot.get_ext(cf.module_name):
-            return
-        self.bot.logger.debug(f"Checking {cf.module_name}")
-        commands = get_all_commands(cf.module)
-
-        self.bot.logger.debug("Checking for changes")
-        for module, cmds in commands.items():
-            # Check if a module was removed
-            if module not in commands:
-                self.bot.logger.debug(f"Module {module} removed")
-                self.bot.unload_extension(module)
-
-            # Check if a module is new
-            elif module not in self.command_cache:
-                self.bot.logger.debug(f"Module {module} added")
-                try:
-                    self.bot.load_extension(module)
-                except ExtensionLoadException:
-                    self.bot.logger.warning(f"Failed to load new module {module}")
-
-            # Check if a module has more/less commands
-            elif len(self.command_cache[module]) != len(cmds):
-                self.bot.logger.debug("Number of commands changed, reloading")
-                try:
-                    self.bot.reload_extension(module)
-                except ExtensionNotFound:
-                    try:
-                        self.bot.load_extension(module)
-                    except ExtensionLoadException:
-                        self.bot.logger.warning(f"Failed to update module {module}")
-                except ExtensionLoadException:
-                    self.bot.logger.warning(f"Failed to update module {module}")
-
-            # Check each command for differences
-            else:
-                for cmd in cmds:
-                    old_cmd = find(
-                        lambda x, cmd=cmd: x.resolved_name == cmd.resolved_name,
-                        self.command_cache[module],
-                    )
-
-                    # Extract useful info
-                    old_args = old_cmd.options
-                    old_arg_names = []
-                    new_arg_names = []
-                    if old_args:
-                        old_arg_names = [x.name.default for x in old_args]
-                    new_args = cmd.options
-                    if new_args:
-                        new_arg_names = [x.name.default for x in new_args]
-
-                    # No changes
-                    if not old_args and not new_args:
-                        continue
-
-                    # Check if number of args has changed
-                    if len(old_arg_names) != len(new_arg_names):
-                        self.bot.logger.debug("Number of arguments changed, reloading")
-                        try:
-                            self.bot.reload_extension(module)
-                        except Exception:
-                            self.bot.logger.exception(f"Failed to update module {module}", exc_info=True)
-
-                    # Check if arg names have changed
-                    elif len(set(old_arg_names) - set(new_arg_names)) > 0:
-                        self.bot.logger.debug("Argument names changed, reloading")
-                        try:
-                            self.bot.reload_extension(module)
-                        except Exception:
-                            self.bot.logger.exception(f"Failed to update module {module}", exc_info=True)
-
-                    # Check if arg types have changed
-                    elif any(new_args[idx].type != x.type for idx, x in enumerate(old_args)):
-                        self.bot.logger.debug("Argument types changed, reloading")
-                        try:
-                            self.bot.reload_extension(module)
-                        except Exception:
-                            self.bot.logger.exception(f"Failed to update module {module}", exc_info=True)
-                    else:
-                        self.bot.logger.debug("No changes detected")
-        self.command_cache.clear()
-
-
-def setup(
-    bot: Client,
-    poll: bool = False,
-) -> None:
-    Jurigged(bot, poll=poll)
+import inspect
+from pathlib import Path
+from types import ModuleType
+from typing import Callable, Dict
+
+from interactions import Extension, SlashCommand, Client
+from interactions.client.errors import ExtensionLoadException, ExtensionNotFound
+from interactions.client.utils.misc_utils import find
+from interactions.client.const import get_logger
+
+try:
+    from jurigged import watch, CodeFile
+    from jurigged.live import WatchOperation
+    from jurigged.codetools import (
+        AddOperation,
+        DeleteOperation,
+        UpdateOperation,
+        LineDefinition,
+    )
+except ModuleNotFoundError:
+    get_logger().error(
+        "jurigged not installed, cannot enable jurigged integration.  Install with `pip install interactions[jurigged]`"
+    )
+    raise
+
+
+__all__ = ("Jurigged", "setup")
+
+
+def get_all_commands(module: ModuleType) -> Dict[str, Callable]:
+    """
+    Get all SlashCommands from a specified module.
+
+    Args:
+        module: Module to extract commands from
+    """
+    commands = {}
+
+    def is_extension(e) -> bool:
+        """Check that an object is an extension."""
+        return inspect.isclass(e) and issubclass(e, Extension) and e is not Extension
+
+    def is_slashcommand(e) -> bool:
+        """Check that an object is a slash command."""
+        return isinstance(e, SlashCommand)
+
+    for _name, item in inspect.getmembers(module, is_extension):
+        inspect_result = inspect.getmembers(item, is_slashcommand)
+        exts = []
+        for _, val in inspect_result:
+            exts.append(val)
+        commands[f"{module.__name__}"] = exts
+
+    return {k: v for k, v in commands.items() if v is not None}
+
+
+class Jurigged(Extension):
+    def __init__(self, *_, poll=False) -> None:
+        self.poll = poll
+        self.command_cache = {}
+        self.watcher = None
+
+    async def async_start(self) -> None:
+        """Jurigged starting utility."""
+        self.bot.logger.warning("Setting sync_ext to True by default for syncing changes")
+        self.bot.sync_ext = True
+
+        self.bot.logger.info("Loading jurigged")
+        path = Path().resolve()
+        self.watcher = watch(f"{path}/[!.]*.py", logger=self.jurigged_log, poll=self.poll)
+        self.watcher.prerun.register(self.jurigged_prerun)
+        self.watcher.postrun.register(self.jurigged_postrun)
+
+    def jurigged_log(self, event: WatchOperation | AddOperation | DeleteOperation | UpdateOperation) -> None:
+        """
+        Log a jurigged event
+
+        Args:
+            event: jurigged event
+        """
+        if isinstance(event, WatchOperation):
+            self.bot.logger.debug(f"Watch {event.filename}")
+        elif isinstance(event, (Exception, SyntaxError)):
+            self.bot.logger.exception("Jurigged encountered an error", exc_info=True)
+        else:
+            action = None
+            lineno = event.defn.stashed.lineno
+            dotpath = event.defn.dotpath()
+            extra = ""
+
+            if isinstance(event.defn, LineDefinition):
+                dotpath = event.defn.parent.dotpath()
+                extra = f" | {event.defn.text}"
+
+            if isinstance(event, AddOperation):
+                action = "Run" if isinstance(event.defn, LineDefinition) else "Add"
+            elif isinstance(event, UpdateOperation):
+                action = "Update"
+            elif isinstance(event, DeleteOperation):
+                action = "Delete"
+            if not action:
+                self.bot.logger.debug(event)
+            else:
+                event_str = "{action} {dotpath}:{lineno}{extra}"
+                self.bot.logger.debug(event_str.format(action=action, dotpath=dotpath, lineno=lineno, extra=extra))
+
+    def jurigged_prerun(self, _path: str, cf: CodeFile) -> None:
+        """
+        Jurigged prerun event.
+
+        Args:
+            _path: Path to file
+            cf: File information
+        """
+        if self.bot.get_ext(cf.module_name):
+            self.bot.logger.debug(f"Caching {cf.module_name}")
+            self.command_cache = get_all_commands(cf.module)
+
+    def jurigged_postrun(self, _path: str, cf: CodeFile) -> None:  # noqa: C901
+        """
+        Jurigged postrun event.
+
+        Args:
+            _path: Path to file
+            cf: File information
+        """
+        if not self.bot.get_ext(cf.module_name):
+            return
+        self.bot.logger.debug(f"Checking {cf.module_name}")
+        commands = get_all_commands(cf.module)
+
+        self.bot.logger.debug("Checking for changes")
+        for module, cmds in commands.items():
+            # Check if a module was removed
+            if module not in commands:
+                self.bot.logger.debug(f"Module {module} removed")
+                self.bot.unload_extension(module)
+
+            # Check if a module is new
+            elif module not in self.command_cache:
+                self.bot.logger.debug(f"Module {module} added")
+                try:
+                    self.bot.load_extension(module)
+                except ExtensionLoadException:
+                    self.bot.logger.warning(f"Failed to load new module {module}")
+
+            # Check if a module has more/less commands
+            elif len(self.command_cache[module]) != len(cmds):
+                self.bot.logger.debug("Number of commands changed, reloading")
+                try:
+                    self.bot.reload_extension(module)
+                except ExtensionNotFound:
+                    try:
+                        self.bot.load_extension(module)
+                    except ExtensionLoadException:
+                        self.bot.logger.warning(f"Failed to update module {module}")
+                except ExtensionLoadException:
+                    self.bot.logger.warning(f"Failed to update module {module}")
+
+            # Check each command for differences
+            else:
+                for cmd in cmds:
+                    old_cmd = find(
+                        lambda x, cmd=cmd: x.resolved_name == cmd.resolved_name,
+                        self.command_cache[module],
+                    )
+
+                    # Extract useful info
+                    old_args = old_cmd.options
+                    old_arg_names = []
+                    new_arg_names = []
+                    if old_args:
+                        old_arg_names = [x.name.default for x in old_args]
+                    new_args = cmd.options
+                    if new_args:
+                        new_arg_names = [x.name.default for x in new_args]
+
+                    # No changes
+                    if not old_args and not new_args:
+                        continue
+
+                    # Check if number of args has changed
+                    if len(old_arg_names) != len(new_arg_names):
+                        self.bot.logger.debug("Number of arguments changed, reloading")
+                        try:
+                            self.bot.reload_extension(module)
+                        except Exception:
+                            self.bot.logger.exception(f"Failed to update module {module}", exc_info=True)
+
+                    # Check if arg names have changed
+                    elif len(set(old_arg_names) - set(new_arg_names)) > 0:
+                        self.bot.logger.debug("Argument names changed, reloading")
+                        try:
+                            self.bot.reload_extension(module)
+                        except Exception:
+                            self.bot.logger.exception(f"Failed to update module {module}", exc_info=True)
+
+                    # Check if arg types have changed
+                    elif any(new_args[idx].type != x.type for idx, x in enumerate(old_args)):
+                        self.bot.logger.debug("Argument types changed, reloading")
+                        try:
+                            self.bot.reload_extension(module)
+                        except Exception:
+                            self.bot.logger.exception(f"Failed to update module {module}", exc_info=True)
+                    else:
+                        self.bot.logger.debug("No changes detected")
+        self.command_cache.clear()
+
+
+def setup(
+    bot: Client,
+    poll: bool = False,
+) -> None:
+    Jurigged(bot, poll=poll)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/paginators.py` & `discord-py-interactions-5.6.0/interactions/ext/paginators.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,443 +1,443 @@
-import asyncio
-import textwrap
-import uuid
-from typing import Callable, Coroutine, List, Optional, Sequence, TYPE_CHECKING, Union
-
-import attrs
-
-from interactions import (
-    Embed,
-    ComponentContext,
-    ActionRow,
-    Button,
-    ButtonStyle,
-    spread_to_rows,
-    ComponentCommand,
-    BaseContext,
-    Message,
-    MISSING,
-    Snowflake_Type,
-    StringSelectMenu,
-    StringSelectOption,
-    Color,
-    BrandColors,
-)
-from interactions.client.utils.serializer import export_converter
-from interactions.models.discord.emoji import process_emoji, PartialEmoji
-
-if TYPE_CHECKING:
-    from interactions import Client
-    from interactions.ext.prefixed_commands.context import PrefixedContext
-
-__all__ = ("Paginator",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Timeout:
-    paginator: "Paginator" = attrs.field(
-        repr=False,
-    )
-    """The paginator that this timeout is associated with."""
-    run: bool = attrs.field(repr=False, default=True)
-    """Whether or not this timeout is currently running."""
-    ping: asyncio.Event = asyncio.Event()
-    """The event that is used to wait the paginator action."""
-
-    async def __call__(self) -> None:
-        while self.run:
-            try:
-                await asyncio.wait_for(self.ping.wait(), timeout=self.paginator.timeout_interval)
-            except asyncio.TimeoutError:
-                if self.paginator.message:
-                    await self.paginator.message.edit(components=self.paginator.create_components(True))
-                return
-            else:
-                self.ping.clear()
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Page:
-    content: str = attrs.field(
-        repr=False,
-    )
-    """The content of the page."""
-    title: Optional[str] = attrs.field(repr=False, default=None)
-    """The title of the page."""
-    prefix: str = attrs.field(repr=False, kw_only=True, default="")
-    """Content that is prepended to the page."""
-    suffix: str = attrs.field(repr=False, kw_only=True, default="")
-    """Content that is appended to the page."""
-
-    @property
-    def get_summary(self) -> str:
-        """Get the short version of the page content."""
-        return self.title or textwrap.shorten(self.content, 40, placeholder="...")
-
-    def to_embed(self) -> Embed:
-        """Process the page to an embed."""
-        return Embed(description=f"{self.prefix}\n{self.content}\n{self.suffix}", title=self.title)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Paginator:
-    client: "Client" = attrs.field(
-        repr=False,
-    )
-    """The client to hook listeners into"""
-
-    page_index: int = attrs.field(repr=False, kw_only=True, default=0)
-    """The index of the current page being displayed"""
-    pages: Sequence[Page | Embed] = attrs.field(repr=False, factory=list, kw_only=True)
-    """The pages this paginator holds"""
-    timeout_interval: int = attrs.field(repr=False, default=0, kw_only=True)
-    """How long until this paginator disables itself"""
-    callback: Callable[..., Coroutine] = attrs.field(repr=False, default=None)
-    """A coroutine to call should the select button be pressed"""
-
-    show_first_button: bool = attrs.field(repr=False, default=True)
-    """Should a `First` button be shown"""
-    show_back_button: bool = attrs.field(repr=False, default=True)
-    """Should a `Back` button be shown"""
-    show_next_button: bool = attrs.field(repr=False, default=True)
-    """Should a `Next` button be shown"""
-    show_last_button: bool = attrs.field(repr=False, default=True)
-    """Should a `Last` button be shown"""
-    show_callback_button: bool = attrs.field(repr=False, default=False)
-    """Show a button which will call the `callback`"""
-    show_select_menu: bool = attrs.field(repr=False, default=False)
-    """Should a select menu be shown for navigation"""
-
-    first_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
-        repr=False, default="⏮️", metadata=export_converter(process_emoji)
-    )
-    """The emoji to use for the first button"""
-    back_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
-        repr=False, default="⬅️", metadata=export_converter(process_emoji)
-    )
-    """The emoji to use for the back button"""
-    next_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
-        repr=False, default="➡️", metadata=export_converter(process_emoji)
-    )
-    """The emoji to use for the next button"""
-    last_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
-        repr=False, default="⏩", metadata=export_converter(process_emoji)
-    )
-    """The emoji to use for the last button"""
-    callback_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
-        repr=False, default="✅", metadata=export_converter(process_emoji)
-    )
-    """The emoji to use for the callback button"""
-
-    wrong_user_message: str = attrs.field(repr=False, default="This paginator is not for you")
-    """The message to be sent when the wrong user uses this paginator"""
-
-    default_title: Optional[str] = attrs.field(repr=False, default=None)
-    """The default title to show on the embeds"""
-    default_color: Color = attrs.field(repr=False, default=BrandColors.BLURPLE)
-    """The default colour to show on the embeds"""
-    default_button_color: Union[ButtonStyle, int] = attrs.field(repr=False, default=ButtonStyle.BLURPLE)
-    """The color of the buttons"""
-
-    _uuid: str = attrs.field(repr=False, factory=uuid.uuid4)
-    _message: Message = attrs.field(repr=False, default=MISSING)
-    _timeout_task: Timeout = attrs.field(repr=False, default=MISSING)
-    _author_id: Snowflake_Type = attrs.field(repr=False, default=MISSING)
-
-    def __attrs_post_init__(self) -> None:
-        self.client.add_component_callback(
-            ComponentCommand(
-                name=f"Paginator:{self._uuid}",
-                callback=self._on_button,
-                listeners=[
-                    f"{self._uuid}|select",
-                    f"{self._uuid}|first",
-                    f"{self._uuid}|back",
-                    f"{self._uuid}|callback",
-                    f"{self._uuid}|next",
-                    f"{self._uuid}|last",
-                ],
-            )
-        )
-
-    @property
-    def message(self) -> Message:
-        """The message this paginator is currently attached to"""
-        return self._message
-
-    @property
-    def author_id(self) -> Snowflake_Type:
-        """The ID of the author of the message this paginator is currently attached to"""
-        return self._author_id
-
-    @classmethod
-    def create_from_embeds(cls, client: "Client", *embeds: Embed, timeout: int = 0) -> "Paginator":
-        """
-        Create a paginator system from a list of embeds.
-
-        Args:
-            client: A reference to the client
-            *embeds: The embeds to use for each page
-            timeout: A timeout to wait before closing the paginator
-
-        Returns:
-            A paginator system
-        """
-        return cls(client, pages=list(embeds), timeout_interval=timeout)
-
-    @classmethod
-    def create_from_string(
-        cls,
-        client: "Client",
-        content: str,
-        prefix: str = "",
-        suffix: str = "",
-        page_size: int = 4000,
-        timeout: int = 0,
-    ) -> "Paginator":
-        """
-        Create a paginator system from a string.
-
-        Args:
-            client: A reference to the client
-            content: The content to paginate
-            prefix: The prefix for each page to use
-            suffix: The suffix for each page to use
-            page_size: The maximum characters for each page
-            timeout: A timeout to wait before closing the paginator
-
-        Returns:
-            A paginator system
-        """
-        content_pages = textwrap.wrap(
-            content,
-            width=page_size - (len(prefix) + len(suffix)),
-            break_long_words=True,
-            break_on_hyphens=False,
-            replace_whitespace=False,
-        )
-        pages = [Page(c, prefix=prefix, suffix=suffix) for c in content_pages]
-        return cls(client, pages=pages, timeout_interval=timeout)
-
-    @classmethod
-    def create_from_list(
-        cls,
-        client: "Client",
-        content: list[str],
-        prefix: str = "",
-        suffix: str = "",
-        page_size: int = 4000,
-        timeout: int = 0,
-    ) -> "Paginator":
-        """
-        Create a paginator from a list of strings. Useful to maintain formatting.
-
-        Args:
-            client: A reference to the client
-            content: The content to paginate
-            prefix: The prefix for each page to use
-            suffix: The suffix for each page to use
-            page_size: The maximum characters for each page
-            timeout: A timeout to wait before closing the paginator
-
-        Returns:
-            A paginator system
-        """
-        pages = []
-        page = ""
-        for entry in content:
-            if len(page) + len(f"\n{entry}") <= page_size:
-                page += f"{entry}\n"
-            else:
-                pages.append(Page(page, prefix=prefix, suffix=suffix))
-                page = ""
-        if page != "":
-            pages.append(Page(page, prefix=prefix, suffix=suffix))
-        return cls(client, pages=pages, timeout_interval=timeout)
-
-    def create_components(self, disable: bool = False) -> List[ActionRow]:
-        """
-        Create the components for the paginator message.
-
-        Args:
-            disable: Should all the components be disabled?
-
-        Returns:
-            A list of ActionRows
-
-        """
-        output = []
-
-        if self.show_select_menu:
-            current = self.pages[self.page_index]
-            output.append(
-                StringSelectMenu(
-                    *(
-                        StringSelectOption(
-                            label=f"{i+1} {p.get_summary if isinstance(p, Page) else p.title}", value=str(i)
-                        )
-                        for i, p in enumerate(self.pages)
-                    ),
-                    custom_id=f"{self._uuid}|select",
-                    placeholder=f"{self.page_index+1} {current.get_summary if isinstance(current, Page) else current.title}",
-                    max_values=1,
-                    disabled=disable,
-                )
-            )
-
-        if self.show_first_button:
-            output.append(
-                Button(
-                    style=self.default_button_color,
-                    emoji=PartialEmoji.from_dict(process_emoji(self.first_button_emoji)),
-                    custom_id=f"{self._uuid}|first",
-                    disabled=disable or self.page_index == 0,
-                )
-            )
-        if self.show_back_button:
-            output.append(
-                Button(
-                    style=self.default_button_color,
-                    emoji=PartialEmoji.from_dict(process_emoji(self.back_button_emoji)),
-                    custom_id=f"{self._uuid}|back",
-                    disabled=disable or self.page_index == 0,
-                )
-            )
-
-        if self.show_callback_button:
-            output.append(
-                Button(
-                    style=self.default_button_color,
-                    emoji=PartialEmoji.from_dict(process_emoji(self.callback_button_emoji)),
-                    custom_id=f"{self._uuid}|callback",
-                    disabled=disable,
-                )
-            )
-
-        if self.show_next_button:
-            output.append(
-                Button(
-                    style=self.default_button_color,
-                    emoji=PartialEmoji.from_dict(process_emoji(self.next_button_emoji)),
-                    custom_id=f"{self._uuid}|next",
-                    disabled=disable or self.page_index >= len(self.pages) - 1,
-                )
-            )
-        if self.show_last_button:
-            output.append(
-                Button(
-                    style=self.default_button_color,
-                    emoji=PartialEmoji.from_dict(process_emoji(self.last_button_emoji)),
-                    custom_id=f"{self._uuid}|last",
-                    disabled=disable or self.page_index >= len(self.pages) - 1,
-                )
-            )
-
-        return spread_to_rows(*output)
-
-    def to_dict(self) -> dict:
-        """Convert this paginator into a dictionary for sending."""
-        page = self.pages[self.page_index]
-
-        if isinstance(page, Page):
-            page = page.to_embed()
-            if not page.title and self.default_title:
-                page.title = self.default_title
-        if not page.footer:
-            page.set_footer(f"Page {self.page_index+1}/{len(self.pages)}")
-        if not page.color:
-            page.color = self.default_color
-
-        return {
-            "embeds": [page.to_dict()],
-            "components": [c.to_dict() for c in self.create_components()],
-        }
-
-    async def send(self, ctx: BaseContext) -> Message:
-        """
-        Send this paginator.
-
-        Args:
-            ctx: The context to send this paginator with
-
-        Returns:
-            The resulting message
-
-        """
-        self._message = await ctx.send(**self.to_dict())
-        self._author_id = ctx.author.id
-
-        if self.timeout_interval > 1:
-            self._timeout_task = Timeout(self)
-            _ = asyncio.create_task(self._timeout_task())
-
-        return self._message
-
-    async def reply(self, ctx: "PrefixedContext") -> Message:
-        """
-        Reply this paginator to ctx.
-
-        Args:
-            ctx: The context to reply this paginator with
-        Returns:
-            The resulting message
-        """
-        self._message = await ctx.reply(**self.to_dict())
-        self._author_id = ctx.author.id
-
-        if self.timeout_interval > 1:
-            self._timeout_task = Timeout(self)
-            _ = asyncio.create_task(self._timeout_task())
-
-        return self._message
-
-    async def stop(self) -> None:
-        """Disable this paginator."""
-        if self._timeout_task:
-            self._timeout_task.run = False
-            self._timeout_task.ping.set()
-        await self._message.edit(components=self.create_components(True))
-
-    async def update(self) -> None:
-        """
-        Update the paginator to the current state.
-
-        Use this if you have programmatically changed the page_index
-
-        """
-        await self._message.edit(**self.to_dict())
-
-    async def _on_button(self, ctx: ComponentContext, *args, **kwargs) -> Optional[Message]:
-        if ctx.author.id != self.author_id:
-            return (
-                await ctx.send(self.wrong_user_message, ephemeral=True)
-                if self.wrong_user_message
-                else await ctx.defer(edit_origin=True)
-            )
-        if self._timeout_task:
-            self._timeout_task.ping.set()
-        match ctx.custom_id.split("|")[1]:
-            case "first":
-                self.page_index = 0
-            case "last":
-                self.page_index = len(self.pages) - 1
-            case "next":
-                if (self.page_index + 1) < len(self.pages):
-                    self.page_index += 1
-            case "back":
-                if self.page_index >= 1:
-                    self.page_index -= 1
-            case "select":
-                self.page_index = int(ctx.values[0])
-            case "callback":
-                if self.callback:
-                    return await self.callback(ctx)
-
-        await ctx.edit_origin(**self.to_dict())
-        return None
-
-
-def setup(_) -> None:
-    """A dummy setup function to trip the extension loader"""
-    raise RuntimeError(
-        "`interactions.ext.paginator` should not be loaded as an extension - instead import it and use it in your code."
-    )
+import asyncio
+import textwrap
+import uuid
+from typing import Callable, Coroutine, List, Optional, Sequence, TYPE_CHECKING, Union
+
+import attrs
+
+from interactions import (
+    Embed,
+    ComponentContext,
+    ActionRow,
+    Button,
+    ButtonStyle,
+    spread_to_rows,
+    ComponentCommand,
+    BaseContext,
+    Message,
+    MISSING,
+    Snowflake_Type,
+    StringSelectMenu,
+    StringSelectOption,
+    Color,
+    BrandColors,
+)
+from interactions.client.utils.serializer import export_converter
+from interactions.models.discord.emoji import process_emoji, PartialEmoji
+
+if TYPE_CHECKING:
+    from interactions import Client
+    from interactions.ext.prefixed_commands.context import PrefixedContext
+
+__all__ = ("Paginator",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Timeout:
+    paginator: "Paginator" = attrs.field(
+        repr=False,
+    )
+    """The paginator that this timeout is associated with."""
+    run: bool = attrs.field(repr=False, default=True)
+    """Whether or not this timeout is currently running."""
+    ping: asyncio.Event = asyncio.Event()
+    """The event that is used to wait the paginator action."""
+
+    async def __call__(self) -> None:
+        while self.run:
+            try:
+                await asyncio.wait_for(self.ping.wait(), timeout=self.paginator.timeout_interval)
+            except asyncio.TimeoutError:
+                if self.paginator.message:
+                    await self.paginator.message.edit(components=self.paginator.create_components(True))
+                return
+            else:
+                self.ping.clear()
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Page:
+    content: str = attrs.field(
+        repr=False,
+    )
+    """The content of the page."""
+    title: Optional[str] = attrs.field(repr=False, default=None)
+    """The title of the page."""
+    prefix: str = attrs.field(repr=False, kw_only=True, default="")
+    """Content that is prepended to the page."""
+    suffix: str = attrs.field(repr=False, kw_only=True, default="")
+    """Content that is appended to the page."""
+
+    @property
+    def get_summary(self) -> str:
+        """Get the short version of the page content."""
+        return self.title or textwrap.shorten(self.content, 40, placeholder="...")
+
+    def to_embed(self) -> Embed:
+        """Process the page to an embed."""
+        return Embed(description=f"{self.prefix}\n{self.content}\n{self.suffix}", title=self.title)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Paginator:
+    client: "Client" = attrs.field(
+        repr=False,
+    )
+    """The client to hook listeners into"""
+
+    page_index: int = attrs.field(repr=False, kw_only=True, default=0)
+    """The index of the current page being displayed"""
+    pages: Sequence[Page | Embed] = attrs.field(repr=False, factory=list, kw_only=True)
+    """The pages this paginator holds"""
+    timeout_interval: int = attrs.field(repr=False, default=0, kw_only=True)
+    """How long until this paginator disables itself"""
+    callback: Callable[..., Coroutine] = attrs.field(repr=False, default=None)
+    """A coroutine to call should the select button be pressed"""
+
+    show_first_button: bool = attrs.field(repr=False, default=True)
+    """Should a `First` button be shown"""
+    show_back_button: bool = attrs.field(repr=False, default=True)
+    """Should a `Back` button be shown"""
+    show_next_button: bool = attrs.field(repr=False, default=True)
+    """Should a `Next` button be shown"""
+    show_last_button: bool = attrs.field(repr=False, default=True)
+    """Should a `Last` button be shown"""
+    show_callback_button: bool = attrs.field(repr=False, default=False)
+    """Show a button which will call the `callback`"""
+    show_select_menu: bool = attrs.field(repr=False, default=False)
+    """Should a select menu be shown for navigation"""
+
+    first_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
+        repr=False, default="⏮️", metadata=export_converter(process_emoji)
+    )
+    """The emoji to use for the first button"""
+    back_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
+        repr=False, default="⬅️", metadata=export_converter(process_emoji)
+    )
+    """The emoji to use for the back button"""
+    next_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
+        repr=False, default="➡️", metadata=export_converter(process_emoji)
+    )
+    """The emoji to use for the next button"""
+    last_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
+        repr=False, default="⏩", metadata=export_converter(process_emoji)
+    )
+    """The emoji to use for the last button"""
+    callback_button_emoji: Optional[Union["PartialEmoji", dict, str]] = attrs.field(
+        repr=False, default="✅", metadata=export_converter(process_emoji)
+    )
+    """The emoji to use for the callback button"""
+
+    wrong_user_message: str = attrs.field(repr=False, default="This paginator is not for you")
+    """The message to be sent when the wrong user uses this paginator"""
+
+    default_title: Optional[str] = attrs.field(repr=False, default=None)
+    """The default title to show on the embeds"""
+    default_color: Color = attrs.field(repr=False, default=BrandColors.BLURPLE)
+    """The default colour to show on the embeds"""
+    default_button_color: Union[ButtonStyle, int] = attrs.field(repr=False, default=ButtonStyle.BLURPLE)
+    """The color of the buttons"""
+
+    _uuid: str = attrs.field(repr=False, factory=uuid.uuid4)
+    _message: Message = attrs.field(repr=False, default=MISSING)
+    _timeout_task: Timeout = attrs.field(repr=False, default=MISSING)
+    _author_id: Snowflake_Type = attrs.field(repr=False, default=MISSING)
+
+    def __attrs_post_init__(self) -> None:
+        self.client.add_component_callback(
+            ComponentCommand(
+                name=f"Paginator:{self._uuid}",
+                callback=self._on_button,
+                listeners=[
+                    f"{self._uuid}|select",
+                    f"{self._uuid}|first",
+                    f"{self._uuid}|back",
+                    f"{self._uuid}|callback",
+                    f"{self._uuid}|next",
+                    f"{self._uuid}|last",
+                ],
+            )
+        )
+
+    @property
+    def message(self) -> Message:
+        """The message this paginator is currently attached to"""
+        return self._message
+
+    @property
+    def author_id(self) -> Snowflake_Type:
+        """The ID of the author of the message this paginator is currently attached to"""
+        return self._author_id
+
+    @classmethod
+    def create_from_embeds(cls, client: "Client", *embeds: Embed, timeout: int = 0) -> "Paginator":
+        """
+        Create a paginator system from a list of embeds.
+
+        Args:
+            client: A reference to the client
+            *embeds: The embeds to use for each page
+            timeout: A timeout to wait before closing the paginator
+
+        Returns:
+            A paginator system
+        """
+        return cls(client, pages=list(embeds), timeout_interval=timeout)
+
+    @classmethod
+    def create_from_string(
+        cls,
+        client: "Client",
+        content: str,
+        prefix: str = "",
+        suffix: str = "",
+        page_size: int = 4000,
+        timeout: int = 0,
+    ) -> "Paginator":
+        """
+        Create a paginator system from a string.
+
+        Args:
+            client: A reference to the client
+            content: The content to paginate
+            prefix: The prefix for each page to use
+            suffix: The suffix for each page to use
+            page_size: The maximum characters for each page
+            timeout: A timeout to wait before closing the paginator
+
+        Returns:
+            A paginator system
+        """
+        content_pages = textwrap.wrap(
+            content,
+            width=page_size - (len(prefix) + len(suffix)),
+            break_long_words=True,
+            break_on_hyphens=False,
+            replace_whitespace=False,
+        )
+        pages = [Page(c, prefix=prefix, suffix=suffix) for c in content_pages]
+        return cls(client, pages=pages, timeout_interval=timeout)
+
+    @classmethod
+    def create_from_list(
+        cls,
+        client: "Client",
+        content: list[str],
+        prefix: str = "",
+        suffix: str = "",
+        page_size: int = 4000,
+        timeout: int = 0,
+    ) -> "Paginator":
+        """
+        Create a paginator from a list of strings. Useful to maintain formatting.
+
+        Args:
+            client: A reference to the client
+            content: The content to paginate
+            prefix: The prefix for each page to use
+            suffix: The suffix for each page to use
+            page_size: The maximum characters for each page
+            timeout: A timeout to wait before closing the paginator
+
+        Returns:
+            A paginator system
+        """
+        pages = []
+        page = ""
+        for entry in content:
+            if len(page) + len(f"\n{entry}") <= page_size:
+                page += f"{entry}\n"
+            else:
+                pages.append(Page(page, prefix=prefix, suffix=suffix))
+                page = ""
+        if page != "":
+            pages.append(Page(page, prefix=prefix, suffix=suffix))
+        return cls(client, pages=pages, timeout_interval=timeout)
+
+    def create_components(self, disable: bool = False) -> List[ActionRow]:
+        """
+        Create the components for the paginator message.
+
+        Args:
+            disable: Should all the components be disabled?
+
+        Returns:
+            A list of ActionRows
+
+        """
+        output = []
+
+        if self.show_select_menu:
+            current = self.pages[self.page_index]
+            output.append(
+                StringSelectMenu(
+                    *(
+                        StringSelectOption(
+                            label=f"{i+1} {p.get_summary if isinstance(p, Page) else p.title}", value=str(i)
+                        )
+                        for i, p in enumerate(self.pages)
+                    ),
+                    custom_id=f"{self._uuid}|select",
+                    placeholder=f"{self.page_index+1} {current.get_summary if isinstance(current, Page) else current.title}",
+                    max_values=1,
+                    disabled=disable,
+                )
+            )
+
+        if self.show_first_button:
+            output.append(
+                Button(
+                    style=self.default_button_color,
+                    emoji=PartialEmoji.from_dict(process_emoji(self.first_button_emoji)),
+                    custom_id=f"{self._uuid}|first",
+                    disabled=disable or self.page_index == 0,
+                )
+            )
+        if self.show_back_button:
+            output.append(
+                Button(
+                    style=self.default_button_color,
+                    emoji=PartialEmoji.from_dict(process_emoji(self.back_button_emoji)),
+                    custom_id=f"{self._uuid}|back",
+                    disabled=disable or self.page_index == 0,
+                )
+            )
+
+        if self.show_callback_button:
+            output.append(
+                Button(
+                    style=self.default_button_color,
+                    emoji=PartialEmoji.from_dict(process_emoji(self.callback_button_emoji)),
+                    custom_id=f"{self._uuid}|callback",
+                    disabled=disable,
+                )
+            )
+
+        if self.show_next_button:
+            output.append(
+                Button(
+                    style=self.default_button_color,
+                    emoji=PartialEmoji.from_dict(process_emoji(self.next_button_emoji)),
+                    custom_id=f"{self._uuid}|next",
+                    disabled=disable or self.page_index >= len(self.pages) - 1,
+                )
+            )
+        if self.show_last_button:
+            output.append(
+                Button(
+                    style=self.default_button_color,
+                    emoji=PartialEmoji.from_dict(process_emoji(self.last_button_emoji)),
+                    custom_id=f"{self._uuid}|last",
+                    disabled=disable or self.page_index >= len(self.pages) - 1,
+                )
+            )
+
+        return spread_to_rows(*output)
+
+    def to_dict(self) -> dict:
+        """Convert this paginator into a dictionary for sending."""
+        page = self.pages[self.page_index]
+
+        if isinstance(page, Page):
+            page = page.to_embed()
+            if not page.title and self.default_title:
+                page.title = self.default_title
+        if not page.footer:
+            page.set_footer(f"Page {self.page_index+1}/{len(self.pages)}")
+        if not page.color:
+            page.color = self.default_color
+
+        return {
+            "embeds": [page.to_dict()],
+            "components": [c.to_dict() for c in self.create_components()],
+        }
+
+    async def send(self, ctx: BaseContext) -> Message:
+        """
+        Send this paginator.
+
+        Args:
+            ctx: The context to send this paginator with
+
+        Returns:
+            The resulting message
+
+        """
+        self._message = await ctx.send(**self.to_dict())
+        self._author_id = ctx.author.id
+
+        if self.timeout_interval > 1:
+            self._timeout_task = Timeout(self)
+            _ = asyncio.create_task(self._timeout_task())
+
+        return self._message
+
+    async def reply(self, ctx: "PrefixedContext") -> Message:
+        """
+        Reply this paginator to ctx.
+
+        Args:
+            ctx: The context to reply this paginator with
+        Returns:
+            The resulting message
+        """
+        self._message = await ctx.reply(**self.to_dict())
+        self._author_id = ctx.author.id
+
+        if self.timeout_interval > 1:
+            self._timeout_task = Timeout(self)
+            _ = asyncio.create_task(self._timeout_task())
+
+        return self._message
+
+    async def stop(self) -> None:
+        """Disable this paginator."""
+        if self._timeout_task:
+            self._timeout_task.run = False
+            self._timeout_task.ping.set()
+        await self._message.edit(components=self.create_components(True))
+
+    async def update(self) -> None:
+        """
+        Update the paginator to the current state.
+
+        Use this if you have programmatically changed the page_index
+
+        """
+        await self._message.edit(**self.to_dict())
+
+    async def _on_button(self, ctx: ComponentContext, *args, **kwargs) -> Optional[Message]:
+        if ctx.author.id != self.author_id:
+            return (
+                await ctx.send(self.wrong_user_message, ephemeral=True)
+                if self.wrong_user_message
+                else await ctx.defer(edit_origin=True)
+            )
+        if self._timeout_task:
+            self._timeout_task.ping.set()
+        match ctx.custom_id.split("|")[1]:
+            case "first":
+                self.page_index = 0
+            case "last":
+                self.page_index = len(self.pages) - 1
+            case "next":
+                if (self.page_index + 1) < len(self.pages):
+                    self.page_index += 1
+            case "back":
+                if self.page_index >= 1:
+                    self.page_index -= 1
+            case "select":
+                self.page_index = int(ctx.values[0])
+            case "callback":
+                if self.callback:
+                    return await self.callback(ctx)
+
+        await ctx.edit_origin(**self.to_dict())
+        return None
+
+
+def setup(_) -> None:
+    """A dummy setup function to trip the extension loader"""
+    raise RuntimeError(
+        "`interactions.ext.paginator` should not be loaded as an extension - instead import it and use it in your code."
+    )
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/__init__.py` & `discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/__init__.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-from .command import prefixed_command, PrefixedCommand, PrefixedCommandParameter
-from .context import PrefixedContext
-
-from .help import PrefixedHelpCommand
-from .manager import PrefixedInjectedClient, PrefixedManager, setup
-from .utils import when_mentioned, when_mentioned_or
-
-__all__ = (
-    "prefixed_command",
-    "PrefixedCommand",
-    "PrefixedCommandParameter",
-    "PrefixedContext",
-    "PrefixedHelpCommand",
-    "PrefixedInjectedClient",
-    "PrefixedManager",
-    "setup",
-    "when_mentioned",
-    "when_mentioned_or",
-)
+from .command import prefixed_command, PrefixedCommand, PrefixedCommandParameter
+from .context import PrefixedContext
+
+from .help import PrefixedHelpCommand
+from .manager import PrefixedInjectedClient, PrefixedManager, setup
+from .utils import when_mentioned, when_mentioned_or
+
+__all__ = (
+    "prefixed_command",
+    "PrefixedCommand",
+    "PrefixedCommandParameter",
+    "PrefixedContext",
+    "PrefixedHelpCommand",
+    "PrefixedInjectedClient",
+    "PrefixedManager",
+    "setup",
+    "when_mentioned",
+    "when_mentioned_or",
+)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/context.py` & `discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/context.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-from typing import Optional, Union, Iterable, TYPE_CHECKING
-
-from typing_extensions import Self
-
-from interactions.client.client import Client
-from interactions.client.mixins.send import SendMixin
-from interactions.models.discord.embed import Embed
-from interactions.models.discord.file import UPLOADABLE_TYPE
-from interactions.models.discord.message import Message
-from interactions.models.internal.context import BaseContext
-from interactions.models.misc.context_manager import Typing
-
-if TYPE_CHECKING:
-    from .command import PrefixedCommand
-
-__all__ = ("PrefixedContext",)
-
-
-class PrefixedContext(BaseContext, SendMixin):
-    _message: Message
-
-    prefix: str
-    "The prefix used to invoke this command."
-    content_parameters: str
-    "The message content without the command and prefix."
-    command: "PrefixedCommand"
-    "The command this context invokes."
-
-    args: list[str]
-    "The arguments passed to the message."
-    kwargs: dict
-    "This is always empty, and is only here for compatibility with other types of commands."
-
-    @classmethod
-    def from_dict(cls, client: "Client", payload: dict) -> Self:
-        # this doesn't mean anything, so just implement it to make abc happy
-        raise NotImplementedError
-
-    @classmethod
-    def from_message(cls, client: "Client", message: Message) -> Self:
-        instance = cls(client=client)
-
-        # hack to work around BaseContext property
-        # since the message is the most important part of the context,
-        # we don't want to rely on the cache for it
-        instance._message = message
-
-        instance.message_id = message.id
-        instance.author_id = message._author_id
-        instance.channel_id = message._channel_id
-        instance.guild_id = message._guild_id
-
-        instance.prefix = ""
-        instance.content_parameters = ""
-        instance.command = None  # type: ignore
-        instance.args = []
-        instance.kwargs = {}
-        return instance
-
-    @property
-    def message(self) -> Message:
-        """The message that invoked this context."""
-        return self._message
-
-    @property
-    def invoke_target(self) -> str:
-        """The name of the command to be invoked."""
-        return self.command.name
-
-    @property
-    def typing(self) -> Typing:
-        """A context manager to send a typing state to the context's channel as long as the wrapped operation takes."""
-        return self.channel.typing
-
-    async def _send_http_request(self, message_payload: dict, files: Iterable["UPLOADABLE_TYPE"] | None = None) -> dict:
-        return await self.client.http.create_message(message_payload, self.channel_id, files=files)
-
-    async def reply(
-        self,
-        content: Optional[str] = None,
-        embeds: Optional[Union[Iterable[Union[Embed, dict]], Union[Embed, dict]]] = None,
-        embed: Optional[Union[Embed, dict]] = None,
-        **kwargs,
-    ) -> Message:
-        """
-        Reply to the context's message. Takes all the same attributes as `send`.
-
-        Args:
-            content: Message text content.
-            embeds: Embedded rich content (up to 6000 characters).
-            embed: Embedded rich content (up to 6000 characters).
-            **kwargs: Additional options to pass to `send`.
-
-        Returns:
-            New message object.
-
-        """
-        return await self.send(content=content, reply_to=self.message, embeds=embeds or embed, **kwargs)
+from typing import Optional, Union, Iterable, TYPE_CHECKING
+
+from typing_extensions import Self
+
+from interactions.client.client import Client
+from interactions.client.mixins.send import SendMixin
+from interactions.models.discord.embed import Embed
+from interactions.models.discord.file import UPLOADABLE_TYPE
+from interactions.models.discord.message import Message
+from interactions.models.internal.context import BaseContext
+from interactions.models.misc.context_manager import Typing
+
+if TYPE_CHECKING:
+    from .command import PrefixedCommand
+
+__all__ = ("PrefixedContext",)
+
+
+class PrefixedContext(BaseContext, SendMixin):
+    _message: Message
+
+    prefix: str
+    "The prefix used to invoke this command."
+    content_parameters: str
+    "The message content without the command and prefix."
+    command: "PrefixedCommand"
+    "The command this context invokes."
+
+    args: list[str]
+    "The arguments passed to the message."
+    kwargs: dict
+    "This is always empty, and is only here for compatibility with other types of commands."
+
+    @classmethod
+    def from_dict(cls, client: "Client", payload: dict) -> Self:
+        # this doesn't mean anything, so just implement it to make abc happy
+        raise NotImplementedError
+
+    @classmethod
+    def from_message(cls, client: "Client", message: Message) -> Self:
+        instance = cls(client=client)
+
+        # hack to work around BaseContext property
+        # since the message is the most important part of the context,
+        # we don't want to rely on the cache for it
+        instance._message = message
+
+        instance.message_id = message.id
+        instance.author_id = message._author_id
+        instance.channel_id = message._channel_id
+        instance.guild_id = message._guild_id
+
+        instance.prefix = ""
+        instance.content_parameters = ""
+        instance.command = None  # type: ignore
+        instance.args = []
+        instance.kwargs = {}
+        return instance
+
+    @property
+    def message(self) -> Message:
+        """The message that invoked this context."""
+        return self._message
+
+    @property
+    def invoke_target(self) -> str:
+        """The name of the command to be invoked."""
+        return self.command.name
+
+    @property
+    def typing(self) -> Typing:
+        """A context manager to send a typing state to the context's channel as long as the wrapped operation takes."""
+        return self.channel.typing
+
+    async def _send_http_request(self, message_payload: dict, files: Iterable["UPLOADABLE_TYPE"] | None = None) -> dict:
+        return await self.client.http.create_message(message_payload, self.channel_id, files=files)
+
+    async def reply(
+        self,
+        content: Optional[str] = None,
+        embeds: Optional[Union[Iterable[Union[Embed, dict]], Union[Embed, dict]]] = None,
+        embed: Optional[Union[Embed, dict]] = None,
+        **kwargs,
+    ) -> Message:
+        """
+        Reply to the context's message. Takes all the same attributes as `send`.
+
+        Args:
+            content: Message text content.
+            embeds: Embedded rich content (up to 6000 characters).
+            embed: Embedded rich content (up to 6000 characters).
+            **kwargs: Additional options to pass to `send`.
+
+        Returns:
+            New message object.
+
+        """
+        return await self.send(content=content, reply_to=self.message, embeds=embeds or embed, **kwargs)
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/help.py` & `discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/help.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,187 +1,187 @@
-import functools
-from logging import Logger
-
-import attrs
-
-from interactions import Embed, get_logger
-from interactions.ext.paginators import Paginator
-from interactions.models.discord.color import BrandColors, Color
-from .command import prefixed_command, PrefixedCommand
-from .context import PrefixedContext
-from .manager import PrefixedInjectedClient
-
-__all__ = ("PrefixedHelpCommand",)
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=True)
-class PrefixedHelpCommand:
-    """A help command for all prefixed commands in a bot."""
-
-    client: "PrefixedInjectedClient" = attrs.field()
-    """The client to use for the help command."""
-
-    show_hidden: bool = attrs.field(default=False, kw_only=True)
-    """Should hidden commands be shown?"""
-    show_disabled: bool = attrs.field(default=False, kw_only=True)
-    """Should disabled commands be shown?"""
-    run_checks: bool = attrs.field(default=False, kw_only=True)
-    """Should only commands that's checks pass be shown?"""
-    show_self: bool = attrs.field(default=False, kw_only=True)
-    """Should this command be shown in the help message?"""
-    show_usage: bool = attrs.field(default=False, kw_only=True)
-    """Should usage for commands be shown?"""
-    show_aliases: bool = attrs.field(default=False, kw_only=True)
-    """Should aliases for commands be shown?"""
-    show_prefix: bool = attrs.field(default=False, kw_only=True)
-    """Should the prefix be shown?"""
-    embed_color: Color = attrs.field(default=BrandColors.BLURPLE, kw_only=True)
-    """The colour to show in the Embeds."""
-
-    embed_title: str = attrs.field(default="{username} Help Command", kw_only=True)
-    """The title to use in the embed. {username} will be replaced by the client's username."""
-    not_found_message: str = attrs.field(default="Sorry! No command called `{cmd_name}` was found.", kw_only=True)
-    """The message to send when a command was not found. {cmd_name} will be replaced by the requested command."""
-    fallback_help_string: str = attrs.field(default="No help message available.", kw_only=True)
-    """The text to display when a command does not have a help string defined."""
-    fallback_brief_string: str = attrs.field(default="No help message available.", kw_only=True)
-    """The text to display when a command does not have a brief string defined."""
-
-    _cmd: PrefixedCommand = attrs.field(init=False, default=None)
-    logger: Logger = attrs.field(init=False, factory=get_logger)
-
-    def __attrs_post_init__(self) -> None:
-        if not self._cmd:
-            self._cmd = self._callback  # type: ignore
-
-    def register(self) -> None:
-        """Registers the help command."""
-        if not isinstance(self._cmd.callback, functools.partial):
-            # prevent wrap-nesting
-            self._cmd.callback = functools.partial(self._cmd.callback, self)
-
-        # replace existing help command if found
-        if "help" in self.client.prefixed.commands:
-            self.logger.warning("Replacing existing help command.")
-            del self.client.prefixed.commands["help"]
-
-        self.client.prefixed.add_command(self._cmd)  # type: ignore
-
-    async def send_help(self, ctx: PrefixedContext, cmd_name: str | None) -> None:
-        """
-        Send a help message to the given context.
-
-        Args:
-            ctx: The context to use.
-            cmd_name: An optional command name to send help for.
-        """
-        await self._callback.callback(ctx, cmd_name)  # type: ignore
-
-    @prefixed_command(name="help")
-    async def _callback(self, ctx: PrefixedContext, *, cmd_name: str | None = None) -> None:
-        if cmd_name:
-            return await self._help_specific(ctx, cmd_name)
-        await self._help_list(ctx)
-
-    async def _help_list(self, ctx: PrefixedContext) -> None:
-        cmds = await self._gather(ctx)
-
-        output = []
-        for cmd in cmds.values():
-            _temp = self._generate_command_string(cmd, ctx)
-            _temp += f"\n{cmd.brief or self.fallback_brief_string}"
-
-            output.append(self._sanitise_mentions(_temp))
-        if len("\n".join(output)) > 500:
-            paginator = Paginator.create_from_list(self.client, output, page_size=500)
-            paginator.default_color = self.embed_color
-            paginator.default_title = self.embed_title.format(username=self.client.user.username)
-            await paginator.send(ctx)
-        else:
-            embed = Embed(
-                title=self.embed_title.format(username=self.client.user.username),
-                description="\n".join(output),
-                color=self.embed_color,
-            )
-            await ctx.reply(embeds=embed)
-
-    async def _help_specific(self, ctx: PrefixedContext, cmd_name: str) -> None:
-        cmds = await self._gather(ctx)
-
-        if cmd := cmds.get(cmd_name.lower()):
-            _temp = self._generate_command_string(cmd, ctx)
-            _temp += f"\n{cmd.help or self.fallback_help_string}"
-            await ctx.reply(self._sanitise_mentions(_temp))
-        else:
-            await ctx.reply(self.not_found_message.format(cmd_name=cmd_name))
-
-    async def _gather(self, ctx: PrefixedContext | None = None) -> dict[str, PrefixedCommand]:
-        """
-        Gather commands based on the rules set out in the class attributes.
-
-        Args:
-            ctx: The context to use to establish usability.
-
-        Returns:
-            dict[str, PrefixedCommand]: A list of commands fit the class attribute configuration.
-        """
-        out: dict[str, PrefixedCommand] = {}
-
-        for cmd in frozenset(self.client.prefixed.commands.values()):
-            if not cmd.enabled and not self.show_disabled:
-                continue
-
-            if cmd == self._cmd and not self.show_self:
-                continue
-
-            if cmd.hidden and not self.show_hidden:
-                continue
-
-            if ctx and cmd.checks and not self.run_checks:
-                # cmd._can_run would check the cooldowns, we don't want that so manual calling is required
-                for _c in cmd.checks:
-                    if not await _c(ctx):
-                        continue
-
-                if cmd.extension and cmd.extension.extension_checks:
-                    for _c in cmd.extension.extension_checks:
-                        if not await _c(ctx):
-                            continue
-
-            out[cmd.qualified_name] = cmd
-
-        return out
-
-    def _sanitise_mentions(self, text: str) -> str:
-        """
-        Replace mentions with a format that won't ping or look weird in code blocks.
-
-        Args:
-            The text to sanitise.
-        """
-        mappings = {
-            "@everyone": "@\u200beveryone",
-            "@here": "@\u200bhere",
-            f"<@{self.client.user.id}>": f"@{self.client.user.username}",
-            f"<@!{self.client.user.id}>": f"@{self.client.user.username}",
-        }
-        for source, target in mappings.items():
-            text = text.replace(source, target)
-
-        return text
-
-    def _generate_command_string(self, cmd: PrefixedCommand, ctx: PrefixedContext) -> str:
-        """
-        Generate a string based on a command, class attributes, and the context.
-
-        Args:
-            cmd: The command in question.
-            ctx: The context for this command.
-        """
-        _temp = f"`{ctx.prefix if self.show_prefix else ''}{cmd.qualified_name}`"
-
-        if cmd.aliases and self.show_aliases:
-            _temp += "|" + "|".join([f"`{a}`" for a in cmd.aliases])
-
-        if cmd.usage and self.show_usage:
-            _temp += f" {cmd.usage}"
-        return _temp
+import functools
+from logging import Logger
+
+import attrs
+
+from interactions import Embed, get_logger
+from interactions.ext.paginators import Paginator
+from interactions.models.discord.color import BrandColors, Color
+from .command import prefixed_command, PrefixedCommand
+from .context import PrefixedContext
+from .manager import PrefixedInjectedClient
+
+__all__ = ("PrefixedHelpCommand",)
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=True)
+class PrefixedHelpCommand:
+    """A help command for all prefixed commands in a bot."""
+
+    client: "PrefixedInjectedClient" = attrs.field()
+    """The client to use for the help command."""
+
+    show_hidden: bool = attrs.field(default=False, kw_only=True)
+    """Should hidden commands be shown?"""
+    show_disabled: bool = attrs.field(default=False, kw_only=True)
+    """Should disabled commands be shown?"""
+    run_checks: bool = attrs.field(default=False, kw_only=True)
+    """Should only commands that's checks pass be shown?"""
+    show_self: bool = attrs.field(default=False, kw_only=True)
+    """Should this command be shown in the help message?"""
+    show_usage: bool = attrs.field(default=False, kw_only=True)
+    """Should usage for commands be shown?"""
+    show_aliases: bool = attrs.field(default=False, kw_only=True)
+    """Should aliases for commands be shown?"""
+    show_prefix: bool = attrs.field(default=False, kw_only=True)
+    """Should the prefix be shown?"""
+    embed_color: Color = attrs.field(default=BrandColors.BLURPLE, kw_only=True)
+    """The colour to show in the Embeds."""
+
+    embed_title: str = attrs.field(default="{username} Help Command", kw_only=True)
+    """The title to use in the embed. {username} will be replaced by the client's username."""
+    not_found_message: str = attrs.field(default="Sorry! No command called `{cmd_name}` was found.", kw_only=True)
+    """The message to send when a command was not found. {cmd_name} will be replaced by the requested command."""
+    fallback_help_string: str = attrs.field(default="No help message available.", kw_only=True)
+    """The text to display when a command does not have a help string defined."""
+    fallback_brief_string: str = attrs.field(default="No help message available.", kw_only=True)
+    """The text to display when a command does not have a brief string defined."""
+
+    _cmd: PrefixedCommand = attrs.field(init=False, default=None)
+    logger: Logger = attrs.field(init=False, factory=get_logger)
+
+    def __attrs_post_init__(self) -> None:
+        if not self._cmd:
+            self._cmd = self._callback  # type: ignore
+
+    def register(self) -> None:
+        """Registers the help command."""
+        if not isinstance(self._cmd.callback, functools.partial):
+            # prevent wrap-nesting
+            self._cmd.callback = functools.partial(self._cmd.callback, self)
+
+        # replace existing help command if found
+        if "help" in self.client.prefixed.commands:
+            self.logger.warning("Replacing existing help command.")
+            del self.client.prefixed.commands["help"]
+
+        self.client.prefixed.add_command(self._cmd)  # type: ignore
+
+    async def send_help(self, ctx: PrefixedContext, cmd_name: str | None) -> None:
+        """
+        Send a help message to the given context.
+
+        Args:
+            ctx: The context to use.
+            cmd_name: An optional command name to send help for.
+        """
+        await self._callback.callback(ctx, cmd_name)  # type: ignore
+
+    @prefixed_command(name="help")
+    async def _callback(self, ctx: PrefixedContext, *, cmd_name: str | None = None) -> None:
+        if cmd_name:
+            return await self._help_specific(ctx, cmd_name)
+        await self._help_list(ctx)
+
+    async def _help_list(self, ctx: PrefixedContext) -> None:
+        cmds = await self._gather(ctx)
+
+        output = []
+        for cmd in cmds.values():
+            _temp = self._generate_command_string(cmd, ctx)
+            _temp += f"\n{cmd.brief or self.fallback_brief_string}"
+
+            output.append(self._sanitise_mentions(_temp))
+        if len("\n".join(output)) > 500:
+            paginator = Paginator.create_from_list(self.client, output, page_size=500)
+            paginator.default_color = self.embed_color
+            paginator.default_title = self.embed_title.format(username=self.client.user.username)
+            await paginator.send(ctx)
+        else:
+            embed = Embed(
+                title=self.embed_title.format(username=self.client.user.username),
+                description="\n".join(output),
+                color=self.embed_color,
+            )
+            await ctx.reply(embeds=embed)
+
+    async def _help_specific(self, ctx: PrefixedContext, cmd_name: str) -> None:
+        cmds = await self._gather(ctx)
+
+        if cmd := cmds.get(cmd_name.lower()):
+            _temp = self._generate_command_string(cmd, ctx)
+            _temp += f"\n{cmd.help or self.fallback_help_string}"
+            await ctx.reply(self._sanitise_mentions(_temp))
+        else:
+            await ctx.reply(self.not_found_message.format(cmd_name=cmd_name))
+
+    async def _gather(self, ctx: PrefixedContext | None = None) -> dict[str, PrefixedCommand]:
+        """
+        Gather commands based on the rules set out in the class attributes.
+
+        Args:
+            ctx: The context to use to establish usability.
+
+        Returns:
+            dict[str, PrefixedCommand]: A list of commands fit the class attribute configuration.
+        """
+        out: dict[str, PrefixedCommand] = {}
+
+        for cmd in frozenset(self.client.prefixed.commands.values()):
+            if not cmd.enabled and not self.show_disabled:
+                continue
+
+            if cmd == self._cmd and not self.show_self:
+                continue
+
+            if cmd.hidden and not self.show_hidden:
+                continue
+
+            if ctx and cmd.checks and not self.run_checks:
+                # cmd._can_run would check the cooldowns, we don't want that so manual calling is required
+                for _c in cmd.checks:
+                    if not await _c(ctx):
+                        continue
+
+                if cmd.extension and cmd.extension.extension_checks:
+                    for _c in cmd.extension.extension_checks:
+                        if not await _c(ctx):
+                            continue
+
+            out[cmd.qualified_name] = cmd
+
+        return out
+
+    def _sanitise_mentions(self, text: str) -> str:
+        """
+        Replace mentions with a format that won't ping or look weird in code blocks.
+
+        Args:
+            The text to sanitise.
+        """
+        mappings = {
+            "@everyone": "@\u200beveryone",
+            "@here": "@\u200bhere",
+            f"<@{self.client.user.id}>": f"@{self.client.user.username}",
+            f"<@!{self.client.user.id}>": f"@{self.client.user.username}",
+        }
+        for source, target in mappings.items():
+            text = text.replace(source, target)
+
+        return text
+
+    def _generate_command_string(self, cmd: PrefixedCommand, ctx: PrefixedContext) -> str:
+        """
+        Generate a string based on a command, class attributes, and the context.
+
+        Args:
+            cmd: The command in question.
+            ctx: The context for this command.
+        """
+        _temp = f"`{ctx.prefix if self.show_prefix else ''}{cmd.qualified_name}`"
+
+        if cmd.aliases and self.show_aliases:
+            _temp += "|" + "|".join([f"`{a}`" for a in cmd.aliases])
+
+        if cmd.usage and self.show_usage:
+            _temp += f" {cmd.usage}"
+        return _temp
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/prefixed_commands/manager.py` & `discord-py-interactions-5.6.0/interactions/ext/prefixed_commands/manager.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,376 +1,376 @@
-import contextlib
-from asyncio import TimeoutError
-from collections import defaultdict
-from typing import Optional, Callable, Any, Coroutine, cast, Iterable
-from typing_extensions import Self
-
-from interactions.api.events.base import RawGatewayEvent
-from interactions.api.events.discord import MessageCreate
-from interactions.api.events.internal import (
-    CommandError,
-    CommandCompletion,
-    CallbackAdded,
-    ExtensionUnload,
-)
-from interactions.client.client import Client
-from interactions.client.utils.input_utils import get_args, get_first_word
-from interactions.models.discord.enums import Intents
-from interactions.models.discord.message import Message
-from interactions.models.internal.listener import listen
-from .command import PrefixedCommand
-from .context import PrefixedContext
-from .utils import when_mentioned
-
-__all__ = ("PrefixedInjectedClient", "PrefixedManager", "setup")
-
-
-class PrefixedInjectedClient(Client):
-    """
-    A semi-stub for a `Client` injected with prefixed commands.
-
-    This should only be used for type hinting.
-    """
-
-    prefixed: "PrefixedManager"
-    "The prefixed command manager for this client."
-
-
-class PrefixedManager:
-    """
-    The main part of the extension. Deals with injecting itself in the first place.
-
-    Parameters:
-        client: The client instance.
-        default_prefix: The default prefix to use. Defaults to `None`.
-        generate_prefixes: An asynchronous function \
-            that takes in a `Client` and `Message` object and returns either a \
-            string or an iterable of strings. Defaults to `None`.
-        prefixed_context: The object to instantiate for Prefixed Context
-    """
-
-    def __init__(
-        self,
-        client: Client,
-        *,
-        default_prefix: Optional[str | list[str]] = None,
-        generate_prefixes: Optional[
-            Callable[
-                [Client, Message],
-                Coroutine[Any, Any, str | list[str]],
-            ]
-        ] = None,
-        prefixed_context: type[PrefixedContext] = PrefixedContext,
-    ) -> None:
-        # typehinting funkyness for better typehints
-        client = cast(PrefixedInjectedClient, client)
-
-        self.client = client
-        self.default_prefix = default_prefix
-        self.prefixed_context = prefixed_context
-        self.commands: dict[str, PrefixedCommand] = {}
-        self._ext_command_list: defaultdict[str, set[str]] = defaultdict(set)
-
-        if (
-            default_prefix or (generate_prefixes and generate_prefixes != when_mentioned)
-        ) and Intents.MESSAGE_CONTENT not in client.intents:
-            client.logger.warning(
-                "Prefixed commands will not work since the required intent is not set -> Requires:"
-                f" {Intents.MESSAGE_CONTENT.__repr__()} or usage of the default mention prefix as the prefix"
-            )
-
-        if default_prefix is None and generate_prefixes is None:
-            # by default, use mentioning the bot as the prefix
-            generate_prefixes = when_mentioned
-
-        self.generate_prefixes = (  # type: ignore
-            generate_prefixes if generate_prefixes is not None else self.generate_prefixes
-        )
-
-        self.client.prefixed = self
-
-        self._dispatch_prefixed_commands = self._dispatch_prefixed_commands.copy_with_binding(self)
-        self._register_command = self._register_command.copy_with_binding(self)
-        self._handle_ext_unload = self._handle_ext_unload.copy_with_binding(self)
-
-        self.client.add_listener(self._dispatch_prefixed_commands)
-        self.client.add_listener(self._register_command)
-        self.client.add_listener(self._handle_ext_unload)
-
-    async def generate_prefixes(self, client: Client, msg: Message) -> str | list[str]:
-        """
-        Generates a list of prefixes a prefixed command can have based on the client and message.
-
-        This can be overwritten by passing a function to generate_prefixes on initialization.
-
-        Args:
-            client: The client instance.
-            msg: The message sent.
-
-        Returns:
-            The prefix(es) to check for.
-        """
-        return self.default_prefix  # type: ignore
-
-    def add_command(self, command: PrefixedCommand) -> None:
-        """
-        Add a prefixed command to the manager.
-
-        Args:
-            command: The command to add.
-        """
-        if command.is_subcommand:
-            raise ValueError("You cannot add subcommands to the client - add the base command instead.")
-
-        command._parse_parameters()
-
-        if self.commands.get(command.name):
-            raise ValueError(f"Duplicate command! Multiple commands share the name/alias: {command.name}.")
-        self.commands[command.name] = command
-
-        for alias in command.aliases:
-            if self.commands.get(alias):
-                raise ValueError(f"Duplicate command! Multiple commands share the name/alias: {alias}.")
-            self.commands[alias] = command
-
-        if command.extension:
-            self._ext_command_list[command.extension.extension_name].add(command.name)
-            command.extension._commands.append(command)
-
-    def get_command(self, name: str) -> Optional[PrefixedCommand]:
-        """
-        Gets a prefixed command by the name/alias specified.
-
-        This function is able to resolve subcommands - fully qualified names can be used.
-        For example, passing in ``foo bar`` would get the subcommand ``bar`` from the
-        command ``foo``.
-
-        Args:
-            name: The name of the command to search for.
-
-        Returns:
-            The command object, if found.
-        """
-        if " " not in name:
-            return self.commands.get(name)
-
-        names = name.split()
-        if not names:
-            return None
-
-        cmd = self.commands.get(names[0])
-        if not cmd:
-            return cmd
-
-        for name in names[1:]:
-            try:
-                cmd = cmd.subcommands[name]
-            except (AttributeError, KeyError):
-                return None
-
-        return cmd
-
-    def _remove_cmd_and_aliases(self, name: str) -> None:
-        if cmd := self.commands.pop(name, None):
-            if cmd.extension:
-                self._ext_command_list[cmd.extension.extension_name].discard(cmd.name)
-                with contextlib.suppress(ValueError):
-                    cmd.extension._commands.remove(cmd)
-
-            for alias in cmd.aliases:
-                self.commands.pop(alias, None)
-
-    def remove_command(self, name: str, delete_parent_if_empty: bool = False) -> Optional[PrefixedCommand]:
-        """
-        Removes a prefixed command if it exists.
-
-        If an alias is specified, only the alias will be removed.
-        This function is able to resolve subcommands - fully qualified names can be used.
-        For example, passing in ``foo bar`` would delete the subcommand ``bar``
-        from the command ``foo``.
-
-        Args:
-            name: The command to remove.
-            delete_parent_if_empty: Should the parent command be deleted if it \
-                ends up having no subcommands after deleting the command specified? \
-                Defaults to `False`.
-
-        Returns:
-            The command that was removed, if one was. If the command was not found,
-            this function returns `None`.
-        """
-        command = self.get_command(name)
-
-        if command is None:
-            return None
-
-        if name in command.aliases:
-            command.aliases.remove(name)
-            return command
-
-        if command.parent:
-            command.parent.remove_command(command.name)
-        else:
-            self._remove_cmd_and_aliases(command.name)
-
-        if delete_parent_if_empty:
-            while command.parent is not None and not command.parent.subcommands:
-                if command.parent.parent:
-                    _new_cmd = command.parent
-                    command.parent.parent.remove_command(command.parent.name)
-                    command = _new_cmd
-                else:
-                    self._remove_cmd_and_aliases(command.parent.name)
-                    break
-
-        return command
-
-    @listen("callback_added")
-    async def _register_command(self, event: CallbackAdded) -> None:
-        """Registers a prefixed command, if there is one given."""
-        if not isinstance(event.callback, PrefixedCommand):
-            return
-
-        cmd = event.callback
-        cmd.extension = event.extension
-
-        if not cmd.is_subcommand:
-            self.add_command(cmd)
-
-    @listen("extension_unload")
-    async def _handle_ext_unload(self, event: ExtensionUnload) -> None:
-        """Unregisters all prefixed commands in an extension as it is being unloaded."""
-        for name in self._ext_command_list[event.extension.extension_name].copy():
-            self.remove_command(name)
-
-    @listen("raw_message_create", is_default_listener=True)
-    async def _dispatch_prefixed_commands(self, event: RawGatewayEvent) -> None:  # noqa: C901
-        """Determine if a prefixed command is being triggered, and dispatch it."""
-        # don't waste time processing this if there are no prefixed commands
-        if not self.commands:
-            return
-
-        data = event.data
-
-        # many bots will not have the message content intent, and so will not have content
-        # for most messages. since there's nothing for prefixed commands to work off of,
-        # we might as well not waste time
-        if not data.get("content"):
-            return
-
-        # webhooks and users labeled with the bot property are bots, and should be ignored
-        if data.get("webhook_id") or data["author"].get("bot", False):
-            return
-
-        # now, we've done the basic filtering out, but everything from here on out relies
-        # on a proper message object, so now we either hope its already in the cache or wait
-        # on the processor
-
-        # first, let's check the cache...
-        message = self.client.cache.get_message(int(data["channel_id"]), int(data["id"]))
-
-        # this huge if statement basically checks if the message hasn't been fully processed by
-        # the processor yet, which would mean that these fields aren't fully filled
-        if message and (
-            (not message._guild_id and event.data.get("guild_id"))
-            or (message._guild_id and not message.guild)
-            or not message.channel
-        ):
-            message = None
-
-        # if we didn't get a message, then we know we should wait for the message create event
-        if not message:
-            try:
-                # i think 2 seconds is a very generous timeout limit
-                msg_event: MessageCreate = await self.client.wait_for(
-                    MessageCreate, checks=lambda e: int(e.message.id) == int(data["id"]), timeout=2
-                )
-                message = msg_event.message
-            except TimeoutError:
-                return
-
-        if not message.content:
-            return
-
-        # here starts the actual prefixed command parsing part
-        prefixes: str | Iterable[str] = await self.generate_prefixes(self.client, message)
-
-        if isinstance(prefixes, str):
-            # its easier to treat everything as if it may be an iterable
-            # rather than building a special case for this
-            prefixes = (prefixes,)  # type: ignore
-
-        prefix_used = next(
-            (prefix for prefix in prefixes if message.content.startswith(prefix)),
-            None,
-        )
-        if not prefix_used:
-            return
-
-        context = self.prefixed_context.from_message(self.client, message)
-        context.prefix = prefix_used
-
-        content_parameters = message.content.removeprefix(prefix_used).strip()
-        command: "Self | PrefixedCommand" = self  # yes, this is a hack
-
-        while True:
-            first_word: str = get_first_word(content_parameters)  # type: ignore
-            if isinstance(command, PrefixedCommand):
-                new_command = command.subcommands.get(first_word)
-            else:
-                new_command = command.commands.get(first_word)
-            if not new_command or not new_command.enabled:
-                break
-
-            command = new_command
-            content_parameters = content_parameters.removeprefix(first_word).strip()
-
-        if not isinstance(command, PrefixedCommand) or not command.enabled:
-            return
-
-        context.command = command
-        context.content_parameters = content_parameters.strip()
-        context.args = get_args(context.content_parameters)
-        try:
-            if self.client.pre_run_callback:
-                await self.client.pre_run_callback(context)
-            await command(context)
-            if self.client.post_run_callback:
-                await self.client.post_run_callback(context)
-        except Exception as e:
-            self.client.dispatch(CommandError(ctx=context, error=e))
-        finally:
-            self.client.dispatch(CommandCompletion(ctx=context))
-
-
-def setup(
-    client: Client,
-    *,
-    default_prefix: Optional[str | list[str]] = None,
-    generate_prefixes: Optional[
-        Callable[
-            [Client, Message],
-            Coroutine[Any, Any, str | list[str]],
-        ]
-    ] = None,
-    prefixed_context: type[PrefixedContext] = PrefixedContext,
-) -> PrefixedManager:
-    """
-    Sets up prefixed commands. It is recommended to use this function directly to do so.
-
-    Parameters:
-        client: The client instance.
-        default_prefix: The default prefix to use. Defaults to `None`.
-        generate_prefixes: An asynchronous function \
-            that takes in a `Client` and `Message` object and returns either a \
-            string or an iterable of strings. Defaults to `None`.
-        prefixed_context: The object to instantiate for Prefixed Context
-
-    Returns:
-        PrefixedManager: The class that deals with all things prefixed commands.
-    """
-    return PrefixedManager(
-        client,
-        default_prefix=default_prefix,
-        generate_prefixes=generate_prefixes,
-        prefixed_context=prefixed_context,
-    )
+import contextlib
+from asyncio import TimeoutError
+from collections import defaultdict
+from typing import Optional, Callable, Any, Coroutine, cast, Iterable
+from typing_extensions import Self
+
+from interactions.api.events.base import RawGatewayEvent
+from interactions.api.events.discord import MessageCreate
+from interactions.api.events.internal import (
+    CommandError,
+    CommandCompletion,
+    CallbackAdded,
+    ExtensionUnload,
+)
+from interactions.client.client import Client
+from interactions.client.utils.input_utils import get_args, get_first_word
+from interactions.models.discord.enums import Intents
+from interactions.models.discord.message import Message
+from interactions.models.internal.listener import listen
+from .command import PrefixedCommand
+from .context import PrefixedContext
+from .utils import when_mentioned
+
+__all__ = ("PrefixedInjectedClient", "PrefixedManager", "setup")
+
+
+class PrefixedInjectedClient(Client):
+    """
+    A semi-stub for a `Client` injected with prefixed commands.
+
+    This should only be used for type hinting.
+    """
+
+    prefixed: "PrefixedManager"
+    "The prefixed command manager for this client."
+
+
+class PrefixedManager:
+    """
+    The main part of the extension. Deals with injecting itself in the first place.
+
+    Parameters:
+        client: The client instance.
+        default_prefix: The default prefix to use. Defaults to `None`.
+        generate_prefixes: An asynchronous function \
+            that takes in a `Client` and `Message` object and returns either a \
+            string or an iterable of strings. Defaults to `None`.
+        prefixed_context: The object to instantiate for Prefixed Context
+    """
+
+    def __init__(
+        self,
+        client: Client,
+        *,
+        default_prefix: Optional[str | list[str]] = None,
+        generate_prefixes: Optional[
+            Callable[
+                [Client, Message],
+                Coroutine[Any, Any, str | list[str]],
+            ]
+        ] = None,
+        prefixed_context: type[PrefixedContext] = PrefixedContext,
+    ) -> None:
+        # typehinting funkyness for better typehints
+        client = cast(PrefixedInjectedClient, client)
+
+        self.client = client
+        self.default_prefix = default_prefix
+        self.prefixed_context = prefixed_context
+        self.commands: dict[str, PrefixedCommand] = {}
+        self._ext_command_list: defaultdict[str, set[str]] = defaultdict(set)
+
+        if (
+            default_prefix or (generate_prefixes and generate_prefixes != when_mentioned)
+        ) and Intents.MESSAGE_CONTENT not in client.intents:
+            client.logger.warning(
+                "Prefixed commands will not work since the required intent is not set -> Requires:"
+                f" {Intents.MESSAGE_CONTENT.__repr__()} or usage of the default mention prefix as the prefix"
+            )
+
+        if default_prefix is None and generate_prefixes is None:
+            # by default, use mentioning the bot as the prefix
+            generate_prefixes = when_mentioned
+
+        self.generate_prefixes = (  # type: ignore
+            generate_prefixes if generate_prefixes is not None else self.generate_prefixes
+        )
+
+        self.client.prefixed = self
+
+        self._dispatch_prefixed_commands = self._dispatch_prefixed_commands.copy_with_binding(self)
+        self._register_command = self._register_command.copy_with_binding(self)
+        self._handle_ext_unload = self._handle_ext_unload.copy_with_binding(self)
+
+        self.client.add_listener(self._dispatch_prefixed_commands)
+        self.client.add_listener(self._register_command)
+        self.client.add_listener(self._handle_ext_unload)
+
+    async def generate_prefixes(self, client: Client, msg: Message) -> str | list[str]:
+        """
+        Generates a list of prefixes a prefixed command can have based on the client and message.
+
+        This can be overwritten by passing a function to generate_prefixes on initialization.
+
+        Args:
+            client: The client instance.
+            msg: The message sent.
+
+        Returns:
+            The prefix(es) to check for.
+        """
+        return self.default_prefix  # type: ignore
+
+    def add_command(self, command: PrefixedCommand) -> None:
+        """
+        Add a prefixed command to the manager.
+
+        Args:
+            command: The command to add.
+        """
+        if command.is_subcommand:
+            raise ValueError("You cannot add subcommands to the client - add the base command instead.")
+
+        command._parse_parameters()
+
+        if self.commands.get(command.name):
+            raise ValueError(f"Duplicate command! Multiple commands share the name/alias: {command.name}.")
+        self.commands[command.name] = command
+
+        for alias in command.aliases:
+            if self.commands.get(alias):
+                raise ValueError(f"Duplicate command! Multiple commands share the name/alias: {alias}.")
+            self.commands[alias] = command
+
+        if command.extension:
+            self._ext_command_list[command.extension.extension_name].add(command.name)
+            command.extension._commands.append(command)
+
+    def get_command(self, name: str) -> Optional[PrefixedCommand]:
+        """
+        Gets a prefixed command by the name/alias specified.
+
+        This function is able to resolve subcommands - fully qualified names can be used.
+        For example, passing in ``foo bar`` would get the subcommand ``bar`` from the
+        command ``foo``.
+
+        Args:
+            name: The name of the command to search for.
+
+        Returns:
+            The command object, if found.
+        """
+        if " " not in name:
+            return self.commands.get(name)
+
+        names = name.split()
+        if not names:
+            return None
+
+        cmd = self.commands.get(names[0])
+        if not cmd:
+            return cmd
+
+        for name in names[1:]:
+            try:
+                cmd = cmd.subcommands[name]
+            except (AttributeError, KeyError):
+                return None
+
+        return cmd
+
+    def _remove_cmd_and_aliases(self, name: str) -> None:
+        if cmd := self.commands.pop(name, None):
+            if cmd.extension:
+                self._ext_command_list[cmd.extension.extension_name].discard(cmd.name)
+                with contextlib.suppress(ValueError):
+                    cmd.extension._commands.remove(cmd)
+
+            for alias in cmd.aliases:
+                self.commands.pop(alias, None)
+
+    def remove_command(self, name: str, delete_parent_if_empty: bool = False) -> Optional[PrefixedCommand]:
+        """
+        Removes a prefixed command if it exists.
+
+        If an alias is specified, only the alias will be removed.
+        This function is able to resolve subcommands - fully qualified names can be used.
+        For example, passing in ``foo bar`` would delete the subcommand ``bar``
+        from the command ``foo``.
+
+        Args:
+            name: The command to remove.
+            delete_parent_if_empty: Should the parent command be deleted if it \
+                ends up having no subcommands after deleting the command specified? \
+                Defaults to `False`.
+
+        Returns:
+            The command that was removed, if one was. If the command was not found,
+            this function returns `None`.
+        """
+        command = self.get_command(name)
+
+        if command is None:
+            return None
+
+        if name in command.aliases:
+            command.aliases.remove(name)
+            return command
+
+        if command.parent:
+            command.parent.remove_command(command.name)
+        else:
+            self._remove_cmd_and_aliases(command.name)
+
+        if delete_parent_if_empty:
+            while command.parent is not None and not command.parent.subcommands:
+                if command.parent.parent:
+                    _new_cmd = command.parent
+                    command.parent.parent.remove_command(command.parent.name)
+                    command = _new_cmd
+                else:
+                    self._remove_cmd_and_aliases(command.parent.name)
+                    break
+
+        return command
+
+    @listen("callback_added")
+    async def _register_command(self, event: CallbackAdded) -> None:
+        """Registers a prefixed command, if there is one given."""
+        if not isinstance(event.callback, PrefixedCommand):
+            return
+
+        cmd = event.callback
+        cmd.extension = event.extension
+
+        if not cmd.is_subcommand:
+            self.add_command(cmd)
+
+    @listen("extension_unload")
+    async def _handle_ext_unload(self, event: ExtensionUnload) -> None:
+        """Unregisters all prefixed commands in an extension as it is being unloaded."""
+        for name in self._ext_command_list[event.extension.extension_name].copy():
+            self.remove_command(name)
+
+    @listen("raw_message_create", is_default_listener=True)
+    async def _dispatch_prefixed_commands(self, event: RawGatewayEvent) -> None:  # noqa: C901
+        """Determine if a prefixed command is being triggered, and dispatch it."""
+        # don't waste time processing this if there are no prefixed commands
+        if not self.commands:
+            return
+
+        data = event.data
+
+        # many bots will not have the message content intent, and so will not have content
+        # for most messages. since there's nothing for prefixed commands to work off of,
+        # we might as well not waste time
+        if not data.get("content"):
+            return
+
+        # webhooks and users labeled with the bot property are bots, and should be ignored
+        if data.get("webhook_id") or data["author"].get("bot", False):
+            return
+
+        # now, we've done the basic filtering out, but everything from here on out relies
+        # on a proper message object, so now we either hope its already in the cache or wait
+        # on the processor
+
+        # first, let's check the cache...
+        message = self.client.cache.get_message(int(data["channel_id"]), int(data["id"]))
+
+        # this huge if statement basically checks if the message hasn't been fully processed by
+        # the processor yet, which would mean that these fields aren't fully filled
+        if message and (
+            (not message._guild_id and event.data.get("guild_id"))
+            or (message._guild_id and not message.guild)
+            or not message.channel
+        ):
+            message = None
+
+        # if we didn't get a message, then we know we should wait for the message create event
+        if not message:
+            try:
+                # i think 2 seconds is a very generous timeout limit
+                msg_event: MessageCreate = await self.client.wait_for(
+                    MessageCreate, checks=lambda e: int(e.message.id) == int(data["id"]), timeout=2
+                )
+                message = msg_event.message
+            except TimeoutError:
+                return
+
+        if not message.content:
+            return
+
+        # here starts the actual prefixed command parsing part
+        prefixes: str | Iterable[str] = await self.generate_prefixes(self.client, message)
+
+        if isinstance(prefixes, str):
+            # its easier to treat everything as if it may be an iterable
+            # rather than building a special case for this
+            prefixes = (prefixes,)  # type: ignore
+
+        prefix_used = next(
+            (prefix for prefix in prefixes if message.content.startswith(prefix)),
+            None,
+        )
+        if not prefix_used:
+            return
+
+        context = self.prefixed_context.from_message(self.client, message)
+        context.prefix = prefix_used
+
+        content_parameters = message.content.removeprefix(prefix_used).strip()
+        command: "Self | PrefixedCommand" = self  # yes, this is a hack
+
+        while True:
+            first_word: str = get_first_word(content_parameters)  # type: ignore
+            if isinstance(command, PrefixedCommand):
+                new_command = command.subcommands.get(first_word)
+            else:
+                new_command = command.commands.get(first_word)
+            if not new_command or not new_command.enabled:
+                break
+
+            command = new_command
+            content_parameters = content_parameters.removeprefix(first_word).strip()
+
+        if not isinstance(command, PrefixedCommand) or not command.enabled:
+            return
+
+        context.command = command
+        context.content_parameters = content_parameters.strip()
+        context.args = get_args(context.content_parameters)
+        try:
+            if self.client.pre_run_callback:
+                await self.client.pre_run_callback(context)
+            await command(context)
+            if self.client.post_run_callback:
+                await self.client.post_run_callback(context)
+        except Exception as e:
+            self.client.dispatch(CommandError(ctx=context, error=e))
+        finally:
+            self.client.dispatch(CommandCompletion(ctx=context))
+
+
+def setup(
+    client: Client,
+    *,
+    default_prefix: Optional[str | list[str]] = None,
+    generate_prefixes: Optional[
+        Callable[
+            [Client, Message],
+            Coroutine[Any, Any, str | list[str]],
+        ]
+    ] = None,
+    prefixed_context: type[PrefixedContext] = PrefixedContext,
+) -> PrefixedManager:
+    """
+    Sets up prefixed commands. It is recommended to use this function directly to do so.
+
+    Parameters:
+        client: The client instance.
+        default_prefix: The default prefix to use. Defaults to `None`.
+        generate_prefixes: An asynchronous function \
+            that takes in a `Client` and `Message` object and returns either a \
+            string or an iterable of strings. Defaults to `None`.
+        prefixed_context: The object to instantiate for Prefixed Context
+
+    Returns:
+        PrefixedManager: The class that deals with all things prefixed commands.
+    """
+    return PrefixedManager(
+        client,
+        default_prefix=default_prefix,
+        generate_prefixes=generate_prefixes,
+        prefixed_context=prefixed_context,
+    )
```

### Comparing `discord-py-interactions-5.5.1/interactions/ext/sentry.py` & `discord-py-interactions-5.6.0/interactions/ext/sentry.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,102 +1,103 @@
-"""
-Sets up a Sentry Logger
-
-And then call `bot.load_extension('interactions.ext.sentry', token=SENTRY_TOKEN)`
-Optionally takes a filter function that will be called before sending the event to Sentry.
-"""
-import functools
-import logging
-from typing import Any, Callable, Optional
-
-from interactions.api.events.internal import Error
-from interactions.client.const import get_logger
-from interactions.models.internal.tasks.task import Task
-
-try:
-    import sentry_sdk
-except ModuleNotFoundError:
-    get_logger().error(
-        "sentry-sdk not installed, cannot enable sentry integration.  Install with `pip install interactions[sentry]`"
-    )
-    raise
-
-from interactions import Client, Extension, listen
-
-__all__ = ("setup", "default_sentry_filter")
-
-
-def default_sentry_filter(event: dict[str, Any], hint: dict[str, Any]) -> Optional[dict[str, Any]]:
-    if "log_record" in hint:
-        record: logging.LogRecord = hint["log_record"]
-        if "interactions" in record.name:
-            #  There are some logging messages that are not worth sending to sentry.
-            if ": 403" in record.message:
-                return None
-            if record.message.startswith("Ignoring exception in "):
-                return None
-
-    if "exc_info" in hint:
-        exc_type, exc_value, tb = hint["exc_info"]
-        if isinstance(exc_value, KeyboardInterrupt):
-            #  We don't need to report a ctrl+c
-            return None
-    return event
-
-
-class SentryExtension(Extension):
-    @listen()
-    async def on_startup(self) -> None:
-        sentry_sdk.set_context(
-            "bot",
-            {
-                "name": str(self.bot.user),
-                "intents": repr(self.bot.intents),
-            },
-        )
-        sentry_sdk.set_tag("bot_name", str(self.bot.user))
-
-    @listen(disable_default_listeners=False)
-    async def on_error(self, event: Error) -> None:
-        with sentry_sdk.configure_scope() as scope:
-            scope.set_tag("source", event.source)
-            if event.ctx:
-                scope.set_context(
-                    type(event.ctx).__name__,
-                    {
-                        "args": event.ctx.args,
-                        "kwargs": event.ctx.kwargs,
-                        "message": event.ctx.message,
-                    },
-                )
-                if event.ctx.author:
-                    scope.set_user({"id": event.ctx.author.id, "username": event.ctx.author.tag})
-            sentry_sdk.capture_exception(event.error)
-
-
-class HookedTask(Task):
-    """We're subclassing purely for the type hinting.  The following method will be transplanted onto Task."""
-
-    def on_error_sentry_hook(self: Task, error: Exception) -> None:
-        with sentry_sdk.configure_scope() as scope:
-            if isinstance(self.callback, functools.partial):
-                scope.set_tag("task", self.callback.func.__name__)
-            else:
-                scope.set_tag("task", self.callback.__name__)
-
-            scope.set_tag("iteration", self.iteration)
-            sentry_sdk.capture_exception(error)
-
-
-def setup(
-    bot: Client,
-    token: str = None,
-    filter: Optional[Callable[[dict[str, Any], dict[str, Any]], Optional[dict[str, Any]]]] = None,
-) -> None:
-    if not token:
-        bot.logger.error("Cannot enable sentry integration, no token provided")
-        return
-    if filter is None:
-        filter = default_sentry_filter
-    sentry_sdk.init(token, before_send=filter)
-    Task.on_error_sentry_hook = HookedTask.on_error_sentry_hook  # type: ignore
-    SentryExtension(bot)
+"""
+Sets up a Sentry Logger
+
+And then call `bot.load_extension('interactions.ext.sentry', token=SENTRY_TOKEN)`
+Optionally takes a filter function that will be called before sending the event to Sentry.
+"""
+import functools
+import logging
+from typing import Any, Callable, Optional
+
+from interactions.api.events.internal import Error
+from interactions.client.const import get_logger
+from interactions.models.internal.tasks.task import Task
+
+try:
+    import sentry_sdk
+except ModuleNotFoundError:
+    get_logger().error(
+        "sentry-sdk not installed, cannot enable sentry integration.  Install with `pip install interactions[sentry]`"
+    )
+    raise
+
+from interactions import Client, Extension, listen
+
+__all__ = ("setup", "default_sentry_filter")
+
+
+def default_sentry_filter(event: dict[str, Any], hint: dict[str, Any]) -> Optional[dict[str, Any]]:
+    if "log_record" in hint:
+        record: logging.LogRecord = hint["log_record"]
+        if "interactions" in record.name:
+            #  There are some logging messages that are not worth sending to sentry.
+            if ": 403" in record.message:
+                return None
+            if record.message.startswith("Ignoring exception in "):
+                return None
+
+    if "exc_info" in hint:
+        exc_type, exc_value, tb = hint["exc_info"]
+        if isinstance(exc_value, KeyboardInterrupt):
+            #  We don't need to report a ctrl+c
+            return None
+    return event
+
+
+class SentryExtension(Extension):
+    @listen()
+    async def on_startup(self) -> None:
+        sentry_sdk.set_context(
+            "bot",
+            {
+                "name": str(self.bot.user),
+                "intents": repr(self.bot.intents),
+            },
+        )
+        sentry_sdk.set_tag("bot_name", str(self.bot.user))
+
+    @listen(disable_default_listeners=False)
+    async def on_error(self, event: Error) -> None:
+        with sentry_sdk.configure_scope() as scope:
+            scope.set_tag("source", event.source)
+            if event.ctx:
+                scope.set_context(
+                    type(event.ctx).__name__,
+                    {
+                        "args": event.ctx.args,
+                        "kwargs": event.ctx.kwargs,
+                        "message": event.ctx.message,
+                    },
+                )
+                if event.ctx.author:
+                    scope.set_user({"id": event.ctx.author.id, "username": event.ctx.author.tag})
+            sentry_sdk.capture_exception(event.error)
+
+
+class HookedTask(Task):
+    """We're subclassing purely for the type hinting.  The following method will be transplanted onto Task."""
+
+    def on_error_sentry_hook(self: Task, error: Exception) -> None:
+        with sentry_sdk.configure_scope() as scope:
+            if isinstance(self.callback, functools.partial):
+                scope.set_tag("task", self.callback.func.__name__)
+            else:
+                scope.set_tag("task", self.callback.__name__)
+
+            scope.set_tag("iteration", self.iteration)
+            sentry_sdk.capture_exception(error)
+
+
+def setup(
+    bot: Client,
+    token: str = None,
+    filter: Optional[Callable[[dict[str, Any], dict[str, Any]], Optional[dict[str, Any]]]] = None,
+    **kwargs,
+) -> None:
+    if not token:
+        bot.logger.error("Cannot enable sentry integration, no token provided")
+        return
+    if filter is None:
+        filter = default_sentry_filter
+    sentry_sdk.init(token, before_send=filter, **kwargs)
+    Task.on_error_sentry_hook = HookedTask.on_error_sentry_hook  # type: ignore
+    SentryExtension(bot)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/__init__.py` & `discord-py-interactions-5.6.0/interactions/models/discord/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,354 +1,357 @@
-from .activity import Activity, ActivityAssets, ActivityParty, ActivitySecrets, ActivityTimestamps
-from .app_perms import ApplicationCommandPermission
-from .application import Application
-from .asset import Asset
-from .auto_mod import AutoModerationAction, AutoModRule
-from .channel import (
-    BaseChannel,
-    ChannelHistory,
-    DM,
-    DMChannel,
-    DMGroup,
-    GuildCategory,
-    GuildChannel,
-    GuildForum,
-    GuildForumPost,
-    GuildNews,
-    GuildNewsThread,
-    GuildPrivateThread,
-    GuildPublicThread,
-    GuildStageVoice,
-    GuildText,
-    GuildVoice,
-    InvitableMixin,
-    MessageableMixin,
-    PermissionOverwrite,
-    process_permission_overwrites,
-    ThreadableMixin,
-    ThreadChannel,
-    TYPE_ALL_CHANNEL,
-    TYPE_CHANNEL_MAPPING,
-    TYPE_DM_CHANNEL,
-    TYPE_GUILD_CHANNEL,
-    TYPE_MESSAGEABLE_CHANNEL,
-    TYPE_THREAD_CHANNEL,
-    TYPE_VOICE_CHANNEL,
-    WebhookMixin,
-)
-from .color import (
-    BrandColors,
-    BrandColours,
-    Color,
-    COLOR_TYPES,
-    Colour,
-    FlatUIColors,
-    FlatUIColours,
-    MaterialColors,
-    MaterialColours,
-    process_color,
-    process_colour,
-    RoleColors,
-    RoleColours,
-)
-from .components import (
-    ActionRow,
-    BaseComponent,
-    BaseSelectMenu,
-    Button,
-    ChannelSelectMenu,
-    get_components_ids,
-    InteractiveComponent,
-    MentionableSelectMenu,
-    process_components,
-    RoleSelectMenu,
-    spread_to_rows,
-    StringSelectMenu,
-    StringSelectOption,
-    TYPE_COMPONENT_MAPPING,
-    UserSelectMenu,
-)
-
-from .embed import Embed, EmbedAttachment, EmbedAuthor, EmbedField, EmbedFooter, EmbedProvider, process_embeds
-from .emoji import CustomEmoji, PartialEmoji, process_emoji, process_emoji_req_format
-from .enums import (
-    ActivityFlag,
-    ActivityType,
-    ApplicationFlags,
-    AuditLogEventType,
-    AutoArchiveDuration,
-    ButtonStyle,
-    ChannelFlags,
-    ChannelType,
-    CommandType,
-    ComponentType,
-    DefaultNotificationLevel,
-    ExplicitContentFilterLevel,
-    ForumLayoutType,
-    IntegrationExpireBehaviour,
-    Intents,
-    InteractionPermissionTypes,
-    InteractionType,
-    InviteTargetType,
-    MemberFlags,
-    MentionType,
-    MessageActivityType,
-    MessageFlags,
-    MessageType,
-    MFALevel,
-    NSFWLevel,
-    OverwriteType,
-    Permissions,
-    PremiumTier,
-    PremiumType,
-    ScheduledEventPrivacyLevel,
-    ScheduledEventStatus,
-    ScheduledEventType,
-    StagePrivacyLevel,
-    Status,
-    StickerFormatType,
-    StickerTypes,
-    SystemChannelFlags,
-    TeamMembershipState,
-    UserFlags,
-    VerificationLevel,
-    VideoQualityMode,
-    WebSocketOPCode,
-)
-from .file import File, open_file, UPLOADABLE_TYPE
-from .guild import (
-    AuditLog,
-    AuditLogChange,
-    AuditLogEntry,
-    AuditLogHistory,
-    BaseGuild,
-    Guild,
-    GuildBan,
-    GuildIntegration,
-    GuildPreview,
-    GuildTemplate,
-    GuildWelcome,
-    GuildWelcomeChannel,
-    GuildWidget,
-    GuildWidgetSettings,
-)
-from .invite import Invite
-from .message import (
-    AllowedMentions,
-    Attachment,
-    BaseMessage,
-    ChannelMention,
-    Message,
-    MessageActivity,
-    MessageInteraction,
-    MessageReference,
-    process_allowed_mentions,
-    process_message_payload,
-    process_message_reference,
-)
-from .modal import InputText, Modal, ParagraphText, ShortText, TextStyles
-from .reaction import Reaction, ReactionUsers
-from .role import Role
-from .scheduled_event import ScheduledEvent
-from .snowflake import (
-    Snowflake,
-    Snowflake_Type,
-    SnowflakeObject,
-    to_optional_snowflake,
-    to_snowflake,
-    to_snowflake_list,
-)
-from .stage_instance import StageInstance
-from .sticker import Sticker, StickerItem, StickerPack
-from .team import Team, TeamMember
-from .thread import ThreadList, ThreadMember, ThreadTag
-from .timestamp import Timestamp, TimestampStyles
-from .user import BaseUser, Member, User, ClientUser
-from .voice_state import VoiceRegion, VoiceState
-
-__all__ = (
-    "ActionRow",
-    "Activity",
-    "ActivityAssets",
-    "ActivityFlag",
-    "ActivityParty",
-    "ActivitySecrets",
-    "ActivityTimestamps",
-    "ActivityType",
-    "AllowedMentions",
-    "Application",
-    "ApplicationCommandPermission",
-    "ApplicationFlags",
-    "Asset",
-    "Attachment",
-    "AuditLog",
-    "AuditLogChange",
-    "AuditLogEntry",
-    "AuditLogEventType",
-    "AuditLogHistory",
-    "AutoArchiveDuration",
-    "AutoModerationAction",
-    "AutoModRule",
-    "BaseChannel",
-    "BaseComponent",
-    "BaseGuild",
-    "BaseMessage",
-    "BaseSelectMenu",
-    "BaseUser",
-    "BrandColors",
-    "BrandColours",
-    "Button",
-    "ButtonStyle",
-    "ChannelFlags",
-    "ChannelHistory",
-    "ChannelMention",
-    "ChannelSelectMenu",
-    "ChannelType",
-    "ClientUser",
-    "Color",
-    "COLOR_TYPES",
-    "Colour",
-    "CommandType",
-    "ComponentType",
-    "CustomEmoji",
-    "DefaultNotificationLevel",
-    "DM",
-    "DMChannel",
-    "DMGroup",
-    "Embed",
-    "EmbedAttachment",
-    "EmbedAuthor",
-    "EmbedField",
-    "EmbedFooter",
-    "EmbedProvider",
-    "ExplicitContentFilterLevel",
-    "File",
-    "FlatUIColors",
-    "FlatUIColours",
-    "ForumLayoutType",
-    "get_components_ids",
-    "Guild",
-    "GuildBan",
-    "GuildCategory",
-    "GuildChannel",
-    "GuildForum",
-    "GuildForumPost",
-    "GuildIntegration",
-    "GuildNews",
-    "GuildNewsThread",
-    "GuildPreview",
-    "GuildPrivateThread",
-    "GuildPublicThread",
-    "GuildStageVoice",
-    "GuildTemplate",
-    "GuildText",
-    "GuildVoice",
-    "GuildWelcome",
-    "GuildWelcomeChannel",
-    "GuildWidget",
-    "GuildWidgetSettings",
-    "InputText",
-    "IntegrationExpireBehaviour",
-    "Intents",
-    "InteractionPermissionTypes",
-    "InteractionType",
-    "InteractiveComponent",
-    "InvitableMixin",
-    "Invite",
-    "InviteTargetType",
-    "MaterialColors",
-    "MaterialColours",
-    "Member",
-    "MemberFlags",
-    "MentionableSelectMenu",
-    "MentionType",
-    "Message",
-    "MessageableMixin",
-    "MessageActivity",
-    "MessageActivityType",
-    "MessageFlags",
-    "MessageInteraction",
-    "MessageReference",
-    "MessageType",
-    "MFALevel",
-    "Modal",
-    "NSFWLevel",
-    "open_file",
-    "OverwriteType",
-    "ParagraphText",
-    "PartialEmoji",
-    "PermissionOverwrite",
-    "Permissions",
-    "PremiumTier",
-    "PremiumType",
-    "process_allowed_mentions",
-    "process_color",
-    "process_colour",
-    "process_components",
-    "process_embeds",
-    "process_emoji",
-    "process_emoji_req_format",
-    "process_message_payload",
-    "process_message_reference",
-    "process_permission_overwrites",
-    "Reaction",
-    "ReactionUsers",
-    "Role",
-    "RoleColors",
-    "RoleColours",
-    "RoleSelectMenu",
-    "ScheduledEvent",
-    "ScheduledEventPrivacyLevel",
-    "ScheduledEventStatus",
-    "ScheduledEventType",
-    "ShortText",
-    "Snowflake",
-    "Snowflake_Type",
-    "SnowflakeObject",
-    "spread_to_rows",
-    "StageInstance",
-    "StagePrivacyLevel",
-    "Status",
-    "Sticker",
-    "StickerFormatType",
-    "StickerItem",
-    "StickerPack",
-    "StickerTypes",
-    "StringSelectMenu",
-    "StringSelectOption",
-    "SystemChannelFlags",
-    "Team",
-    "TeamMember",
-    "TeamMembershipState",
-    "TextStyles",
-    "ThreadableMixin",
-    "ThreadChannel",
-    "ThreadList",
-    "ThreadMember",
-    "ThreadTag",
-    "Timestamp",
-    "TimestampStyles",
-    "to_optional_snowflake",
-    "to_snowflake",
-    "to_snowflake_list",
-    "TYPE_ALL_CHANNEL",
-    "TYPE_CHANNEL_MAPPING",
-    "TYPE_COMPONENT_MAPPING",
-    "TYPE_DM_CHANNEL",
-    "TYPE_GUILD_CHANNEL",
-    "TYPE_MESSAGEABLE_CHANNEL",
-    "TYPE_THREAD_CHANNEL",
-    "TYPE_VOICE_CHANNEL",
-    "UPLOADABLE_TYPE",
-    "User",
-    "UserFlags",
-    "UserSelectMenu",
-    "VerificationLevel",
-    "VideoQualityMode",
-    "VoiceRegion",
-    "VoiceState",
-    "Webhook",
-    "WebhookMixin",
-    "WebhookTypes",
-    "WebSocketOPCode",
-)
-from .webhooks import Webhook, WebhookTypes
+from .activity import Activity, ActivityAssets, ActivityParty, ActivitySecrets, ActivityTimestamps
+from .app_perms import ApplicationCommandPermission
+from .application import Application
+from .asset import Asset
+from .auto_mod import AutoModerationAction, AutoModRule
+from .channel import (
+    BaseChannel,
+    ChannelHistory,
+    DM,
+    DMChannel,
+    DMGroup,
+    GuildCategory,
+    GuildChannel,
+    GuildForum,
+    GuildForumPost,
+    GuildNews,
+    GuildNewsThread,
+    GuildPrivateThread,
+    GuildPublicThread,
+    GuildStageVoice,
+    GuildText,
+    GuildVoice,
+    InvitableMixin,
+    MessageableMixin,
+    PermissionOverwrite,
+    process_permission_overwrites,
+    ThreadableMixin,
+    ThreadChannel,
+    TYPE_ALL_CHANNEL,
+    TYPE_CHANNEL_MAPPING,
+    TYPE_DM_CHANNEL,
+    TYPE_GUILD_CHANNEL,
+    TYPE_MESSAGEABLE_CHANNEL,
+    TYPE_THREAD_CHANNEL,
+    TYPE_VOICE_CHANNEL,
+    WebhookMixin,
+)
+from .color import (
+    BrandColors,
+    BrandColours,
+    Color,
+    COLOR_TYPES,
+    Colour,
+    FlatUIColors,
+    FlatUIColours,
+    MaterialColors,
+    MaterialColours,
+    process_color,
+    process_colour,
+    RoleColors,
+    RoleColours,
+)
+from .components import (
+    ActionRow,
+    BaseComponent,
+    BaseSelectMenu,
+    Button,
+    ChannelSelectMenu,
+    get_components_ids,
+    InteractiveComponent,
+    MentionableSelectMenu,
+    process_components,
+    RoleSelectMenu,
+    spread_to_rows,
+    StringSelectMenu,
+    StringSelectOption,
+    TYPE_COMPONENT_MAPPING,
+    UserSelectMenu,
+)
+
+from .embed import Embed, EmbedAttachment, EmbedAuthor, EmbedField, EmbedFooter, EmbedProvider, process_embeds
+from .emoji import CustomEmoji, PartialEmoji, process_emoji, process_emoji_req_format
+from .enums import (
+    ActivityFlag,
+    ActivityType,
+    ApplicationFlags,
+    AuditLogEventType,
+    AutoArchiveDuration,
+    ButtonStyle,
+    ChannelFlags,
+    ChannelType,
+    CommandType,
+    ComponentType,
+    DefaultNotificationLevel,
+    ExplicitContentFilterLevel,
+    ForumLayoutType,
+    IntegrationExpireBehaviour,
+    Intents,
+    InteractionPermissionTypes,
+    InteractionType,
+    InviteTargetType,
+    MemberFlags,
+    MentionType,
+    MessageActivityType,
+    MessageFlags,
+    MessageType,
+    MFALevel,
+    NSFWLevel,
+    OverwriteType,
+    Permissions,
+    PremiumTier,
+    PremiumType,
+    ScheduledEventPrivacyLevel,
+    ScheduledEventStatus,
+    ScheduledEventType,
+    StagePrivacyLevel,
+    Status,
+    StickerFormatType,
+    StickerTypes,
+    SystemChannelFlags,
+    TeamMembershipState,
+    UserFlags,
+    VerificationLevel,
+    VideoQualityMode,
+    WebSocketOPCode,
+)
+from .file import File, open_file, UPLOADABLE_TYPE
+from .guild import (
+    AuditLog,
+    AuditLogChange,
+    AuditLogEntry,
+    AuditLogHistory,
+    BaseGuild,
+    Guild,
+    GuildBan,
+    GuildIntegration,
+    GuildPreview,
+    GuildTemplate,
+    GuildWelcome,
+    GuildWelcomeChannel,
+    GuildWidget,
+    GuildWidgetSettings,
+)
+from .invite import Invite
+from .message import (
+    AllowedMentions,
+    Attachment,
+    BaseMessage,
+    ChannelMention,
+    Message,
+    MessageActivity,
+    MessageInteraction,
+    MessageReference,
+    process_allowed_mentions,
+    process_message_payload,
+    process_message_reference,
+)
+from .modal import InputText, Modal, ParagraphText, ShortText, TextStyles
+from .reaction import Reaction, ReactionUsers
+from .role import Role
+from .scheduled_event import ScheduledEvent
+from .snowflake import (
+    Snowflake,
+    Snowflake_Type,
+    SnowflakeObject,
+    to_optional_snowflake,
+    to_snowflake,
+    to_snowflake_list,
+)
+from .stage_instance import StageInstance
+from .sticker import Sticker, StickerItem, StickerPack
+from .team import Team, TeamMember
+from .thread import ThreadList, ThreadMember, ThreadTag, DefaultReaction, process_thread_tag, process_default_reaction
+from .timestamp import Timestamp, TimestampStyles
+from .user import BaseUser, Member, User, ClientUser
+from .voice_state import VoiceRegion, VoiceState
+
+__all__ = (
+    "ActionRow",
+    "Activity",
+    "ActivityAssets",
+    "ActivityFlag",
+    "ActivityParty",
+    "ActivitySecrets",
+    "ActivityTimestamps",
+    "ActivityType",
+    "AllowedMentions",
+    "Application",
+    "ApplicationCommandPermission",
+    "ApplicationFlags",
+    "Asset",
+    "Attachment",
+    "AuditLog",
+    "AuditLogChange",
+    "AuditLogEntry",
+    "AuditLogEventType",
+    "AuditLogHistory",
+    "AutoArchiveDuration",
+    "AutoModerationAction",
+    "AutoModRule",
+    "BaseChannel",
+    "BaseComponent",
+    "BaseGuild",
+    "BaseMessage",
+    "BaseSelectMenu",
+    "BaseUser",
+    "BrandColors",
+    "BrandColours",
+    "Button",
+    "ButtonStyle",
+    "ChannelFlags",
+    "ChannelHistory",
+    "ChannelMention",
+    "ChannelSelectMenu",
+    "ChannelType",
+    "ClientUser",
+    "Color",
+    "COLOR_TYPES",
+    "Colour",
+    "CommandType",
+    "ComponentType",
+    "CustomEmoji",
+    "DefaultNotificationLevel",
+    "DefaultReaction",
+    "DM",
+    "DMChannel",
+    "DMGroup",
+    "Embed",
+    "EmbedAttachment",
+    "EmbedAuthor",
+    "EmbedField",
+    "EmbedFooter",
+    "EmbedProvider",
+    "ExplicitContentFilterLevel",
+    "File",
+    "FlatUIColors",
+    "FlatUIColours",
+    "ForumLayoutType",
+    "get_components_ids",
+    "Guild",
+    "GuildBan",
+    "GuildCategory",
+    "GuildChannel",
+    "GuildForum",
+    "GuildForumPost",
+    "GuildIntegration",
+    "GuildNews",
+    "GuildNewsThread",
+    "GuildPreview",
+    "GuildPrivateThread",
+    "GuildPublicThread",
+    "GuildStageVoice",
+    "GuildTemplate",
+    "GuildText",
+    "GuildVoice",
+    "GuildWelcome",
+    "GuildWelcomeChannel",
+    "GuildWidget",
+    "GuildWidgetSettings",
+    "InputText",
+    "IntegrationExpireBehaviour",
+    "Intents",
+    "InteractionPermissionTypes",
+    "InteractionType",
+    "InteractiveComponent",
+    "InvitableMixin",
+    "Invite",
+    "InviteTargetType",
+    "MaterialColors",
+    "MaterialColours",
+    "Member",
+    "MemberFlags",
+    "MentionableSelectMenu",
+    "MentionType",
+    "Message",
+    "MessageableMixin",
+    "MessageActivity",
+    "MessageActivityType",
+    "MessageFlags",
+    "MessageInteraction",
+    "MessageReference",
+    "MessageType",
+    "MFALevel",
+    "Modal",
+    "NSFWLevel",
+    "open_file",
+    "OverwriteType",
+    "ParagraphText",
+    "PartialEmoji",
+    "PermissionOverwrite",
+    "Permissions",
+    "PremiumTier",
+    "PremiumType",
+    "process_allowed_mentions",
+    "process_color",
+    "process_colour",
+    "process_components",
+    "process_default_reaction",
+    "process_embeds",
+    "process_emoji",
+    "process_emoji_req_format",
+    "process_message_payload",
+    "process_message_reference",
+    "process_permission_overwrites",
+    "process_thread_tag",
+    "Reaction",
+    "ReactionUsers",
+    "Role",
+    "RoleColors",
+    "RoleColours",
+    "RoleSelectMenu",
+    "ScheduledEvent",
+    "ScheduledEventPrivacyLevel",
+    "ScheduledEventStatus",
+    "ScheduledEventType",
+    "ShortText",
+    "Snowflake",
+    "Snowflake_Type",
+    "SnowflakeObject",
+    "spread_to_rows",
+    "StageInstance",
+    "StagePrivacyLevel",
+    "Status",
+    "Sticker",
+    "StickerFormatType",
+    "StickerItem",
+    "StickerPack",
+    "StickerTypes",
+    "StringSelectMenu",
+    "StringSelectOption",
+    "SystemChannelFlags",
+    "Team",
+    "TeamMember",
+    "TeamMembershipState",
+    "TextStyles",
+    "ThreadableMixin",
+    "ThreadChannel",
+    "ThreadList",
+    "ThreadMember",
+    "ThreadTag",
+    "Timestamp",
+    "TimestampStyles",
+    "to_optional_snowflake",
+    "to_snowflake",
+    "to_snowflake_list",
+    "TYPE_ALL_CHANNEL",
+    "TYPE_CHANNEL_MAPPING",
+    "TYPE_COMPONENT_MAPPING",
+    "TYPE_DM_CHANNEL",
+    "TYPE_GUILD_CHANNEL",
+    "TYPE_MESSAGEABLE_CHANNEL",
+    "TYPE_THREAD_CHANNEL",
+    "TYPE_VOICE_CHANNEL",
+    "UPLOADABLE_TYPE",
+    "User",
+    "UserFlags",
+    "UserSelectMenu",
+    "VerificationLevel",
+    "VideoQualityMode",
+    "VoiceRegion",
+    "VoiceState",
+    "Webhook",
+    "WebhookMixin",
+    "WebhookTypes",
+    "WebSocketOPCode",
+)
+from .webhooks import Webhook, WebhookTypes
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/activity.py` & `discord-py-interactions-5.6.0/interactions/models/discord/activity.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,118 +1,118 @@
-from typing import Optional, List
-
-import attrs
-
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.attr_converters import timestamp_converter, optional
-from interactions.client.utils.serializer import dict_filter_none
-from interactions.models.discord.emoji import PartialEmoji
-from interactions.models.discord.enums import ActivityType, ActivityFlag
-from interactions.models.discord.snowflake import Snowflake_Type
-from interactions.models.discord.timestamp import Timestamp
-
-__all__ = (
-    "ActivityTimestamps",
-    "ActivityParty",
-    "ActivityAssets",
-    "ActivitySecrets",
-    "Activity",
-)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ActivityTimestamps(DictSerializationMixin):
-    start: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))
-    """The start time of the activity. Shows "elapsed" timer on discord client."""
-    end: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))
-    """The end time of the activity. Shows "remaining" timer on discord client."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ActivityParty(DictSerializationMixin):
-    id: Optional[str] = attrs.field(repr=False, default=None)
-    """A unique identifier for this party"""
-    size: Optional[List[int]] = attrs.field(repr=False, default=None)
-    """Info about the size of the party"""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ActivityAssets(DictSerializationMixin):
-    large_image: Optional[str] = attrs.field(repr=False, default=None)
-    """The large image for this activity. Uses discord's asset image url format."""
-    large_text: Optional[str] = attrs.field(repr=False, default=None)
-    """Hover text for the large image"""
-    small_image: Optional[str] = attrs.field(repr=False, default=None)
-    """The large image for this activity. Uses discord's asset image url format."""
-    small_text: Optional[str] = attrs.field(repr=False, default=None)
-    """Hover text for the small image"""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ActivitySecrets(DictSerializationMixin):
-    join: Optional[str] = attrs.field(repr=False, default=None)
-    """The secret for joining a party"""
-    spectate: Optional[str] = attrs.field(repr=False, default=None)
-    """The secret for spectating a party"""
-    match: Optional[str] = attrs.field(repr=False, default=None)
-    """The secret for a specific instanced match"""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Activity(DictSerializationMixin):
-    """Represents a discord activity object use for rich presence in discord."""
-
-    name: str = attrs.field(repr=True)
-    """The activity's name"""
-    type: ActivityType = attrs.field(repr=True, default=ActivityType.GAME)
-    """The type of activity"""
-    url: Optional[str] = attrs.field(repr=True, default=None)
-    """Stream url, is validated when type is 1"""
-    created_at: Optional[Timestamp] = attrs.field(repr=True, default=None, converter=optional(timestamp_converter))
-    """When the activity was added to the user's session"""
-    timestamps: Optional[ActivityTimestamps] = attrs.field(
-        repr=False, default=None, converter=optional(ActivityTimestamps.from_dict)
-    )
-    """Start and/or end of the game"""
-    application_id: "Snowflake_Type" = attrs.field(repr=False, default=None)
-    """Application id for the game"""
-    details: Optional[str] = attrs.field(repr=False, default=None)
-    """What the player is currently doing"""
-    state: Optional[str] = attrs.field(repr=False, default=None)
-    """The user's current party status"""
-    emoji: Optional[PartialEmoji] = attrs.field(repr=False, default=None, converter=optional(PartialEmoji.from_dict))
-    """The emoji used for a custom status"""
-    party: Optional[ActivityParty] = attrs.field(repr=False, default=None, converter=optional(ActivityParty.from_dict))
-    """Information for the current party of the player"""
-    assets: Optional[ActivityAssets] = attrs.field(
-        repr=False, default=None, converter=optional(ActivityAssets.from_dict)
-    )
-    """Assets to display on the player's profile"""
-    secrets: Optional[ActivitySecrets] = attrs.field(
-        repr=False, default=None, converter=optional(ActivitySecrets.from_dict)
-    )
-    """Secrets for Rich Presence joining and spectating"""
-    instance: Optional[bool] = attrs.field(repr=False, default=False)
-    """Whether or not the activity is an instanced game session"""
-    flags: Optional[ActivityFlag] = attrs.field(repr=False, default=None, converter=optional(ActivityFlag))
-    """Activity flags bitwise OR together, describes what the payload includes"""
-    buttons: List[str] = attrs.field(repr=False, factory=list)
-    """The custom buttons shown in the Rich Presence (max 2)"""
-
-    @classmethod
-    def create(cls, name: str, type: ActivityType = ActivityType.GAME, url: Optional[str] = None) -> "Activity":
-        """
-        Creates an activity object for the bot.
-
-        Args:
-            name: The new activity's name
-            type: Type of activity to create
-            url: Stream link for the activity
-
-        Returns:
-            The new activity object
-
-        """
-        return cls(name=name, type=type, url=url)
-
-    def to_dict(self) -> dict:
-        return dict_filter_none({"name": self.name, "type": self.type, "url": self.url})
+from typing import Optional, List
+
+import attrs
+
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.attr_converters import timestamp_converter, optional
+from interactions.client.utils.serializer import dict_filter_none
+from interactions.models.discord.emoji import PartialEmoji
+from interactions.models.discord.enums import ActivityType, ActivityFlag
+from interactions.models.discord.snowflake import Snowflake_Type
+from interactions.models.discord.timestamp import Timestamp
+
+__all__ = (
+    "ActivityTimestamps",
+    "ActivityParty",
+    "ActivityAssets",
+    "ActivitySecrets",
+    "Activity",
+)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ActivityTimestamps(DictSerializationMixin):
+    start: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))
+    """The start time of the activity. Shows "elapsed" timer on discord client."""
+    end: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))
+    """The end time of the activity. Shows "remaining" timer on discord client."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ActivityParty(DictSerializationMixin):
+    id: Optional[str] = attrs.field(repr=False, default=None)
+    """A unique identifier for this party"""
+    size: Optional[List[int]] = attrs.field(repr=False, default=None)
+    """Info about the size of the party"""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ActivityAssets(DictSerializationMixin):
+    large_image: Optional[str] = attrs.field(repr=False, default=None)
+    """The large image for this activity. Uses discord's asset image url format."""
+    large_text: Optional[str] = attrs.field(repr=False, default=None)
+    """Hover text for the large image"""
+    small_image: Optional[str] = attrs.field(repr=False, default=None)
+    """The large image for this activity. Uses discord's asset image url format."""
+    small_text: Optional[str] = attrs.field(repr=False, default=None)
+    """Hover text for the small image"""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ActivitySecrets(DictSerializationMixin):
+    join: Optional[str] = attrs.field(repr=False, default=None)
+    """The secret for joining a party"""
+    spectate: Optional[str] = attrs.field(repr=False, default=None)
+    """The secret for spectating a party"""
+    match: Optional[str] = attrs.field(repr=False, default=None)
+    """The secret for a specific instanced match"""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Activity(DictSerializationMixin):
+    """Represents a discord activity object use for rich presence in discord."""
+
+    name: str = attrs.field(repr=True)
+    """The activity's name"""
+    type: ActivityType = attrs.field(repr=True, default=ActivityType.GAME)
+    """The type of activity"""
+    url: Optional[str] = attrs.field(repr=True, default=None)
+    """Stream url, is validated when type is 1"""
+    created_at: Optional[Timestamp] = attrs.field(repr=True, default=None, converter=optional(timestamp_converter))
+    """When the activity was added to the user's session"""
+    timestamps: Optional[ActivityTimestamps] = attrs.field(
+        repr=False, default=None, converter=optional(ActivityTimestamps.from_dict)
+    )
+    """Start and/or end of the game"""
+    application_id: "Snowflake_Type" = attrs.field(repr=False, default=None)
+    """Application id for the game"""
+    details: Optional[str] = attrs.field(repr=False, default=None)
+    """What the player is currently doing"""
+    state: Optional[str] = attrs.field(repr=False, default=None)
+    """The user's current party status"""
+    emoji: Optional[PartialEmoji] = attrs.field(repr=False, default=None, converter=optional(PartialEmoji.from_dict))
+    """The emoji used for a custom status"""
+    party: Optional[ActivityParty] = attrs.field(repr=False, default=None, converter=optional(ActivityParty.from_dict))
+    """Information for the current party of the player"""
+    assets: Optional[ActivityAssets] = attrs.field(
+        repr=False, default=None, converter=optional(ActivityAssets.from_dict)
+    )
+    """Assets to display on the player's profile"""
+    secrets: Optional[ActivitySecrets] = attrs.field(
+        repr=False, default=None, converter=optional(ActivitySecrets.from_dict)
+    )
+    """Secrets for Rich Presence joining and spectating"""
+    instance: Optional[bool] = attrs.field(repr=False, default=False)
+    """Whether or not the activity is an instanced game session"""
+    flags: Optional[ActivityFlag] = attrs.field(repr=False, default=None, converter=optional(ActivityFlag))
+    """Activity flags bitwise OR together, describes what the payload includes"""
+    buttons: List[str] = attrs.field(repr=False, factory=list)
+    """The custom buttons shown in the Rich Presence (max 2)"""
+
+    @classmethod
+    def create(cls, name: str, type: ActivityType = ActivityType.GAME, url: Optional[str] = None) -> "Activity":
+        """
+        Creates an activity object for the bot.
+
+        Args:
+            name: The new activity's name
+            type: Type of activity to create
+            url: Stream link for the activity
+
+        Returns:
+            The new activity object
+
+        """
+        return cls(name=name, type=type, url=url)
+
+    def to_dict(self) -> dict:
+        return dict_filter_none({"name": self.name, "type": self.type, "url": self.url})
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/app_perms.py` & `discord-py-interactions-5.6.0/interactions/models/discord/app_perms.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,90 +1,90 @@
-from typing import TYPE_CHECKING
-
-import attrs
-
-from interactions.models.discord.base import DiscordObject, ClientObject
-from interactions.models.discord.enums import InteractionPermissionTypes
-from interactions.models.discord.snowflake import to_snowflake
-
-if TYPE_CHECKING:
-    from interactions import BaseContext
-    from interactions import Snowflake_Type, Guild
-
-__all__ = ("ApplicationCommandPermission",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ApplicationCommandPermission(DiscordObject):
-    id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-    """ID of the role user or channel"""
-    type: InteractionPermissionTypes = attrs.field(repr=False, converter=InteractionPermissionTypes)
-    """Type of permission (role user or channel)"""
-    permission: bool = attrs.field(repr=False, default=False)
-    """Whether the command is enabled for this permission"""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class CommandPermissions(ClientObject):
-    command_id: "Snowflake_Type" = attrs.field(
-        repr=False,
-    )
-    _guild: "Guild" = attrs.field(
-        repr=False,
-    )
-
-    permissions: dict["Snowflake_Type", ApplicationCommandPermission] = attrs.field(
-        repr=False, factory=dict, init=False
-    )
-
-    def is_enabled(self, *object_id) -> bool:
-        """
-        Check if a command is enabled for given scope(s). Takes into account the permissions for the bot itself
-
-        Args:
-            *object_id: The object(s) ID to check for.
-
-        Returns:
-            Whether the command is enabled for the given scope(s).
-        """
-        bot_perms = self._guild.command_permissions.get(self._client.app.id)
-
-        for obj_id in object_id:
-            obj_id = to_snowflake(obj_id)
-            if permission := self.permissions.get(obj_id):
-                if not permission.permission:
-                    return False
-
-            if bot_perms:
-                if permission := bot_perms.permissions.get(obj_id):
-                    if not permission.permission:
-                        return False
-        return True
-
-    def is_enabled_in_context(self, context: "BaseContext") -> bool:
-        """
-        Check if a command is enabled for the given context.
-
-        Args:
-            context: The context to check for.
-
-        Returns:
-            Whether the command is enabled for the given context.
-        """
-        everyone_role = context.guild.id
-        all_channels = context.guild.id - 1  # why tf discord
-        return self.is_enabled(
-            context.channel.id,
-            *context.member.roles,
-            context.author.id,
-            everyone_role,
-            all_channels,
-        )
-
-    def update_permissions(self, *permissions: ApplicationCommandPermission) -> None:
-        """
-        Update the permissions for the command.
-
-        Args:
-            permissions: The permission to set.
-        """
-        self.permissions = {perm.id: perm for perm in permissions}
+from typing import TYPE_CHECKING
+
+import attrs
+
+from interactions.models.discord.base import DiscordObject, ClientObject
+from interactions.models.discord.enums import InteractionPermissionTypes
+from interactions.models.discord.snowflake import to_snowflake
+
+if TYPE_CHECKING:
+    from interactions import BaseContext
+    from interactions import Snowflake_Type, Guild
+
+__all__ = ("ApplicationCommandPermission",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ApplicationCommandPermission(DiscordObject):
+    id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+    """ID of the role user or channel"""
+    type: InteractionPermissionTypes = attrs.field(repr=False, converter=InteractionPermissionTypes)
+    """Type of permission (role user or channel)"""
+    permission: bool = attrs.field(repr=False, default=False)
+    """Whether the command is enabled for this permission"""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class CommandPermissions(ClientObject):
+    command_id: "Snowflake_Type" = attrs.field(
+        repr=False,
+    )
+    _guild: "Guild" = attrs.field(
+        repr=False,
+    )
+
+    permissions: dict["Snowflake_Type", ApplicationCommandPermission] = attrs.field(
+        repr=False, factory=dict, init=False
+    )
+
+    def is_enabled(self, *object_id) -> bool:
+        """
+        Check if a command is enabled for given scope(s). Takes into account the permissions for the bot itself
+
+        Args:
+            *object_id: The object(s) ID to check for.
+
+        Returns:
+            Whether the command is enabled for the given scope(s).
+        """
+        bot_perms = self._guild.command_permissions.get(self._client.app.id)
+
+        for obj_id in object_id:
+            obj_id = to_snowflake(obj_id)
+            if permission := self.permissions.get(obj_id):
+                if not permission.permission:
+                    return False
+
+            if bot_perms:
+                if permission := bot_perms.permissions.get(obj_id):
+                    if not permission.permission:
+                        return False
+        return True
+
+    def is_enabled_in_context(self, context: "BaseContext") -> bool:
+        """
+        Check if a command is enabled for the given context.
+
+        Args:
+            context: The context to check for.
+
+        Returns:
+            Whether the command is enabled for the given context.
+        """
+        everyone_role = context.guild.id
+        all_channels = context.guild.id - 1  # why tf discord
+        return self.is_enabled(
+            context.channel.id,
+            *context.member.roles,
+            context.author.id,
+            everyone_role,
+            all_channels,
+        )
+
+    def update_permissions(self, *permissions: ApplicationCommandPermission) -> None:
+        """
+        Update the permissions for the command.
+
+        Args:
+            permissions: The permission to set.
+        """
+        self.permissions = {perm.id: perm for perm in permissions}
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/application.py` & `discord-py-interactions-5.6.0/interactions/models/discord/application.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,87 +1,87 @@
-from typing import TYPE_CHECKING, List, Optional, Dict, Any
-
-import attrs
-
-from interactions.client.const import MISSING
-from interactions.client.utils.attr_converters import optional
-from interactions.models.discord.asset import Asset
-from interactions.models.discord.enums import ApplicationFlags
-from interactions.models.discord.snowflake import Snowflake_Type, to_snowflake
-from interactions.models.discord.team import Team
-from .base import DiscordObject
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-    from interactions.models import User
-
-__all__ = ("Application",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Application(DiscordObject):
-    """Represents a discord application."""
-
-    name: str = attrs.field(repr=True)
-    """The name of the application"""
-    icon: Optional[Asset] = attrs.field(repr=False, default=None)
-    """The icon of the application"""
-    description: Optional[str] = attrs.field(repr=False, default=None)
-    """The description of the application"""
-    rpc_origins: Optional[List[str]] = attrs.field(repr=False, default=None)
-    """An array of rpc origin urls, if rpc is enabled"""
-    bot_public: bool = attrs.field(repr=False, default=True)
-    """When false only app owner can join the app's bot to guilds"""
-    bot_require_code_grant: bool = attrs.field(repr=False, default=False)
-    """When true the app's bot will only join upon completion of the full oauth2 code grant flow"""
-    terms_of_service_url: Optional[str] = attrs.field(repr=False, default=None)
-    """The url of the app's terms of service"""
-    privacy_policy_url: Optional[str] = attrs.field(repr=False, default=None)
-    """The url of the app's privacy policy"""
-    owner_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
-    """The id of the owner of the application"""
-    summary: str = attrs.field(
-        repr=False,
-    )
-    """If this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku"""
-    verify_key: Optional[str] = attrs.field(repr=False, default=MISSING)
-    """The hex encoded key for verification in interactions and the GameSDK's GetTicket"""
-    team: Optional["Team"] = attrs.field(repr=False, default=None)
-    """If the application belongs to a team, this will be a list of the members of that team"""
-    guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """If this application is a game sold on Discord, this field will be the guild to which it has been linked"""
-    primary_sku_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """If this application is a game sold on Discord, this field will be the id of the "Game SKU" that is created, if exists"""
-    slug: Optional[str] = attrs.field(repr=False, default=None)
-    """If this application is a game sold on Discord, this field will be the URL slug that links to the store page"""
-    cover_image: Optional[Asset] = attrs.field(repr=False, default=None)
-    """The application's default rich presence invite cover"""
-    flags: Optional["ApplicationFlags"] = attrs.field(repr=False, default=None, converter=optional(ApplicationFlags))
-    """The application's public flags"""
-    tags: Optional[List[str]] = attrs.field(repr=False, default=None)
-    """The application's tags describing its functionality and content"""
-    # todo: implement an ApplicationInstallParams object. See https://discord.com/developers/docs/resources/application#install-params-object
-    install_params: Optional[dict] = attrs.field(repr=False, default=None)
-    """The application's settings for in-app invitation to guilds"""
-    custom_install_url: Optional[str] = attrs.field(repr=False, default=None)
-    """The application's custom authorization link for invitation to a guild"""
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        if data.get("team"):
-            data["team"] = Team.from_dict(data["team"], client)
-            data["owner_id"] = data["team"].owner_user_id
-        elif "owner" in data:
-            owner = client.cache.place_user_data(data.pop("owner"))
-            data["owner_id"] = owner.id
-
-        if data.get("icon"):
-            data["icon"] = Asset.from_path_hash(client, f"app-icons/{data['id']}/{{}}", data["icon"])
-        if data.get("cover_image"):
-            data["cover_image"] = Asset.from_path_hash(client, f"app-icons/{data['id']}/{{}}", data["cover_image"])
-
-        return data
-
-    @property
-    def owner(self) -> "User":
-        """The user object for the owner of this application"""
-        return self._client.cache.get_user(self.owner_id)
+from typing import TYPE_CHECKING, List, Optional, Dict, Any
+
+import attrs
+
+from interactions.client.const import MISSING
+from interactions.client.utils.attr_converters import optional
+from interactions.models.discord.asset import Asset
+from interactions.models.discord.enums import ApplicationFlags
+from interactions.models.discord.snowflake import Snowflake_Type, to_snowflake
+from interactions.models.discord.team import Team
+from .base import DiscordObject
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+    from interactions.models import User
+
+__all__ = ("Application",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Application(DiscordObject):
+    """Represents a discord application."""
+
+    name: str = attrs.field(repr=True)
+    """The name of the application"""
+    icon: Optional[Asset] = attrs.field(repr=False, default=None)
+    """The icon of the application"""
+    description: Optional[str] = attrs.field(repr=False, default=None)
+    """The description of the application"""
+    rpc_origins: Optional[List[str]] = attrs.field(repr=False, default=None)
+    """An array of rpc origin urls, if rpc is enabled"""
+    bot_public: bool = attrs.field(repr=False, default=True)
+    """When false only app owner can join the app's bot to guilds"""
+    bot_require_code_grant: bool = attrs.field(repr=False, default=False)
+    """When true the app's bot will only join upon completion of the full oauth2 code grant flow"""
+    terms_of_service_url: Optional[str] = attrs.field(repr=False, default=None)
+    """The url of the app's terms of service"""
+    privacy_policy_url: Optional[str] = attrs.field(repr=False, default=None)
+    """The url of the app's privacy policy"""
+    owner_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
+    """The id of the owner of the application"""
+    summary: str = attrs.field(
+        repr=False,
+    )
+    """If this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku"""
+    verify_key: Optional[str] = attrs.field(repr=False, default=MISSING)
+    """The hex encoded key for verification in interactions and the GameSDK's GetTicket"""
+    team: Optional["Team"] = attrs.field(repr=False, default=None)
+    """If the application belongs to a team, this will be a list of the members of that team"""
+    guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """If this application is a game sold on Discord, this field will be the guild to which it has been linked"""
+    primary_sku_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """If this application is a game sold on Discord, this field will be the id of the "Game SKU" that is created, if exists"""
+    slug: Optional[str] = attrs.field(repr=False, default=None)
+    """If this application is a game sold on Discord, this field will be the URL slug that links to the store page"""
+    cover_image: Optional[Asset] = attrs.field(repr=False, default=None)
+    """The application's default rich presence invite cover"""
+    flags: Optional["ApplicationFlags"] = attrs.field(repr=False, default=None, converter=optional(ApplicationFlags))
+    """The application's public flags"""
+    tags: Optional[List[str]] = attrs.field(repr=False, default=None)
+    """The application's tags describing its functionality and content"""
+    # todo: implement an ApplicationInstallParams object. See https://discord.com/developers/docs/resources/application#install-params-object
+    install_params: Optional[dict] = attrs.field(repr=False, default=None)
+    """The application's settings for in-app invitation to guilds"""
+    custom_install_url: Optional[str] = attrs.field(repr=False, default=None)
+    """The application's custom authorization link for invitation to a guild"""
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        if data.get("team"):
+            data["team"] = Team.from_dict(data["team"], client)
+            data["owner_id"] = data["team"].owner_user_id
+        elif "owner" in data:
+            owner = client.cache.place_user_data(data.pop("owner"))
+            data["owner_id"] = owner.id
+
+        if data.get("icon"):
+            data["icon"] = Asset.from_path_hash(client, f"app-icons/{data['id']}/{{}}", data["icon"])
+        if data.get("cover_image"):
+            data["cover_image"] = Asset.from_path_hash(client, f"app-icons/{data['id']}/{{}}", data["cover_image"])
+
+        return data
+
+    @property
+    def owner(self) -> "User":
+        """The user object for the owner of this application"""
+        return self._client.cache.get_user(self.owner_id)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/asset.py` & `discord-py-interactions-5.6.0/interactions/models/discord/asset.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,132 +1,132 @@
-import re
-from typing import TYPE_CHECKING, Optional, Union
-
-import attrs
-
-from interactions.client.utils.serializer import no_export_meta
-
-if TYPE_CHECKING:
-    from os import PathLike
-
-    from interactions.client import Client
-
-__all__ = ("Asset",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Asset:
-    """
-    Represents a discord asset.
-
-    Attributes:
-        BASE str: The `cdn` address for assets
-        url str: The URL of this asset
-        hash Optional[str]: The hash of this asset
-
-    """
-
-    BASE = "https://cdn.discordapp.com"
-
-    _client: "Client" = attrs.field(repr=False, metadata=no_export_meta)
-    _url: str = attrs.field(repr=True)
-    hash: Optional[str] = attrs.field(repr=True, default=None)
-
-    @classmethod
-    def from_path_hash(cls, client: "Client", path: str, asset_hash: str) -> "Asset":
-        """
-        Create an asset from a path and asset's hash.
-
-        Args:
-            client: The bot instance
-            path: The CDN Endpoints for the type of asset.
-            asset_hash: The hash representation of the target asset.
-
-        Returns:
-            A new Asset object
-
-        """
-        url = f"{cls.BASE}/{path.format(asset_hash)}"
-        return cls(client=client, url=url, hash=asset_hash)
-
-    @property
-    def url(self) -> str:
-        """The URL of this asset."""
-        ext = ".gif" if self.animated else ".png"
-        return f"{self._url}{ext}?size=4096"
-
-    def as_url(self, *, extension: str | None = None, size: int = 4096) -> str:
-        """
-        Get the url of this asset.
-
-        Args:
-            extension: The extension to override the assets default with
-            size: The size of asset to return
-
-        Returns:
-            A url for this asset with the given parameters
-        """
-        if not extension:
-            extension = ".gif" if self.animated else ".png"
-        elif not extension.startswith("."):
-            extension = f".{extension}"
-
-        return f"{self._url}{extension}?size={size}"
-
-    @property
-    def animated(self) -> bool:
-        """True if this asset is animated."""
-        # damn hashes with version numbers
-        _hash = re.sub(r"^v\d+_", "", self.hash or "")
-        return bool(self.hash) and _hash.startswith("a_")
-
-    async def fetch(self, extension: Optional[str] = None, size: Optional[int] = None) -> bytes:
-        """
-        Fetch the asset from the Discord CDN.
-
-        Args:
-            extension: File extension based on the target image format
-            size: The image size, can be any power of two between 16 and 4096.
-
-        Returns:
-            Raw byte array of the file
-
-        Raises:
-            ValueError: Incorrect file size if not power of 2 between 16 and 4096
-
-        """
-        if not extension:
-            extension = ".gif" if self.animated else ".png"
-
-        url = self._url + extension
-
-        if size:
-            if size == 0 or size & (size - 1) != 0:  # if not power of 2
-                raise ValueError("Size should be a power of 2")
-            if not 16 <= size <= 4096:
-                raise ValueError("Size should be between 16 and 4096")
-
-            url = f"{url}?size={size}"
-
-        return await self._client.http.request_cdn(url, self)
-
-    async def save(
-        self,
-        fd: Union[str, bytes, "PathLike", int],
-        extension: Optional[str] = None,
-        size: Optional[int] = None,
-    ) -> int:
-        """
-        Save the asset to a local file.
-
-        Args:
-            fd: Destination path to save the file to.
-            extension: File extension based on the target image format.
-            size: The image size, can be any power of two between 16 and 4096.
-
-        Returns:
-            Status code result of file write
-
-        """
-        content = await self.fetch(extension=extension, size=size)
-        with open(fd, "wb") as f:
-            return f.write(content)
+import re
+from typing import TYPE_CHECKING, Optional, Union
+
+import attrs
+
+from interactions.client.utils.serializer import no_export_meta
+
+if TYPE_CHECKING:
+    from os import PathLike
+
+    from interactions.client import Client
+
+__all__ = ("Asset",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Asset:
+    """
+    Represents a discord asset.
+
+    Attributes:
+        BASE str: The `cdn` address for assets
+        url str: The URL of this asset
+        hash Optional[str]: The hash of this asset
+
+    """
+
+    BASE = "https://cdn.discordapp.com"
+
+    _client: "Client" = attrs.field(repr=False, metadata=no_export_meta)
+    _url: str = attrs.field(repr=True)
+    hash: Optional[str] = attrs.field(repr=True, default=None)
+
+    @classmethod
+    def from_path_hash(cls, client: "Client", path: str, asset_hash: str) -> "Asset":
+        """
+        Create an asset from a path and asset's hash.
+
+        Args:
+            client: The bot instance
+            path: The CDN Endpoints for the type of asset.
+            asset_hash: The hash representation of the target asset.
+
+        Returns:
+            A new Asset object
+
+        """
+        url = f"{cls.BASE}/{path.format(asset_hash)}"
+        return cls(client=client, url=url, hash=asset_hash)
+
+    @property
+    def url(self) -> str:
+        """The URL of this asset."""
+        ext = ".gif" if self.animated else ".png"
+        return f"{self._url}{ext}?size=4096"
+
+    def as_url(self, *, extension: str | None = None, size: int = 4096) -> str:
+        """
+        Get the url of this asset.
+
+        Args:
+            extension: The extension to override the assets default with
+            size: The size of asset to return
+
+        Returns:
+            A url for this asset with the given parameters
+        """
+        if not extension:
+            extension = ".gif" if self.animated else ".png"
+        elif not extension.startswith("."):
+            extension = f".{extension}"
+
+        return f"{self._url}{extension}?size={size}"
+
+    @property
+    def animated(self) -> bool:
+        """True if this asset is animated."""
+        # damn hashes with version numbers
+        _hash = re.sub(r"^v\d+_", "", self.hash or "")
+        return bool(self.hash) and _hash.startswith("a_")
+
+    async def fetch(self, extension: Optional[str] = None, size: Optional[int] = None) -> bytes:
+        """
+        Fetch the asset from the Discord CDN.
+
+        Args:
+            extension: File extension based on the target image format
+            size: The image size, can be any power of two between 16 and 4096.
+
+        Returns:
+            Raw byte array of the file
+
+        Raises:
+            ValueError: Incorrect file size if not power of 2 between 16 and 4096
+
+        """
+        if not extension:
+            extension = ".gif" if self.animated else ".png"
+
+        url = self._url + extension
+
+        if size:
+            if size == 0 or size & (size - 1) != 0:  # if not power of 2
+                raise ValueError("Size should be a power of 2")
+            if not 16 <= size <= 4096:
+                raise ValueError("Size should be between 16 and 4096")
+
+            url = f"{url}?size={size}"
+
+        return await self._client.http.request_cdn(url, self)
+
+    async def save(
+        self,
+        fd: Union[str, bytes, "PathLike", int],
+        extension: Optional[str] = None,
+        size: Optional[int] = None,
+    ) -> int:
+        """
+        Save the asset to a local file.
+
+        Args:
+            fd: Destination path to save the file to.
+            extension: File extension based on the target image format.
+            size: The image size, can be any power of two between 16 and 4096.
+
+        Returns:
+            Status code result of file write
+
+        """
+        content = await self.fetch(extension=extension, size=size)
+        with open(fd, "wb") as f:
+            return f.write(content)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/base.py` & `discord-py-interactions-5.6.0/interactions/models/discord/base.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-from typing import TYPE_CHECKING, Any, Dict, List, Type
-
-import attrs
-
-from interactions.client.const import T
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.serializer import no_export_meta
-from interactions.models.discord.snowflake import SnowflakeObject
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-
-__all__ = ("ClientObject", "DiscordObject")
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False)
-class ClientObject(DictSerializationMixin):
-    """Serializable object that requires client reference."""
-
-    _client: "Client" = attrs.field(repr=False, metadata=no_export_meta)
-
-    @property
-    def client(self) -> "Client":
-        return self._client
-
-    @property
-    def bot(self) -> "Client":
-        return self._client
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        return super()._process_dict(data)
-
-    @classmethod
-    def from_dict(cls: Type[T], data: Dict[str, Any], client: "Client") -> T:
-        data = cls._process_dict(data, client)
-        return cls(client=client, **cls._filter_kwargs(data, cls._get_init_keys()))
-
-    @classmethod
-    def from_list(cls: Type[T], datas: List[Dict[str, Any]], client: "Client") -> List[T]:
-        return [cls.from_dict(data, client) for data in datas]
-
-    def update_from_dict(self, data) -> T:
-        data = self._process_dict(data, self._client)
-        for key, value in self._filter_kwargs(data, self._get_keys()).items():
-            setattr(self, key, value)
-
-        return self
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False)
-class DiscordObject(SnowflakeObject, ClientObject):
-    pass
+from typing import TYPE_CHECKING, Any, Dict, List, Type
+
+import attrs
+
+from interactions.client.const import T
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.serializer import no_export_meta
+from interactions.models.discord.snowflake import SnowflakeObject
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+
+__all__ = ("ClientObject", "DiscordObject")
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False)
+class ClientObject(DictSerializationMixin):
+    """Serializable object that requires client reference."""
+
+    _client: "Client" = attrs.field(repr=False, metadata=no_export_meta)
+
+    @property
+    def client(self) -> "Client":
+        return self._client
+
+    @property
+    def bot(self) -> "Client":
+        return self._client
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        return super()._process_dict(data)
+
+    @classmethod
+    def from_dict(cls: Type[T], data: Dict[str, Any], client: "Client") -> T:
+        data = cls._process_dict(data, client)
+        return cls(client=client, **cls._filter_kwargs(data, cls._get_init_keys()))
+
+    @classmethod
+    def from_list(cls: Type[T], datas: List[Dict[str, Any]], client: "Client") -> List[T]:
+        return [cls.from_dict(data, client) for data in datas]
+
+    def update_from_dict(self, data) -> T:
+        data = self._process_dict(data, self._client)
+        for key, value in self._filter_kwargs(data, self._get_keys()).items():
+            setattr(self, key, value)
+
+        return self
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False)
+class DiscordObject(SnowflakeObject, ClientObject):
+    pass
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/channel.py` & `discord-py-interactions-5.6.0/interactions/models/discord/channel.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,2729 +1,2732 @@
-import time
-from asyncio import QueueEmpty
-from collections import namedtuple
-from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union, Callable
-
-import attrs
-
-import interactions.models as models
-from interactions.client.const import Absent, DISCORD_EPOCH, MISSING
-from interactions.client.errors import NotFound, VoiceNotConnected, TooManyChanges
-from interactions.client.mixins.send import SendMixin
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.attr_converters import optional as optional_c
-from interactions.client.utils.attr_converters import timestamp_converter
-from interactions.client.utils.misc_utils import get
-from interactions.client.utils.serializer import to_dict, to_image_data
-from interactions.models.discord.base import DiscordObject
-from interactions.models.discord.emoji import PartialEmoji
-from interactions.models.discord.file import UPLOADABLE_TYPE
-from interactions.models.discord.snowflake import (
-    Snowflake_Type,
-    to_snowflake,
-    to_optional_snowflake,
-    SnowflakeObject,
-)
-from interactions.models.discord.thread import ThreadTag
-from interactions.models.misc.context_manager import Typing
-from interactions.models.misc.iterator import AsyncIterator
-from .enums import (
-    ChannelFlags,
-    ChannelType,
-    OverwriteType,
-    Permissions,
-    VideoQualityMode,
-    AutoArchiveDuration,
-    StagePrivacyLevel,
-    MessageFlags,
-    InviteTargetType,
-)
-
-if TYPE_CHECKING:
-    from aiohttp import FormData
-    from interactions import Client, Embed, BaseComponent, AllowedMentions, Sticker, Message
-    from interactions.models.internal.active_voice_state import ActiveVoiceState
-
-__all__ = (
-    "ChannelHistory",
-    "PermissionOverwrite",
-    "MessageableMixin",
-    "InvitableMixin",
-    "ThreadableMixin",
-    "WebhookMixin",
-    "BaseChannel",
-    "DMChannel",
-    "DM",
-    "DMGroup",
-    "GuildChannel",
-    "GuildCategory",
-    "GuildNews",
-    "GuildText",
-    "ThreadChannel",
-    "GuildForum",
-    "GuildNewsThread",
-    "GuildPublicThread",
-    "GuildForumPost",
-    "GuildPrivateThread",
-    "GuildVoice",
-    "GuildStageVoice",
-    "process_permission_overwrites",
-    "TYPE_ALL_CHANNEL",
-    "TYPE_DM_CHANNEL",
-    "TYPE_GUILD_CHANNEL",
-    "TYPE_THREAD_CHANNEL",
-    "TYPE_VOICE_CHANNEL",
-    "TYPE_CHANNEL_MAPPING",
-    "TYPE_MESSAGEABLE_CHANNEL",
-)
-
-
-class ChannelHistory(AsyncIterator):
-    """
-    An async iterator for searching through a channel's history.
-
-    Attributes:
-        channel: The channel to search through
-        limit: The maximum number of messages to return (set to 0 for no limit)
-        before: get messages before this message ID
-        after: get messages after this message ID
-        around: get messages "around" this message ID
-
-    """
-
-    def __init__(self, channel: "BaseChannel", limit=50, before=None, after=None, around=None) -> None:
-        self.channel: "BaseChannel" = channel
-        self.before: Snowflake_Type = before
-        self.after: Snowflake_Type = after
-        self.around: Snowflake_Type = around
-        super().__init__(limit)
-
-    async def fetch(self) -> List["models.Message"]:
-        """
-        Fetch additional objects.
-
-        Your implementation of this method *must* return a list of objects.
-        If no more objects are available, raise QueueEmpty
-
-        Returns:
-            List of objects
-
-        Raises:
-              QueueEmpty: when no more objects are available.
-
-        """
-        if self.after:
-            if not self.last:
-                self.last = namedtuple("temp", "id")
-                self.last.id = self.after
-            messages = await self.channel.fetch_messages(limit=self.get_limit, after=self.last.id)
-            messages.sort(key=lambda x: x.id)
-
-        elif self.around:
-            messages = await self.channel.fetch_messages(limit=self.get_limit, around=self.around)
-            # todo: decide how getting *more* messages from `around` would work
-            self._limit = 1  # stops history from getting more messages
-
-        else:
-            if self.before and not self.last:
-                self.last = namedtuple("temp", "id")
-                self.last.id = self.before
-
-            messages = await self.channel.fetch_messages(limit=self.get_limit, before=self.last.id)
-            messages.sort(key=lambda x: x.id, reverse=True)
-        return messages
-
-
-class ArchivedForumPosts(AsyncIterator):
-    def __init__(self, channel: "BaseChannel", limit: int = 50, before: Snowflake_Type = None) -> None:
-        self.channel: "BaseChannel" = channel
-        self.before: Snowflake_Type = before
-        self._more: bool = True
-        super().__init__(limit)
-
-        if self.before:
-            self.last = self.before
-
-    async def fetch(self) -> list["GuildForumPost"]:
-        if self._more:
-            expected = self.get_limit
-
-            rcv = await self.channel._client.http.list_public_archived_threads(
-                self.channel.id,
-                limit=expected,
-                before=to_snowflake(self.last) if self.last else None,
-            )
-            threads = [self.channel._client.cache.place_channel_data(data) for data in rcv["threads"]]
-
-            if not rcv:
-                raise QueueEmpty
-
-            self._more = rcv.get("has_more", False)
-            return threads
-        raise QueueEmpty
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class PermissionOverwrite(SnowflakeObject, DictSerializationMixin):
-    """
-    Channel Permissions Overwrite object.
-
-    !!! note
-        `id` here is not an attribute of the overwrite, it is the ID of the overwritten instance
-
-    """
-
-    type: "OverwriteType" = attrs.field(repr=True, converter=OverwriteType)
-    """Permission overwrite type (role or member)"""
-    allow: Optional["Permissions"] = attrs.field(
-        repr=True, converter=optional_c(Permissions), kw_only=True, default=None
-    )
-    """Permissions to allow"""
-    deny: Optional["Permissions"] = attrs.field(
-        repr=True, converter=optional_c(Permissions), kw_only=True, default=None
-    )
-    """Permissions to deny"""
-
-    @classmethod
-    def for_target(cls, target_type: Union["models.Role", "models.Member", "models.User"]) -> "PermissionOverwrite":
-        """
-        Create a PermissionOverwrite for a role or member.
-
-        Args:
-            target_type: The type of the target (role or member)
-
-        Returns:
-            PermissionOverwrite
-
-        """
-        if isinstance(target_type, models.Role):
-            return cls(type=OverwriteType.ROLE, id=target_type.id)
-        if isinstance(target_type, (models.Member, models.User)):
-            return cls(type=OverwriteType.MEMBER, id=target_type.id)
-        raise TypeError("target_type must be a Role, Member or User")
-
-    def add_allows(self, *perms: "Permissions") -> None:
-        """
-        Add permissions to allow.
-
-        Args:
-            *perms: Permissions to add
-
-        """
-        if not self.allow:
-            self.allow = Permissions.NONE
-        for perm in perms:
-            self.allow |= perm
-
-    def add_denies(self, *perms: "Permissions") -> None:
-        """
-        Add permissions to deny.
-
-        Args:
-            *perms: Permissions to add
-
-        """
-        if not self.deny:
-            self.deny = Permissions.NONE
-        for perm in perms:
-            self.deny |= perm
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class MessageableMixin(SendMixin):
-    last_message_id: Optional[Snowflake_Type] = attrs.field(
-        repr=False, default=None
-    )  # TODO May need to think of dynamically updating this.
-    """The id of the last message sent in this channel (may not point to an existing or valid message)"""
-    default_auto_archive_duration: int = attrs.field(repr=False, default=AutoArchiveDuration.ONE_DAY)
-    """Default duration that the clients (not the API) will use for newly created threads, in minutes, to automatically archive the thread after recent activity"""
-    last_pin_timestamp: Optional["models.Timestamp"] = attrs.field(
-        repr=False, default=None, converter=optional_c(timestamp_converter)
-    )
-    """When the last pinned message was pinned. This may be None when a message is not pinned."""
-
-    async def _send_http_request(
-        self, message_payload: Union[dict, "FormData"], files: list["UPLOADABLE_TYPE"] | None = None
-    ) -> dict:
-        return await self._client.http.create_message(message_payload, self.id, files=files)
-
-    async def fetch_message(self, message_id: Snowflake_Type, *, force: bool = False) -> Optional["models.Message"]:
-        """
-        Fetch a message from the channel.
-
-        Args:
-            message_id: ID of message to retrieve.
-            force: Whether to force a fetch from the API.
-
-        Returns:
-            The message object fetched. If the message is not found, returns None.
-
-        """
-        try:
-            return await self._client.cache.fetch_message(self.id, message_id, force=force)
-        except NotFound:
-            return None
-
-    def get_message(self, message_id: Snowflake_Type) -> "models.Message":
-        """
-        Get a message from the channel.
-
-        Args:
-            message_id: ID of message to retrieve.
-
-        Returns:
-            The message object fetched.
-
-        """
-        message_id = to_snowflake(message_id)
-        message: "models.Message" = self._client.cache.get_message(self.id, message_id)
-        return message
-
-    def history(
-        self,
-        limit: int = 100,
-        before: Snowflake_Type = None,
-        after: Snowflake_Type = None,
-        around: Snowflake_Type = None,
-    ) -> ChannelHistory:
-        """
-        Get an async iterator for the history of this channel.
-
-        Args:
-            limit: The maximum number of messages to return (set to 0 for no limit)
-            before: get messages before this message ID
-            after: get messages after this message ID
-            around: get messages "around" this message ID
-
-        ??? Hint "Example Usage:"
-            ```python
-            async for message in channel.history(limit=0):
-                if message.author.id == 174918559539920897:
-                    print("Found author's message")
-                    # ...
-                    break
-            ```
-            or
-            ```python
-            history = channel.history(limit=250)
-            # Flatten the async iterator into a list
-            messages = await history.flatten()
-            ```
-
-        Returns:
-            ChannelHistory (AsyncIterator)
-
-        """
-        return ChannelHistory(self, limit, before, after, around)
-
-    async def fetch_messages(
-        self,
-        limit: int = 50,
-        around: Snowflake_Type = MISSING,
-        before: Snowflake_Type = MISSING,
-        after: Snowflake_Type = MISSING,
-    ) -> List["models.Message"]:
-        """
-        Fetch multiple messages from the channel.
-
-        Args:
-            limit: Max number of messages to return, default `50`, max `100`
-            around: Message to get messages around
-            before: Message to get messages before
-            after: Message to get messages after
-
-        Returns:
-            A list of messages fetched.
-
-        """
-        if limit > 100:
-            raise ValueError("You cannot fetch more than 100 messages at once.")
-
-        if around:
-            around = to_snowflake(around)
-        elif before:
-            before = to_snowflake(before)
-        elif after:
-            after = to_snowflake(after)
-
-        messages_data = await self._client.http.get_channel_messages(
-            self.id, limit, around=around, before=before, after=after
-        )
-        for m in messages_data:
-            m["guild_id"] = self._guild_id
-
-        return [self._client.cache.place_message_data(m) for m in messages_data]
-
-    async def fetch_pinned_messages(self) -> List["models.Message"]:
-        """
-        Fetch pinned messages from the channel.
-
-        Returns:
-            A list of messages fetched.
-
-        """
-        messages_data = await self._client.http.get_pinned_messages(self.id)
-        return [self._client.cache.place_message_data(message_data) for message_data in messages_data]
-
-    async def delete_messages(
-        self,
-        messages: List[Union[Snowflake_Type, "models.Message"]],
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> None:
-        """
-        Bulk delete messages from channel.
-
-        Args:
-            messages: List of messages or message IDs to delete.
-            reason: The reason for this action. Used for audit logs.
-
-        """
-        message_ids = [to_snowflake(message) for message in messages]
-        # TODO Add check for min/max and duplicates.
-
-        if len(message_ids) == 1:
-            # bulk delete messages will throw a http error if only 1 message is passed
-            await self.delete_message(message_ids[0], reason)
-        else:
-            await self._client.http.bulk_delete_messages(self.id, message_ids, reason)
-
-    async def delete_message(self, message: Union[Snowflake_Type, "models.Message"], reason: str = None) -> None:
-        """
-        Delete a single message from a channel.
-
-        Args:
-            message: The message to delete
-            reason: The reason for this action
-
-        """
-        message = to_snowflake(message)
-        await self._client.http.delete_message(self.id, message, reason=reason)
-
-    async def purge(
-        self,
-        deletion_limit: int = 50,
-        search_limit: int = 100,
-        predicate: Callable[["models.Message"], bool] = MISSING,
-        avoid_loading_msg: bool = True,
-        return_messages: bool = False,
-        before: Optional[Snowflake_Type] = MISSING,
-        after: Optional[Snowflake_Type] = MISSING,
-        around: Optional[Snowflake_Type] = MISSING,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> int | List["models.Message"]:
-        """
-        Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit`.
-
-        ??? Hint "Example Usage:"
-            ```python
-            # this will delete the last 20 messages sent by a user with the given ID
-            deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897)
-            await channel.send(f"{deleted} messages deleted")
-            ```
-
-        Args:
-            deletion_limit: The target amount of messages to delete
-            search_limit: How many messages to search through
-            predicate: A function that returns True or False, and takes a message as an argument
-            avoid_loading_msg: Should the bot attempt to avoid deleting its own loading messages (recommended enabled)
-            return_messages: Should the bot return the messages that were deleted
-            before: Search messages before this ID
-            after: Search messages after this ID
-            around: Search messages around this ID
-            reason: The reason for this deletion
-
-        Returns:
-            The total amount of messages deleted
-
-        """
-        if not predicate:
-
-            def predicate(m) -> bool:
-                return True
-
-        to_delete = []
-
-        # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake
-        fourteen_days_ago = int((time.time() - 1209600) * 1000.0 - DISCORD_EPOCH) << 22
-        async for message in self.history(limit=search_limit, before=before, after=after, around=around):
-            if deletion_limit != 0 and len(to_delete) == deletion_limit:
-                break
-
-            if not predicate(message):
-                # fails predicate
-                continue
-
-            if (
-                avoid_loading_msg
-                and message._author_id == self._client.user.id
-                and MessageFlags.LOADING in message.flags
-            ):
-                continue
-
-            if message.id < fourteen_days_ago:
-                # message is too old to be purged
-                continue
-
-            to_delete.append(message)
-
-        out = to_delete.copy()
-        while len(to_delete):
-            iteration = [to_delete.pop().id for i in range(min(100, len(to_delete)))]
-            await self.delete_messages(iteration, reason=reason)
-        return out if return_messages else len(out)
-
-    async def trigger_typing(self) -> None:
-        """Trigger a typing animation in this channel."""
-        await self._client.http.trigger_typing_indicator(self.id)
-
-    @property
-    def typing(self) -> Typing:
-        """A context manager to send a typing state to a given channel as long as long as the wrapped operation takes."""
-        return Typing(self)
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class InvitableMixin:
-    async def create_invite(
-        self,
-        max_age: int = 86400,
-        max_uses: int = 0,
-        temporary: bool = False,
-        unique: bool = False,
-        target_type: Optional[InviteTargetType] = None,
-        target_user: Optional[Union[Snowflake_Type, "models.User"]] = None,
-        target_application: Optional[Union[Snowflake_Type, "models.Application"]] = None,
-        reason: Optional[str] = None,
-    ) -> "models.Invite":
-        """
-        Creates a new channel invite.
-
-        Args:
-            max_age: Max age of invite in seconds, default 86400 (24 hours).
-            max_uses: Max uses of invite, default 0.
-            temporary: Grants temporary membership, default False.
-            unique: Invite is unique, default false.
-            target_type: Target type for streams and embedded applications.
-            target_user: Target User ID for Stream target type.
-            target_application: Target Application ID for Embedded App target type.
-            reason: The reason for creating this invite.
-
-        Returns:
-            Newly created Invite object.
-
-        """
-        if target_type:
-            if target_type == InviteTargetType.STREAM and not target_user:
-                raise ValueError("Stream target must include target user id.")
-            if target_type == InviteTargetType.EMBEDDED_APPLICATION and not target_application:
-                raise ValueError("Embedded Application target must include target application id.")
-
-        if target_user and target_application:
-            raise ValueError("Invite target must be either User or Embedded Application, not both.")
-        if target_user:
-            target_user = to_snowflake(target_user)
-            target_type = InviteTargetType.STREAM
-        if target_application:
-            target_application = to_snowflake(target_application)
-            target_type = InviteTargetType.EMBEDDED_APPLICATION
-
-        invite_data = await self._client.http.create_channel_invite(
-            self.id,
-            max_age,
-            max_uses,
-            temporary,
-            unique,
-            target_user_id=target_user,
-            target_application_id=target_application,
-            reason=reason,
-        )
-        return models.Invite.from_dict(invite_data, self._client)
-
-    async def fetch_invites(self) -> List["models.Invite"]:
-        """
-        Fetches all invites (with invite metadata) for the channel.
-
-        Returns:
-            List of Invite objects.
-
-        """
-        invites_data = await self._client.http.get_channel_invites(self.id)
-        return models.Invite.from_list(invites_data, self._client)
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class ThreadableMixin:
-    async def create_thread(
-        self,
-        name: str,
-        message: Absent[Snowflake_Type] = MISSING,
-        thread_type: Absent[ChannelType] = MISSING,
-        invitable: Absent[bool] = MISSING,
-        rate_limit_per_user: Absent[int] = MISSING,
-        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
-        reason: Absent[str] = None,
-    ) -> "TYPE_THREAD_CHANNEL":
-        """
-        Creates a new thread in this channel. If a message is provided, it will be used as the initial message.
-
-        Args:
-            name: 1-100 character thread name
-            message: The message to connect this thread to. Required for news channel.
-            thread_type: Is the thread private or public. Not applicable to news channel, it will always be GUILD_NEWS_THREAD.
-            invitable: whether non-moderators can add other non-moderators to a thread. Only applicable when creating a private thread.
-            rate_limit_per_user: The time users must wait between sending messages (0-21600).
-            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
-            reason: The reason for creating this thread.
-
-        Returns:
-            The created thread, if successful
-
-        """
-        if self.type == ChannelType.GUILD_NEWS and not message:
-            raise ValueError("News channel must include message to create thread from.")
-
-        if message and (thread_type or invitable):
-            raise ValueError("Message cannot be used with thread_type or invitable.")
-
-        if thread_type != ChannelType.GUILD_PRIVATE_THREAD and invitable:
-            raise ValueError("Invitable only applies to private threads.")
-
-        thread_data = await self._client.http.create_thread(
-            channel_id=self.id,
-            name=name,
-            thread_type=thread_type,
-            invitable=invitable,
-            rate_limit_per_user=rate_limit_per_user,
-            auto_archive_duration=auto_archive_duration,
-            message_id=to_optional_snowflake(message),
-            reason=reason,
-        )
-        return self._client.cache.place_channel_data(thread_data)
-
-    async def fetch_public_archived_threads(
-        self, limit: int = None, before: Optional["models.Timestamp"] = None
-    ) -> "models.ThreadList":
-        """
-        Get a `ThreadList` of archived **public** threads available in this channel.
-
-        Args:
-            limit: optional maximum number of threads to return
-            before: Returns threads before this timestamp
-
-        Returns:
-            A `ThreadList` of archived threads.
-
-        """
-        threads_data = await self._client.http.list_public_archived_threads(
-            channel_id=self.id, limit=limit, before=before
-        )
-        threads_data["id"] = self.id
-        return models.ThreadList.from_dict(threads_data, self._client)
-
-    async def fetch_private_archived_threads(
-        self, limit: int = None, before: Optional["models.Timestamp"] = None
-    ) -> "models.ThreadList":
-        """
-        Get a `ThreadList` of archived **private** threads available in this channel.
-
-        Args:
-            limit: optional maximum number of threads to return
-            before: Returns threads before this timestamp
-
-        Returns:
-            A `ThreadList` of archived threads.
-
-        """
-        threads_data = await self._client.http.list_private_archived_threads(
-            channel_id=self.id, limit=limit, before=before
-        )
-        threads_data["id"] = self.id
-        return models.ThreadList.from_dict(threads_data, self._client)
-
-    async def fetch_archived_threads(
-        self, limit: int = None, before: Optional["models.Timestamp"] = None
-    ) -> "models.ThreadList":
-        """
-        Get a `ThreadList` of archived threads available in this channel.
-
-        Args:
-            limit: optional maximum number of threads to return
-            before: Returns threads before this timestamp
-
-        Returns:
-            A `ThreadList` of archived threads.
-
-        """
-        threads_data = await self._client.http.list_private_archived_threads(
-            channel_id=self.id, limit=limit, before=before
-        )
-        threads_data.update(
-            await self._client.http.list_public_archived_threads(channel_id=self.id, limit=limit, before=before)
-        )
-        threads_data["id"] = self.id
-        return models.ThreadList.from_dict(threads_data, self._client)
-
-    async def fetch_joined_private_archived_threads(
-        self, limit: int = None, before: Optional["models.Timestamp"] = None
-    ) -> "models.ThreadList":
-        """
-        Get a `ThreadList` of threads the bot is a participant of in this channel.
-
-        Args:
-            limit: optional maximum number of threads to return
-            before: Returns threads before this timestamp
-
-        Returns:
-            A `ThreadList` of threads the bot is a participant of.
-
-        """
-        threads_data = await self._client.http.list_joined_private_archived_threads(
-            channel_id=self.id, limit=limit, before=before
-        )
-        threads_data["id"] = self.id
-        return models.ThreadList.from_dict(threads_data, self._client)
-
-    async def fetch_active_threads(self) -> "models.ThreadList":
-        """
-        Gets all active threads in the channel, including public and private threads.
-
-        Returns:
-            A `ThreadList` of active threads.
-
-        """
-        threads_data = await self._client.http.list_active_threads(guild_id=self._guild_id)
-
-        # delete the items where the channel_id does not match
-        removed_thread_ids = []
-        cleaned_threads_data_threads = []
-        for thread in threads_data["threads"]:
-            if thread["parent_id"] == str(self.id):
-                cleaned_threads_data_threads.append(thread)
-            else:
-                removed_thread_ids.append(thread["id"])
-        threads_data["threads"] = cleaned_threads_data_threads
-
-        cleaned_member_data_threads = [
-            thread_member for thread_member in threads_data["members"] if thread_member["id"] not in removed_thread_ids
-        ]
-        threads_data["members"] = cleaned_member_data_threads
-
-        return models.ThreadList.from_dict(threads_data, self._client)
-
-    async def fetch_all_threads(self) -> "models.ThreadList":
-        """
-        Gets all threads in the channel. Active and archived, including public and private threads.
-
-        Returns:
-            A `ThreadList` of all threads.
-
-        """
-        threads = await self.fetch_active_threads()
-
-        # update that data with the archived threads
-        archived_threads = await self.fetch_archived_threads()
-        threads.threads.extend(archived_threads.threads)
-        threads.members.extend(archived_threads.members)
-
-        return threads
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class WebhookMixin:
-    async def create_webhook(self, name: str, avatar: Absent[UPLOADABLE_TYPE] = MISSING) -> "models.Webhook":
-        """
-        Create a webhook in this channel.
-
-        Args:
-            name: The name of the webhook
-            avatar: An optional default avatar image to use
-
-        Returns:
-            The created webhook object
-
-        Raises:
-            ValueError: If you try to name the webhook "Clyde"
-
-        """
-        return await models.Webhook.create(self._client, self, name, avatar)  # type: ignore
-
-    async def delete_webhook(self, webhook: "models.Webhook") -> None:
-        """
-        Delete a given webhook in this channel.
-
-        Args:
-            webhook: The webhook to delete
-
-        """
-        return await webhook.delete()
-
-    async def fetch_webhooks(self) -> List["models.Webhook"]:
-        """
-        Fetches all the webhooks for this channel.
-
-        Returns:
-            List of webhook objects
-
-        """
-        resp = await self._client.http.get_channel_webhooks(self.id)
-        return [models.Webhook.from_dict(d, self._client) for d in resp]
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class BaseChannel(DiscordObject):
-    name: Optional[str] = attrs.field(repr=True, default=None)
-    """The name of the channel (1-100 characters)"""
-    type: Union[ChannelType, int] = attrs.field(repr=True, converter=ChannelType)
-    """The channel topic (0-1024 characters)"""
-
-    @classmethod
-    def from_dict_factory(cls, data: dict, client: "Client") -> "TYPE_ALL_CHANNEL":
-        """
-        Creates a channel object of the appropriate type.
-
-        Args:
-            data: The channel data.
-            client: The bot.
-
-        Returns:
-            The new channel object.
-
-        """
-        channel_type = data.get("type")
-        channel_class = TYPE_CHANNEL_MAPPING.get(channel_type, None)
-        if not channel_class:
-            client.logger.error(f"Unsupported channel type for {data} ({channel_type}).")
-            channel_class = BaseChannel
-
-        if channel_class == GuildPublicThread:
-            # attempt to determine if this thread is a forum post (thanks discord)
-            parent_channel = client.cache.get_channel(data["parent_id"])
-            if parent_channel and parent_channel.type == ChannelType.GUILD_FORUM:
-                channel_class = GuildForumPost
-
-        return channel_class.from_dict(data, client)
-
-    @property
-    def mention(self) -> str:
-        """Returns a string that would mention the channel."""
-        return f"<#{self.id}>"
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        icon: Absent[UPLOADABLE_TYPE] = MISSING,
-        type: Absent[ChannelType] = MISSING,
-        position: Absent[int] = MISSING,
-        topic: Absent[str] = MISSING,
-        nsfw: Absent[bool] = MISSING,
-        rate_limit_per_user: Absent[int] = MISSING,
-        bitrate: Absent[int] = MISSING,
-        user_limit: Absent[int] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        parent_id: Absent[Snowflake_Type] = MISSING,
-        rtc_region: Absent[Union["models.VoiceRegion", str]] = MISSING,
-        video_quality_mode: Absent[VideoQualityMode] = MISSING,
-        default_auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
-        archived: Absent[bool] = MISSING,
-        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
-        locked: Absent[bool] = MISSING,
-        invitable: Absent[bool] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> "TYPE_ALL_CHANNEL":
-        """
-        Edits the channel.
-
-        Args:
-            name: 1-100 character channel name
-            icon: DM Group icon
-            type: The type of channel; only conversion between text and news is supported and only in guilds with the "NEWS" feature
-            position: The position of the channel in the left-hand listing
-            topic: 0-1024 character channel topic
-            nsfw: Whether the channel is nsfw
-            rate_limit_per_user: Amount of seconds a user has to wait before sending another message (0-21600)
-            bitrate: The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)
-            user_limit: The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit
-            permission_overwrites: Channel or category-specific permissions
-            parent_id: The id of the new parent category for a channel
-            rtc_region: Channel voice region id, automatic when set to None.
-            video_quality_mode: The camera video quality mode of the voice channel
-            default_auto_archive_duration: The default duration that the clients use (not the API) for newly created threads in the channel, in minutes, to automatically archive the thread after recent activity
-            archived: Whether the thread is archived
-            auto_archive_duration: Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
-            locked: Whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
-            invitable: Whether non-moderators can add other non-moderators to a thread; only available on private threads
-            reason: The reason for editing the channel
-
-        Returns:
-            The edited channel. May be a new object if the channel type changes.
-
-        """
-        payload = {
-            "name": name,
-            "icon": to_image_data(icon),
-            "type": type,
-            "position": position,
-            "topic": topic,
-            "nsfw": nsfw,
-            "rate_limit_per_user": rate_limit_per_user,
-            "bitrate": bitrate,
-            "user_limit": user_limit,
-            "permission_overwrites": process_permission_overwrites(permission_overwrites),
-            "parent_id": to_optional_snowflake(parent_id),
-            "rtc_region": rtc_region.id if isinstance(rtc_region, models.VoiceRegion) else rtc_region,
-            "video_quality_mode": video_quality_mode,
-            "default_auto_archive_duration": default_auto_archive_duration,
-            "archived": archived,
-            "auto_archive_duration": auto_archive_duration,
-            "locked": locked,
-            "invitable": invitable,
-            **kwargs,
-        }
-        channel_data = await self._client.http.modify_channel(self.id, payload, reason)
-        if not channel_data:
-            raise TooManyChanges(
-                "You have changed this channel too frequently, you need to wait a while before trying again."
-            ) from None
-
-        return self._client.cache.place_channel_data(channel_data)
-
-    async def delete(self, reason: Absent[Optional[str]] = MISSING) -> None:
-        """
-        Delete this channel.
-
-        Args:
-            reason: The reason for deleting this channel
-
-        """
-        await self._client.http.delete_channel(self.id, reason)
-
-
-################################################################
-# DMs
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class DMChannel(BaseChannel, MessageableMixin):
-    recipients: List["models.User"] = attrs.field(repr=False, factory=list)
-    """The users of the DM that will receive messages sent"""
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        data = super()._process_dict(data, client)
-        if recipients := data.get("recipients", None):
-            data["recipients"] = [
-                client.cache.place_user_data(recipient) if isinstance(recipient, dict) else recipient
-                for recipient in recipients
-            ]
-        return data
-
-    @property
-    def members(self) -> List["models.User"]:
-        """Returns a list of users that are in this DM channel."""
-        return self.recipients
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class DM(DMChannel):
-    @property
-    def recipient(self) -> "models.User":
-        """Returns the user that is in this DM channel."""
-        return self.recipients[0]
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class DMGroup(DMChannel):
-    owner_id: Snowflake_Type = attrs.field(repr=True)
-    """id of the creator of the group DM"""
-    application_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)
-    """Application id of the group DM creator if it is bot-created"""
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        icon: Absent[UPLOADABLE_TYPE] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> "DMGroup":
-        """
-        Edit this DM Channel.
-
-        Args:
-            name: 1-100 character channel name
-            icon: An icon to use
-            reason: The reason for this change
-        """
-        return await super().edit(name=name, icon=icon, reason=reason, **kwargs)
-
-    async def fetch_owner(self, *, force: bool = False) -> "models.User":
-        """
-        Fetch the owner of this DM group
-
-        Args:
-            force: Whether to force a fetch from the API
-        """
-        return await self._client.cache.fetch_user(self.owner_id, force=force)
-
-    def get_owner(self) -> "models.User":
-        """Get the owner of this DM group"""
-        return self._client.cache.get_user(self.owner_id)
-
-    async def add_recipient(
-        self,
-        user: Union["models.User", Snowflake_Type],
-        access_token: str,
-        nickname: Absent[Optional[str]] = MISSING,
-    ) -> None:
-        """
-        Add a recipient to this DM Group.
-
-        Args:
-            user: The user to add
-            access_token: access token of a user that has granted your app the gdm.join scope
-            nickname: nickname to apply to the user being added
-
-        """
-        user = await self._client.cache.fetch_user(user)
-        await self._client.http.group_dm_add_recipient(self.id, user.id, access_token, nickname)
-        self.recipients.append(user)
-
-    async def remove_recipient(self, user: Union["models.User", Snowflake_Type]) -> None:
-        """
-        Remove a recipient from this DM Group.
-
-        Args:
-            user: The user to remove
-
-        """
-        user = await self._client.cache.fetch_user(user)
-        await self._client.http.group_dm_remove_recipient(self.id, user.id)
-        self.recipients.remove(user)
-
-
-################################################################
-# Guild
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class GuildChannel(BaseChannel):
-    position: Optional[int] = attrs.field(repr=False, default=0)
-    """Sorting position of the channel"""
-    nsfw: bool = attrs.field(repr=False, default=False)
-    """Whether the channel is nsfw"""
-    parent_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
-    """id of the parent category for a channel (each parent category can contain up to 50 channels)"""
-    permission_overwrites: list[PermissionOverwrite] = attrs.field(repr=False, factory=list)
-    """A list of the overwritten permissions for the members and roles"""
-
-    _guild_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
-
-    @property
-    def guild(self) -> "models.Guild":
-        """The guild this channel belongs to."""
-        return self._client.cache.get_guild(self._guild_id)
-
-    @property
-    def category(self) -> Optional["GuildCategory"]:
-        """The parent category of this channel."""
-        return self._client.cache.get_channel(self.parent_id)
-
-    @property
-    def gui_position(self) -> int:
-        """The position of this channel in the Discord interface."""
-        return self.guild.get_channel_gui_position(self.id)
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        data = super()._process_dict(data, client)
-        if overwrites := data.get("permission_overwrites"):
-            data["permission_overwrites"] = PermissionOverwrite.from_list(overwrites)
-        return data
-
-    def permissions_for(self, instance: Snowflake_Type) -> Permissions:
-        """
-        Calculates permissions for an instance
-
-        Args:
-            instance: Member or Role instance (or its ID)
-
-        Returns:
-            Permissions data
-
-        Raises:
-            ValueError: If could not find any member or role by given ID
-            RuntimeError: If given instance is from another guild
-
-        """
-        if (is_member := isinstance(instance, models.Member)) or isinstance(instance, models.Role):
-            if instance._guild_id != self._guild_id:
-                raise RuntimeError("Unable to calculate permissions for the instance from different guild")
-
-            if is_member:
-                return instance.channel_permissions(self)
-
-            permissions = instance.permissions
-
-            for overwrite in self.permission_overwrites:
-                if overwrite.id == instance.id:
-                    permissions &= ~overwrite.deny
-                    permissions |= overwrite.allow
-                    break
-
-            return permissions
-
-        instance = to_snowflake(instance)
-        guild = self.guild
-        if instance := guild.get_member(instance) or guild.get_role(instance):
-            return self.permissions_for(instance)
-        raise ValueError("Unable to find any member or role by given instance ID")
-
-    async def add_permission(
-        self,
-        target: Union["PermissionOverwrite", "models.Role", "models.User", "models.Member", "Snowflake_Type"],
-        type: Optional["OverwriteType"] = None,
-        allow: Optional[List["Permissions"] | int] = None,
-        deny: Optional[List["Permissions"] | int] = None,
-        reason: Optional[str] = None,
-    ) -> None:
-        """
-        Add a permission to this channel.
-
-        Args:
-            target: The updated PermissionOverwrite object, or the Role or User object/id to update
-            type: The type of permission overwrite. Only applicable if target is an id
-            allow: List of permissions to allow. Only applicable if target is not an PermissionOverwrite object
-            deny: List of permissions to deny. Only applicable if target is not an PermissionOverwrite object
-            reason: The reason for this change
-
-        Raises:
-            ValueError: Invalid target for permission
-
-        """
-        allow = allow or []
-        deny = deny or []
-        if not isinstance(target, PermissionOverwrite):
-            if isinstance(target, (models.User, models.Member)):
-                target = target.id
-                type = OverwriteType.MEMBER
-            elif isinstance(target, models.Role):
-                target = target.id
-                type = OverwriteType.ROLE
-            elif type and isinstance(target, Snowflake_Type):
-                target = to_snowflake(target)
-            else:
-                raise ValueError("Invalid target and/or type for permission")
-            overwrite = PermissionOverwrite(id=target, type=type, allow=Permissions.NONE, deny=Permissions.NONE)
-            if isinstance(allow, int):
-                overwrite.allow |= allow
-            else:
-                for perm in allow:
-                    overwrite.allow |= perm
-            if isinstance(deny, int):
-                overwrite.deny |= deny
-            else:
-                for perm in deny:
-                    overwrite.deny |= perm
-        else:
-            overwrite = target
-
-        if exists := get(self.permission_overwrites, id=overwrite.id, type=overwrite.type):
-            exists.deny = (exists.deny | overwrite.deny) & ~overwrite.allow
-            exists.allow = (exists.allow | overwrite.allow) & ~overwrite.deny
-            await self.edit_permission(exists, reason)
-        else:
-            permission_overwrites = self.permission_overwrites
-            permission_overwrites.append(overwrite)
-            await self.edit(permission_overwrites=permission_overwrites)
-
-    async def edit_permission(self, overwrite: PermissionOverwrite, reason: Optional[str] = None) -> None:
-        """
-        Edit the permissions for this channel.
-
-        Args:
-            overwrite: The permission overwrite to apply
-            reason: The reason for this change
-        """
-        await self._client.http.edit_channel_permission(
-            self.id,
-            overwrite_id=overwrite.id,
-            allow=overwrite.allow,
-            deny=overwrite.deny,
-            perm_type=overwrite.type,
-            reason=reason,
-        )
-
-    async def delete_permission(
-        self,
-        target: Union["PermissionOverwrite", "models.Role", "models.User"],
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> None:
-        """
-        Delete a permission overwrite for this channel.
-
-        Args:
-            target: The permission overwrite to delete
-            reason: The reason for this change
-
-        """
-        target = to_snowflake(target)
-        await self._client.http.delete_channel_permission(self.id, target, reason)
-
-    async def set_permission(
-        self,
-        target: Union["models.Role", "models.Member", "models.User"],
-        *,
-        add_reactions: bool | None = None,
-        administrator: bool | None = None,
-        attach_files: bool | None = None,
-        ban_members: bool | None = None,
-        change_nickname: bool | None = None,
-        connect: bool | None = None,
-        create_instant_invite: bool | None = None,
-        deafen_members: bool | None = None,
-        embed_links: bool | None = None,
-        kick_members: bool | None = None,
-        manage_channels: bool | None = None,
-        manage_emojis_and_stickers: bool | None = None,
-        manage_events: bool | None = None,
-        manage_guild: bool | None = None,
-        manage_messages: bool | None = None,
-        manage_nicknames: bool | None = None,
-        manage_roles: bool | None = None,
-        manage_threads: bool | None = None,
-        manage_webhooks: bool | None = None,
-        mention_everyone: bool | None = None,
-        moderate_members: bool | None = None,
-        move_members: bool | None = None,
-        mute_members: bool | None = None,
-        priority_speaker: bool | None = None,
-        read_message_history: bool | None = None,
-        request_to_speak: bool | None = None,
-        send_messages: bool | None = None,
-        send_messages_in_threads: bool | None = None,
-        send_tts_messages: bool | None = None,
-        speak: bool | None = None,
-        start_embedded_activities: bool | None = None,
-        stream: bool | None = None,
-        use_application_commands: bool | None = None,
-        use_external_emojis: bool | None = None,
-        use_external_stickers: bool | None = None,
-        use_private_threads: bool | None = None,
-        use_public_threads: bool | None = None,
-        use_vad: bool | None = None,
-        view_audit_log: bool | None = None,
-        view_channel: bool | None = None,
-        view_guild_insights: bool | None = None,
-        reason: str = None,
-    ) -> None:
-        """
-        Set the Permission Overwrites for a given target.
-
-        Args:
-            target: The target to set permission overwrites for
-            add_reactions: Allows for the addition of reactions to messages
-            administrator: Allows all permissions and bypasses channel permission overwrites
-            attach_files: Allows for uploading images and files
-            ban_members: Allows banning members
-            change_nickname: Allows for modification of own nickname
-            connect: Allows for joining of a voice channel
-            create_instant_invite: Allows creation of instant invites
-            deafen_members: Allows for deafening of members in a voice channel
-            embed_links: Links sent by users with this permission will be auto-embedded
-            kick_members: Allows kicking members
-            manage_channels: Allows management and editing of channels
-            manage_emojis_and_stickers: Allows management and editing of emojis and stickers
-            manage_events: Allows for creating, editing, and deleting scheduled events
-            manage_guild: Allows management and editing of the guild
-            manage_messages: Allows for deletion of other users messages
-            manage_nicknames: Allows for modification of other users nicknames
-            manage_roles: Allows management and editing of roles
-            manage_threads: Allows for deleting and archiving threads, and viewing all private threads
-            manage_webhooks: Allows management and editing of webhooks
-            mention_everyone: Allows for using the `@everyone` tag to notify all users in a channel, and the `@here` tag to notify all online users in a channel
-            moderate_members: Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels
-            move_members: Allows for moving of members between voice channels
-            mute_members: Allows for muting members in a voice channel
-            priority_speaker: Allows for using priority speaker in a voice channel
-            read_message_history: Allows for reading of message history
-            request_to_speak: Allows for requesting to speak in stage channels. (This permission is under active development and may be changed or removed.)
-            send_messages:  Allows for sending messages in a channel (does not allow sending messages in threads)
-            send_messages_in_threads: Allows for sending messages in threads
-            send_tts_messages:  Allows for sending of `/tts` messages
-            speak: Allows for speaking in a voice channel
-            start_embedded_activities: Allows for using Activities (applications with the `EMBEDDED` flag) in a voice channel
-            stream: Allows the user to go live
-            use_application_commands: Allows members to use application commands, including slash commands and context menu commands
-            use_external_emojis: Allows the usage of custom emojis from other servers
-            use_external_stickers: Allows the usage of custom stickers from other servers
-            use_private_threads: Allows for creating private threads
-            use_public_threads:  Allows for creating public and announcement threads
-            use_vad: Allows for using voice-activity-detection in a voice channel
-            view_audit_log: Allows for viewing of audit logs
-            view_channel: Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels
-            view_guild_insights: Allows for viewing guild insights
-            reason: The reason for creating this overwrite
-        """
-        overwrite = PermissionOverwrite.for_target(target)
-
-        allow: Permissions = Permissions.NONE
-        deny: Permissions = Permissions.NONE
-
-        for name, val in locals().items():
-            if isinstance(val, bool):
-                if val:
-                    allow |= getattr(Permissions, name.upper())
-                else:
-                    deny |= getattr(Permissions, name.upper())
-
-        overwrite.add_allows(allow)
-        overwrite.add_denies(deny)
-
-        await self.edit_permission(overwrite, reason)
-
-    @property
-    def members(self) -> List["models.Member"]:
-        """Returns a list of members that can see this channel."""
-        return [m for m in self.guild.members if Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore
-
-    @property
-    def bots(self) -> List["models.Member"]:
-        """Returns a list of bots that can see this channel."""
-        return [m for m in self.guild.members if m.bot and Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore
-
-    @property
-    def humans(self) -> List["models.Member"]:
-        """Returns a list of humans that can see this channel."""
-        return [m for m in self.guild.members if not m.bot and Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore
-
-    async def clone(self, name: Optional[str] = None, reason: Absent[Optional[str]] = MISSING) -> "TYPE_GUILD_CHANNEL":
-        """
-        Clone this channel and create a new one.
-
-        Args:
-            name: The name of the new channel. Defaults to the current name
-            reason: The reason for creating this channel
-
-        Returns:
-            The newly created channel.
-
-        """
-        return await self.guild.create_channel(
-            channel_type=self.type,
-            name=name or self.name,
-            topic=getattr(self, "topic", MISSING),
-            position=self.position,
-            permission_overwrites=self.permission_overwrites,
-            category=self.category,
-            nsfw=self.nsfw,
-            bitrate=getattr(self, "bitrate", 64000),
-            user_limit=getattr(self, "user_limit", 0),
-            rate_limit_per_user=getattr(self, "rate_limit_per_user", 0),
-            reason=reason,
-        )
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildCategory(GuildChannel):
-    @property
-    def channels(self) -> List["TYPE_GUILD_CHANNEL"]:
-        """Get all channels within the category"""
-        return [channel for channel in self.guild.channels if channel.parent_id == self.id]
-
-    @property
-    def voice_channels(self) -> List["GuildVoice"]:
-        """Get all voice channels within the category"""
-        return [
-            channel
-            for channel in self.channels
-            if isinstance(channel, GuildVoice) and not isinstance(channel, GuildStageVoice)
-        ]
-
-    @property
-    def stage_channels(self) -> List["GuildStageVoice"]:
-        """Get all stage channels within the category"""
-        return [channel for channel in self.channels if isinstance(channel, GuildStageVoice)]
-
-    @property
-    def text_channels(self) -> List["GuildText"]:
-        """Get all text channels within the category"""
-        return [channel for channel in self.channels if isinstance(channel, GuildText)]
-
-    @property
-    def news_channels(self) -> List["GuildNews"]:
-        """Get all news channels within the category"""
-        return [channel for channel in self.channels if isinstance(channel, GuildNews)]
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        position: Absent[int] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> "GuildCategory":
-        """
-        Edit this channel.
-
-        Args:
-            name: 1-100 character channel name
-            position: the position of the channel in the left-hand listing
-            permission_overwrites: channel or category-specific permissions
-            reason: the reason for this change
-
-        Returns:
-            The updated channel object.
-
-        """
-        return await super().edit(
-            name=name,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            reason=reason,
-            **kwargs,
-        )
-
-    async def create_channel(
-        self,
-        channel_type: Union[ChannelType, int],
-        name: str,
-        topic: Absent[Optional[str]] = MISSING,
-        position: Absent[Optional[int]] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        nsfw: bool = False,
-        bitrate: int = 64000,
-        user_limit: int = 0,
-        rate_limit_per_user: int = 0,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> "TYPE_GUILD_CHANNEL":
-        """
-        Create a guild channel within this category, allows for explicit channel type setting.
-
-        Args:
-            channel_type: The type of channel to create
-            name: The name of the channel
-            topic: The topic of the channel
-            position: The position of the channel in the channel list
-            permission_overwrites: Permission overwrites to apply to the channel
-            nsfw: Should this channel be marked nsfw
-            bitrate: The bitrate of this channel, only for voice
-            user_limit: The max users that can be in this channel, only for voice
-            rate_limit_per_user: The time users must wait between sending messages
-            reason: The reason for creating this channel
-
-        Returns:
-            The newly created channel.
-
-        """
-        return await self.guild.create_channel(
-            channel_type=channel_type,
-            name=name,
-            topic=topic,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            category=self.id,
-            nsfw=nsfw,
-            bitrate=bitrate,
-            user_limit=user_limit,
-            rate_limit_per_user=rate_limit_per_user,
-            reason=reason,
-        )
-
-    async def create_text_channel(
-        self,
-        name: str,
-        topic: Absent[Optional[str]] = MISSING,
-        position: Absent[Optional[int]] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        nsfw: bool = False,
-        rate_limit_per_user: int = 0,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> "GuildText":
-        """
-        Create a text channel in this guild within this category.
-
-        Args:
-            name: The name of the channel
-            topic: The topic of the channel
-            position: The position of the channel in the channel list
-            permission_overwrites: Permission overwrites to apply to the channel
-            nsfw: Should this channel be marked nsfw
-            rate_limit_per_user: The time users must wait between sending messages
-            reason: The reason for creating this channel
-
-        Returns:
-           The newly created text channel.
-
-        """
-        return await self.create_channel(
-            channel_type=ChannelType.GUILD_TEXT,
-            name=name,
-            topic=topic,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            nsfw=nsfw,
-            rate_limit_per_user=rate_limit_per_user,
-            reason=reason,
-        )
-
-    async def create_news_channel(
-        self,
-        name: str,
-        topic: Absent[Optional[str]] = MISSING,
-        position: Absent[Optional[int]] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        nsfw: bool = False,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> "GuildNews":
-        """
-        Create a news channel in this guild within this category.
-
-        Args:
-            name: The name of the channel
-            topic: The topic of the channel
-            position: The position of the channel in the channel list
-            permission_overwrites: Permission overwrites to apply to the channel
-            nsfw: Should this channel be marked nsfw
-            reason: The reason for creating this channel
-
-        Returns:
-           The newly created news channel.
-
-        """
-        return await self.create_channel(
-            channel_type=ChannelType.GUILD_NEWS,
-            name=name,
-            topic=topic,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            nsfw=nsfw,
-            reason=reason,
-        )
-
-    async def create_voice_channel(
-        self,
-        name: str,
-        topic: Absent[Optional[str]] = MISSING,
-        position: Absent[Optional[int]] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        nsfw: bool = False,
-        bitrate: int = 64000,
-        user_limit: int = 0,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> "GuildVoice":
-        """
-        Create a guild voice channel within this category.
-
-        Args:
-            name: The name of the channel
-            topic: The topic of the channel
-            position: The position of the channel in the channel list
-            permission_overwrites: Permission overwrites to apply to the channel
-            nsfw: Should this channel be marked nsfw
-            bitrate: The bitrate of this channel, only for voice
-            user_limit: The max users that can be in this channel, only for voice
-            reason: The reason for creating this channel
-
-        Returns:
-           The newly created voice channel.
-
-        """
-        return await self.create_channel(
-            channel_type=ChannelType.GUILD_VOICE,
-            name=name,
-            topic=topic,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            nsfw=nsfw,
-            bitrate=bitrate,
-            user_limit=user_limit,
-            reason=reason,
-        )
-
-    async def create_stage_channel(
-        self,
-        name: str,
-        topic: Absent[Optional[str]] = MISSING,
-        position: Absent[Optional[int]] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        bitrate: int = 64000,
-        user_limit: int = 0,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> "GuildStageVoice":
-        """
-        Create a guild stage channel within this category.
-
-        Args:
-            name: The name of the channel
-            topic: The topic of the channel
-            position: The position of the channel in the channel list
-            permission_overwrites: Permission overwrites to apply to the channel
-            bitrate: The bitrate of this channel, only for voice
-            user_limit: The max users that can be in this channel, only for voice
-            reason: The reason for creating this channel
-
-        Returns:
-            The newly created stage channel.
-
-        """
-        return await self.create_channel(
-            channel_type=ChannelType.GUILD_STAGE_VOICE,
-            name=name,
-            topic=topic,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            bitrate=bitrate,
-            user_limit=user_limit,
-            reason=reason,
-        )
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildNews(GuildChannel, MessageableMixin, InvitableMixin, ThreadableMixin, WebhookMixin):
-    topic: Optional[str] = attrs.field(repr=False, default=None)
-    """The channel topic (0-1024 characters)"""
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        position: Absent[int] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        parent_id: Absent[Snowflake_Type] = MISSING,
-        nsfw: Absent[bool] = MISSING,
-        topic: Absent[str] = MISSING,
-        channel_type: Absent["ChannelType"] = MISSING,
-        default_auto_archive_duration: Absent["AutoArchiveDuration"] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> Union["GuildNews", "GuildText"]:
-        """
-        Edit the guild text channel.
-
-        Args:
-            name: 1-100 character channel name
-            position: the position of the channel in the left-hand listing
-            permission_overwrites: a list of PermissionOverwrite
-            parent_id:  the parent category `Snowflake_Type` for the channel
-            nsfw: whether the channel is nsfw
-            topic: 0-1024 character channel topic
-            channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the "NEWS" feature
-            default_auto_archive_duration: optional AutoArchiveDuration
-            reason: An optional reason for the audit log
-
-        Returns:
-            The edited channel.
-
-        """
-        return await super().edit(
-            name=name,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            parent_id=parent_id,
-            nsfw=nsfw,
-            topic=topic,
-            type=channel_type,
-            default_auto_archive_duration=default_auto_archive_duration,
-            reason=reason,
-            **kwargs,
-        )
-
-    async def follow(self, webhook_channel_id: Snowflake_Type) -> None:
-        """
-        Follow this channel.
-
-        Args:
-            webhook_channel_id: The ID of the channel to post messages from this channel to
-
-        """
-        await self._client.http.follow_news_channel(self.id, webhook_channel_id)
-
-    async def create_thread_from_message(
-        self,
-        name: str,
-        message: Snowflake_Type,
-        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
-        reason: Absent[str] = None,
-    ) -> "GuildNewsThread":
-        """
-        Creates a new news thread in this channel.
-
-        Args:
-            name: 1-100 character thread name.
-            message: The message to connect this thread to.
-            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
-            reason: The reason for creating this thread.
-
-        Returns:
-            The created public thread, if successful
-
-        """
-        return await self.create_thread(
-            name=name,
-            message=message,
-            auto_archive_duration=auto_archive_duration,
-            reason=reason,
-        )
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildText(GuildChannel, MessageableMixin, InvitableMixin, ThreadableMixin, WebhookMixin):
-    topic: Optional[str] = attrs.field(repr=False, default=None)
-    """The channel topic (0-1024 characters)"""
-    rate_limit_per_user: int = attrs.field(repr=False, default=0)
-    """Amount of seconds a user has to wait before sending another message (0-21600)"""
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        position: Absent[int] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        parent_id: Absent[Snowflake_Type] = MISSING,
-        nsfw: Absent[bool] = MISSING,
-        topic: Absent[str] = MISSING,
-        channel_type: Absent["ChannelType"] = MISSING,
-        default_auto_archive_duration: Absent["AutoArchiveDuration"] = MISSING,
-        rate_limit_per_user: Absent[int] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> Union["GuildText", "GuildNews"]:
-        """
-        Edit the guild text channel.
-
-        Args:
-            name: 1-100 character channel name
-            position: the position of the channel in the left-hand listing
-            permission_overwrites: a list of PermissionOverwrite
-            parent_id:  the parent category `Snowflake_Type` for the channel
-            nsfw: whether the channel is nsfw
-            topic: 0-1024 character channel topic
-            channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the "NEWS" feature
-            default_auto_archive_duration: optional AutoArchiveDuration
-            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
-            reason: An optional reason for the audit log
-
-        Returns:
-            The edited channel.
-
-        """
-        return await super().edit(
-            name=name,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            parent_id=parent_id,
-            nsfw=nsfw,
-            topic=topic,
-            type=channel_type,
-            default_auto_archive_duration=default_auto_archive_duration,
-            rate_limit_per_user=rate_limit_per_user,
-            reason=reason,
-            **kwargs,
-        )
-
-    async def create_public_thread(
-        self,
-        name: str,
-        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
-        rate_limit_per_user: Absent[int] = MISSING,
-        reason: Absent[str] = None,
-    ) -> "GuildPublicThread":
-        """
-        Creates a new public thread in this channel.
-
-        Args:
-            name: 1-100 character thread name.
-            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
-            rate_limit_per_user: The time users must wait between sending messages (0-21600).
-            reason: The reason for creating this thread.
-
-        Returns:
-            The created public thread, if successful
-
-        """
-        return await self.create_thread(
-            name=name,
-            thread_type=ChannelType.GUILD_PUBLIC_THREAD,
-            auto_archive_duration=auto_archive_duration,
-            rate_limit_per_user=rate_limit_per_user,
-            reason=reason,
-        )
-
-    async def create_private_thread(
-        self,
-        name: str,
-        invitable: Absent[bool] = MISSING,
-        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
-        rate_limit_per_user: Absent[int] = MISSING,
-        reason: Absent[str] = None,
-    ) -> "GuildPrivateThread":
-        """
-        Creates a new private thread in this channel.
-
-        Args:
-            name: 1-100 character thread name.
-            invitable: Whether non-moderators can add other non-moderators to a thread.
-            rate_limit_per_user: The time users must wait between sending messages (0-21600).
-            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
-            reason: The reason for creating this thread.
-
-        Returns:
-            The created thread, if successful
-
-        """
-        return await self.create_thread(
-            name=name,
-            thread_type=ChannelType.GUILD_PRIVATE_THREAD,
-            invitable=invitable,
-            rate_limit_per_user=rate_limit_per_user,
-            auto_archive_duration=auto_archive_duration,
-            reason=reason,
-        )
-
-    async def create_thread_from_message(
-        self,
-        name: str,
-        message: Snowflake_Type,
-        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
-        reason: Absent[str] = None,
-    ) -> "GuildPublicThread":
-        """
-        Creates a new public thread in this channel.
-
-        Args:
-            name: 1-100 character thread name.
-            message: The message to connect this thread to.
-            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
-            reason: The reason for creating this thread.
-
-        Returns:
-            The created public thread, if successful
-
-        """
-        return await self.create_thread(
-            name=name,
-            message=message,
-            auto_archive_duration=auto_archive_duration,
-            reason=reason,
-        )
-
-
-################################################################
-# Guild Threads
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class ThreadChannel(BaseChannel, MessageableMixin, WebhookMixin):
-    parent_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
-    """id of the text channel this thread was created"""
-    owner_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
-    """id of the creator of the thread"""
-    topic: Optional[str] = attrs.field(repr=False, default=None)
-    """The thread topic (0-1024 characters)"""
-    message_count: int = attrs.field(repr=False, default=0)
-    """An approximate count of messages in a thread, stops counting at 50"""
-    member_count: int = attrs.field(repr=False, default=0)
-    """An approximate count of users in a thread, stops counting at 50"""
-    archived: bool = attrs.field(repr=False, default=False)
-    """Whether the thread is archived"""
-    auto_archive_duration: int = attrs.field(
-        repr=False,
-        default=attrs.Factory(lambda self: self.default_auto_archive_duration, takes_self=True),
-    )
-    """Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080"""
-    locked: bool = attrs.field(repr=False, default=False)
-    """Whether the thread is locked"""
-    archive_timestamp: Optional["models.Timestamp"] = attrs.field(
-        repr=False, default=None, converter=optional_c(timestamp_converter)
-    )
-    """Timestamp when the thread's archive status was last changed, used for calculating recent activity"""
-    create_timestamp: Optional["models.Timestamp"] = attrs.field(
-        repr=False, default=None, converter=optional_c(timestamp_converter)
-    )
-    """Timestamp when the thread was created"""
-    flags: ChannelFlags = attrs.field(repr=False, default=ChannelFlags.NONE, converter=ChannelFlags)
-    """Flags for the thread"""
-
-    _guild_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        data = super()._process_dict(data, client)
-        thread_metadata: dict = data.get("thread_metadata", {})
-        data.update(thread_metadata)
-        return data
-
-    @property
-    def is_private(self) -> bool:
-        """Is this a private thread?"""
-        return self.type == ChannelType.GUILD_PRIVATE_THREAD
-
-    @property
-    def guild(self) -> "models.Guild":
-        """The guild this channel belongs to."""
-        return self._client.cache.get_guild(self._guild_id)
-
-    @property
-    def parent_channel(self) -> Union[GuildText, "GuildForum"]:
-        """The channel this thread is a child of."""
-        return self._client.cache.get_channel(self.parent_id)
-
-    @property
-    def parent_message(self) -> Optional["Message"]:
-        """The message this thread is a child of."""
-        return self._client.cache.get_message(self.parent_id, self.id)
-
-    @property
-    def mention(self) -> str:
-        """Returns a string that would mention this thread."""
-        return f"<#{self.id}>"
-
-    @property
-    def permission_overwrites(self) -> List["PermissionOverwrite"]:
-        """The permission overwrites for this channel."""
-        return []
-
-    @property
-    def clyde_created(self) -> bool:
-        """Whether this thread was created by Clyde."""
-        return ChannelFlags.CLYDE_THREAD in self.flags
-
-    def permissions_for(self, instance: Snowflake_Type) -> Permissions:
-        """
-        Calculates permissions for an instance
-
-        Args:
-            instance: Member or Role instance (or its ID)
-
-        Returns:
-            Permissions data
-
-        Raises:
-            ValueError: If could not find any member or role by given ID
-            RuntimeError: If given instance is from another guild
-
-        """
-        if self.parent_channel:
-            return self.parent_channel.permissions_for(instance)
-        return Permissions.NONE
-
-    async def fetch_members(self) -> List["models.ThreadMember"]:
-        """Get the members that have access to this thread."""
-        members_data = await self._client.http.list_thread_members(self.id)
-        return models.ThreadMember.from_list(members_data, self._client)
-
-    async def add_member(self, member: Union["models.Member", Snowflake_Type]) -> None:
-        """
-        Add a member to this thread.
-
-        Args:
-            member: The member to add
-
-        """
-        await self._client.http.add_thread_member(self.id, to_snowflake(member))
-
-    async def remove_member(self, member: Union["models.Member", Snowflake_Type]) -> None:
-        """
-        Remove a member from this thread.
-
-        Args:
-            member: The member to remove
-
-        """
-        await self._client.http.remove_thread_member(self.id, to_snowflake(member))
-
-    async def join(self) -> None:
-        """Join this thread."""
-        await self._client.http.join_thread(self.id)
-
-    async def leave(self) -> None:
-        """Leave this thread."""
-        await self._client.http.leave_thread(self.id)
-
-    async def archive(self, locked: bool = False, reason: Absent[str] = MISSING) -> "TYPE_THREAD_CHANNEL":
-        """
-        Helper method to archive this thread.
-
-        Args:
-            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
-            reason: The reason for this archive
-
-        Returns:
-            The archived thread channel object.
-
-        """
-        return await super().edit(locked=locked, archived=True, reason=reason)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildNewsThread(ThreadChannel):
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        archived: Absent[bool] = MISSING,
-        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
-        locked: Absent[bool] = MISSING,
-        rate_limit_per_user: Absent[int] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> "GuildNewsThread":
-        """
-        Edit this thread.
-
-        Args:
-            name: 1-100 character channel name
-            archived: whether the thread is archived
-            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
-            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
-            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
-            reason: The reason for this change
-
-        Returns:
-            The edited thread channel object.
-
-        """
-        return await super().edit(
-            name=name,
-            archived=archived,
-            auto_archive_duration=auto_archive_duration,
-            locked=locked,
-            rate_limit_per_user=rate_limit_per_user,
-            reason=reason,
-            **kwargs,
-        )
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildPublicThread(ThreadChannel):
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        archived: Absent[bool] = MISSING,
-        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
-        locked: Absent[bool] = MISSING,
-        rate_limit_per_user: Absent[int] = MISSING,
-        flags: Absent[Union[int, ChannelFlags]] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> "GuildPublicThread":
-        """
-        Edit this thread.
-
-        Args:
-            name: 1-100 character channel name
-            archived: whether the thread is archived
-            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
-            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
-            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
-            flags: channel flags for forum threads
-            reason: The reason for this change
-
-        Returns:
-            The edited thread channel object.
-        """
-        return await super().edit(
-            name=name,
-            archived=archived,
-            auto_archive_duration=auto_archive_duration,
-            locked=locked,
-            rate_limit_per_user=rate_limit_per_user,
-            reason=reason,
-            flags=flags,
-            **kwargs,
-        )
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildForumPost(GuildPublicThread):
-    """
-    A forum post
-
-    !!! note
-        This model is an abstraction of the api - In reality all posts are GuildPublicThread
-    """
-
-    _applied_tags: list[Snowflake_Type] = attrs.field(repr=False, factory=list)
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        data = super()._process_dict(data, client)
-        data["_applied_tags"] = data.pop("applied_tags") if "applied_tags" in data else []
-        return data
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        archived: Absent[bool] = MISSING,
-        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
-        applied_tags: Absent[List[Union[Snowflake_Type, ThreadTag]]] = MISSING,
-        locked: Absent[bool] = MISSING,
-        rate_limit_per_user: Absent[int] = MISSING,
-        flags: Absent[Union[int, ChannelFlags]] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> "GuildForumPost":
-        """
-        Edit this thread.
-
-        Args:
-            name: 1-100 character channel name
-            archived: whether the thread is archived
-            applied_tags: list of tags to apply
-            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
-            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
-            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
-            flags: channel flags to apply
-            reason: The reason for this change
-
-        Returns:
-            The edited thread channel object.
-        """
-        if applied_tags != MISSING:
-            applied_tags = [str(tag.id) if isinstance(tag, ThreadTag) else str(tag) for tag in applied_tags]
-
-        return await super().edit(
-            name=name,
-            archived=archived,
-            auto_archive_duration=auto_archive_duration,
-            applied_tags=applied_tags,
-            locked=locked,
-            rate_limit_per_user=rate_limit_per_user,
-            reason=reason,
-            flags=flags,
-            **kwargs,
-        )
-
-    @property
-    def applied_tags(self) -> list[ThreadTag]:
-        """The tags applied to this thread."""
-        if not isinstance(self.parent_channel, GuildForum):
-            raise AttributeError("This is only available on forum threads.")
-        return [tag for tag in self.parent_channel.available_tags if str(tag.id) in self._applied_tags]
-
-    @property
-    def initial_post(self) -> Optional["Message"]:
-        """The initial message posted by the OP."""
-        if not isinstance(self.parent_channel, GuildForum):
-            raise AttributeError("This is only available on forum threads.")
-        return self.get_message(self.id)
-
-    @property
-    def pinned(self) -> bool:
-        """Whether this thread is pinned."""
-        return ChannelFlags.PINNED in self.flags
-
-    async def pin(self, reason: Absent[str] = MISSING) -> None:
-        """
-        Pin this thread.
-
-        Args:
-            reason: The reason for this pin
-
-        """
-        flags = self.flags | ChannelFlags.PINNED
-        await self.edit(flags=flags, reason=reason)
-
-    async def unpin(self, reason: Absent[str] = MISSING) -> None:
-        """
-        Unpin this thread.
-
-        Args:
-            reason: The reason for this unpin
-
-        """
-        flags = self.flags & ~ChannelFlags.PINNED
-        await self.edit(flags=flags, reason=reason)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildPrivateThread(ThreadChannel):
-    invitable: bool = attrs.field(repr=False, default=False)
-    """Whether non-moderators can add other non-moderators to a thread"""
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        archived: Absent[bool] = MISSING,
-        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
-        locked: Absent[bool] = MISSING,
-        rate_limit_per_user: Absent[int] = MISSING,
-        invitable: Absent[bool] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> "GuildPrivateThread":
-        """
-        Edit this thread.
-
-        Args:
-            name: 1-100 character channel name
-            archived: whether the thread is archived
-            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
-            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
-            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
-            invitable: whether non-moderators can add other non-moderators to a thread; only available on private threads
-            reason: The reason for this change
-
-        Returns:
-            The edited thread channel object.
-
-        """
-        return await super().edit(
-            name=name,
-            archived=archived,
-            auto_archive_duration=auto_archive_duration,
-            locked=locked,
-            rate_limit_per_user=rate_limit_per_user,
-            invitable=invitable,
-            reason=reason,
-            **kwargs,
-        )
-
-
-################################################################
-# Guild Voices
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
-class VoiceChannel(GuildChannel):  # May not be needed, can be directly just GuildVoice.
-    bitrate: int = attrs.field(
-        repr=False,
-    )
-    """The bitrate (in bits) of the voice channel"""
-    user_limit: int = attrs.field(
-        repr=False,
-    )
-    """The user limit of the voice channel"""
-    rtc_region: str = attrs.field(repr=False, default="auto")
-    """Voice region id for the voice channel, automatic when set to None"""
-    video_quality_mode: Union[VideoQualityMode, int] = attrs.field(repr=False, default=VideoQualityMode.AUTO)
-    """The camera video quality mode of the voice channel, 1 when not present"""
-    _voice_member_ids: list[Snowflake_Type] = attrs.field(repr=False, factory=list)
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        position: Absent[int] = MISSING,
-        permission_overwrites: Absent[
-            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-        ] = MISSING,
-        parent_id: Absent[Snowflake_Type] = MISSING,
-        bitrate: Absent[int] = MISSING,
-        user_limit: Absent[int] = MISSING,
-        rtc_region: Absent[str] = MISSING,
-        video_quality_mode: Absent[VideoQualityMode] = MISSING,
-        reason: Absent[str] = MISSING,
-        **kwargs,
-    ) -> Union["GuildVoice", "GuildStageVoice"]:
-        """
-        Edit guild voice channel.
-
-        Args:
-            name: 1-100 character channel name
-            position: the position of the channel in the left-hand listing
-            permission_overwrites: a list of `PermissionOverwrite` to apply to the channel
-            parent_id: the parent category `Snowflake_Type` for the channel
-            bitrate: the bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)
-            user_limit: the user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit
-            rtc_region: channel voice region id, automatic when not set
-            video_quality_mode: the camera video quality mode of the voice channel
-            reason: optional reason for audit logs
-
-        Returns:
-            The edited voice channel object.
-
-        """
-        return await super().edit(
-            name=name,
-            position=position,
-            permission_overwrites=permission_overwrites,
-            parent_id=parent_id,
-            bitrate=bitrate,
-            user_limit=user_limit,
-            rtc_region=rtc_region,
-            video_quality_mode=video_quality_mode,
-            reason=reason,
-            **kwargs,
-        )
-
-    @property
-    def members(self) -> List["models.Member"]:
-        """Returns a list of members that have access to this voice channel"""
-        return [m for m in self.guild.members if Permissions.CONNECT in m.channel_permissions(self)]  # type: ignore
-
-    @property
-    def voice_members(self) -> List["models.Member"]:
-        """
-        Returns a list of members that are currently in the channel.
-
-        !!! note
-            This will not be accurate if the bot was offline while users joined the channel
-        """
-        return [self._client.cache.get_member(self._guild_id, member_id) for member_id in self._voice_member_ids]
-
-    @property
-    def voice_state(self) -> Optional["ActiveVoiceState"]:
-        """Returns the voice state of the bot in this channel if it is connected"""
-        return self._client.get_bot_voice_state(self._guild_id)
-
-    async def connect(self, muted: bool = False, deafened: bool = False) -> "ActiveVoiceState":
-        """
-        Connect the bot to this voice channel, or move the bot to this voice channel if it is already connected in another voice channel.
-
-        Args:
-            muted: Whether the bot should be muted when connected.
-            deafened: Whether the bot should be deafened when connected.
-
-        Returns:
-            The new active voice state on successfully connection.
-
-        """
-        if not self.voice_state:
-            return await self._client.connect_to_vc(self._guild_id, self.id, muted, deafened)
-        await self.voice_state.move(self.id)
-        return self.voice_state
-
-    async def disconnect(self) -> None:
-        """
-        Disconnect from the currently connected voice state.
-
-        Raises:
-            VoiceNotConnected: if the bot is not connected to a voice channel
-        """
-        if self.voice_state:
-            return await self.voice_state.disconnect()
-        raise VoiceNotConnected
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildVoice(VoiceChannel, InvitableMixin, MessageableMixin):
-    pass
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildStageVoice(GuildVoice):
-    stage_instance: "models.StageInstance" = attrs.field(repr=False, default=MISSING)
-    """The stage instance that this voice channel belongs to"""
-
-    # todo: Listeners and speakers properties (needs voice state caching)
-
-    async def fetch_stage_instance(self) -> "models.StageInstance":
-        """
-        Fetches the stage instance associated with this channel.
-
-        Returns:
-            The stage instance associated with this channel. If no stage is live, will return None.
-
-        """
-        self.stage_instance = models.StageInstance.from_dict(
-            await self._client.http.get_stage_instance(self.id), self._client
-        )
-        return self.stage_instance
-
-    async def create_stage_instance(
-        self,
-        topic: str,
-        privacy_level: StagePrivacyLevel = StagePrivacyLevel.GUILD_ONLY,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> "models.StageInstance":
-        """
-        Create a stage instance in this channel.
-
-        Args:
-            topic: The topic of the stage (1-120 characters)
-            privacy_level: The privacy level of the stage
-            reason: The reason for creating this instance
-
-        Returns:
-            The created stage instance object.
-
-        """
-        self.stage_instance = models.StageInstance.from_dict(
-            await self._client.http.create_stage_instance(self.id, topic, privacy_level, reason),
-            self._client,
-        )
-        return self.stage_instance
-
-    async def close_stage(self, reason: Absent[Optional[str]] = MISSING) -> None:
-        """
-        Closes the live stage instance.
-
-        Args:
-            reason: The reason for closing the stage
-
-        """
-        if not self.stage_instance and not await self.get_stage_instance():
-            # we dont know of an active stage instance, so lets check for one
-            raise ValueError("No stage instance found")
-
-        await self.stage_instance.delete(reason=reason)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class GuildForum(GuildChannel):
-    available_tags: List[ThreadTag] = attrs.field(repr=False, factory=list)
-    """A list of tags available to assign to threads"""
-    last_message_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)
-    # TODO: Implement "template" once the API supports them
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        data = super()._process_dict(data, client)
-        data["available_tags"] = [
-            ThreadTag.from_dict(tag_data | {"parent_channel_id": data["id"]}, client)
-            for tag_data in data.get("available_tags", [])
-        ]
-        return data
-
-    async def create_post(
-        self,
-        name: str,
-        content: str | None,
-        applied_tags: Optional[List[Union["Snowflake_Type", "ThreadTag", str]]] = MISSING,
-        *,
-        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
-        rate_limit_per_user: Absent[int] = MISSING,
-        embeds: Optional[Union[List[Union["Embed", dict]], Union["Embed", dict]]] = None,
-        embed: Optional[Union["Embed", dict]] = None,
-        components: Optional[
-            Union[
-                List[List[Union["BaseComponent", dict]]],
-                List[Union["BaseComponent", dict]],
-                "BaseComponent",
-                dict,
-            ]
-        ] = None,
-        stickers: Optional[Union[List[Union["Sticker", "Snowflake_Type"]], "Sticker", "Snowflake_Type"]] = None,
-        allowed_mentions: Optional[Union["AllowedMentions", dict]] = None,
-        files: Optional[Union["UPLOADABLE_TYPE", List["UPLOADABLE_TYPE"]]] = None,
-        file: Optional["UPLOADABLE_TYPE"] = None,
-        tts: bool = False,
-        reason: Absent[str] = MISSING,
-    ) -> "GuildForumPost":
-        """
-        Create a post within this channel.
-
-        Args:
-            name: The name of the post
-            content: The text content of this post
-            applied_tags: A list of tag ids or tag objects to apply to this post
-            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
-            rate_limit_per_user: The time users must wait between sending messages
-            embeds: Embedded rich content (up to 6000 characters).
-            embed: Embedded rich content (up to 6000 characters).
-            components: The components to include with the message.
-            stickers: IDs of up to 3 stickers in the server to send in the message.
-            allowed_mentions: Allowed mentions for the message.
-            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            tts: Should this message use Text To Speech.
-            reason: The reason for creating this post
-
-        Returns:
-            A GuildForumPost object representing the created post.
-        """
-        if applied_tags != MISSING:
-            processed = []
-            for tag in applied_tags:
-                if isinstance(tag, ThreadTag):
-                    tag = tag.id
-                elif isinstance(tag, (str, int)):
-                    tag = self.get_tag(tag, case_insensitive=True)
-                    if not tag:
-                        continue
-                    tag = tag.id
-                elif isinstance(tag, dict):
-                    tag = tag["id"]
-                processed.append(tag)
-
-            applied_tags = processed
-
-        message_payload = models.discord.message.process_message_payload(
-            content=content,
-            embeds=embeds or embed,
-            components=components,
-            stickers=stickers,
-            allowed_mentions=allowed_mentions,
-            tts=tts,
-        )
-
-        data = await self._client.http.create_forum_thread(
-            self.id,
-            name,
-            auto_archive_duration,
-            message_payload,
-            applied_tags,
-            rate_limit_per_user,
-            files=files or file,
-            reason=reason,
-        )
-        return self._client.cache.place_channel_data(data)
-
-    async def fetch_posts(self) -> List["GuildForumPost"]:
-        """
-        Requests all active posts within this channel.
-
-        Returns:
-            A list of GuildForumPost objects representing the posts.
-        """
-        # I can guarantee this endpoint will need to be converted to an async iterator eventually
-        data = await self._client.http.list_active_threads(self._guild_id)
-        threads = [self._client.cache.place_channel_data(post_data) for post_data in data["threads"]]
-
-        return [thread for thread in threads if thread.parent_id == self.id]
-
-    def get_posts(self, *, exclude_archived: bool = True) -> List["GuildForumPost"]:
-        """
-        List all, cached, active posts within this channel.
-
-        Args:
-            exclude_archived: Whether to exclude archived posts from the response
-
-        Returns:
-            A list of GuildForumPost objects representing the posts.
-        """
-        out = [thread for thread in self.guild.threads if thread.parent_id == self.id]
-        if exclude_archived:
-            return [thread for thread in out if not thread.archived]
-        return out
-
-    def archived_posts(self, limit: int = 0, before: Snowflake_Type | None = None) -> ArchivedForumPosts:
-        """An async iterator for all archived posts in this channel."""
-        return ArchivedForumPosts(self, limit, before)
-
-    async def fetch_post(self, id: "Snowflake_Type", *, force: bool = False) -> "GuildForumPost":
-        """
-        Fetch a post within this channel.
-
-        Args:
-            id: The id of the post to fetch
-            force: Whether to force a fetch from the API
-
-        Returns:
-            A GuildForumPost object representing the post.
-        """
-        return await self._client.fetch_channel(id, force=force)
-
-    def get_post(self, id: "Snowflake_Type") -> "GuildForumPost":
-        """
-        Get a post within this channel.
-
-        Args:
-            id: The id of the post to get
-
-        Returns:
-            A GuildForumPost object representing the post.
-        """
-        return self._client.cache.get_channel(id)
-
-    def get_tag(self, value: str | Snowflake_Type, *, case_insensitive: bool = False) -> Optional["ThreadTag"]:
-        """
-        Get a tag within this channel.
-
-        Args:
-            value: The name or ID of the tag to get
-            case_insensitive: Whether to ignore case when searching for the tag
-
-        Returns:
-            A ThreadTag object representing the tag.
-        """
-
-        def maybe_insensitive(string: str) -> str:
-            return string.lower() if case_insensitive else string
-
-        def predicate(tag: ThreadTag) -> Optional["ThreadTag"]:
-            if str(tag.id) == str(value):
-                return tag
-            if maybe_insensitive(tag.name) == maybe_insensitive(value):
-                return tag
-
-        return next((tag for tag in self.available_tags if predicate(tag)), None)
-
-    async def create_tag(self, name: str, emoji: Union["models.PartialEmoji", dict, str, None] = None) -> "ThreadTag":
-        """
-        Create a tag for this forum.
-
-        Args:
-            name: The name of the tag
-            emoji: The emoji to use for the tag
-
-        !!! note
-            If the emoji is a custom emoji, it must be from the same guild as the channel.
-
-        Returns:
-            The created tag object.
-
-        """
-        payload = {"channel_id": self.id, "name": name}
-
-        if emoji:
-            if isinstance(emoji, str):
-                emoji = PartialEmoji.from_str(emoji)
-            elif isinstance(emoji, dict):
-                emoji = PartialEmoji.from_dict(emoji)
-
-            if emoji.id:
-                payload["emoji_id"] = emoji.id
-            else:
-                payload["emoji_name"] = emoji.name
-
-        data = await self._client.http.create_tag(**payload)
-
-        channel_data = self._client.cache.place_channel_data(data)
-        return [tag for tag in channel_data.available_tags if tag.name == name][0]
-
-    async def edit_tag(
-        self,
-        tag_id: "Snowflake_Type",
-        *,
-        name: str | None = None,
-        emoji: Union["models.PartialEmoji", dict, str, None] = None,
-    ) -> "ThreadTag":
-        """
-        Edit a tag for this forum.
-
-        Args:
-            tag_id: The id of the tag to edit
-            name: The name for this tag
-            emoji: The emoji for this tag
-        """
-        if isinstance(emoji, str):
-            emoji = PartialEmoji.from_str(emoji)
-        elif isinstance(emoji, dict):
-            emoji = PartialEmoji.from_dict(emoji)
-
-        if emoji.id:
-            data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_id=emoji.id)
-        else:
-            data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_name=emoji.name)
-
-        channel_data = self._client.cache.place_channel_data(data)
-        return [tag for tag in channel_data.available_tags if tag.name == name][0]
-
-    async def delete_tag(self, tag_id: "Snowflake_Type") -> None:
-        """
-        Delete a tag for this forum.
-
-        Args:
-            tag_id: The ID of the tag to delete
-        """
-        data = await self._client.http.delete_tag(self.id, tag_id)
-        self._client.cache.place_channel_data(data)
-
-
-def process_permission_overwrites(
-    overwrites: Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
-) -> List[dict]:
-    """
-    Processes a permission overwrite lists into format for sending to discord.
-
-    Args:
-        overwrites: The permission overwrites to process
-
-    Returns:
-        The processed permission overwrites
-
-    """
-    if not overwrites:
-        return overwrites
-
-    if isinstance(overwrites, dict):
-        return [overwrites]
-
-    if isinstance(overwrites, list):
-        return list(map(to_dict, overwrites))
-
-    if isinstance(overwrites, PermissionOverwrite):
-        return [overwrites.to_dict()]
-
-    raise ValueError(f"Invalid overwrites: {overwrites}")
-
-
-TYPE_ALL_CHANNEL = Union[
-    GuildText,
-    GuildForum,
-    GuildNews,
-    GuildVoice,
-    GuildStageVoice,
-    GuildCategory,
-    GuildPublicThread,
-    GuildForumPost,
-    GuildPrivateThread,
-    GuildNewsThread,
-    DM,
-    DMGroup,
-]
-
-
-TYPE_DM_CHANNEL = Union[DM, DMGroup]
-
-
-TYPE_GUILD_CHANNEL = Union[
-    GuildCategory,
-    GuildNews,
-    GuildText,
-    GuildVoice,
-    GuildStageVoice,
-    GuildForum,
-    GuildPublicThread,
-    GuildForumPost,
-    GuildPrivateThread,
-]
-
-
-TYPE_THREAD_CHANNEL = Union[GuildNewsThread, GuildPublicThread, GuildForumPost, GuildPrivateThread]
-
-
-TYPE_VOICE_CHANNEL = Union[GuildVoice, GuildStageVoice]
-
-
-TYPE_MESSAGEABLE_CHANNEL = Union[
-    DM,
-    DMGroup,
-    GuildNews,
-    GuildText,
-    GuildPublicThread,
-    GuildForumPost,
-    GuildPrivateThread,
-    GuildNewsThread,
-    GuildVoice,
-]
-
-
-TYPE_CHANNEL_MAPPING = {
-    ChannelType.GUILD_TEXT: GuildText,
-    ChannelType.GUILD_NEWS: GuildNews,
-    ChannelType.GUILD_VOICE: GuildVoice,
-    ChannelType.GUILD_STAGE_VOICE: GuildStageVoice,
-    ChannelType.GUILD_CATEGORY: GuildCategory,
-    ChannelType.GUILD_PUBLIC_THREAD: GuildPublicThread,
-    ChannelType.GUILD_PRIVATE_THREAD: GuildPrivateThread,
-    ChannelType.GUILD_NEWS_THREAD: GuildNewsThread,
-    ChannelType.DM: DM,
-    ChannelType.GROUP_DM: DMGroup,
-    ChannelType.GUILD_FORUM: GuildForum,
-}
+import time
+from asyncio import QueueEmpty
+from collections import namedtuple
+from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union, Callable
+
+import attrs
+
+import interactions.models as models
+from interactions.client.const import Absent, DISCORD_EPOCH, MISSING
+from interactions.client.errors import NotFound, VoiceNotConnected, TooManyChanges
+from interactions.client.mixins.send import SendMixin
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.attr_converters import optional as optional_c
+from interactions.client.utils.attr_converters import timestamp_converter
+from interactions.client.utils.misc_utils import get
+from interactions.client.utils.serializer import to_dict, to_image_data
+from interactions.models.discord.base import DiscordObject
+from interactions.models.discord.emoji import PartialEmoji
+from interactions.models.discord.file import UPLOADABLE_TYPE
+from interactions.models.discord.snowflake import (
+    Snowflake_Type,
+    to_snowflake,
+    to_optional_snowflake,
+    SnowflakeObject,
+)
+from interactions.models.discord.thread import DefaultReaction, ThreadTag
+from interactions.models.misc.context_manager import Typing
+from interactions.models.misc.iterator import AsyncIterator
+from .enums import (
+    ChannelFlags,
+    ChannelType,
+    OverwriteType,
+    Permissions,
+    VideoQualityMode,
+    AutoArchiveDuration,
+    StagePrivacyLevel,
+    MessageFlags,
+    InviteTargetType,
+)
+
+if TYPE_CHECKING:
+    from aiohttp import FormData
+    from interactions import Client, Embed, BaseComponent, AllowedMentions, Sticker, Message
+    from interactions.models.internal.active_voice_state import ActiveVoiceState
+
+__all__ = (
+    "ChannelHistory",
+    "PermissionOverwrite",
+    "MessageableMixin",
+    "InvitableMixin",
+    "ThreadableMixin",
+    "WebhookMixin",
+    "BaseChannel",
+    "DMChannel",
+    "DM",
+    "DMGroup",
+    "GuildChannel",
+    "GuildCategory",
+    "GuildNews",
+    "GuildText",
+    "ThreadChannel",
+    "GuildForum",
+    "GuildNewsThread",
+    "GuildPublicThread",
+    "GuildForumPost",
+    "GuildPrivateThread",
+    "GuildVoice",
+    "GuildStageVoice",
+    "process_permission_overwrites",
+    "TYPE_ALL_CHANNEL",
+    "TYPE_DM_CHANNEL",
+    "TYPE_GUILD_CHANNEL",
+    "TYPE_THREAD_CHANNEL",
+    "TYPE_VOICE_CHANNEL",
+    "TYPE_CHANNEL_MAPPING",
+    "TYPE_MESSAGEABLE_CHANNEL",
+)
+
+
+class ChannelHistory(AsyncIterator):
+    """
+    An async iterator for searching through a channel's history.
+
+    Attributes:
+        channel: The channel to search through
+        limit: The maximum number of messages to return (set to 0 for no limit)
+        before: get messages before this message ID
+        after: get messages after this message ID
+        around: get messages "around" this message ID
+
+    """
+
+    def __init__(self, channel: "BaseChannel", limit=50, before=None, after=None, around=None) -> None:
+        self.channel: "BaseChannel" = channel
+        self.before: Snowflake_Type = before
+        self.after: Snowflake_Type = after
+        self.around: Snowflake_Type = around
+        super().__init__(limit)
+
+    async def fetch(self) -> List["models.Message"]:
+        """
+        Fetch additional objects.
+
+        Your implementation of this method *must* return a list of objects.
+        If no more objects are available, raise QueueEmpty
+
+        Returns:
+            List of objects
+
+        Raises:
+              QueueEmpty: when no more objects are available.
+
+        """
+        if self.after:
+            if not self.last:
+                self.last = namedtuple("temp", "id")
+                self.last.id = self.after
+            messages = await self.channel.fetch_messages(limit=self.get_limit, after=self.last.id)
+            messages.sort(key=lambda x: x.id)
+
+        elif self.around:
+            messages = await self.channel.fetch_messages(limit=self.get_limit, around=self.around)
+            # todo: decide how getting *more* messages from `around` would work
+            self._limit = 1  # stops history from getting more messages
+
+        else:
+            if self.before and not self.last:
+                self.last = namedtuple("temp", "id")
+                self.last.id = self.before
+
+            messages = await self.channel.fetch_messages(limit=self.get_limit, before=self.last.id)
+            messages.sort(key=lambda x: x.id, reverse=True)
+        return messages
+
+
+class ArchivedForumPosts(AsyncIterator):
+    def __init__(self, channel: "BaseChannel", limit: int = 50, before: Snowflake_Type = None) -> None:
+        self.channel: "BaseChannel" = channel
+        self.before: Snowflake_Type = before
+        self._more: bool = True
+        super().__init__(limit)
+
+        if self.before:
+            self.last = self.before
+
+    async def fetch(self) -> list["GuildForumPost"]:
+        if self._more:
+            expected = self.get_limit
+
+            rcv = await self.channel._client.http.list_public_archived_threads(
+                self.channel.id,
+                limit=expected,
+                before=to_snowflake(self.last) if self.last else None,
+            )
+            threads = [self.channel._client.cache.place_channel_data(data) for data in rcv["threads"]]
+
+            if not rcv:
+                raise QueueEmpty
+
+            self._more = rcv.get("has_more", False)
+            return threads
+        raise QueueEmpty
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class PermissionOverwrite(SnowflakeObject, DictSerializationMixin):
+    """
+    Channel Permissions Overwrite object.
+
+    !!! note
+        `id` here is not an attribute of the overwrite, it is the ID of the overwritten instance
+
+    """
+
+    type: "OverwriteType" = attrs.field(repr=True, converter=OverwriteType)
+    """Permission overwrite type (role or member)"""
+    allow: Optional["Permissions"] = attrs.field(
+        repr=True, converter=optional_c(Permissions), kw_only=True, default=None
+    )
+    """Permissions to allow"""
+    deny: Optional["Permissions"] = attrs.field(
+        repr=True, converter=optional_c(Permissions), kw_only=True, default=None
+    )
+    """Permissions to deny"""
+
+    @classmethod
+    def for_target(cls, target_type: Union["models.Role", "models.Member", "models.User"]) -> "PermissionOverwrite":
+        """
+        Create a PermissionOverwrite for a role or member.
+
+        Args:
+            target_type: The type of the target (role or member)
+
+        Returns:
+            PermissionOverwrite
+
+        """
+        if isinstance(target_type, models.Role):
+            return cls(type=OverwriteType.ROLE, id=target_type.id)
+        if isinstance(target_type, (models.Member, models.User)):
+            return cls(type=OverwriteType.MEMBER, id=target_type.id)
+        raise TypeError("target_type must be a Role, Member or User")
+
+    def add_allows(self, *perms: "Permissions") -> None:
+        """
+        Add permissions to allow.
+
+        Args:
+            *perms: Permissions to add
+
+        """
+        if not self.allow:
+            self.allow = Permissions.NONE
+        for perm in perms:
+            self.allow |= perm
+
+    def add_denies(self, *perms: "Permissions") -> None:
+        """
+        Add permissions to deny.
+
+        Args:
+            *perms: Permissions to add
+
+        """
+        if not self.deny:
+            self.deny = Permissions.NONE
+        for perm in perms:
+            self.deny |= perm
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class MessageableMixin(SendMixin):
+    last_message_id: Optional[Snowflake_Type] = attrs.field(
+        repr=False, default=None
+    )  # TODO May need to think of dynamically updating this.
+    """The id of the last message sent in this channel (may not point to an existing or valid message)"""
+    default_auto_archive_duration: int = attrs.field(repr=False, default=AutoArchiveDuration.ONE_DAY)
+    """Default duration that the clients (not the API) will use for newly created threads, in minutes, to automatically archive the thread after recent activity"""
+    last_pin_timestamp: Optional["models.Timestamp"] = attrs.field(
+        repr=False, default=None, converter=optional_c(timestamp_converter)
+    )
+    """When the last pinned message was pinned. This may be None when a message is not pinned."""
+
+    async def _send_http_request(
+        self, message_payload: Union[dict, "FormData"], files: list["UPLOADABLE_TYPE"] | None = None
+    ) -> dict:
+        return await self._client.http.create_message(message_payload, self.id, files=files)
+
+    async def fetch_message(self, message_id: Snowflake_Type, *, force: bool = False) -> Optional["models.Message"]:
+        """
+        Fetch a message from the channel.
+
+        Args:
+            message_id: ID of message to retrieve.
+            force: Whether to force a fetch from the API.
+
+        Returns:
+            The message object fetched. If the message is not found, returns None.
+
+        """
+        try:
+            return await self._client.cache.fetch_message(self.id, message_id, force=force)
+        except NotFound:
+            return None
+
+    def get_message(self, message_id: Snowflake_Type) -> "models.Message":
+        """
+        Get a message from the channel.
+
+        Args:
+            message_id: ID of message to retrieve.
+
+        Returns:
+            The message object fetched.
+
+        """
+        message_id = to_snowflake(message_id)
+        message: "models.Message" = self._client.cache.get_message(self.id, message_id)
+        return message
+
+    def history(
+        self,
+        limit: int = 100,
+        before: Snowflake_Type = None,
+        after: Snowflake_Type = None,
+        around: Snowflake_Type = None,
+    ) -> ChannelHistory:
+        """
+        Get an async iterator for the history of this channel.
+
+        Args:
+            limit: The maximum number of messages to return (set to 0 for no limit)
+            before: get messages before this message ID
+            after: get messages after this message ID
+            around: get messages "around" this message ID
+
+        ??? Hint "Example Usage:"
+            ```python
+            async for message in channel.history(limit=0):
+                if message.author.id == 174918559539920897:
+                    print("Found author's message")
+                    # ...
+                    break
+            ```
+            or
+            ```python
+            history = channel.history(limit=250)
+            # Flatten the async iterator into a list
+            messages = await history.flatten()
+            ```
+
+        Returns:
+            ChannelHistory (AsyncIterator)
+
+        """
+        return ChannelHistory(self, limit, before, after, around)
+
+    async def fetch_messages(
+        self,
+        limit: int = 50,
+        around: Snowflake_Type = MISSING,
+        before: Snowflake_Type = MISSING,
+        after: Snowflake_Type = MISSING,
+    ) -> List["models.Message"]:
+        """
+        Fetch multiple messages from the channel.
+
+        Args:
+            limit: Max number of messages to return, default `50`, max `100`
+            around: Message to get messages around
+            before: Message to get messages before
+            after: Message to get messages after
+
+        Returns:
+            A list of messages fetched.
+
+        """
+        if limit > 100:
+            raise ValueError("You cannot fetch more than 100 messages at once.")
+
+        if around:
+            around = to_snowflake(around)
+        elif before:
+            before = to_snowflake(before)
+        elif after:
+            after = to_snowflake(after)
+
+        messages_data = await self._client.http.get_channel_messages(
+            self.id, limit, around=around, before=before, after=after
+        )
+        if isinstance(self, GuildChannel):
+            for m in messages_data:
+                m["guild_id"] = self._guild_id
+
+        return [self._client.cache.place_message_data(m) for m in messages_data]
+
+    async def fetch_pinned_messages(self) -> List["models.Message"]:
+        """
+        Fetch pinned messages from the channel.
+
+        Returns:
+            A list of messages fetched.
+
+        """
+        messages_data = await self._client.http.get_pinned_messages(self.id)
+        return [self._client.cache.place_message_data(message_data) for message_data in messages_data]
+
+    async def delete_messages(
+        self,
+        messages: List[Union[Snowflake_Type, "models.Message"]],
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> None:
+        """
+        Bulk delete messages from channel.
+
+        Args:
+            messages: List of messages or message IDs to delete.
+            reason: The reason for this action. Used for audit logs.
+
+        """
+        message_ids = [to_snowflake(message) for message in messages]
+        # TODO Add check for min/max and duplicates.
+
+        if len(message_ids) == 1:
+            # bulk delete messages will throw a http error if only 1 message is passed
+            await self.delete_message(message_ids[0], reason)
+        else:
+            await self._client.http.bulk_delete_messages(self.id, message_ids, reason)
+
+    async def delete_message(self, message: Union[Snowflake_Type, "models.Message"], reason: str = None) -> None:
+        """
+        Delete a single message from a channel.
+
+        Args:
+            message: The message to delete
+            reason: The reason for this action
+
+        """
+        message = to_snowflake(message)
+        await self._client.http.delete_message(self.id, message, reason=reason)
+
+    async def purge(
+        self,
+        deletion_limit: int = 50,
+        search_limit: int = 100,
+        predicate: Callable[["models.Message"], bool] = MISSING,
+        avoid_loading_msg: bool = True,
+        return_messages: bool = False,
+        before: Optional[Snowflake_Type] = MISSING,
+        after: Optional[Snowflake_Type] = MISSING,
+        around: Optional[Snowflake_Type] = MISSING,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> int | List["models.Message"]:
+        """
+        Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit`.
+
+        ??? Hint "Example Usage:"
+            ```python
+            # this will delete the last 20 messages sent by a user with the given ID
+            deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897)
+            await channel.send(f"{deleted} messages deleted")
+            ```
+
+        Args:
+            deletion_limit: The target amount of messages to delete
+            search_limit: How many messages to search through
+            predicate: A function that returns True or False, and takes a message as an argument
+            avoid_loading_msg: Should the bot attempt to avoid deleting its own loading messages (recommended enabled)
+            return_messages: Should the bot return the messages that were deleted
+            before: Search messages before this ID
+            after: Search messages after this ID
+            around: Search messages around this ID
+            reason: The reason for this deletion
+
+        Returns:
+            The total amount of messages deleted
+
+        """
+        if not predicate:
+
+            def predicate(m) -> bool:
+                return True
+
+        to_delete = []
+
+        # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake
+        fourteen_days_ago = int((time.time() - 1209600) * 1000.0 - DISCORD_EPOCH) << 22
+        async for message in self.history(limit=search_limit, before=before, after=after, around=around):
+            if deletion_limit != 0 and len(to_delete) == deletion_limit:
+                break
+
+            if not predicate(message):
+                # fails predicate
+                continue
+
+            if (
+                avoid_loading_msg
+                and message._author_id == self._client.user.id
+                and MessageFlags.LOADING in message.flags
+            ):
+                continue
+
+            if message.id < fourteen_days_ago:
+                # message is too old to be purged
+                continue
+
+            to_delete.append(message)
+
+        out = to_delete.copy()
+        while len(to_delete):
+            iteration = [to_delete.pop().id for i in range(min(100, len(to_delete)))]
+            await self.delete_messages(iteration, reason=reason)
+        return out if return_messages else len(out)
+
+    async def trigger_typing(self) -> None:
+        """Trigger a typing animation in this channel."""
+        await self._client.http.trigger_typing_indicator(self.id)
+
+    @property
+    def typing(self) -> Typing:
+        """A context manager to send a typing state to a given channel as long as long as the wrapped operation takes."""
+        return Typing(self)
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class InvitableMixin:
+    async def create_invite(
+        self,
+        max_age: int = 86400,
+        max_uses: int = 0,
+        temporary: bool = False,
+        unique: bool = False,
+        target_type: Optional[InviteTargetType] = None,
+        target_user: Optional[Union[Snowflake_Type, "models.User"]] = None,
+        target_application: Optional[Union[Snowflake_Type, "models.Application"]] = None,
+        reason: Optional[str] = None,
+    ) -> "models.Invite":
+        """
+        Creates a new channel invite.
+
+        Args:
+            max_age: Max age of invite in seconds, default 86400 (24 hours).
+            max_uses: Max uses of invite, default 0.
+            temporary: Grants temporary membership, default False.
+            unique: Invite is unique, default false.
+            target_type: Target type for streams and embedded applications.
+            target_user: Target User ID for Stream target type.
+            target_application: Target Application ID for Embedded App target type.
+            reason: The reason for creating this invite.
+
+        Returns:
+            Newly created Invite object.
+
+        """
+        if target_type:
+            if target_type == InviteTargetType.STREAM and not target_user:
+                raise ValueError("Stream target must include target user id.")
+            if target_type == InviteTargetType.EMBEDDED_APPLICATION and not target_application:
+                raise ValueError("Embedded Application target must include target application id.")
+
+        if target_user and target_application:
+            raise ValueError("Invite target must be either User or Embedded Application, not both.")
+        if target_user:
+            target_user = to_snowflake(target_user)
+            target_type = InviteTargetType.STREAM
+        if target_application:
+            target_application = to_snowflake(target_application)
+            target_type = InviteTargetType.EMBEDDED_APPLICATION
+
+        invite_data = await self._client.http.create_channel_invite(
+            self.id,
+            max_age,
+            max_uses,
+            temporary,
+            unique,
+            target_user_id=target_user,
+            target_application_id=target_application,
+            reason=reason,
+        )
+        return models.Invite.from_dict(invite_data, self._client)
+
+    async def fetch_invites(self) -> List["models.Invite"]:
+        """
+        Fetches all invites (with invite metadata) for the channel.
+
+        Returns:
+            List of Invite objects.
+
+        """
+        invites_data = await self._client.http.get_channel_invites(self.id)
+        return models.Invite.from_list(invites_data, self._client)
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class ThreadableMixin:
+    async def create_thread(
+        self,
+        name: str,
+        message: Absent[Snowflake_Type] = MISSING,
+        thread_type: Absent[ChannelType] = MISSING,
+        invitable: Absent[bool] = MISSING,
+        rate_limit_per_user: Absent[int] = MISSING,
+        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
+        reason: Absent[str] = None,
+    ) -> "TYPE_THREAD_CHANNEL":
+        """
+        Creates a new thread in this channel. If a message is provided, it will be used as the initial message.
+
+        Args:
+            name: 1-100 character thread name
+            message: The message to connect this thread to. Required for news channel.
+            thread_type: Is the thread private or public. Not applicable to news channel, it will always be GUILD_NEWS_THREAD.
+            invitable: whether non-moderators can add other non-moderators to a thread. Only applicable when creating a private thread.
+            rate_limit_per_user: The time users must wait between sending messages (0-21600).
+            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
+            reason: The reason for creating this thread.
+
+        Returns:
+            The created thread, if successful
+
+        """
+        if self.type == ChannelType.GUILD_NEWS and not message:
+            raise ValueError("News channel must include message to create thread from.")
+
+        if message and (thread_type or invitable):
+            raise ValueError("Message cannot be used with thread_type or invitable.")
+
+        if thread_type != ChannelType.GUILD_PRIVATE_THREAD and invitable:
+            raise ValueError("Invitable only applies to private threads.")
+
+        thread_data = await self._client.http.create_thread(
+            channel_id=self.id,
+            name=name,
+            thread_type=thread_type,
+            invitable=invitable,
+            rate_limit_per_user=rate_limit_per_user,
+            auto_archive_duration=auto_archive_duration,
+            message_id=to_optional_snowflake(message),
+            reason=reason,
+        )
+        return self._client.cache.place_channel_data(thread_data)
+
+    async def fetch_public_archived_threads(
+        self, limit: int = None, before: Optional["models.Timestamp"] = None
+    ) -> "models.ThreadList":
+        """
+        Get a `ThreadList` of archived **public** threads available in this channel.
+
+        Args:
+            limit: optional maximum number of threads to return
+            before: Returns threads before this timestamp
+
+        Returns:
+            A `ThreadList` of archived threads.
+
+        """
+        threads_data = await self._client.http.list_public_archived_threads(
+            channel_id=self.id, limit=limit, before=before
+        )
+        threads_data["id"] = self.id
+        return models.ThreadList.from_dict(threads_data, self._client)
+
+    async def fetch_private_archived_threads(
+        self, limit: int = None, before: Optional["models.Timestamp"] = None
+    ) -> "models.ThreadList":
+        """
+        Get a `ThreadList` of archived **private** threads available in this channel.
+
+        Args:
+            limit: optional maximum number of threads to return
+            before: Returns threads before this timestamp
+
+        Returns:
+            A `ThreadList` of archived threads.
+
+        """
+        threads_data = await self._client.http.list_private_archived_threads(
+            channel_id=self.id, limit=limit, before=before
+        )
+        threads_data["id"] = self.id
+        return models.ThreadList.from_dict(threads_data, self._client)
+
+    async def fetch_archived_threads(
+        self, limit: int = None, before: Optional["models.Timestamp"] = None
+    ) -> "models.ThreadList":
+        """
+        Get a `ThreadList` of archived threads available in this channel.
+
+        Args:
+            limit: optional maximum number of threads to return
+            before: Returns threads before this timestamp
+
+        Returns:
+            A `ThreadList` of archived threads.
+
+        """
+        threads_data = await self._client.http.list_private_archived_threads(
+            channel_id=self.id, limit=limit, before=before
+        )
+        threads_data.update(
+            await self._client.http.list_public_archived_threads(channel_id=self.id, limit=limit, before=before)
+        )
+        threads_data["id"] = self.id
+        return models.ThreadList.from_dict(threads_data, self._client)
+
+    async def fetch_joined_private_archived_threads(
+        self, limit: int = None, before: Optional["models.Timestamp"] = None
+    ) -> "models.ThreadList":
+        """
+        Get a `ThreadList` of threads the bot is a participant of in this channel.
+
+        Args:
+            limit: optional maximum number of threads to return
+            before: Returns threads before this timestamp
+
+        Returns:
+            A `ThreadList` of threads the bot is a participant of.
+
+        """
+        threads_data = await self._client.http.list_joined_private_archived_threads(
+            channel_id=self.id, limit=limit, before=before
+        )
+        threads_data["id"] = self.id
+        return models.ThreadList.from_dict(threads_data, self._client)
+
+    async def fetch_active_threads(self) -> "models.ThreadList":
+        """
+        Gets all active threads in the channel, including public and private threads.
+
+        Returns:
+            A `ThreadList` of active threads.
+
+        """
+        threads_data = await self._client.http.list_active_threads(guild_id=self._guild_id)
+
+        # delete the items where the channel_id does not match
+        removed_thread_ids = []
+        cleaned_threads_data_threads = []
+        for thread in threads_data["threads"]:
+            if thread["parent_id"] == str(self.id):
+                cleaned_threads_data_threads.append(thread)
+            else:
+                removed_thread_ids.append(thread["id"])
+        threads_data["threads"] = cleaned_threads_data_threads
+
+        cleaned_member_data_threads = [
+            thread_member for thread_member in threads_data["members"] if thread_member["id"] not in removed_thread_ids
+        ]
+        threads_data["members"] = cleaned_member_data_threads
+
+        return models.ThreadList.from_dict(threads_data, self._client)
+
+    async def fetch_all_threads(self) -> "models.ThreadList":
+        """
+        Gets all threads in the channel. Active and archived, including public and private threads.
+
+        Returns:
+            A `ThreadList` of all threads.
+
+        """
+        threads = await self.fetch_active_threads()
+
+        # update that data with the archived threads
+        archived_threads = await self.fetch_archived_threads()
+        threads.threads.extend(archived_threads.threads)
+        threads.members.extend(archived_threads.members)
+
+        return threads
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class WebhookMixin:
+    async def create_webhook(self, name: str, avatar: Absent[UPLOADABLE_TYPE] = MISSING) -> "models.Webhook":
+        """
+        Create a webhook in this channel.
+
+        Args:
+            name: The name of the webhook
+            avatar: An optional default avatar image to use
+
+        Returns:
+            The created webhook object
+
+        Raises:
+            ValueError: If you try to name the webhook "Clyde"
+
+        """
+        return await models.Webhook.create(self._client, self, name, avatar)  # type: ignore
+
+    async def delete_webhook(self, webhook: "models.Webhook") -> None:
+        """
+        Delete a given webhook in this channel.
+
+        Args:
+            webhook: The webhook to delete
+
+        """
+        return await webhook.delete()
+
+    async def fetch_webhooks(self) -> List["models.Webhook"]:
+        """
+        Fetches all the webhooks for this channel.
+
+        Returns:
+            List of webhook objects
+
+        """
+        resp = await self._client.http.get_channel_webhooks(self.id)
+        return [models.Webhook.from_dict(d, self._client) for d in resp]
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class BaseChannel(DiscordObject):
+    name: Optional[str] = attrs.field(repr=True, default=None)
+    """The name of the channel (1-100 characters)"""
+    type: Union[ChannelType, int] = attrs.field(repr=True, converter=ChannelType)
+    """The channel topic (0-1024 characters)"""
+
+    @classmethod
+    def from_dict_factory(cls, data: dict, client: "Client") -> "TYPE_ALL_CHANNEL":
+        """
+        Creates a channel object of the appropriate type.
+
+        Args:
+            data: The channel data.
+            client: The bot.
+
+        Returns:
+            The new channel object.
+
+        """
+        channel_type = data.get("type")
+        channel_class = TYPE_CHANNEL_MAPPING.get(channel_type, None)
+        if not channel_class:
+            client.logger.error(f"Unsupported channel type for {data} ({channel_type}).")
+            channel_class = BaseChannel
+
+        if channel_class == GuildPublicThread:
+            # attempt to determine if this thread is a forum post (thanks discord)
+            parent_channel = client.cache.get_channel(data["parent_id"])
+            if parent_channel and parent_channel.type == ChannelType.GUILD_FORUM:
+                channel_class = GuildForumPost
+
+        return channel_class.from_dict(data, client)
+
+    @property
+    def mention(self) -> str:
+        """Returns a string that would mention the channel."""
+        return f"<#{self.id}>"
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        icon: Absent[UPLOADABLE_TYPE] = MISSING,
+        type: Absent[ChannelType] = MISSING,
+        position: Absent[int] = MISSING,
+        topic: Absent[str] = MISSING,
+        nsfw: Absent[bool] = MISSING,
+        rate_limit_per_user: Absent[int] = MISSING,
+        bitrate: Absent[int] = MISSING,
+        user_limit: Absent[int] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        parent_id: Absent[Snowflake_Type] = MISSING,
+        rtc_region: Absent[Union["models.VoiceRegion", str]] = MISSING,
+        video_quality_mode: Absent[VideoQualityMode] = MISSING,
+        default_auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
+        archived: Absent[bool] = MISSING,
+        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
+        locked: Absent[bool] = MISSING,
+        invitable: Absent[bool] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> "TYPE_ALL_CHANNEL":
+        """
+        Edits the channel.
+
+        Args:
+            name: 1-100 character channel name
+            icon: DM Group icon
+            type: The type of channel; only conversion between text and news is supported and only in guilds with the "NEWS" feature
+            position: The position of the channel in the left-hand listing
+            topic: 0-1024 character channel topic
+            nsfw: Whether the channel is nsfw
+            rate_limit_per_user: Amount of seconds a user has to wait before sending another message (0-21600)
+            bitrate: The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)
+            user_limit: The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit
+            permission_overwrites: Channel or category-specific permissions
+            parent_id: The id of the new parent category for a channel
+            rtc_region: Channel voice region id, automatic when set to None.
+            video_quality_mode: The camera video quality mode of the voice channel
+            default_auto_archive_duration: The default duration that the clients use (not the API) for newly created threads in the channel, in minutes, to automatically archive the thread after recent activity
+            archived: Whether the thread is archived
+            auto_archive_duration: Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
+            locked: Whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
+            invitable: Whether non-moderators can add other non-moderators to a thread; only available on private threads
+            reason: The reason for editing the channel
+
+        Returns:
+            The edited channel. May be a new object if the channel type changes.
+
+        """
+        payload = {
+            "name": name,
+            "icon": to_image_data(icon),
+            "type": type,
+            "position": position,
+            "topic": topic,
+            "nsfw": nsfw,
+            "rate_limit_per_user": rate_limit_per_user,
+            "bitrate": bitrate,
+            "user_limit": user_limit,
+            "permission_overwrites": process_permission_overwrites(permission_overwrites),
+            "parent_id": to_optional_snowflake(parent_id),
+            "rtc_region": rtc_region.id if isinstance(rtc_region, models.VoiceRegion) else rtc_region,
+            "video_quality_mode": video_quality_mode,
+            "default_auto_archive_duration": default_auto_archive_duration,
+            "archived": archived,
+            "auto_archive_duration": auto_archive_duration,
+            "locked": locked,
+            "invitable": invitable,
+            **kwargs,
+        }
+        channel_data = await self._client.http.modify_channel(self.id, payload, reason)
+        if not channel_data:
+            raise TooManyChanges(
+                "You have changed this channel too frequently, you need to wait a while before trying again."
+            ) from None
+
+        return self._client.cache.place_channel_data(channel_data)
+
+    async def delete(self, reason: Absent[Optional[str]] = MISSING) -> None:
+        """
+        Delete this channel.
+
+        Args:
+            reason: The reason for deleting this channel
+
+        """
+        await self._client.http.delete_channel(self.id, reason)
+
+
+################################################################
+# DMs
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class DMChannel(BaseChannel, MessageableMixin):
+    recipients: List["models.User"] = attrs.field(repr=False, factory=list)
+    """The users of the DM that will receive messages sent"""
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        data = super()._process_dict(data, client)
+        if recipients := data.get("recipients", None):
+            data["recipients"] = [
+                client.cache.place_user_data(recipient) if isinstance(recipient, dict) else recipient
+                for recipient in recipients
+            ]
+        return data
+
+    @property
+    def members(self) -> List["models.User"]:
+        """Returns a list of users that are in this DM channel."""
+        return self.recipients
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class DM(DMChannel):
+    @property
+    def recipient(self) -> "models.User":
+        """Returns the user that is in this DM channel."""
+        return self.recipients[0]
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class DMGroup(DMChannel):
+    owner_id: Snowflake_Type = attrs.field(repr=True)
+    """id of the creator of the group DM"""
+    application_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)
+    """Application id of the group DM creator if it is bot-created"""
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        icon: Absent[UPLOADABLE_TYPE] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> "DMGroup":
+        """
+        Edit this DM Channel.
+
+        Args:
+            name: 1-100 character channel name
+            icon: An icon to use
+            reason: The reason for this change
+        """
+        return await super().edit(name=name, icon=icon, reason=reason, **kwargs)
+
+    async def fetch_owner(self, *, force: bool = False) -> "models.User":
+        """
+        Fetch the owner of this DM group
+
+        Args:
+            force: Whether to force a fetch from the API
+        """
+        return await self._client.cache.fetch_user(self.owner_id, force=force)
+
+    def get_owner(self) -> "models.User":
+        """Get the owner of this DM group"""
+        return self._client.cache.get_user(self.owner_id)
+
+    async def add_recipient(
+        self,
+        user: Union["models.User", Snowflake_Type],
+        access_token: str,
+        nickname: Absent[Optional[str]] = MISSING,
+    ) -> None:
+        """
+        Add a recipient to this DM Group.
+
+        Args:
+            user: The user to add
+            access_token: access token of a user that has granted your app the gdm.join scope
+            nickname: nickname to apply to the user being added
+
+        """
+        user = await self._client.cache.fetch_user(user)
+        await self._client.http.group_dm_add_recipient(self.id, user.id, access_token, nickname)
+        self.recipients.append(user)
+
+    async def remove_recipient(self, user: Union["models.User", Snowflake_Type]) -> None:
+        """
+        Remove a recipient from this DM Group.
+
+        Args:
+            user: The user to remove
+
+        """
+        user = await self._client.cache.fetch_user(user)
+        await self._client.http.group_dm_remove_recipient(self.id, user.id)
+        self.recipients.remove(user)
+
+
+################################################################
+# Guild
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class GuildChannel(BaseChannel):
+    position: Optional[int] = attrs.field(repr=False, default=0)
+    """Sorting position of the channel"""
+    nsfw: bool = attrs.field(repr=False, default=False)
+    """Whether the channel is nsfw"""
+    parent_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
+    """id of the parent category for a channel (each parent category can contain up to 50 channels)"""
+    permission_overwrites: list[PermissionOverwrite] = attrs.field(repr=False, factory=list)
+    """A list of the overwritten permissions for the members and roles"""
+
+    _guild_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
+
+    @property
+    def guild(self) -> "models.Guild":
+        """The guild this channel belongs to."""
+        return self._client.cache.get_guild(self._guild_id)
+
+    @property
+    def category(self) -> Optional["GuildCategory"]:
+        """The parent category of this channel."""
+        return self._client.cache.get_channel(self.parent_id)
+
+    @property
+    def gui_position(self) -> int:
+        """The position of this channel in the Discord interface."""
+        return self.guild.get_channel_gui_position(self.id)
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        data = super()._process_dict(data, client)
+        if overwrites := data.get("permission_overwrites"):
+            data["permission_overwrites"] = PermissionOverwrite.from_list(overwrites)
+        return data
+
+    def permissions_for(self, instance: Snowflake_Type) -> Permissions:
+        """
+        Calculates permissions for an instance
+
+        Args:
+            instance: Member or Role instance (or its ID)
+
+        Returns:
+            Permissions data
+
+        Raises:
+            ValueError: If could not find any member or role by given ID
+            RuntimeError: If given instance is from another guild
+
+        """
+        if (is_member := isinstance(instance, models.Member)) or isinstance(instance, models.Role):
+            if instance._guild_id != self._guild_id:
+                raise RuntimeError("Unable to calculate permissions for the instance from different guild")
+
+            if is_member:
+                return instance.channel_permissions(self)
+
+            permissions = instance.permissions
+
+            for overwrite in self.permission_overwrites:
+                if overwrite.id == instance.id:
+                    permissions &= ~overwrite.deny
+                    permissions |= overwrite.allow
+                    break
+
+            return permissions
+
+        instance = to_snowflake(instance)
+        guild = self.guild
+        if instance := guild.get_member(instance) or guild.get_role(instance):
+            return self.permissions_for(instance)
+        raise ValueError("Unable to find any member or role by given instance ID")
+
+    async def add_permission(
+        self,
+        target: Union["PermissionOverwrite", "models.Role", "models.User", "models.Member", "Snowflake_Type"],
+        type: Optional["OverwriteType"] = None,
+        allow: Optional[List["Permissions"] | int] = None,
+        deny: Optional[List["Permissions"] | int] = None,
+        reason: Optional[str] = None,
+    ) -> None:
+        """
+        Add a permission to this channel.
+
+        Args:
+            target: The updated PermissionOverwrite object, or the Role or User object/id to update
+            type: The type of permission overwrite. Only applicable if target is an id
+            allow: List of permissions to allow. Only applicable if target is not an PermissionOverwrite object
+            deny: List of permissions to deny. Only applicable if target is not an PermissionOverwrite object
+            reason: The reason for this change
+
+        Raises:
+            ValueError: Invalid target for permission
+
+        """
+        allow = allow or []
+        deny = deny or []
+        if not isinstance(target, PermissionOverwrite):
+            if isinstance(target, (models.User, models.Member)):
+                target = target.id
+                type = OverwriteType.MEMBER
+            elif isinstance(target, models.Role):
+                target = target.id
+                type = OverwriteType.ROLE
+            elif type and isinstance(target, Snowflake_Type):
+                target = to_snowflake(target)
+            else:
+                raise ValueError("Invalid target and/or type for permission")
+            overwrite = PermissionOverwrite(id=target, type=type, allow=Permissions.NONE, deny=Permissions.NONE)
+            if isinstance(allow, int):
+                overwrite.allow |= allow
+            else:
+                for perm in allow:
+                    overwrite.allow |= perm
+            if isinstance(deny, int):
+                overwrite.deny |= deny
+            else:
+                for perm in deny:
+                    overwrite.deny |= perm
+        else:
+            overwrite = target
+
+        if exists := get(self.permission_overwrites, id=overwrite.id, type=overwrite.type):
+            exists.deny = (exists.deny | overwrite.deny) & ~overwrite.allow
+            exists.allow = (exists.allow | overwrite.allow) & ~overwrite.deny
+            await self.edit_permission(exists, reason)
+        else:
+            permission_overwrites = self.permission_overwrites
+            permission_overwrites.append(overwrite)
+            await self.edit(permission_overwrites=permission_overwrites)
+
+    async def edit_permission(self, overwrite: PermissionOverwrite, reason: Optional[str] = None) -> None:
+        """
+        Edit the permissions for this channel.
+
+        Args:
+            overwrite: The permission overwrite to apply
+            reason: The reason for this change
+        """
+        await self._client.http.edit_channel_permission(
+            self.id,
+            overwrite_id=overwrite.id,
+            allow=overwrite.allow,
+            deny=overwrite.deny,
+            perm_type=overwrite.type,
+            reason=reason,
+        )
+
+    async def delete_permission(
+        self,
+        target: Union["PermissionOverwrite", "models.Role", "models.User"],
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> None:
+        """
+        Delete a permission overwrite for this channel.
+
+        Args:
+            target: The permission overwrite to delete
+            reason: The reason for this change
+
+        """
+        target = to_snowflake(target)
+        await self._client.http.delete_channel_permission(self.id, target, reason)
+
+    async def set_permission(
+        self,
+        target: Union["models.Role", "models.Member", "models.User"],
+        *,
+        add_reactions: bool | None = None,
+        administrator: bool | None = None,
+        attach_files: bool | None = None,
+        ban_members: bool | None = None,
+        change_nickname: bool | None = None,
+        connect: bool | None = None,
+        create_instant_invite: bool | None = None,
+        deafen_members: bool | None = None,
+        embed_links: bool | None = None,
+        kick_members: bool | None = None,
+        manage_channels: bool | None = None,
+        manage_emojis_and_stickers: bool | None = None,
+        manage_events: bool | None = None,
+        manage_guild: bool | None = None,
+        manage_messages: bool | None = None,
+        manage_nicknames: bool | None = None,
+        manage_roles: bool | None = None,
+        manage_threads: bool | None = None,
+        manage_webhooks: bool | None = None,
+        mention_everyone: bool | None = None,
+        moderate_members: bool | None = None,
+        move_members: bool | None = None,
+        mute_members: bool | None = None,
+        priority_speaker: bool | None = None,
+        read_message_history: bool | None = None,
+        request_to_speak: bool | None = None,
+        send_messages: bool | None = None,
+        send_messages_in_threads: bool | None = None,
+        send_tts_messages: bool | None = None,
+        speak: bool | None = None,
+        start_embedded_activities: bool | None = None,
+        stream: bool | None = None,
+        use_application_commands: bool | None = None,
+        use_external_emojis: bool | None = None,
+        use_external_stickers: bool | None = None,
+        use_private_threads: bool | None = None,
+        use_public_threads: bool | None = None,
+        use_vad: bool | None = None,
+        view_audit_log: bool | None = None,
+        view_channel: bool | None = None,
+        view_guild_insights: bool | None = None,
+        reason: str = None,
+    ) -> None:
+        """
+        Set the Permission Overwrites for a given target.
+
+        Args:
+            target: The target to set permission overwrites for
+            add_reactions: Allows for the addition of reactions to messages
+            administrator: Allows all permissions and bypasses channel permission overwrites
+            attach_files: Allows for uploading images and files
+            ban_members: Allows banning members
+            change_nickname: Allows for modification of own nickname
+            connect: Allows for joining of a voice channel
+            create_instant_invite: Allows creation of instant invites
+            deafen_members: Allows for deafening of members in a voice channel
+            embed_links: Links sent by users with this permission will be auto-embedded
+            kick_members: Allows kicking members
+            manage_channels: Allows management and editing of channels
+            manage_emojis_and_stickers: Allows management and editing of emojis and stickers
+            manage_events: Allows for creating, editing, and deleting scheduled events
+            manage_guild: Allows management and editing of the guild
+            manage_messages: Allows for deletion of other users messages
+            manage_nicknames: Allows for modification of other users nicknames
+            manage_roles: Allows management and editing of roles
+            manage_threads: Allows for deleting and archiving threads, and viewing all private threads
+            manage_webhooks: Allows management and editing of webhooks
+            mention_everyone: Allows for using the `@everyone` tag to notify all users in a channel, and the `@here` tag to notify all online users in a channel
+            moderate_members: Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels
+            move_members: Allows for moving of members between voice channels
+            mute_members: Allows for muting members in a voice channel
+            priority_speaker: Allows for using priority speaker in a voice channel
+            read_message_history: Allows for reading of message history
+            request_to_speak: Allows for requesting to speak in stage channels. (This permission is under active development and may be changed or removed.)
+            send_messages:  Allows for sending messages in a channel (does not allow sending messages in threads)
+            send_messages_in_threads: Allows for sending messages in threads
+            send_tts_messages:  Allows for sending of `/tts` messages
+            speak: Allows for speaking in a voice channel
+            start_embedded_activities: Allows for using Activities (applications with the `EMBEDDED` flag) in a voice channel
+            stream: Allows the user to go live
+            use_application_commands: Allows members to use application commands, including slash commands and context menu commands
+            use_external_emojis: Allows the usage of custom emojis from other servers
+            use_external_stickers: Allows the usage of custom stickers from other servers
+            use_private_threads: Allows for creating private threads
+            use_public_threads:  Allows for creating public and announcement threads
+            use_vad: Allows for using voice-activity-detection in a voice channel
+            view_audit_log: Allows for viewing of audit logs
+            view_channel: Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels
+            view_guild_insights: Allows for viewing guild insights
+            reason: The reason for creating this overwrite
+        """
+        overwrite = PermissionOverwrite.for_target(target)
+
+        allow: Permissions = Permissions.NONE
+        deny: Permissions = Permissions.NONE
+
+        for name, val in locals().items():
+            if isinstance(val, bool):
+                if val:
+                    allow |= getattr(Permissions, name.upper())
+                else:
+                    deny |= getattr(Permissions, name.upper())
+
+        overwrite.add_allows(allow)
+        overwrite.add_denies(deny)
+
+        await self.edit_permission(overwrite, reason)
+
+    @property
+    def members(self) -> List["models.Member"]:
+        """Returns a list of members that can see this channel."""
+        return [m for m in self.guild.members if Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore
+
+    @property
+    def bots(self) -> List["models.Member"]:
+        """Returns a list of bots that can see this channel."""
+        return [m for m in self.guild.members if m.bot and Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore
+
+    @property
+    def humans(self) -> List["models.Member"]:
+        """Returns a list of humans that can see this channel."""
+        return [m for m in self.guild.members if not m.bot and Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore
+
+    async def clone(self, name: Optional[str] = None, reason: Absent[Optional[str]] = MISSING) -> "TYPE_GUILD_CHANNEL":
+        """
+        Clone this channel and create a new one.
+
+        Args:
+            name: The name of the new channel. Defaults to the current name
+            reason: The reason for creating this channel
+
+        Returns:
+            The newly created channel.
+
+        """
+        return await self.guild.create_channel(
+            channel_type=self.type,
+            name=name or self.name,
+            topic=getattr(self, "topic", MISSING),
+            position=self.position,
+            permission_overwrites=self.permission_overwrites,
+            category=self.category,
+            nsfw=self.nsfw,
+            bitrate=getattr(self, "bitrate", 64000),
+            user_limit=getattr(self, "user_limit", 0),
+            rate_limit_per_user=getattr(self, "rate_limit_per_user", 0),
+            reason=reason,
+        )
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildCategory(GuildChannel):
+    @property
+    def channels(self) -> List["TYPE_GUILD_CHANNEL"]:
+        """Get all channels within the category"""
+        return [channel for channel in self.guild.channels if channel.parent_id == self.id]
+
+    @property
+    def voice_channels(self) -> List["GuildVoice"]:
+        """Get all voice channels within the category"""
+        return [
+            channel
+            for channel in self.channels
+            if isinstance(channel, GuildVoice) and not isinstance(channel, GuildStageVoice)
+        ]
+
+    @property
+    def stage_channels(self) -> List["GuildStageVoice"]:
+        """Get all stage channels within the category"""
+        return [channel for channel in self.channels if isinstance(channel, GuildStageVoice)]
+
+    @property
+    def text_channels(self) -> List["GuildText"]:
+        """Get all text channels within the category"""
+        return [channel for channel in self.channels if isinstance(channel, GuildText)]
+
+    @property
+    def news_channels(self) -> List["GuildNews"]:
+        """Get all news channels within the category"""
+        return [channel for channel in self.channels if isinstance(channel, GuildNews)]
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        position: Absent[int] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> "GuildCategory":
+        """
+        Edit this channel.
+
+        Args:
+            name: 1-100 character channel name
+            position: the position of the channel in the left-hand listing
+            permission_overwrites: channel or category-specific permissions
+            reason: the reason for this change
+
+        Returns:
+            The updated channel object.
+
+        """
+        return await super().edit(
+            name=name,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            reason=reason,
+            **kwargs,
+        )
+
+    async def create_channel(
+        self,
+        channel_type: Union[ChannelType, int],
+        name: str,
+        topic: Absent[Optional[str]] = MISSING,
+        position: Absent[Optional[int]] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        nsfw: bool = False,
+        bitrate: int = 64000,
+        user_limit: int = 0,
+        rate_limit_per_user: int = 0,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> "TYPE_GUILD_CHANNEL":
+        """
+        Create a guild channel within this category, allows for explicit channel type setting.
+
+        Args:
+            channel_type: The type of channel to create
+            name: The name of the channel
+            topic: The topic of the channel
+            position: The position of the channel in the channel list
+            permission_overwrites: Permission overwrites to apply to the channel
+            nsfw: Should this channel be marked nsfw
+            bitrate: The bitrate of this channel, only for voice
+            user_limit: The max users that can be in this channel, only for voice
+            rate_limit_per_user: The time users must wait between sending messages
+            reason: The reason for creating this channel
+
+        Returns:
+            The newly created channel.
+
+        """
+        return await self.guild.create_channel(
+            channel_type=channel_type,
+            name=name,
+            topic=topic,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            category=self.id,
+            nsfw=nsfw,
+            bitrate=bitrate,
+            user_limit=user_limit,
+            rate_limit_per_user=rate_limit_per_user,
+            reason=reason,
+        )
+
+    async def create_text_channel(
+        self,
+        name: str,
+        topic: Absent[Optional[str]] = MISSING,
+        position: Absent[Optional[int]] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        nsfw: bool = False,
+        rate_limit_per_user: int = 0,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> "GuildText":
+        """
+        Create a text channel in this guild within this category.
+
+        Args:
+            name: The name of the channel
+            topic: The topic of the channel
+            position: The position of the channel in the channel list
+            permission_overwrites: Permission overwrites to apply to the channel
+            nsfw: Should this channel be marked nsfw
+            rate_limit_per_user: The time users must wait between sending messages
+            reason: The reason for creating this channel
+
+        Returns:
+           The newly created text channel.
+
+        """
+        return await self.create_channel(
+            channel_type=ChannelType.GUILD_TEXT,
+            name=name,
+            topic=topic,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            nsfw=nsfw,
+            rate_limit_per_user=rate_limit_per_user,
+            reason=reason,
+        )
+
+    async def create_news_channel(
+        self,
+        name: str,
+        topic: Absent[Optional[str]] = MISSING,
+        position: Absent[Optional[int]] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        nsfw: bool = False,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> "GuildNews":
+        """
+        Create a news channel in this guild within this category.
+
+        Args:
+            name: The name of the channel
+            topic: The topic of the channel
+            position: The position of the channel in the channel list
+            permission_overwrites: Permission overwrites to apply to the channel
+            nsfw: Should this channel be marked nsfw
+            reason: The reason for creating this channel
+
+        Returns:
+           The newly created news channel.
+
+        """
+        return await self.create_channel(
+            channel_type=ChannelType.GUILD_NEWS,
+            name=name,
+            topic=topic,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            nsfw=nsfw,
+            reason=reason,
+        )
+
+    async def create_voice_channel(
+        self,
+        name: str,
+        topic: Absent[Optional[str]] = MISSING,
+        position: Absent[Optional[int]] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        nsfw: bool = False,
+        bitrate: int = 64000,
+        user_limit: int = 0,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> "GuildVoice":
+        """
+        Create a guild voice channel within this category.
+
+        Args:
+            name: The name of the channel
+            topic: The topic of the channel
+            position: The position of the channel in the channel list
+            permission_overwrites: Permission overwrites to apply to the channel
+            nsfw: Should this channel be marked nsfw
+            bitrate: The bitrate of this channel, only for voice
+            user_limit: The max users that can be in this channel, only for voice
+            reason: The reason for creating this channel
+
+        Returns:
+           The newly created voice channel.
+
+        """
+        return await self.create_channel(
+            channel_type=ChannelType.GUILD_VOICE,
+            name=name,
+            topic=topic,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            nsfw=nsfw,
+            bitrate=bitrate,
+            user_limit=user_limit,
+            reason=reason,
+        )
+
+    async def create_stage_channel(
+        self,
+        name: str,
+        topic: Absent[Optional[str]] = MISSING,
+        position: Absent[Optional[int]] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        bitrate: int = 64000,
+        user_limit: int = 0,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> "GuildStageVoice":
+        """
+        Create a guild stage channel within this category.
+
+        Args:
+            name: The name of the channel
+            topic: The topic of the channel
+            position: The position of the channel in the channel list
+            permission_overwrites: Permission overwrites to apply to the channel
+            bitrate: The bitrate of this channel, only for voice
+            user_limit: The max users that can be in this channel, only for voice
+            reason: The reason for creating this channel
+
+        Returns:
+            The newly created stage channel.
+
+        """
+        return await self.create_channel(
+            channel_type=ChannelType.GUILD_STAGE_VOICE,
+            name=name,
+            topic=topic,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            bitrate=bitrate,
+            user_limit=user_limit,
+            reason=reason,
+        )
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildNews(GuildChannel, MessageableMixin, InvitableMixin, ThreadableMixin, WebhookMixin):
+    topic: Optional[str] = attrs.field(repr=False, default=None)
+    """The channel topic (0-1024 characters)"""
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        position: Absent[int] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        parent_id: Absent[Snowflake_Type] = MISSING,
+        nsfw: Absent[bool] = MISSING,
+        topic: Absent[str] = MISSING,
+        channel_type: Absent["ChannelType"] = MISSING,
+        default_auto_archive_duration: Absent["AutoArchiveDuration"] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> Union["GuildNews", "GuildText"]:
+        """
+        Edit the guild text channel.
+
+        Args:
+            name: 1-100 character channel name
+            position: the position of the channel in the left-hand listing
+            permission_overwrites: a list of PermissionOverwrite
+            parent_id:  the parent category `Snowflake_Type` for the channel
+            nsfw: whether the channel is nsfw
+            topic: 0-1024 character channel topic
+            channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the "NEWS" feature
+            default_auto_archive_duration: optional AutoArchiveDuration
+            reason: An optional reason for the audit log
+
+        Returns:
+            The edited channel.
+
+        """
+        return await super().edit(
+            name=name,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            parent_id=parent_id,
+            nsfw=nsfw,
+            topic=topic,
+            type=channel_type,
+            default_auto_archive_duration=default_auto_archive_duration,
+            reason=reason,
+            **kwargs,
+        )
+
+    async def follow(self, webhook_channel_id: Snowflake_Type) -> None:
+        """
+        Follow this channel.
+
+        Args:
+            webhook_channel_id: The ID of the channel to post messages from this channel to
+
+        """
+        await self._client.http.follow_news_channel(self.id, webhook_channel_id)
+
+    async def create_thread_from_message(
+        self,
+        name: str,
+        message: Snowflake_Type,
+        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
+        reason: Absent[str] = None,
+    ) -> "GuildNewsThread":
+        """
+        Creates a new news thread in this channel.
+
+        Args:
+            name: 1-100 character thread name.
+            message: The message to connect this thread to.
+            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
+            reason: The reason for creating this thread.
+
+        Returns:
+            The created public thread, if successful
+
+        """
+        return await self.create_thread(
+            name=name,
+            message=message,
+            auto_archive_duration=auto_archive_duration,
+            reason=reason,
+        )
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildText(GuildChannel, MessageableMixin, InvitableMixin, ThreadableMixin, WebhookMixin):
+    topic: Optional[str] = attrs.field(repr=False, default=None)
+    """The channel topic (0-1024 characters)"""
+    rate_limit_per_user: int = attrs.field(repr=False, default=0)
+    """Amount of seconds a user has to wait before sending another message (0-21600)"""
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        position: Absent[int] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        parent_id: Absent[Snowflake_Type] = MISSING,
+        nsfw: Absent[bool] = MISSING,
+        topic: Absent[str] = MISSING,
+        channel_type: Absent["ChannelType"] = MISSING,
+        default_auto_archive_duration: Absent["AutoArchiveDuration"] = MISSING,
+        rate_limit_per_user: Absent[int] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> Union["GuildText", "GuildNews"]:
+        """
+        Edit the guild text channel.
+
+        Args:
+            name: 1-100 character channel name
+            position: the position of the channel in the left-hand listing
+            permission_overwrites: a list of PermissionOverwrite
+            parent_id:  the parent category `Snowflake_Type` for the channel
+            nsfw: whether the channel is nsfw
+            topic: 0-1024 character channel topic
+            channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the "NEWS" feature
+            default_auto_archive_duration: optional AutoArchiveDuration
+            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
+            reason: An optional reason for the audit log
+
+        Returns:
+            The edited channel.
+
+        """
+        return await super().edit(
+            name=name,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            parent_id=parent_id,
+            nsfw=nsfw,
+            topic=topic,
+            type=channel_type,
+            default_auto_archive_duration=default_auto_archive_duration,
+            rate_limit_per_user=rate_limit_per_user,
+            reason=reason,
+            **kwargs,
+        )
+
+    async def create_public_thread(
+        self,
+        name: str,
+        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
+        rate_limit_per_user: Absent[int] = MISSING,
+        reason: Absent[str] = None,
+    ) -> "GuildPublicThread":
+        """
+        Creates a new public thread in this channel.
+
+        Args:
+            name: 1-100 character thread name.
+            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
+            rate_limit_per_user: The time users must wait between sending messages (0-21600).
+            reason: The reason for creating this thread.
+
+        Returns:
+            The created public thread, if successful
+
+        """
+        return await self.create_thread(
+            name=name,
+            thread_type=ChannelType.GUILD_PUBLIC_THREAD,
+            auto_archive_duration=auto_archive_duration,
+            rate_limit_per_user=rate_limit_per_user,
+            reason=reason,
+        )
+
+    async def create_private_thread(
+        self,
+        name: str,
+        invitable: Absent[bool] = MISSING,
+        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
+        rate_limit_per_user: Absent[int] = MISSING,
+        reason: Absent[str] = None,
+    ) -> "GuildPrivateThread":
+        """
+        Creates a new private thread in this channel.
+
+        Args:
+            name: 1-100 character thread name.
+            invitable: Whether non-moderators can add other non-moderators to a thread.
+            rate_limit_per_user: The time users must wait between sending messages (0-21600).
+            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
+            reason: The reason for creating this thread.
+
+        Returns:
+            The created thread, if successful
+
+        """
+        return await self.create_thread(
+            name=name,
+            thread_type=ChannelType.GUILD_PRIVATE_THREAD,
+            invitable=invitable,
+            rate_limit_per_user=rate_limit_per_user,
+            auto_archive_duration=auto_archive_duration,
+            reason=reason,
+        )
+
+    async def create_thread_from_message(
+        self,
+        name: str,
+        message: Snowflake_Type,
+        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
+        reason: Absent[str] = None,
+    ) -> "GuildPublicThread":
+        """
+        Creates a new public thread in this channel.
+
+        Args:
+            name: 1-100 character thread name.
+            message: The message to connect this thread to.
+            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
+            reason: The reason for creating this thread.
+
+        Returns:
+            The created public thread, if successful
+
+        """
+        return await self.create_thread(
+            name=name,
+            message=message,
+            auto_archive_duration=auto_archive_duration,
+            reason=reason,
+        )
+
+
+################################################################
+# Guild Threads
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class ThreadChannel(BaseChannel, MessageableMixin, WebhookMixin):
+    parent_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
+    """id of the text channel this thread was created"""
+    owner_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
+    """id of the creator of the thread"""
+    topic: Optional[str] = attrs.field(repr=False, default=None)
+    """The thread topic (0-1024 characters)"""
+    message_count: int = attrs.field(repr=False, default=0)
+    """An approximate count of messages in a thread, stops counting at 50"""
+    member_count: int = attrs.field(repr=False, default=0)
+    """An approximate count of users in a thread, stops counting at 50"""
+    archived: bool = attrs.field(repr=False, default=False)
+    """Whether the thread is archived"""
+    auto_archive_duration: int = attrs.field(
+        repr=False,
+        default=attrs.Factory(lambda self: self.default_auto_archive_duration, takes_self=True),
+    )
+    """Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080"""
+    locked: bool = attrs.field(repr=False, default=False)
+    """Whether the thread is locked"""
+    archive_timestamp: Optional["models.Timestamp"] = attrs.field(
+        repr=False, default=None, converter=optional_c(timestamp_converter)
+    )
+    """Timestamp when the thread's archive status was last changed, used for calculating recent activity"""
+    create_timestamp: Optional["models.Timestamp"] = attrs.field(
+        repr=False, default=None, converter=optional_c(timestamp_converter)
+    )
+    """Timestamp when the thread was created"""
+    flags: ChannelFlags = attrs.field(repr=False, default=ChannelFlags.NONE, converter=ChannelFlags)
+    """Flags for the thread"""
+
+    _guild_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        data = super()._process_dict(data, client)
+        thread_metadata: dict = data.get("thread_metadata", {})
+        data.update(thread_metadata)
+        return data
+
+    @property
+    def is_private(self) -> bool:
+        """Is this a private thread?"""
+        return self.type == ChannelType.GUILD_PRIVATE_THREAD
+
+    @property
+    def guild(self) -> "models.Guild":
+        """The guild this channel belongs to."""
+        return self._client.cache.get_guild(self._guild_id)
+
+    @property
+    def parent_channel(self) -> Union[GuildText, "GuildForum"]:
+        """The channel this thread is a child of."""
+        return self._client.cache.get_channel(self.parent_id)
+
+    @property
+    def parent_message(self) -> Optional["Message"]:
+        """The message this thread is a child of."""
+        return self._client.cache.get_message(self.parent_id, self.id)
+
+    @property
+    def mention(self) -> str:
+        """Returns a string that would mention this thread."""
+        return f"<#{self.id}>"
+
+    @property
+    def permission_overwrites(self) -> List["PermissionOverwrite"]:
+        """The permission overwrites for this channel."""
+        return []
+
+    @property
+    def clyde_created(self) -> bool:
+        """Whether this thread was created by Clyde."""
+        return ChannelFlags.CLYDE_THREAD in self.flags
+
+    def permissions_for(self, instance: Snowflake_Type) -> Permissions:
+        """
+        Calculates permissions for an instance
+
+        Args:
+            instance: Member or Role instance (or its ID)
+
+        Returns:
+            Permissions data
+
+        Raises:
+            ValueError: If could not find any member or role by given ID
+            RuntimeError: If given instance is from another guild
+
+        """
+        if self.parent_channel:
+            return self.parent_channel.permissions_for(instance)
+        return Permissions.NONE
+
+    async def fetch_members(self) -> List["models.ThreadMember"]:
+        """Get the members that have access to this thread."""
+        members_data = await self._client.http.list_thread_members(self.id)
+        return models.ThreadMember.from_list(members_data, self._client)
+
+    async def add_member(self, member: Union["models.Member", Snowflake_Type]) -> None:
+        """
+        Add a member to this thread.
+
+        Args:
+            member: The member to add
+
+        """
+        await self._client.http.add_thread_member(self.id, to_snowflake(member))
+
+    async def remove_member(self, member: Union["models.Member", Snowflake_Type]) -> None:
+        """
+        Remove a member from this thread.
+
+        Args:
+            member: The member to remove
+
+        """
+        await self._client.http.remove_thread_member(self.id, to_snowflake(member))
+
+    async def join(self) -> None:
+        """Join this thread."""
+        await self._client.http.join_thread(self.id)
+
+    async def leave(self) -> None:
+        """Leave this thread."""
+        await self._client.http.leave_thread(self.id)
+
+    async def archive(self, locked: bool = False, reason: Absent[str] = MISSING) -> "TYPE_THREAD_CHANNEL":
+        """
+        Helper method to archive this thread.
+
+        Args:
+            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
+            reason: The reason for this archive
+
+        Returns:
+            The archived thread channel object.
+
+        """
+        return await super().edit(locked=locked, archived=True, reason=reason)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildNewsThread(ThreadChannel):
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        archived: Absent[bool] = MISSING,
+        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
+        locked: Absent[bool] = MISSING,
+        rate_limit_per_user: Absent[int] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> "GuildNewsThread":
+        """
+        Edit this thread.
+
+        Args:
+            name: 1-100 character channel name
+            archived: whether the thread is archived
+            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
+            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
+            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
+            reason: The reason for this change
+
+        Returns:
+            The edited thread channel object.
+
+        """
+        return await super().edit(
+            name=name,
+            archived=archived,
+            auto_archive_duration=auto_archive_duration,
+            locked=locked,
+            rate_limit_per_user=rate_limit_per_user,
+            reason=reason,
+            **kwargs,
+        )
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildPublicThread(ThreadChannel):
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        archived: Absent[bool] = MISSING,
+        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
+        locked: Absent[bool] = MISSING,
+        rate_limit_per_user: Absent[int] = MISSING,
+        flags: Absent[Union[int, ChannelFlags]] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> "GuildPublicThread":
+        """
+        Edit this thread.
+
+        Args:
+            name: 1-100 character channel name
+            archived: whether the thread is archived
+            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
+            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
+            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
+            flags: channel flags for forum threads
+            reason: The reason for this change
+
+        Returns:
+            The edited thread channel object.
+        """
+        return await super().edit(
+            name=name,
+            archived=archived,
+            auto_archive_duration=auto_archive_duration,
+            locked=locked,
+            rate_limit_per_user=rate_limit_per_user,
+            reason=reason,
+            flags=flags,
+            **kwargs,
+        )
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildForumPost(GuildPublicThread):
+    """
+    A forum post
+
+    !!! note
+        This model is an abstraction of the api - In reality all posts are GuildPublicThread
+    """
+
+    _applied_tags: list[Snowflake_Type] = attrs.field(repr=False, factory=list)
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        data = super()._process_dict(data, client)
+        data["_applied_tags"] = data.pop("applied_tags") if "applied_tags" in data else []
+        return data
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        archived: Absent[bool] = MISSING,
+        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
+        applied_tags: Absent[List[Union[Snowflake_Type, ThreadTag]]] = MISSING,
+        locked: Absent[bool] = MISSING,
+        rate_limit_per_user: Absent[int] = MISSING,
+        flags: Absent[Union[int, ChannelFlags]] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> "GuildForumPost":
+        """
+        Edit this thread.
+
+        Args:
+            name: 1-100 character channel name
+            archived: whether the thread is archived
+            applied_tags: list of tags to apply
+            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
+            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
+            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
+            flags: channel flags to apply
+            reason: The reason for this change
+
+        Returns:
+            The edited thread channel object.
+        """
+        if applied_tags != MISSING:
+            applied_tags = [str(tag.id) if isinstance(tag, ThreadTag) else str(tag) for tag in applied_tags]
+
+        return await super().edit(
+            name=name,
+            archived=archived,
+            auto_archive_duration=auto_archive_duration,
+            applied_tags=applied_tags,
+            locked=locked,
+            rate_limit_per_user=rate_limit_per_user,
+            reason=reason,
+            flags=flags,
+            **kwargs,
+        )
+
+    @property
+    def applied_tags(self) -> list[ThreadTag]:
+        """The tags applied to this thread."""
+        if not isinstance(self.parent_channel, GuildForum):
+            raise AttributeError("This is only available on forum threads.")
+        return [tag for tag in self.parent_channel.available_tags if str(tag.id) in self._applied_tags]
+
+    @property
+    def initial_post(self) -> Optional["Message"]:
+        """The initial message posted by the OP."""
+        if not isinstance(self.parent_channel, GuildForum):
+            raise AttributeError("This is only available on forum threads.")
+        return self.get_message(self.id)
+
+    @property
+    def pinned(self) -> bool:
+        """Whether this thread is pinned."""
+        return ChannelFlags.PINNED in self.flags
+
+    async def pin(self, reason: Absent[str] = MISSING) -> None:
+        """
+        Pin this thread.
+
+        Args:
+            reason: The reason for this pin
+
+        """
+        flags = self.flags | ChannelFlags.PINNED
+        await self.edit(flags=flags, reason=reason)
+
+    async def unpin(self, reason: Absent[str] = MISSING) -> None:
+        """
+        Unpin this thread.
+
+        Args:
+            reason: The reason for this unpin
+
+        """
+        flags = self.flags & ~ChannelFlags.PINNED
+        await self.edit(flags=flags, reason=reason)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildPrivateThread(ThreadChannel):
+    invitable: bool = attrs.field(repr=False, default=False)
+    """Whether non-moderators can add other non-moderators to a thread"""
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        archived: Absent[bool] = MISSING,
+        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,
+        locked: Absent[bool] = MISSING,
+        rate_limit_per_user: Absent[int] = MISSING,
+        invitable: Absent[bool] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> "GuildPrivateThread":
+        """
+        Edit this thread.
+
+        Args:
+            name: 1-100 character channel name
+            archived: whether the thread is archived
+            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080
+            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it
+            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)
+            invitable: whether non-moderators can add other non-moderators to a thread; only available on private threads
+            reason: The reason for this change
+
+        Returns:
+            The edited thread channel object.
+
+        """
+        return await super().edit(
+            name=name,
+            archived=archived,
+            auto_archive_duration=auto_archive_duration,
+            locked=locked,
+            rate_limit_per_user=rate_limit_per_user,
+            invitable=invitable,
+            reason=reason,
+            **kwargs,
+        )
+
+
+################################################################
+# Guild Voices
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)
+class VoiceChannel(GuildChannel):  # May not be needed, can be directly just GuildVoice.
+    bitrate: int = attrs.field(
+        repr=False,
+    )
+    """The bitrate (in bits) of the voice channel"""
+    user_limit: int = attrs.field(
+        repr=False,
+    )
+    """The user limit of the voice channel"""
+    rtc_region: str = attrs.field(repr=False, default="auto")
+    """Voice region id for the voice channel, automatic when set to None"""
+    video_quality_mode: Union[VideoQualityMode, int] = attrs.field(repr=False, default=VideoQualityMode.AUTO)
+    """The camera video quality mode of the voice channel, 1 when not present"""
+    _voice_member_ids: list[Snowflake_Type] = attrs.field(repr=False, factory=list)
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        position: Absent[int] = MISSING,
+        permission_overwrites: Absent[
+            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+        ] = MISSING,
+        parent_id: Absent[Snowflake_Type] = MISSING,
+        bitrate: Absent[int] = MISSING,
+        user_limit: Absent[int] = MISSING,
+        rtc_region: Absent[str] = MISSING,
+        video_quality_mode: Absent[VideoQualityMode] = MISSING,
+        reason: Absent[str] = MISSING,
+        **kwargs,
+    ) -> Union["GuildVoice", "GuildStageVoice"]:
+        """
+        Edit guild voice channel.
+
+        Args:
+            name: 1-100 character channel name
+            position: the position of the channel in the left-hand listing
+            permission_overwrites: a list of `PermissionOverwrite` to apply to the channel
+            parent_id: the parent category `Snowflake_Type` for the channel
+            bitrate: the bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)
+            user_limit: the user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit
+            rtc_region: channel voice region id, automatic when not set
+            video_quality_mode: the camera video quality mode of the voice channel
+            reason: optional reason for audit logs
+
+        Returns:
+            The edited voice channel object.
+
+        """
+        return await super().edit(
+            name=name,
+            position=position,
+            permission_overwrites=permission_overwrites,
+            parent_id=parent_id,
+            bitrate=bitrate,
+            user_limit=user_limit,
+            rtc_region=rtc_region,
+            video_quality_mode=video_quality_mode,
+            reason=reason,
+            **kwargs,
+        )
+
+    @property
+    def members(self) -> List["models.Member"]:
+        """Returns a list of members that have access to this voice channel"""
+        return [m for m in self.guild.members if Permissions.CONNECT in m.channel_permissions(self)]  # type: ignore
+
+    @property
+    def voice_members(self) -> List["models.Member"]:
+        """
+        Returns a list of members that are currently in the channel.
+
+        !!! note
+            This will not be accurate if the bot was offline while users joined the channel
+        """
+        return [self._client.cache.get_member(self._guild_id, member_id) for member_id in self._voice_member_ids]
+
+    @property
+    def voice_state(self) -> Optional["ActiveVoiceState"]:
+        """Returns the voice state of the bot in this channel if it is connected"""
+        return self._client.get_bot_voice_state(self._guild_id)
+
+    async def connect(self, muted: bool = False, deafened: bool = False) -> "ActiveVoiceState":
+        """
+        Connect the bot to this voice channel, or move the bot to this voice channel if it is already connected in another voice channel.
+
+        Args:
+            muted: Whether the bot should be muted when connected.
+            deafened: Whether the bot should be deafened when connected.
+
+        Returns:
+            The new active voice state on successfully connection.
+
+        """
+        if not self.voice_state:
+            return await self._client.connect_to_vc(self._guild_id, self.id, muted, deafened)
+        await self.voice_state.move(self.id)
+        return self.voice_state
+
+    async def disconnect(self) -> None:
+        """
+        Disconnect from the currently connected voice state.
+
+        Raises:
+            VoiceNotConnected: if the bot is not connected to a voice channel
+        """
+        if self.voice_state:
+            return await self.voice_state.disconnect()
+        raise VoiceNotConnected
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildVoice(VoiceChannel, InvitableMixin, MessageableMixin):
+    pass
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildStageVoice(GuildVoice):
+    stage_instance: "models.StageInstance" = attrs.field(repr=False, default=MISSING)
+    """The stage instance that this voice channel belongs to"""
+
+    # todo: Listeners and speakers properties (needs voice state caching)
+
+    async def fetch_stage_instance(self) -> "models.StageInstance":
+        """
+        Fetches the stage instance associated with this channel.
+
+        Returns:
+            The stage instance associated with this channel. If no stage is live, will return None.
+
+        """
+        self.stage_instance = models.StageInstance.from_dict(
+            await self._client.http.get_stage_instance(self.id), self._client
+        )
+        return self.stage_instance
+
+    async def create_stage_instance(
+        self,
+        topic: str,
+        privacy_level: StagePrivacyLevel = StagePrivacyLevel.GUILD_ONLY,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> "models.StageInstance":
+        """
+        Create a stage instance in this channel.
+
+        Args:
+            topic: The topic of the stage (1-120 characters)
+            privacy_level: The privacy level of the stage
+            reason: The reason for creating this instance
+
+        Returns:
+            The created stage instance object.
+
+        """
+        self.stage_instance = models.StageInstance.from_dict(
+            await self._client.http.create_stage_instance(self.id, topic, privacy_level, reason),
+            self._client,
+        )
+        return self.stage_instance
+
+    async def close_stage(self, reason: Absent[Optional[str]] = MISSING) -> None:
+        """
+        Closes the live stage instance.
+
+        Args:
+            reason: The reason for closing the stage
+
+        """
+        if not self.stage_instance and not await self.get_stage_instance():
+            # we dont know of an active stage instance, so lets check for one
+            raise ValueError("No stage instance found")
+
+        await self.stage_instance.delete(reason=reason)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class GuildForum(GuildChannel):
+    available_tags: List[ThreadTag] = attrs.field(repr=False, factory=list)
+    """A list of tags available to assign to threads"""
+    default_reaction_emoji: Optional[DefaultReaction] = attrs.field(repr=False, default=None)
+    """The default emoji to react with for posts"""
+    last_message_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)
+    # TODO: Implement "template" once the API supports them
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        data = super()._process_dict(data, client)
+        data["available_tags"] = [
+            ThreadTag.from_dict(tag_data | {"parent_channel_id": data["id"]}, client)
+            for tag_data in data.get("available_tags", [])
+        ]
+        return data
+
+    async def create_post(
+        self,
+        name: str,
+        content: str | None,
+        applied_tags: Optional[List[Union["Snowflake_Type", "ThreadTag", str]]] = MISSING,
+        *,
+        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,
+        rate_limit_per_user: Absent[int] = MISSING,
+        embeds: Optional[Union[List[Union["Embed", dict]], Union["Embed", dict]]] = None,
+        embed: Optional[Union["Embed", dict]] = None,
+        components: Optional[
+            Union[
+                List[List[Union["BaseComponent", dict]]],
+                List[Union["BaseComponent", dict]],
+                "BaseComponent",
+                dict,
+            ]
+        ] = None,
+        stickers: Optional[Union[List[Union["Sticker", "Snowflake_Type"]], "Sticker", "Snowflake_Type"]] = None,
+        allowed_mentions: Optional[Union["AllowedMentions", dict]] = None,
+        files: Optional[Union["UPLOADABLE_TYPE", List["UPLOADABLE_TYPE"]]] = None,
+        file: Optional["UPLOADABLE_TYPE"] = None,
+        tts: bool = False,
+        reason: Absent[str] = MISSING,
+    ) -> "GuildForumPost":
+        """
+        Create a post within this channel.
+
+        Args:
+            name: The name of the post
+            content: The text content of this post
+            applied_tags: A list of tag ids or tag objects to apply to this post
+            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.
+            rate_limit_per_user: The time users must wait between sending messages
+            embeds: Embedded rich content (up to 6000 characters).
+            embed: Embedded rich content (up to 6000 characters).
+            components: The components to include with the message.
+            stickers: IDs of up to 3 stickers in the server to send in the message.
+            allowed_mentions: Allowed mentions for the message.
+            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            tts: Should this message use Text To Speech.
+            reason: The reason for creating this post
+
+        Returns:
+            A GuildForumPost object representing the created post.
+        """
+        if applied_tags != MISSING:
+            processed = []
+            for tag in applied_tags:
+                if isinstance(tag, ThreadTag):
+                    tag = tag.id
+                elif isinstance(tag, (str, int)):
+                    tag = self.get_tag(tag, case_insensitive=True)
+                    if not tag:
+                        continue
+                    tag = tag.id
+                elif isinstance(tag, dict):
+                    tag = tag["id"]
+                processed.append(tag)
+
+            applied_tags = processed
+
+        message_payload = models.discord.message.process_message_payload(
+            content=content,
+            embeds=embeds or embed,
+            components=components,
+            stickers=stickers,
+            allowed_mentions=allowed_mentions,
+            tts=tts,
+        )
+
+        data = await self._client.http.create_forum_thread(
+            self.id,
+            name,
+            auto_archive_duration,
+            message_payload,
+            applied_tags,
+            rate_limit_per_user,
+            files=files or file,
+            reason=reason,
+        )
+        return self._client.cache.place_channel_data(data)
+
+    async def fetch_posts(self) -> List["GuildForumPost"]:
+        """
+        Requests all active posts within this channel.
+
+        Returns:
+            A list of GuildForumPost objects representing the posts.
+        """
+        # I can guarantee this endpoint will need to be converted to an async iterator eventually
+        data = await self._client.http.list_active_threads(self._guild_id)
+        threads = [self._client.cache.place_channel_data(post_data) for post_data in data["threads"]]
+
+        return [thread for thread in threads if thread.parent_id == self.id]
+
+    def get_posts(self, *, exclude_archived: bool = True) -> List["GuildForumPost"]:
+        """
+        List all, cached, active posts within this channel.
+
+        Args:
+            exclude_archived: Whether to exclude archived posts from the response
+
+        Returns:
+            A list of GuildForumPost objects representing the posts.
+        """
+        out = [thread for thread in self.guild.threads if thread.parent_id == self.id]
+        if exclude_archived:
+            return [thread for thread in out if not thread.archived]
+        return out
+
+    def archived_posts(self, limit: int = 0, before: Snowflake_Type | None = None) -> ArchivedForumPosts:
+        """An async iterator for all archived posts in this channel."""
+        return ArchivedForumPosts(self, limit, before)
+
+    async def fetch_post(self, id: "Snowflake_Type", *, force: bool = False) -> "GuildForumPost":
+        """
+        Fetch a post within this channel.
+
+        Args:
+            id: The id of the post to fetch
+            force: Whether to force a fetch from the API
+
+        Returns:
+            A GuildForumPost object representing the post.
+        """
+        return await self._client.fetch_channel(id, force=force)
+
+    def get_post(self, id: "Snowflake_Type") -> "GuildForumPost":
+        """
+        Get a post within this channel.
+
+        Args:
+            id: The id of the post to get
+
+        Returns:
+            A GuildForumPost object representing the post.
+        """
+        return self._client.cache.get_channel(id)
+
+    def get_tag(self, value: str | Snowflake_Type, *, case_insensitive: bool = False) -> Optional["ThreadTag"]:
+        """
+        Get a tag within this channel.
+
+        Args:
+            value: The name or ID of the tag to get
+            case_insensitive: Whether to ignore case when searching for the tag
+
+        Returns:
+            A ThreadTag object representing the tag.
+        """
+
+        def maybe_insensitive(string: str) -> str:
+            return string.lower() if case_insensitive else string
+
+        def predicate(tag: ThreadTag) -> Optional["ThreadTag"]:
+            if str(tag.id) == str(value):
+                return tag
+            if maybe_insensitive(tag.name) == maybe_insensitive(value):
+                return tag
+
+        return next((tag for tag in self.available_tags if predicate(tag)), None)
+
+    async def create_tag(self, name: str, emoji: Union["models.PartialEmoji", dict, str, None] = None) -> "ThreadTag":
+        """
+        Create a tag for this forum.
+
+        Args:
+            name: The name of the tag
+            emoji: The emoji to use for the tag
+
+        !!! note
+            If the emoji is a custom emoji, it must be from the same guild as the channel.
+
+        Returns:
+            The created tag object.
+
+        """
+        payload = {"channel_id": self.id, "name": name}
+
+        if emoji:
+            if isinstance(emoji, str):
+                emoji = PartialEmoji.from_str(emoji)
+            elif isinstance(emoji, dict):
+                emoji = PartialEmoji.from_dict(emoji)
+
+            if emoji.id:
+                payload["emoji_id"] = emoji.id
+            else:
+                payload["emoji_name"] = emoji.name
+
+        data = await self._client.http.create_tag(**payload)
+
+        channel_data = self._client.cache.place_channel_data(data)
+        return [tag for tag in channel_data.available_tags if tag.name == name][0]
+
+    async def edit_tag(
+        self,
+        tag_id: "Snowflake_Type",
+        *,
+        name: str | None = None,
+        emoji: Union["models.PartialEmoji", dict, str, None] = None,
+    ) -> "ThreadTag":
+        """
+        Edit a tag for this forum.
+
+        Args:
+            tag_id: The id of the tag to edit
+            name: The name for this tag
+            emoji: The emoji for this tag
+        """
+        if isinstance(emoji, str):
+            emoji = PartialEmoji.from_str(emoji)
+        elif isinstance(emoji, dict):
+            emoji = PartialEmoji.from_dict(emoji)
+
+        if emoji.id:
+            data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_id=emoji.id)
+        else:
+            data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_name=emoji.name)
+
+        channel_data = self._client.cache.place_channel_data(data)
+        return [tag for tag in channel_data.available_tags if tag.name == name][0]
+
+    async def delete_tag(self, tag_id: "Snowflake_Type") -> None:
+        """
+        Delete a tag for this forum.
+
+        Args:
+            tag_id: The ID of the tag to delete
+        """
+        data = await self._client.http.delete_tag(self.id, tag_id)
+        self._client.cache.place_channel_data(data)
+
+
+def process_permission_overwrites(
+    overwrites: Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]
+) -> List[dict]:
+    """
+    Processes a permission overwrite lists into format for sending to discord.
+
+    Args:
+        overwrites: The permission overwrites to process
+
+    Returns:
+        The processed permission overwrites
+
+    """
+    if not overwrites:
+        return overwrites
+
+    if isinstance(overwrites, dict):
+        return [overwrites]
+
+    if isinstance(overwrites, list):
+        return list(map(to_dict, overwrites))
+
+    if isinstance(overwrites, PermissionOverwrite):
+        return [overwrites.to_dict()]
+
+    raise ValueError(f"Invalid overwrites: {overwrites}")
+
+
+TYPE_ALL_CHANNEL = Union[
+    GuildText,
+    GuildForum,
+    GuildNews,
+    GuildVoice,
+    GuildStageVoice,
+    GuildCategory,
+    GuildPublicThread,
+    GuildForumPost,
+    GuildPrivateThread,
+    GuildNewsThread,
+    DM,
+    DMGroup,
+]
+
+
+TYPE_DM_CHANNEL = Union[DM, DMGroup]
+
+
+TYPE_GUILD_CHANNEL = Union[
+    GuildCategory,
+    GuildNews,
+    GuildText,
+    GuildVoice,
+    GuildStageVoice,
+    GuildForum,
+    GuildPublicThread,
+    GuildForumPost,
+    GuildPrivateThread,
+]
+
+
+TYPE_THREAD_CHANNEL = Union[GuildNewsThread, GuildPublicThread, GuildForumPost, GuildPrivateThread]
+
+
+TYPE_VOICE_CHANNEL = Union[GuildVoice, GuildStageVoice]
+
+
+TYPE_MESSAGEABLE_CHANNEL = Union[
+    DM,
+    DMGroup,
+    GuildNews,
+    GuildText,
+    GuildPublicThread,
+    GuildForumPost,
+    GuildPrivateThread,
+    GuildNewsThread,
+    GuildVoice,
+]
+
+
+TYPE_CHANNEL_MAPPING = {
+    ChannelType.GUILD_TEXT: GuildText,
+    ChannelType.GUILD_NEWS: GuildNews,
+    ChannelType.GUILD_VOICE: GuildVoice,
+    ChannelType.GUILD_STAGE_VOICE: GuildStageVoice,
+    ChannelType.GUILD_CATEGORY: GuildCategory,
+    ChannelType.GUILD_PUBLIC_THREAD: GuildPublicThread,
+    ChannelType.GUILD_PRIVATE_THREAD: GuildPrivateThread,
+    ChannelType.GUILD_NEWS_THREAD: GuildNewsThread,
+    ChannelType.DM: DM,
+    ChannelType.GROUP_DM: DMGroup,
+    ChannelType.GUILD_FORUM: GuildForum,
+}
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/components.py` & `discord-py-interactions-5.6.0/interactions/models/discord/components.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,713 +1,713 @@
-import contextlib
-import uuid
-from abc import abstractmethod
-from typing import Any, Dict, Iterator, List, Optional, Union
-
-import discord_typings
-
-from interactions.client.const import ACTION_ROW_MAX_ITEMS, MISSING
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.models.discord.emoji import PartialEmoji, process_emoji
-from interactions.models.discord.enums import ButtonStyle, ChannelType, ComponentType
-
-__all__ = (
-    "BaseComponent",
-    "InteractiveComponent",
-    "ActionRow",
-    "Button",
-    "BaseSelectMenu",
-    "StringSelectMenu",
-    "StringSelectOption",
-    "UserSelectMenu",
-    "RoleSelectMenu",
-    "MentionableSelectMenu",
-    "ChannelSelectMenu",
-    "process_components",
-    "spread_to_rows",
-    "get_components_ids",
-    "TYPE_COMPONENT_MAPPING",
-)
-
-
-class BaseComponent(DictSerializationMixin):
-    """
-    A base component class.
-
-    !!! Warning
-        This should never be directly instantiated.
-
-    """
-
-    type: ComponentType
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} type={self.type}>"
-
-    @classmethod
-    @abstractmethod
-    def from_dict(cls, data: dict) -> "BaseComponent":
-        """
-        Create a component from a dictionary.
-
-        Args:
-            data: the dictionary to create the component from
-
-        Returns:
-            The created component.
-
-        """
-        raise NotImplementedError
-
-    @classmethod
-    def from_dict_factory(
-        cls,
-        data: dict,
-        *,
-        alternate_mapping: dict[ComponentType, "BaseComponent"] | None = None,
-    ) -> "BaseComponent":
-        """
-        Creates a component from a payload.
-
-        Args:
-            data: the payload from Discord
-            alternate_mapping: an optional mapping of component types to classes
-        """
-        data.pop("hash", None)  # redundant
-
-        component_type = data.pop("type", None)
-
-        mapping = alternate_mapping or TYPE_COMPONENT_MAPPING
-
-        if component_class := mapping.get(component_type, None):
-            return component_class.from_dict(data)
-        raise TypeError(f"Unsupported component type for {data} ({component_type}), please consult the docs.")
-
-
-class InteractiveComponent(BaseComponent):
-    """
-    A base interactive component class.
-
-    !!! Warning
-        This should never be instantiated.
-
-    """
-
-    type: ComponentType
-    custom_id: str
-
-    def __eq__(self, other: Any) -> bool:
-        if isinstance(other, dict):
-            other = BaseComponent.from_dict_factory(other)
-        return self.custom_id == other.custom_id and self.type == other.type
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id}>"
-
-
-class ActionRow(BaseComponent):
-    """
-    Represents an action row.
-
-    Attributes:
-        components list[Dict | BaseComponent]: A sequence of components contained within this action row
-    """
-
-    def __init__(self, *components: Dict | BaseComponent) -> None:
-        if isinstance(components, (list, tuple)):
-            # flatten user error
-            components = list(components)
-
-        self.components: list[Dict | BaseComponent] = [
-            BaseComponent.from_dict_factory(c) if isinstance(c, dict) else c for c in components
-        ]
-
-        self.type: ComponentType = ComponentType.ACTION_ROW
-        self._max_items = ACTION_ROW_MAX_ITEMS
-
-    @classmethod
-    def from_dict(cls, data: discord_typings.ActionRowData) -> "ActionRow":
-        return cls(*data["components"])
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} type={self.type} components={len(self.components)}>"
-
-    def add_component(self, *components: dict | BaseComponent) -> None:
-        """
-        Add a component to this action row.
-
-        Args:
-            *components: The component(s) to add.
-        """
-        if isinstance(components, (list, tuple)):
-            # flatten user error
-            components = list(components)
-
-        self.components.extend(BaseComponent.from_dict_factory(c) if isinstance(c, dict) else c for c in components)
-
-    @classmethod
-    def split_components(cls, *components: dict | BaseComponent, count_per_row: int = 5) -> list["ActionRow"]:
-        """
-        Split components into action rows.
-
-        Args:
-            *components: The components to split.
-            count_per_row: The amount of components to have per row.
-
-        Returns:
-            A list of action rows.
-        """
-        buffer = []
-        action_rows = []
-
-        for component in components:
-            c_type = component.type if hasattr(component, "type") else component["type"]
-            if c_type in (
-                ComponentType.STRING_SELECT,
-                ComponentType.USER_SELECT,
-                ComponentType.ROLE_SELECT,
-                ComponentType.MENTIONABLE_SELECT,
-                ComponentType.CHANNEL_SELECT,
-            ):
-                # Selects can only be in their own row
-                if buffer:
-                    action_rows.append(cls(*buffer))
-                    buffer = []
-                action_rows.append(cls(component))
-            else:
-                buffer.append(component)
-                if len(buffer) >= count_per_row:
-                    action_rows.append(cls(*buffer))
-                    buffer = []
-
-        if buffer:
-            action_rows.append(cls(*buffer))
-        return action_rows
-
-    def to_dict(self) -> discord_typings.ActionRowData:
-        return {
-            "type": self.type.value,  # type: ignore
-            "components": [c.to_dict() for c in self.components],
-        }
-
-
-class Button(InteractiveComponent):
-    """
-    Represents a discord ui button.
-
-    Attributes:
-        style optional[ButtonStyle, int]: Buttons come in a variety of styles to convey different types of actions.
-        label optional[str]: The text that appears on the button, max 80 characters.
-        emoji optional[Union[PartialEmoji, dict, str]]: The emoji that appears on the button.
-        custom_id Optional[str]: A developer-defined identifier for the button, max 100 characters.
-        url Optional[str]: A url for link-style buttons.
-        disabled bool: Disable the button and make it not interactable, default false.
-
-    """
-
-    Styles: ButtonStyle = ButtonStyle
-
-    def __init__(
-        self,
-        *,
-        style: ButtonStyle | int,
-        label: str | None = None,
-        emoji: "PartialEmoji | None | str" = None,
-        custom_id: str = None,
-        url: str | None = None,
-        disabled: bool = False,
-    ) -> None:
-        self.style: ButtonStyle = ButtonStyle(style)
-        self.label: str | None = label
-        self.emoji: "PartialEmoji | None" = emoji
-        self.custom_id: str | None = custom_id
-        self.url: str | None = url
-        self.disabled: bool = disabled
-
-        self.type: ComponentType = ComponentType.BUTTON
-
-        if self.style == ButtonStyle.URL:
-            if self.custom_id is not None:
-                raise ValueError("URL buttons cannot have a custom_id.")
-            if self.url is None:
-                raise ValueError("URL buttons must have a url.")
-
-        elif self.custom_id is None:
-            self.custom_id = str(uuid.uuid4())
-        if not self.label and not self.emoji:
-            raise ValueError("Buttons must have a label or an emoji.")
-
-        if isinstance(self.emoji, str):
-            self.emoji = PartialEmoji.from_str(self.emoji)
-
-    @classmethod
-    def from_dict(cls, data: discord_typings.ButtonComponentData) -> "Button":
-        emoji = process_emoji(data.get("emoji"))
-        emoji = PartialEmoji.from_dict(emoji) if emoji else None
-        return cls(
-            style=ButtonStyle(data["style"]),
-            label=data.get("label"),
-            emoji=emoji,
-            custom_id=data.get("custom_id"),
-            url=data.get("url"),
-            disabled=data.get("disabled", False),
-        )
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} type={self.type} style={self.style} label={self.label} emoji={self.emoji} custom_id={self.custom_id} url={self.url} disabled={self.disabled}>"
-
-    def to_dict(self) -> discord_typings.ButtonComponentData:
-        emoji = self.emoji.to_dict() if self.emoji else None
-        if emoji and hasattr(emoji, "to_dict"):
-            emoji = emoji.to_dict()
-
-        return {
-            "type": self.type.value,  # type: ignore
-            "style": self.style.value,  # type: ignore
-            "label": self.label,
-            "emoji": emoji,
-            "custom_id": self.custom_id,
-            "url": self.url,
-            "disabled": self.disabled,
-        }
-
-
-class BaseSelectMenu(InteractiveComponent):
-    """
-    Represents a select menu component
-
-    Attributes:
-        custom_id str: A developer-defined identifier for the button, max 100 characters.
-        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
-        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
-        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
-        disabled bool: Disable the select and make it not intractable, default false.
-        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
-    """
-
-    def __init__(
-        self,
-        *,
-        placeholder: str | None = None,
-        min_values: int = 1,
-        max_values: int = 1,
-        custom_id: str | None = None,
-        disabled: bool = False,
-    ) -> None:
-        self.custom_id: str = custom_id or str(uuid.uuid4())
-        self.placeholder: str | None = placeholder
-        self.min_values: int = min_values
-        self.max_values: int = max_values
-        self.disabled: bool = disabled
-
-        self.type: ComponentType = MISSING
-
-    @classmethod
-    def from_dict(cls, data: discord_typings.SelectMenuComponentData) -> "BaseSelectMenu":
-        return cls(
-            placeholder=data.get("placeholder"),
-            min_values=data["min_values"],
-            max_values=data["max_values"],
-            custom_id=data["custom_id"],
-            disabled=data.get("disabled", False),
-        )
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id} placeholder={self.placeholder} min_values={self.min_values} max_values={self.max_values} disabled={self.disabled}>"
-
-    def to_dict(self) -> discord_typings.SelectMenuComponentData:
-        return {
-            "type": self.type.value,  # type: ignore
-            "custom_id": self.custom_id,
-            "placeholder": self.placeholder,
-            "min_values": self.min_values,
-            "max_values": self.max_values,
-            "disabled": self.disabled,
-        }
-
-
-class StringSelectOption(BaseComponent):
-    """
-    Represents a select option.
-
-    Attributes:
-        label str: The label (max 80 characters)
-        value str: The value of the select, this is whats sent to your bot
-        description Optional[str]: A description of this option
-        emoji Optional[Union[PartialEmoji, dict, str]: An emoji to show in this select option
-        default bool: Is this option selected by default
-    """
-
-    def __init__(
-        self,
-        *,
-        label: str,
-        value: str,
-        description: str | None = None,
-        emoji: "PartialEmoji | None | str" = None,
-        default: bool = False,
-    ) -> None:
-        self.label: str = label
-        self.value: str = value
-        self.description: str | None = description
-        self.emoji: PartialEmoji | None = emoji
-        self.default: bool = default
-
-        if isinstance(self.emoji, str):
-            self.emoji = PartialEmoji.from_str(self.emoji)
-
-    @classmethod
-    def converter(cls, value: Any) -> "StringSelectOption":
-        if isinstance(value, StringSelectOption):
-            return value
-        if isinstance(value, dict):
-            return cls.from_dict(value)
-
-        if isinstance(value, str):
-            return cls(label=value, value=value)
-
-        with contextlib.suppress(TypeError):
-            possible_iter = iter(value)
-
-            return cls(label=possible_iter[0], value=possible_iter[1])
-        raise TypeError(f"Cannot convert {value} of type {type(value)} to a SelectOption")
-
-    @classmethod
-    def from_dict(cls, data: discord_typings.SelectMenuOptionData) -> "StringSelectOption":
-        emoji = process_emoji(data.get("emoji"))
-        emoji = PartialEmoji.from_dict(emoji) if emoji else None
-        return cls(
-            label=data["label"],
-            value=data["value"],
-            description=data.get("description"),
-            emoji=emoji,
-            default=data.get("default", False),
-        )
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} label={self.label} value={self.value} description={self.description} emoji={self.emoji} default={self.default}>"
-
-    def to_dict(self) -> discord_typings.SelectMenuOptionData:
-        emoji = self.emoji.to_dict() if self.emoji else None
-        if emoji and hasattr(emoji, "to_dict"):
-            emoji = emoji.to_dict()
-
-        return {
-            "label": self.label,
-            "value": self.value,
-            "description": self.description,
-            "emoji": emoji,
-            "default": self.default,
-        }
-
-
-class StringSelectMenu(BaseSelectMenu):
-    """
-    Represents a string select component.
-
-    Attributes:
-        options List[dict]: The choices in the select, max 25.
-        custom_id str: A developer-defined identifier for the button, max 100 characters.
-        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
-        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
-        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
-        disabled bool: Disable the select and make it not intractable, default false.
-        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
-    """
-
-    def __init__(
-        self,
-        *options: StringSelectOption
-        | str
-        | discord_typings.SelectMenuOptionData
-        | list[StringSelectOption | str | discord_typings.SelectMenuOptionData],
-        placeholder: str | None = None,
-        min_values: int = 1,
-        max_values: int = 1,
-        custom_id: str | None = None,
-        disabled: bool = False,
-    ) -> None:
-        super().__init__(
-            placeholder=placeholder,
-            min_values=min_values,
-            max_values=max_values,
-            custom_id=custom_id,
-            disabled=disabled,
-        )
-        if isinstance(options, (list, tuple)) and len(options) == 1 and isinstance(options[0], (list, tuple)):
-            # user passed in a list of options, expand it out
-            options = options[0]
-
-        self.options: list[StringSelectOption] = [StringSelectOption.converter(option) for option in options]
-        self.type: ComponentType = ComponentType.STRING_SELECT
-
-    @classmethod
-    def from_dict(cls, data: discord_typings.SelectMenuComponentData) -> "StringSelectMenu":
-        return cls(
-            *data["options"],
-            placeholder=data.get("placeholder"),
-            min_values=data["min_values"],
-            max_values=data["max_values"],
-            custom_id=data["custom_id"],
-            disabled=data.get("disabled", False),
-        )
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id} placeholder={self.placeholder} min_values={self.min_values} max_values={self.max_values} disabled={self.disabled} options={self.options}>"
-
-    def to_dict(self) -> discord_typings.SelectMenuComponentData:
-        return {
-            **super().to_dict(),
-            "options": [option.to_dict() for option in self.options],
-        }
-
-
-class UserSelectMenu(BaseSelectMenu):
-    """
-    Represents a user select component.
-
-    Attributes:
-        custom_id str: A developer-defined identifier for the button, max 100 characters.
-        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
-        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
-        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
-        disabled bool: Disable the select and make it not intractable, default false.
-        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
-    """
-
-    def __init__(
-        self,
-        *,
-        placeholder: str | None = None,
-        min_values: int = 1,
-        max_values: int = 1,
-        custom_id: str | None = None,
-        disabled: bool = False,
-    ) -> None:
-        super().__init__(
-            placeholder=placeholder,
-            min_values=min_values,
-            max_values=max_values,
-            custom_id=custom_id,
-            disabled=disabled,
-        )
-
-        self.type: ComponentType = ComponentType.USER_SELECT
-
-
-class RoleSelectMenu(BaseSelectMenu):
-    """
-    Represents a user select component.
-
-    Attributes:
-        custom_id str: A developer-defined identifier for the button, max 100 characters.
-        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
-        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
-        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
-        disabled bool: Disable the select and make it not intractable, default false.
-        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
-    """
-
-    def __init__(
-        self,
-        *,
-        placeholder: str | None = None,
-        min_values: int = 1,
-        max_values: int = 1,
-        custom_id: str | None = None,
-        disabled: bool = False,
-    ) -> None:
-        super().__init__(
-            placeholder=placeholder,
-            min_values=min_values,
-            max_values=max_values,
-            custom_id=custom_id,
-            disabled=disabled,
-        )
-
-        self.type: ComponentType = ComponentType.ROLE_SELECT
-
-
-class MentionableSelectMenu(BaseSelectMenu):
-    def __init__(
-        self,
-        *,
-        placeholder: str | None = None,
-        min_values: int = 1,
-        max_values: int = 1,
-        custom_id: str | None = None,
-        disabled: bool = False,
-    ) -> None:
-        super().__init__(
-            placeholder=placeholder,
-            min_values=min_values,
-            max_values=max_values,
-            custom_id=custom_id,
-            disabled=disabled,
-        )
-
-        self.type: ComponentType = ComponentType.MENTIONABLE_SELECT
-
-
-class ChannelSelectMenu(BaseSelectMenu):
-    def __init__(
-        self,
-        *,
-        channel_types: list[ChannelType] | None = None,
-        placeholder: str | None = None,
-        min_values: int = 1,
-        max_values: int = 1,
-        custom_id: str | None = None,
-        disabled: bool = False,
-    ) -> None:
-        super().__init__(
-            placeholder=placeholder,
-            min_values=min_values,
-            max_values=max_values,
-            custom_id=custom_id,
-            disabled=disabled,
-        )
-
-        self.channel_types: list[ChannelType] | None = channel_types or []
-        self.type: ComponentType = ComponentType.CHANNEL_SELECT
-
-    ChannelTypes: ChannelType = ChannelType
-
-    @classmethod
-    def from_dict(cls, data: discord_typings.SelectMenuComponentData) -> "ChannelSelectMenu":
-        return cls(
-            placeholder=data.get("placeholder"),
-            min_values=data["min_values"],
-            max_values=data["max_values"],
-            custom_id=data["custom_id"],
-            disabled=data.get("disabled", False),
-            channel_types=data.get("channel_types", []),
-        )
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id} placeholder={self.placeholder} min_values={self.min_values} max_values={self.max_values} disabled={self.disabled} channel_types={self.channel_types}>"
-
-    def to_dict(self) -> discord_typings.SelectMenuComponentData:
-        return {
-            **super().to_dict(),
-            "channel_types": self.channel_types,
-        }
-
-
-def process_components(
-    components: Optional[
-        Union[
-            List[List[Union[BaseComponent, Dict]]],
-            List[Union[BaseComponent, Dict]],
-            BaseComponent,
-            Dict,
-        ]
-    ]
-) -> List[Dict]:
-    """
-    Process the passed components into a format discord will understand.
-
-    Args:
-        components: List of dict / components to process
-
-    Returns:
-        formatted dictionary for discord
-
-    Raises:
-        ValueError: Invalid components
-
-    """
-    if not components:
-        # Its just empty, so nothing to process.
-        return components
-
-    if isinstance(components, dict):
-        # If a naked dictionary is passed, assume the user knows what they're doing and send it blindly
-        # after wrapping it in a list for discord
-        return [components]
-
-    if issubclass(type(components), BaseComponent):
-        # Naked component was passed
-        components = [components]
-
-    if isinstance(components, list):
-        if all(isinstance(c, dict) for c in components):
-            # user has passed a list of dicts, this is the correct format, blindly send it
-            return components
-
-        if all(isinstance(c, list) for c in components):
-            # list of lists... actionRow-less sending
-            return [ActionRow(*row).to_dict() for row in components]
-
-        if all(issubclass(type(c), InteractiveComponent) for c in components):
-            # list of naked components
-            return [ActionRow(*components).to_dict()]
-
-        if all(isinstance(c, ActionRow) for c in components):
-            # we have a list of action rows
-            return [action_row.to_dict() for action_row in components]
-
-    raise ValueError(f"Invalid components: {components}")
-
-
-def spread_to_rows(*components: Union[ActionRow, Button, StringSelectMenu], max_in_row: int = 5) -> List[ActionRow]:
-    """
-    A helper function that spreads your components into `ActionRow`s of a set size.
-
-    Args:
-        *components: The components to spread, use `None` to explicit start a new row
-        max_in_row: The maximum number of components in each row
-
-    Returns:
-        List[ActionRow] of components spread to rows
-
-    Raises:
-        ValueError: Too many or few components or rows
-
-    """
-    # todo: incorrect format errors
-    if not components or len(components) > 25:
-        raise ValueError("Number of components should be between 1 and 25.")
-    return ActionRow.split_components(*components, count_per_row=max_in_row)
-
-
-def get_components_ids(component: Union[str, dict, list, InteractiveComponent]) -> Iterator[str]:
-    """
-    Creates a generator with the `custom_id` of a component or list of components.
-
-    Args:
-        component: Objects to get `custom_id`s from
-
-    Returns:
-        Generator with the `custom_id` of a component or list of components.
-
-    Raises:
-        ValueError: Unknown component type
-
-    """
-    if isinstance(component, str):
-        yield component
-    elif isinstance(component, dict):
-        if component["type"] == ComponentType.actionrow:
-            yield from (comp["custom_id"] for comp in component["components"] if "custom_id" in comp)
-        elif "custom_id" in component:
-            yield component["custom_id"]
-    elif c_id := getattr(component, "custom_id", None):
-        yield c_id
-    elif isinstance(component, ActionRow):
-        yield from (comp_id for comp in component.components for comp_id in get_components_ids(comp))
-
-    elif isinstance(component, list):
-        yield from (comp_id for comp in component for comp_id in get_components_ids(comp))
-    else:
-        raise ValueError(f"Unknown component type of {component} ({type(component)}). " f"Expected str, dict or list")
-
-
-TYPE_COMPONENT_MAPPING = {
-    ComponentType.ACTION_ROW: ActionRow,
-    ComponentType.BUTTON: Button,
-    ComponentType.STRING_SELECT: StringSelectMenu,
-    ComponentType.USER_SELECT: UserSelectMenu,
-    ComponentType.CHANNEL_SELECT: ChannelSelectMenu,
-    ComponentType.ROLE_SELECT: RoleSelectMenu,
-    ComponentType.MENTIONABLE_SELECT: MentionableSelectMenu,
-}
+import contextlib
+import uuid
+from abc import abstractmethod
+from typing import Any, Dict, Iterator, List, Optional, Union
+
+import discord_typings
+
+from interactions.client.const import ACTION_ROW_MAX_ITEMS, MISSING
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.models.discord.emoji import PartialEmoji, process_emoji
+from interactions.models.discord.enums import ButtonStyle, ChannelType, ComponentType
+
+__all__ = (
+    "BaseComponent",
+    "InteractiveComponent",
+    "ActionRow",
+    "Button",
+    "BaseSelectMenu",
+    "StringSelectMenu",
+    "StringSelectOption",
+    "UserSelectMenu",
+    "RoleSelectMenu",
+    "MentionableSelectMenu",
+    "ChannelSelectMenu",
+    "process_components",
+    "spread_to_rows",
+    "get_components_ids",
+    "TYPE_COMPONENT_MAPPING",
+)
+
+
+class BaseComponent(DictSerializationMixin):
+    """
+    A base component class.
+
+    !!! Warning
+        This should never be directly instantiated.
+
+    """
+
+    type: ComponentType
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} type={self.type}>"
+
+    @classmethod
+    @abstractmethod
+    def from_dict(cls, data: dict) -> "BaseComponent":
+        """
+        Create a component from a dictionary.
+
+        Args:
+            data: the dictionary to create the component from
+
+        Returns:
+            The created component.
+
+        """
+        raise NotImplementedError
+
+    @classmethod
+    def from_dict_factory(
+        cls,
+        data: dict,
+        *,
+        alternate_mapping: dict[ComponentType, "BaseComponent"] | None = None,
+    ) -> "BaseComponent":
+        """
+        Creates a component from a payload.
+
+        Args:
+            data: the payload from Discord
+            alternate_mapping: an optional mapping of component types to classes
+        """
+        data.pop("hash", None)  # redundant
+
+        component_type = data.pop("type", None)
+
+        mapping = alternate_mapping or TYPE_COMPONENT_MAPPING
+
+        if component_class := mapping.get(component_type, None):
+            return component_class.from_dict(data)
+        raise TypeError(f"Unsupported component type for {data} ({component_type}), please consult the docs.")
+
+
+class InteractiveComponent(BaseComponent):
+    """
+    A base interactive component class.
+
+    !!! Warning
+        This should never be instantiated.
+
+    """
+
+    type: ComponentType
+    custom_id: str
+
+    def __eq__(self, other: Any) -> bool:
+        if isinstance(other, dict):
+            other = BaseComponent.from_dict_factory(other)
+        return self.custom_id == other.custom_id and self.type == other.type
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id}>"
+
+
+class ActionRow(BaseComponent):
+    """
+    Represents an action row.
+
+    Attributes:
+        components list[Dict | BaseComponent]: A sequence of components contained within this action row
+    """
+
+    def __init__(self, *components: Dict | BaseComponent) -> None:
+        if isinstance(components, (list, tuple)):
+            # flatten user error
+            components = list(components)
+
+        self.components: list[Dict | BaseComponent] = [
+            BaseComponent.from_dict_factory(c) if isinstance(c, dict) else c for c in components
+        ]
+
+        self.type: ComponentType = ComponentType.ACTION_ROW
+        self._max_items = ACTION_ROW_MAX_ITEMS
+
+    @classmethod
+    def from_dict(cls, data: discord_typings.ActionRowData) -> "ActionRow":
+        return cls(*data["components"])
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} type={self.type} components={len(self.components)}>"
+
+    def add_component(self, *components: dict | BaseComponent) -> None:
+        """
+        Add a component to this action row.
+
+        Args:
+            *components: The component(s) to add.
+        """
+        if isinstance(components, (list, tuple)):
+            # flatten user error
+            components = list(components)
+
+        self.components.extend(BaseComponent.from_dict_factory(c) if isinstance(c, dict) else c for c in components)
+
+    @classmethod
+    def split_components(cls, *components: dict | BaseComponent, count_per_row: int = 5) -> list["ActionRow"]:
+        """
+        Split components into action rows.
+
+        Args:
+            *components: The components to split.
+            count_per_row: The amount of components to have per row.
+
+        Returns:
+            A list of action rows.
+        """
+        buffer = []
+        action_rows = []
+
+        for component in components:
+            c_type = component.type if hasattr(component, "type") else component["type"]
+            if c_type in (
+                ComponentType.STRING_SELECT,
+                ComponentType.USER_SELECT,
+                ComponentType.ROLE_SELECT,
+                ComponentType.MENTIONABLE_SELECT,
+                ComponentType.CHANNEL_SELECT,
+            ):
+                # Selects can only be in their own row
+                if buffer:
+                    action_rows.append(cls(*buffer))
+                    buffer = []
+                action_rows.append(cls(component))
+            else:
+                buffer.append(component)
+                if len(buffer) >= count_per_row:
+                    action_rows.append(cls(*buffer))
+                    buffer = []
+
+        if buffer:
+            action_rows.append(cls(*buffer))
+        return action_rows
+
+    def to_dict(self) -> discord_typings.ActionRowData:
+        return {
+            "type": self.type.value,  # type: ignore
+            "components": [c.to_dict() for c in self.components],
+        }
+
+
+class Button(InteractiveComponent):
+    """
+    Represents a discord ui button.
+
+    Attributes:
+        style optional[ButtonStyle, int]: Buttons come in a variety of styles to convey different types of actions.
+        label optional[str]: The text that appears on the button, max 80 characters.
+        emoji optional[Union[PartialEmoji, dict, str]]: The emoji that appears on the button.
+        custom_id Optional[str]: A developer-defined identifier for the button, max 100 characters.
+        url Optional[str]: A url for link-style buttons.
+        disabled bool: Disable the button and make it not interactable, default false.
+
+    """
+
+    Styles: ButtonStyle = ButtonStyle
+
+    def __init__(
+        self,
+        *,
+        style: ButtonStyle | int,
+        label: str | None = None,
+        emoji: "PartialEmoji | None | str" = None,
+        custom_id: str = None,
+        url: str | None = None,
+        disabled: bool = False,
+    ) -> None:
+        self.style: ButtonStyle = ButtonStyle(style)
+        self.label: str | None = label
+        self.emoji: "PartialEmoji | None" = emoji
+        self.custom_id: str | None = custom_id
+        self.url: str | None = url
+        self.disabled: bool = disabled
+
+        self.type: ComponentType = ComponentType.BUTTON
+
+        if self.style == ButtonStyle.URL:
+            if self.custom_id is not None:
+                raise ValueError("URL buttons cannot have a custom_id.")
+            if self.url is None:
+                raise ValueError("URL buttons must have a url.")
+
+        elif self.custom_id is None:
+            self.custom_id = str(uuid.uuid4())
+        if not self.label and not self.emoji:
+            raise ValueError("Buttons must have a label or an emoji.")
+
+        if isinstance(self.emoji, str):
+            self.emoji = PartialEmoji.from_str(self.emoji)
+
+    @classmethod
+    def from_dict(cls, data: discord_typings.ButtonComponentData) -> "Button":
+        emoji = process_emoji(data.get("emoji"))
+        emoji = PartialEmoji.from_dict(emoji) if emoji else None
+        return cls(
+            style=ButtonStyle(data["style"]),
+            label=data.get("label"),
+            emoji=emoji,
+            custom_id=data.get("custom_id"),
+            url=data.get("url"),
+            disabled=data.get("disabled", False),
+        )
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} type={self.type} style={self.style} label={self.label} emoji={self.emoji} custom_id={self.custom_id} url={self.url} disabled={self.disabled}>"
+
+    def to_dict(self) -> discord_typings.ButtonComponentData:
+        emoji = self.emoji.to_dict() if self.emoji else None
+        if emoji and hasattr(emoji, "to_dict"):
+            emoji = emoji.to_dict()
+
+        return {
+            "type": self.type.value,  # type: ignore
+            "style": self.style.value,  # type: ignore
+            "label": self.label,
+            "emoji": emoji,
+            "custom_id": self.custom_id,
+            "url": self.url,
+            "disabled": self.disabled,
+        }
+
+
+class BaseSelectMenu(InteractiveComponent):
+    """
+    Represents a select menu component
+
+    Attributes:
+        custom_id str: A developer-defined identifier for the button, max 100 characters.
+        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
+        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
+        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
+        disabled bool: Disable the select and make it not intractable, default false.
+        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
+    """
+
+    def __init__(
+        self,
+        *,
+        placeholder: str | None = None,
+        min_values: int = 1,
+        max_values: int = 1,
+        custom_id: str | None = None,
+        disabled: bool = False,
+    ) -> None:
+        self.custom_id: str = custom_id or str(uuid.uuid4())
+        self.placeholder: str | None = placeholder
+        self.min_values: int = min_values
+        self.max_values: int = max_values
+        self.disabled: bool = disabled
+
+        self.type: ComponentType = MISSING
+
+    @classmethod
+    def from_dict(cls, data: discord_typings.SelectMenuComponentData) -> "BaseSelectMenu":
+        return cls(
+            placeholder=data.get("placeholder"),
+            min_values=data["min_values"],
+            max_values=data["max_values"],
+            custom_id=data["custom_id"],
+            disabled=data.get("disabled", False),
+        )
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id} placeholder={self.placeholder} min_values={self.min_values} max_values={self.max_values} disabled={self.disabled}>"
+
+    def to_dict(self) -> discord_typings.SelectMenuComponentData:
+        return {
+            "type": self.type.value,  # type: ignore
+            "custom_id": self.custom_id,
+            "placeholder": self.placeholder,
+            "min_values": self.min_values,
+            "max_values": self.max_values,
+            "disabled": self.disabled,
+        }
+
+
+class StringSelectOption(BaseComponent):
+    """
+    Represents a select option.
+
+    Attributes:
+        label str: The label (max 80 characters)
+        value str: The value of the select, this is whats sent to your bot
+        description Optional[str]: A description of this option
+        emoji Optional[Union[PartialEmoji, dict, str]: An emoji to show in this select option
+        default bool: Is this option selected by default
+    """
+
+    def __init__(
+        self,
+        *,
+        label: str,
+        value: str,
+        description: str | None = None,
+        emoji: "PartialEmoji | None | str" = None,
+        default: bool = False,
+    ) -> None:
+        self.label: str = label
+        self.value: str = value
+        self.description: str | None = description
+        self.emoji: PartialEmoji | None = emoji
+        self.default: bool = default
+
+        if isinstance(self.emoji, str):
+            self.emoji = PartialEmoji.from_str(self.emoji)
+
+    @classmethod
+    def converter(cls, value: Any) -> "StringSelectOption":
+        if isinstance(value, StringSelectOption):
+            return value
+        if isinstance(value, dict):
+            return cls.from_dict(value)
+
+        if isinstance(value, str):
+            return cls(label=value, value=value)
+
+        with contextlib.suppress(TypeError):
+            possible_iter = iter(value)
+
+            return cls(label=possible_iter[0], value=possible_iter[1])
+        raise TypeError(f"Cannot convert {value} of type {type(value)} to a SelectOption")
+
+    @classmethod
+    def from_dict(cls, data: discord_typings.SelectMenuOptionData) -> "StringSelectOption":
+        emoji = process_emoji(data.get("emoji"))
+        emoji = PartialEmoji.from_dict(emoji) if emoji else None
+        return cls(
+            label=data["label"],
+            value=data["value"],
+            description=data.get("description"),
+            emoji=emoji,
+            default=data.get("default", False),
+        )
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} label={self.label} value={self.value} description={self.description} emoji={self.emoji} default={self.default}>"
+
+    def to_dict(self) -> discord_typings.SelectMenuOptionData:
+        emoji = self.emoji.to_dict() if self.emoji else None
+        if emoji and hasattr(emoji, "to_dict"):
+            emoji = emoji.to_dict()
+
+        return {
+            "label": self.label,
+            "value": self.value,
+            "description": self.description,
+            "emoji": emoji,
+            "default": self.default,
+        }
+
+
+class StringSelectMenu(BaseSelectMenu):
+    """
+    Represents a string select component.
+
+    Attributes:
+        options List[dict]: The choices in the select, max 25.
+        custom_id str: A developer-defined identifier for the button, max 100 characters.
+        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
+        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
+        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
+        disabled bool: Disable the select and make it not intractable, default false.
+        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
+    """
+
+    def __init__(
+        self,
+        *options: StringSelectOption
+        | str
+        | discord_typings.SelectMenuOptionData
+        | list[StringSelectOption | str | discord_typings.SelectMenuOptionData],
+        placeholder: str | None = None,
+        min_values: int = 1,
+        max_values: int = 1,
+        custom_id: str | None = None,
+        disabled: bool = False,
+    ) -> None:
+        super().__init__(
+            placeholder=placeholder,
+            min_values=min_values,
+            max_values=max_values,
+            custom_id=custom_id,
+            disabled=disabled,
+        )
+        if isinstance(options, (list, tuple)) and len(options) == 1 and isinstance(options[0], (list, tuple)):
+            # user passed in a list of options, expand it out
+            options = options[0]
+
+        self.options: list[StringSelectOption] = [StringSelectOption.converter(option) for option in options]
+        self.type: ComponentType = ComponentType.STRING_SELECT
+
+    @classmethod
+    def from_dict(cls, data: discord_typings.SelectMenuComponentData) -> "StringSelectMenu":
+        return cls(
+            *data["options"],
+            placeholder=data.get("placeholder"),
+            min_values=data["min_values"],
+            max_values=data["max_values"],
+            custom_id=data["custom_id"],
+            disabled=data.get("disabled", False),
+        )
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id} placeholder={self.placeholder} min_values={self.min_values} max_values={self.max_values} disabled={self.disabled} options={self.options}>"
+
+    def to_dict(self) -> discord_typings.SelectMenuComponentData:
+        return {
+            **super().to_dict(),
+            "options": [option.to_dict() for option in self.options],
+        }
+
+
+class UserSelectMenu(BaseSelectMenu):
+    """
+    Represents a user select component.
+
+    Attributes:
+        custom_id str: A developer-defined identifier for the button, max 100 characters.
+        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
+        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
+        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
+        disabled bool: Disable the select and make it not intractable, default false.
+        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
+    """
+
+    def __init__(
+        self,
+        *,
+        placeholder: str | None = None,
+        min_values: int = 1,
+        max_values: int = 1,
+        custom_id: str | None = None,
+        disabled: bool = False,
+    ) -> None:
+        super().__init__(
+            placeholder=placeholder,
+            min_values=min_values,
+            max_values=max_values,
+            custom_id=custom_id,
+            disabled=disabled,
+        )
+
+        self.type: ComponentType = ComponentType.USER_SELECT
+
+
+class RoleSelectMenu(BaseSelectMenu):
+    """
+    Represents a user select component.
+
+    Attributes:
+        custom_id str: A developer-defined identifier for the button, max 100 characters.
+        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.
+        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)
+        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)
+        disabled bool: Disable the select and make it not intractable, default false.
+        type Union[ComponentType, int]: The action role type number defined by discord. This cannot be modified.
+    """
+
+    def __init__(
+        self,
+        *,
+        placeholder: str | None = None,
+        min_values: int = 1,
+        max_values: int = 1,
+        custom_id: str | None = None,
+        disabled: bool = False,
+    ) -> None:
+        super().__init__(
+            placeholder=placeholder,
+            min_values=min_values,
+            max_values=max_values,
+            custom_id=custom_id,
+            disabled=disabled,
+        )
+
+        self.type: ComponentType = ComponentType.ROLE_SELECT
+
+
+class MentionableSelectMenu(BaseSelectMenu):
+    def __init__(
+        self,
+        *,
+        placeholder: str | None = None,
+        min_values: int = 1,
+        max_values: int = 1,
+        custom_id: str | None = None,
+        disabled: bool = False,
+    ) -> None:
+        super().__init__(
+            placeholder=placeholder,
+            min_values=min_values,
+            max_values=max_values,
+            custom_id=custom_id,
+            disabled=disabled,
+        )
+
+        self.type: ComponentType = ComponentType.MENTIONABLE_SELECT
+
+
+class ChannelSelectMenu(BaseSelectMenu):
+    def __init__(
+        self,
+        *,
+        channel_types: list[ChannelType] | None = None,
+        placeholder: str | None = None,
+        min_values: int = 1,
+        max_values: int = 1,
+        custom_id: str | None = None,
+        disabled: bool = False,
+    ) -> None:
+        super().__init__(
+            placeholder=placeholder,
+            min_values=min_values,
+            max_values=max_values,
+            custom_id=custom_id,
+            disabled=disabled,
+        )
+
+        self.channel_types: list[ChannelType] | None = channel_types or []
+        self.type: ComponentType = ComponentType.CHANNEL_SELECT
+
+    ChannelTypes: ChannelType = ChannelType
+
+    @classmethod
+    def from_dict(cls, data: discord_typings.SelectMenuComponentData) -> "ChannelSelectMenu":
+        return cls(
+            placeholder=data.get("placeholder"),
+            min_values=data["min_values"],
+            max_values=data["max_values"],
+            custom_id=data["custom_id"],
+            disabled=data.get("disabled", False),
+            channel_types=data.get("channel_types", []),
+        )
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} type={self.type} custom_id={self.custom_id} placeholder={self.placeholder} min_values={self.min_values} max_values={self.max_values} disabled={self.disabled} channel_types={self.channel_types}>"
+
+    def to_dict(self) -> discord_typings.SelectMenuComponentData:
+        return {
+            **super().to_dict(),
+            "channel_types": self.channel_types,
+        }
+
+
+def process_components(
+    components: Optional[
+        Union[
+            List[List[Union[BaseComponent, Dict]]],
+            List[Union[BaseComponent, Dict]],
+            BaseComponent,
+            Dict,
+        ]
+    ]
+) -> List[Dict]:
+    """
+    Process the passed components into a format discord will understand.
+
+    Args:
+        components: List of dict / components to process
+
+    Returns:
+        formatted dictionary for discord
+
+    Raises:
+        ValueError: Invalid components
+
+    """
+    if not components:
+        # Its just empty, so nothing to process.
+        return components
+
+    if isinstance(components, dict):
+        # If a naked dictionary is passed, assume the user knows what they're doing and send it blindly
+        # after wrapping it in a list for discord
+        return [components]
+
+    if issubclass(type(components), BaseComponent):
+        # Naked component was passed
+        components = [components]
+
+    if isinstance(components, list):
+        if all(isinstance(c, dict) for c in components):
+            # user has passed a list of dicts, this is the correct format, blindly send it
+            return components
+
+        if all(isinstance(c, list) for c in components):
+            # list of lists... actionRow-less sending
+            return [ActionRow(*row).to_dict() for row in components]
+
+        if all(issubclass(type(c), InteractiveComponent) for c in components):
+            # list of naked components
+            return [ActionRow(*components).to_dict()]
+
+        if all(isinstance(c, ActionRow) for c in components):
+            # we have a list of action rows
+            return [action_row.to_dict() for action_row in components]
+
+    raise ValueError(f"Invalid components: {components}")
+
+
+def spread_to_rows(*components: Union[ActionRow, Button, StringSelectMenu], max_in_row: int = 5) -> List[ActionRow]:
+    """
+    A helper function that spreads your components into `ActionRow`s of a set size.
+
+    Args:
+        *components: The components to spread, use `None` to explicit start a new row
+        max_in_row: The maximum number of components in each row
+
+    Returns:
+        List[ActionRow] of components spread to rows
+
+    Raises:
+        ValueError: Too many or few components or rows
+
+    """
+    # todo: incorrect format errors
+    if not components or len(components) > 25:
+        raise ValueError("Number of components should be between 1 and 25.")
+    return ActionRow.split_components(*components, count_per_row=max_in_row)
+
+
+def get_components_ids(component: Union[str, dict, list, InteractiveComponent]) -> Iterator[str]:
+    """
+    Creates a generator with the `custom_id` of a component or list of components.
+
+    Args:
+        component: Objects to get `custom_id`s from
+
+    Returns:
+        Generator with the `custom_id` of a component or list of components.
+
+    Raises:
+        ValueError: Unknown component type
+
+    """
+    if isinstance(component, str):
+        yield component
+    elif isinstance(component, dict):
+        if component["type"] == ComponentType.actionrow:
+            yield from (comp["custom_id"] for comp in component["components"] if "custom_id" in comp)
+        elif "custom_id" in component:
+            yield component["custom_id"]
+    elif c_id := getattr(component, "custom_id", None):
+        yield c_id
+    elif isinstance(component, ActionRow):
+        yield from (comp_id for comp in component.components for comp_id in get_components_ids(comp))
+
+    elif isinstance(component, list):
+        yield from (comp_id for comp in component for comp_id in get_components_ids(comp))
+    else:
+        raise ValueError(f"Unknown component type of {component} ({type(component)}). " f"Expected str, dict or list")
+
+
+TYPE_COMPONENT_MAPPING = {
+    ComponentType.ACTION_ROW: ActionRow,
+    ComponentType.BUTTON: Button,
+    ComponentType.STRING_SELECT: StringSelectMenu,
+    ComponentType.USER_SELECT: UserSelectMenu,
+    ComponentType.CHANNEL_SELECT: ChannelSelectMenu,
+    ComponentType.ROLE_SELECT: RoleSelectMenu,
+    ComponentType.MENTIONABLE_SELECT: MentionableSelectMenu,
+}
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/embed.py` & `discord-py-interactions-5.6.0/interactions/models/discord/embed.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,489 +1,489 @@
-from datetime import datetime
-from typing import Any, Dict, List, Optional, Union
-
-import attrs
-from attrs.validators import instance_of
-from attrs.validators import optional as v_optional
-
-from interactions.client.const import (
-    EMBED_MAX_NAME_LENGTH,
-    EMBED_MAX_FIELDS,
-    EMBED_MAX_DESC_LENGTH,
-    EMBED_TOTAL_MAX,
-    EMBED_FIELD_VALUE_LENGTH,
-)
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.attr_converters import optional as c_optional, list_converter
-from interactions.client.utils.attr_converters import timestamp_converter
-from interactions.client.utils.serializer import no_export_meta, export_converter
-from interactions.models.discord.color import Color, process_color
-from interactions.models.discord.enums import EmbedType
-from interactions.models.discord.timestamp import Timestamp
-
-__all__ = (
-    "EmbedField",
-    "EmbedAuthor",
-    "EmbedAttachment",
-    "EmbedAuthor",
-    "EmbedFooter",
-    "EmbedProvider",
-    "Embed",
-    "process_embeds",
-)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class EmbedField(DictSerializationMixin):
-    """
-    Representation of an embed field.
-
-    Attributes:
-        name: Field name
-        value: Field value
-        inline: If the field should be inline
-
-    """
-
-    name: str = attrs.field(
-        repr=False,
-    )
-    value: str = attrs.field(
-        repr=False,
-    )
-    inline: bool = attrs.field(repr=False, default=False)
-
-    @name.validator
-    def _name_validation(self, attribute: str, value: Any) -> None:
-        if len(value) > EMBED_MAX_NAME_LENGTH:
-            raise ValueError(f"Field name cannot exceed {EMBED_MAX_NAME_LENGTH} characters")
-
-    @value.validator
-    def _value_validation(self, attribute: str, value: Any) -> None:
-        if len(value) > EMBED_FIELD_VALUE_LENGTH:
-            raise ValueError(f"Field value cannot exceed {EMBED_FIELD_VALUE_LENGTH} characters")
-
-    def __len__(self) -> int:
-        return len(self.name) + len(self.value)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class EmbedAuthor(DictSerializationMixin):
-    """
-    Representation of an embed author.
-
-    Attributes:
-        name: Name to show on embed
-        url: Url to go to when name is clicked
-        icon_url: Icon to show next to name
-        proxy_icon_url: Proxy icon url
-
-    """
-
-    name: Optional[str] = attrs.field(repr=False, default=None)
-    url: Optional[str] = attrs.field(repr=False, default=None)
-    icon_url: Optional[str] = attrs.field(repr=False, default=None)
-    proxy_icon_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)
-
-    @name.validator
-    def _name_validation(self, attribute: str, value: Any) -> None:
-        if len(value) > EMBED_MAX_NAME_LENGTH:
-            raise ValueError(f"Field name cannot exceed {EMBED_MAX_NAME_LENGTH} characters")
-
-    def __len__(self) -> int:
-        return len(self.name)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class EmbedAttachment(DictSerializationMixin):  # thumbnail or image or video
-    """
-    Representation of an attachment.
-
-    Attributes:
-        url: Attachment url
-        proxy_url: Proxy url
-        height: Attachment height
-        width: Attachment width
-
-    """
-
-    url: Optional[str] = attrs.field(repr=False, default=None)
-    proxy_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)
-    height: Optional[int] = attrs.field(repr=False, default=None, metadata=no_export_meta)
-    width: Optional[int] = attrs.field(repr=False, default=None, metadata=no_export_meta)
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any]) -> Dict[str, Any]:
-        return {"url": data} if isinstance(data, str) else data
-
-    @property
-    def size(self) -> tuple[Optional[int], Optional[int]]:
-        return self.height, self.width
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class EmbedFooter(DictSerializationMixin):
-    """
-    Representation of an Embed Footer.
-
-    Attributes:
-        text: Footer text
-        icon_url: Footer icon url
-        proxy_icon_url: Proxy icon url
-
-    """
-
-    text: str = attrs.field(
-        repr=False,
-    )
-    icon_url: Optional[str] = attrs.field(repr=False, default=None)
-    proxy_icon_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)
-
-    @classmethod
-    def converter(cls, ingest: Union[dict, str, "EmbedFooter"]) -> "EmbedFooter":
-        """
-        A converter to handle users passing raw strings or dictionaries as footers to the Embed object.
-
-        Args:
-            ingest: The data to convert
-
-        Returns:
-            An EmbedFooter object
-        """
-        return cls(text=ingest) if isinstance(ingest, str) else cls.from_dict(ingest)
-
-    def __len__(self) -> int:
-        return len(self.text)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class EmbedProvider(DictSerializationMixin):
-    """
-    Represents an embed's provider.
-
-    !!! note
-        Only used by system embeds, not bots
-
-    Attributes:
-        name: Provider name
-        url: Provider url
-
-    """
-
-    name: Optional[str] = attrs.field(repr=False, default=None)
-    url: Optional[str] = attrs.field(repr=False, default=None)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class Embed(DictSerializationMixin):
-    """Represents a discord embed object."""
-
-    title: Optional[str] = attrs.field(default=None, repr=True)
-    """The title of the embed"""
-    description: Optional[str] = attrs.field(default=None, repr=True)
-    """The description of the embed"""
-    color: Optional[Union[Color, dict, tuple, list, str, int]] = attrs.field(
-        default=None, repr=True, metadata=export_converter(process_color)
-    )
-    """The colour of the embed"""
-    url: Optional[str] = attrs.field(default=None, validator=v_optional(instance_of(str)), repr=True)
-    """The url the embed should direct to when clicked"""
-    timestamp: Optional[Timestamp] = attrs.field(
-        default=None,
-        converter=c_optional(timestamp_converter),
-        validator=v_optional(instance_of((datetime, float, int))),
-        repr=True,
-    )
-    """Timestamp of embed content"""
-    fields: List[EmbedField] = attrs.field(factory=list, converter=EmbedField.from_list, repr=True)
-    """A list of [fields][interactions.models.discord.embed.EmbedField] to go in the embed"""
-    author: Optional[EmbedAuthor] = attrs.field(repr=False, default=None, converter=c_optional(EmbedAuthor.from_dict))
-    """The author of the embed"""
-    thumbnail: Optional[EmbedAttachment] = attrs.field(
-        repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict)
-    )
-    """The thumbnail of the embed"""
-    images: list[EmbedAttachment] = attrs.field(
-        repr=False, factory=list, converter=list_converter(EmbedAttachment.from_dict)
-    )
-    """The images of the embed"""
-    video: Optional[EmbedAttachment] = attrs.field(
-        repr=False,
-        default=None,
-        converter=c_optional(EmbedAttachment.from_dict),
-        metadata=no_export_meta,
-    )
-    """The video of the embed, only used by system embeds"""
-    footer: Optional[EmbedFooter] = attrs.field(repr=False, default=None, converter=c_optional(EmbedFooter.converter))
-    """The footer of the embed"""
-    provider: Optional[EmbedProvider] = attrs.field(
-        repr=False,
-        default=None,
-        converter=c_optional(EmbedProvider.from_dict),
-        metadata=no_export_meta,
-    )
-    """The provider of the embed, only used for system embeds"""
-    type: EmbedType = attrs.field(
-        repr=False,
-        default=EmbedType.RICH,
-        converter=c_optional(EmbedType),
-        metadata=no_export_meta,
-    )
-
-    @property
-    def image(self) -> Optional[EmbedAttachment]:
-        """
-        The image of the embed.
-
-        Raises:
-            ValueError: If there are multiple images in the embed.
-        """
-        if len(self.images) <= 1:
-            return self.images[0] if self.images else None
-        raise ValueError("There are multiple images in this embed, use `images` instead")
-
-    @image.setter
-    def image(self, value: Optional[EmbedAttachment]) -> "Embed":
-        """Set the image of the embed."""
-        self.images = [] if value is None else [value]
-        return self
-
-    @title.validator
-    def _name_validation(self, attribute: str, value: Any) -> None:
-        """Validate the embed title."""
-        if value is not None:
-            if isinstance(value, str):
-                if len(value) > EMBED_MAX_NAME_LENGTH:
-                    raise ValueError(f"Title cannot exceed {EMBED_MAX_NAME_LENGTH} characters")
-                return
-            raise TypeError("Title must be of type String")
-
-    @description.validator
-    def _description_validation(self, attribute: str, value: Any) -> None:
-        """Validate the description."""
-        if value is not None:
-            if isinstance(value, str):
-                if len(value) > EMBED_MAX_DESC_LENGTH:
-                    raise ValueError(f"Description cannot exceed {EMBED_MAX_DESC_LENGTH} characters")
-                return
-            raise TypeError("Description must be of type String")
-
-    @fields.validator
-    def _fields_validation(self, attribute: str, value: Any) -> None:
-        """Validate the fields."""
-        if isinstance(value, list) and len(value) > EMBED_MAX_FIELDS:
-            raise ValueError(f"Embeds can only hold {EMBED_MAX_FIELDS} fields")
-
-    def _check_object(self) -> None:
-        self._name_validation("title", self.title)
-        self._description_validation("description", self.description)
-        self._fields_validation("fields", self.fields)
-
-        if len(self) > EMBED_TOTAL_MAX:
-            raise ValueError(
-                "Your embed is too large, more info at https://discord.com/developers/docs/resources/channel#embed-limits"
-            )
-
-    def __len__(self) -> int:
-        # yes i know there are far more optimal ways to write this
-        # its written like this for readability
-        total: int = 0
-        if self.title:
-            total += len(self.title)
-        if self.description:
-            total += len(self.description)
-        if self.footer:
-            total += len(self.footer)
-        if self.author:
-            total += len(self.author)
-        if self.fields:
-            total += sum(map(len, self.fields))
-        return total
-
-    def __bool__(self) -> bool:
-        return any(
-            (
-                self.title,
-                self.description,
-                self.fields,
-                self.author,
-                self.thumbnail,
-                self.footer,
-                self.images,
-                self.video,
-            )
-        )
-
-    def set_author(
-        self,
-        name: str,
-        url: Optional[str] = None,
-        icon_url: Optional[str] = None,
-    ) -> "Embed":
-        """
-        Set the author field of the embed.
-
-        Args:
-            name: The text to go in the title section
-            url: A url link to the author
-            icon_url: A url of an image to use as the icon
-
-        """
-        self.author = EmbedAuthor(name=name, url=url, icon_url=icon_url)
-        return self
-
-    def set_thumbnail(self, url: str) -> "Embed":
-        """
-        Set the thumbnail of the embed.
-
-        Args:
-            url: the url of the image to use
-
-        """
-        self.thumbnail = EmbedAttachment(url=url)
-        return self
-
-    def set_image(self, url: str) -> "Embed":
-        """
-        Set the image of the embed.
-
-        Args:
-            url: the url of the image to use
-
-        """
-        self.images = [EmbedAttachment(url=url)]
-        return self
-
-    def set_images(self, *images: str) -> "Embed":
-        """
-        Set multiple images for the embed.
-
-        Note:
-            To use multiple images, you must also set a url for this embed.
-
-        Warning:
-            This takes advantage of an undocumented feature of the API, and may be removed at any time.
-
-        Args:
-            images: the images to use
-
-        """
-        if len(self.images) + len(images) > 1 and not self.url:
-            raise ValueError("To use multiple images, you must also set a url for this embed")
-
-        self.images = [EmbedAttachment(url=url) for url in images]
-        return self
-
-    def add_image(self, image: str) -> "Embed":
-        """
-        Add an image to the embed.
-
-        Note:
-            To use multiple images, you must also set a url for this embed.
-
-        Warning:
-            This takes advantage of an undocumented feature of the API, and may be removed at any time.
-
-        Args:
-            image: the image to add
-        """
-        if len(self.images) > 0 and not self.url:
-            raise ValueError("To use multiple images, you must also set a url for this embed")
-        self.images.append(EmbedAttachment(url=image))
-        return self
-
-    def set_footer(self, text: str, icon_url: Optional[str] = None) -> "Embed":
-        """
-        Set the footer field of the embed.
-
-        Args:
-            text: The text to go in the title section
-            icon_url: A url of an image to use as the icon
-
-        """
-        self.footer = EmbedFooter(text=text, icon_url=icon_url)
-        return self
-
-    def add_field(self, name: str, value: Any, inline: bool = False) -> "Embed":
-        """
-        Add a field to the embed.
-
-        Args:
-            name: The title of this field
-            value: The value in this field
-            inline: Should this field be inline with other fields?
-
-        """
-        self.fields.append(EmbedField(name, str(value), inline))
-        self._fields_validation("fields", self.fields)
-
-        return self
-
-    def add_fields(self, *fields: EmbedField | str | dict) -> "Embed":
-        """
-        Add multiple fields to the embed.
-
-        Args:
-            fields: The fields to add
-
-        """
-        for _field in fields:
-            if isinstance(_field, EmbedField):
-                self.fields.append(_field)
-                self._fields_validation("fields", self.fields)
-            elif isinstance(_field, str):
-                self.add_field(_field, _field)
-            elif isinstance(_field, dict):
-                self.add_field(**_field)
-            else:
-                raise TypeError(f"Expected EmbedField, str or dict, got {type(_field).__name__}")
-        return self
-
-    def to_dict(self) -> Dict[str, Any]:
-        data = super().to_dict()
-        if images := data.pop("images", []):
-            if len(images) > 1:
-                if not self.url:
-                    raise ValueError("To use multiple images, you must also set a url for this embed")
-
-                data["image"] = images[0]
-                data = [data]
-
-                data.extend({"image": image, "url": self.url} for image in images[1:])
-            else:
-                data["image"] = images[0]
-
-        return data
-
-
-def process_embeds(embeds: Optional[Union[List[Union[Embed, Dict]], Union[Embed, Dict]]]) -> Optional[List[dict]]:
-    """
-    Process the passed embeds into a format discord will understand.
-
-    Args:
-        embeds: List of dict / embeds to process
-
-    Returns:
-        formatted list for discord
-
-    """
-    if embeds is None:
-        # Its just empty, so nothing to process.
-        return embeds
-
-    if isinstance(embeds, Embed):
-        # Single embed, convert it to dict and wrap it into a list for discord.
-        out = embeds.to_dict()
-        return out if isinstance(out, list) else [out]
-    if isinstance(embeds, dict):
-        # We assume the dict correctly represents a single discord embed and just send it blindly
-        # after wrapping it in a list for discord
-        return [embeds]
-
-    if isinstance(embeds, list):
-        # A list of embeds, convert Embed to dict representation if needed.
-        out = [embed.to_dict() if isinstance(embed, Embed) else embed for embed in embeds]
-        if any(isinstance(embed, list) for embed in out):
-            raise ValueError("You cannot send multiple embeds when using multiple images in a single embed")
-        return out
-
-    raise ValueError(f"Invalid embeds: {embeds}")
+from datetime import datetime
+from typing import Any, Dict, List, Optional, Union
+
+import attrs
+from attrs.validators import instance_of
+from attrs.validators import optional as v_optional
+
+from interactions.client.const import (
+    EMBED_MAX_NAME_LENGTH,
+    EMBED_MAX_FIELDS,
+    EMBED_MAX_DESC_LENGTH,
+    EMBED_TOTAL_MAX,
+    EMBED_FIELD_VALUE_LENGTH,
+)
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.attr_converters import optional as c_optional, list_converter
+from interactions.client.utils.attr_converters import timestamp_converter
+from interactions.client.utils.serializer import no_export_meta, export_converter
+from interactions.models.discord.color import Color, process_color
+from interactions.models.discord.enums import EmbedType
+from interactions.models.discord.timestamp import Timestamp
+
+__all__ = (
+    "EmbedField",
+    "EmbedAuthor",
+    "EmbedAttachment",
+    "EmbedAuthor",
+    "EmbedFooter",
+    "EmbedProvider",
+    "Embed",
+    "process_embeds",
+)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class EmbedField(DictSerializationMixin):
+    """
+    Representation of an embed field.
+
+    Attributes:
+        name: Field name
+        value: Field value
+        inline: If the field should be inline
+
+    """
+
+    name: str = attrs.field(
+        repr=False,
+    )
+    value: str = attrs.field(
+        repr=False,
+    )
+    inline: bool = attrs.field(repr=False, default=False)
+
+    @name.validator
+    def _name_validation(self, attribute: str, value: Any) -> None:
+        if len(value) > EMBED_MAX_NAME_LENGTH:
+            raise ValueError(f"Field name cannot exceed {EMBED_MAX_NAME_LENGTH} characters")
+
+    @value.validator
+    def _value_validation(self, attribute: str, value: Any) -> None:
+        if len(value) > EMBED_FIELD_VALUE_LENGTH:
+            raise ValueError(f"Field value cannot exceed {EMBED_FIELD_VALUE_LENGTH} characters")
+
+    def __len__(self) -> int:
+        return len(self.name) + len(self.value)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class EmbedAuthor(DictSerializationMixin):
+    """
+    Representation of an embed author.
+
+    Attributes:
+        name: Name to show on embed
+        url: Url to go to when name is clicked
+        icon_url: Icon to show next to name
+        proxy_icon_url: Proxy icon url
+
+    """
+
+    name: Optional[str] = attrs.field(repr=False, default=None)
+    url: Optional[str] = attrs.field(repr=False, default=None)
+    icon_url: Optional[str] = attrs.field(repr=False, default=None)
+    proxy_icon_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)
+
+    @name.validator
+    def _name_validation(self, attribute: str, value: Any) -> None:
+        if len(value) > EMBED_MAX_NAME_LENGTH:
+            raise ValueError(f"Field name cannot exceed {EMBED_MAX_NAME_LENGTH} characters")
+
+    def __len__(self) -> int:
+        return len(self.name)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class EmbedAttachment(DictSerializationMixin):  # thumbnail or image or video
+    """
+    Representation of an attachment.
+
+    Attributes:
+        url: Attachment url
+        proxy_url: Proxy url
+        height: Attachment height
+        width: Attachment width
+
+    """
+
+    url: Optional[str] = attrs.field(repr=False, default=None)
+    proxy_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)
+    height: Optional[int] = attrs.field(repr=False, default=None, metadata=no_export_meta)
+    width: Optional[int] = attrs.field(repr=False, default=None, metadata=no_export_meta)
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any]) -> Dict[str, Any]:
+        return {"url": data} if isinstance(data, str) else data
+
+    @property
+    def size(self) -> tuple[Optional[int], Optional[int]]:
+        return self.height, self.width
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class EmbedFooter(DictSerializationMixin):
+    """
+    Representation of an Embed Footer.
+
+    Attributes:
+        text: Footer text
+        icon_url: Footer icon url
+        proxy_icon_url: Proxy icon url
+
+    """
+
+    text: str = attrs.field(
+        repr=False,
+    )
+    icon_url: Optional[str] = attrs.field(repr=False, default=None)
+    proxy_icon_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)
+
+    @classmethod
+    def converter(cls, ingest: Union[dict, str, "EmbedFooter"]) -> "EmbedFooter":
+        """
+        A converter to handle users passing raw strings or dictionaries as footers to the Embed object.
+
+        Args:
+            ingest: The data to convert
+
+        Returns:
+            An EmbedFooter object
+        """
+        return cls(text=ingest) if isinstance(ingest, str) else cls.from_dict(ingest)
+
+    def __len__(self) -> int:
+        return len(self.text)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class EmbedProvider(DictSerializationMixin):
+    """
+    Represents an embed's provider.
+
+    !!! note
+        Only used by system embeds, not bots
+
+    Attributes:
+        name: Provider name
+        url: Provider url
+
+    """
+
+    name: Optional[str] = attrs.field(repr=False, default=None)
+    url: Optional[str] = attrs.field(repr=False, default=None)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class Embed(DictSerializationMixin):
+    """Represents a discord embed object."""
+
+    title: Optional[str] = attrs.field(default=None, repr=True)
+    """The title of the embed"""
+    description: Optional[str] = attrs.field(default=None, repr=True)
+    """The description of the embed"""
+    color: Optional[Union[Color, dict, tuple, list, str, int]] = attrs.field(
+        default=None, repr=True, metadata=export_converter(process_color)
+    )
+    """The colour of the embed"""
+    url: Optional[str] = attrs.field(default=None, validator=v_optional(instance_of(str)), repr=True)
+    """The url the embed should direct to when clicked"""
+    timestamp: Optional[Timestamp] = attrs.field(
+        default=None,
+        converter=c_optional(timestamp_converter),
+        validator=v_optional(instance_of((datetime, float, int))),
+        repr=True,
+    )
+    """Timestamp of embed content"""
+    fields: List[EmbedField] = attrs.field(factory=list, converter=EmbedField.from_list, repr=True)
+    """A list of [fields][interactions.models.discord.embed.EmbedField] to go in the embed"""
+    author: Optional[EmbedAuthor] = attrs.field(repr=False, default=None, converter=c_optional(EmbedAuthor.from_dict))
+    """The author of the embed"""
+    thumbnail: Optional[EmbedAttachment] = attrs.field(
+        repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict)
+    )
+    """The thumbnail of the embed"""
+    images: list[EmbedAttachment] = attrs.field(
+        repr=False, factory=list, converter=list_converter(EmbedAttachment.from_dict)
+    )
+    """The images of the embed"""
+    video: Optional[EmbedAttachment] = attrs.field(
+        repr=False,
+        default=None,
+        converter=c_optional(EmbedAttachment.from_dict),
+        metadata=no_export_meta,
+    )
+    """The video of the embed, only used by system embeds"""
+    footer: Optional[EmbedFooter] = attrs.field(repr=False, default=None, converter=c_optional(EmbedFooter.converter))
+    """The footer of the embed"""
+    provider: Optional[EmbedProvider] = attrs.field(
+        repr=False,
+        default=None,
+        converter=c_optional(EmbedProvider.from_dict),
+        metadata=no_export_meta,
+    )
+    """The provider of the embed, only used for system embeds"""
+    type: EmbedType = attrs.field(
+        repr=False,
+        default=EmbedType.RICH,
+        converter=c_optional(EmbedType),
+        metadata=no_export_meta,
+    )
+
+    @property
+    def image(self) -> Optional[EmbedAttachment]:
+        """
+        The image of the embed.
+
+        Raises:
+            ValueError: If there are multiple images in the embed.
+        """
+        if len(self.images) <= 1:
+            return self.images[0] if self.images else None
+        raise ValueError("There are multiple images in this embed, use `images` instead")
+
+    @image.setter
+    def image(self, value: Optional[EmbedAttachment]) -> "Embed":
+        """Set the image of the embed."""
+        self.images = [] if value is None else [value]
+        return self
+
+    @title.validator
+    def _name_validation(self, attribute: str, value: Any) -> None:
+        """Validate the embed title."""
+        if value is not None:
+            if isinstance(value, str):
+                if len(value) > EMBED_MAX_NAME_LENGTH:
+                    raise ValueError(f"Title cannot exceed {EMBED_MAX_NAME_LENGTH} characters")
+                return
+            raise TypeError("Title must be of type String")
+
+    @description.validator
+    def _description_validation(self, attribute: str, value: Any) -> None:
+        """Validate the description."""
+        if value is not None:
+            if isinstance(value, str):
+                if len(value) > EMBED_MAX_DESC_LENGTH:
+                    raise ValueError(f"Description cannot exceed {EMBED_MAX_DESC_LENGTH} characters")
+                return
+            raise TypeError("Description must be of type String")
+
+    @fields.validator
+    def _fields_validation(self, attribute: str, value: Any) -> None:
+        """Validate the fields."""
+        if isinstance(value, list) and len(value) > EMBED_MAX_FIELDS:
+            raise ValueError(f"Embeds can only hold {EMBED_MAX_FIELDS} fields")
+
+    def _check_object(self) -> None:
+        self._name_validation("title", self.title)
+        self._description_validation("description", self.description)
+        self._fields_validation("fields", self.fields)
+
+        if len(self) > EMBED_TOTAL_MAX:
+            raise ValueError(
+                "Your embed is too large, more info at https://discord.com/developers/docs/resources/channel#embed-limits"
+            )
+
+    def __len__(self) -> int:
+        # yes i know there are far more optimal ways to write this
+        # its written like this for readability
+        total: int = 0
+        if self.title:
+            total += len(self.title)
+        if self.description:
+            total += len(self.description)
+        if self.footer:
+            total += len(self.footer)
+        if self.author:
+            total += len(self.author)
+        if self.fields:
+            total += sum(map(len, self.fields))
+        return total
+
+    def __bool__(self) -> bool:
+        return any(
+            (
+                self.title,
+                self.description,
+                self.fields,
+                self.author,
+                self.thumbnail,
+                self.footer,
+                self.images,
+                self.video,
+            )
+        )
+
+    def set_author(
+        self,
+        name: str,
+        url: Optional[str] = None,
+        icon_url: Optional[str] = None,
+    ) -> "Embed":
+        """
+        Set the author field of the embed.
+
+        Args:
+            name: The text to go in the title section
+            url: A url link to the author
+            icon_url: A url of an image to use as the icon
+
+        """
+        self.author = EmbedAuthor(name=name, url=url, icon_url=icon_url)
+        return self
+
+    def set_thumbnail(self, url: str) -> "Embed":
+        """
+        Set the thumbnail of the embed.
+
+        Args:
+            url: the url of the image to use
+
+        """
+        self.thumbnail = EmbedAttachment(url=url)
+        return self
+
+    def set_image(self, url: str) -> "Embed":
+        """
+        Set the image of the embed.
+
+        Args:
+            url: the url of the image to use
+
+        """
+        self.images = [EmbedAttachment(url=url)]
+        return self
+
+    def set_images(self, *images: str) -> "Embed":
+        """
+        Set multiple images for the embed.
+
+        Note:
+            To use multiple images, you must also set a url for this embed.
+
+        Warning:
+            This takes advantage of an undocumented feature of the API, and may be removed at any time.
+
+        Args:
+            images: the images to use
+
+        """
+        if len(self.images) + len(images) > 1 and not self.url:
+            raise ValueError("To use multiple images, you must also set a url for this embed")
+
+        self.images = [EmbedAttachment(url=url) for url in images]
+        return self
+
+    def add_image(self, image: str) -> "Embed":
+        """
+        Add an image to the embed.
+
+        Note:
+            To use multiple images, you must also set a url for this embed.
+
+        Warning:
+            This takes advantage of an undocumented feature of the API, and may be removed at any time.
+
+        Args:
+            image: the image to add
+        """
+        if len(self.images) > 0 and not self.url:
+            raise ValueError("To use multiple images, you must also set a url for this embed")
+        self.images.append(EmbedAttachment(url=image))
+        return self
+
+    def set_footer(self, text: str, icon_url: Optional[str] = None) -> "Embed":
+        """
+        Set the footer field of the embed.
+
+        Args:
+            text: The text to go in the title section
+            icon_url: A url of an image to use as the icon
+
+        """
+        self.footer = EmbedFooter(text=text, icon_url=icon_url)
+        return self
+
+    def add_field(self, name: str, value: Any, inline: bool = False) -> "Embed":
+        """
+        Add a field to the embed.
+
+        Args:
+            name: The title of this field
+            value: The value in this field
+            inline: Should this field be inline with other fields?
+
+        """
+        self.fields.append(EmbedField(name, str(value), inline))
+        self._fields_validation("fields", self.fields)
+
+        return self
+
+    def add_fields(self, *fields: EmbedField | str | dict) -> "Embed":
+        """
+        Add multiple fields to the embed.
+
+        Args:
+            fields: The fields to add
+
+        """
+        for _field in fields:
+            if isinstance(_field, EmbedField):
+                self.fields.append(_field)
+                self._fields_validation("fields", self.fields)
+            elif isinstance(_field, str):
+                self.add_field(_field, _field)
+            elif isinstance(_field, dict):
+                self.add_field(**_field)
+            else:
+                raise TypeError(f"Expected EmbedField, str or dict, got {type(_field).__name__}")
+        return self
+
+    def to_dict(self) -> Dict[str, Any]:
+        data = super().to_dict()
+        if images := data.pop("images", []):
+            if len(images) > 1:
+                if not self.url:
+                    raise ValueError("To use multiple images, you must also set a url for this embed")
+
+                data["image"] = images[0]
+                data = [data]
+
+                data.extend({"image": image, "url": self.url} for image in images[1:])
+            else:
+                data["image"] = images[0]
+
+        return data
+
+
+def process_embeds(embeds: Optional[Union[List[Union[Embed, Dict]], Union[Embed, Dict]]]) -> Optional[List[dict]]:
+    """
+    Process the passed embeds into a format discord will understand.
+
+    Args:
+        embeds: List of dict / embeds to process
+
+    Returns:
+        formatted list for discord
+
+    """
+    if embeds is None:
+        # Its just empty, so nothing to process.
+        return embeds
+
+    if isinstance(embeds, Embed):
+        # Single embed, convert it to dict and wrap it into a list for discord.
+        out = embeds.to_dict()
+        return out if isinstance(out, list) else [out]
+    if isinstance(embeds, dict):
+        # We assume the dict correctly represents a single discord embed and just send it blindly
+        # after wrapping it in a list for discord
+        return [embeds]
+
+    if isinstance(embeds, list):
+        # A list of embeds, convert Embed to dict representation if needed.
+        out = [embed.to_dict() if isinstance(embed, Embed) else embed for embed in embeds]
+        if any(isinstance(embed, list) for embed in out):
+            raise ValueError("You cannot send multiple embeds when using multiple images in a single embed")
+        return out
+
+    raise ValueError(f"Invalid embeds: {embeds}")
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/emoji.py` & `discord-py-interactions-5.6.0/interactions/models/discord/emoji.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,259 +1,259 @@
-import re
-import string
-import unicodedata
-from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union
-
-import attrs
-import emoji
-
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.attr_converters import list_converter
-from interactions.client.utils.attr_converters import optional
-from interactions.client.utils.serializer import dict_filter_none, no_export_meta
-from interactions.models.discord.base import ClientObject
-from interactions.models.discord.snowflake import SnowflakeObject, to_snowflake
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-    from interactions.models.discord.guild import Guild
-    from interactions.models.discord.user import User, Member
-    from interactions.models.discord.role import Role
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-__all__ = ("PartialEmoji", "CustomEmoji", "process_emoji_req_format", "process_emoji")
-
-emoji_regex = re.compile(r"<?(a)?:(\w*):(\d*)>?")
-unicode_emoji_reg = re.compile(r"[^\w\s,’‘“”…–—•◦‣⁃⁎⁏⁒⁓⁺⁻⁼⁽⁾ⁿ₊₋₌₍₎]")  # noqa: RUF001
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class PartialEmoji(SnowflakeObject, DictSerializationMixin):
-    """Represent a basic ("partial") emoji used in discord."""
-
-    id: Optional["Snowflake_Type"] = attrs.field(
-        repr=True, default=None, converter=optional(to_snowflake)
-    )  # can be None for Standard Emoji
-    """The custom emoji id. Leave empty if you are using standard unicode emoji."""
-    name: Optional[str] = attrs.field(repr=True, default=None)
-    """The custom emoji name, or standard unicode emoji in string"""
-    animated: bool = attrs.field(repr=True, default=False)
-    """Whether this emoji is animated"""
-
-    @classmethod
-    def from_str(cls, emoji_str: str, *, language: str = "alias") -> Optional["PartialEmoji"]:
-        """
-        Generate a PartialEmoji from a discord Emoji string representation, or unicode emoji.
-
-        Handles:
-            <:emoji_name:emoji_id>
-            :emoji_name:emoji_id
-            <a:emoji_name:emoji_id>
-            a:emoji_name:emoji_id
-            👋
-            :wave:
-
-        Args:
-            emoji_str: The string representation an emoji
-            language: The language to use for the unicode emoji parsing
-
-        Returns:
-            A PartialEmoji object
-
-        Raises:
-            ValueError: if the string cannot be parsed
-
-        """
-        if parsed := emoji_regex.findall(emoji_str):
-            parsed = tuple(filter(None, parsed[0]))
-            if len(parsed) == 3:
-                return cls(name=parsed[1], id=parsed[2], animated=True)
-            if len(parsed) == 2:
-                return cls(name=parsed[0], id=parsed[1])
-            _name = emoji.emojize(emoji_str, language=language)
-            if _emoji_list := emoji.distinct_emoji_list(_name):
-                return cls(name=_emoji_list[0])
-        else:
-            if _emoji_list := emoji.distinct_emoji_list(emoji_str):
-                return cls(name=_emoji_list[0])
-
-            # the emoji lib handles *most* emoji, however there are certain ones that it misses
-            # this acts as a fallback check
-            if matches := unicode_emoji_reg.search(emoji_str):
-                match = matches.group()
-
-                # the regex will match certain special characters, so this acts as a final failsafe
-                if match not in string.printable and unicodedata.category(match) == "So":
-                    return cls(name=match)
-        return None
-
-    def __str__(self) -> str:
-        s = self.req_format
-        if self.id:
-            s = f"<{'a:' if self.animated else ':'}{s}>"
-        return s
-
-    def __eq__(self, other) -> bool:
-        if not isinstance(other, PartialEmoji):
-            return False
-        return self.id == other.id if self.id else self.name == other.name
-
-    @property
-    def req_format(self) -> str:
-        """Format used for web request."""
-        return f"{self.name}:{self.id}" if self.id else self.name
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class CustomEmoji(PartialEmoji, ClientObject):
-    """Represent a custom emoji in a guild with all its properties."""
-
-    _client: "Client" = attrs.field(repr=False, metadata=no_export_meta)
-
-    require_colons: bool = attrs.field(repr=False, default=False)
-    """Whether this emoji must be wrapped in colons"""
-    managed: bool = attrs.field(repr=False, default=False)
-    """Whether this emoji is managed"""
-    available: bool = attrs.field(repr=False, default=False)
-    """Whether this emoji can be used, may be false due to loss of Server Boosts."""
-
-    _creator_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
-    _role_ids: List["Snowflake_Type"] = attrs.field(
-        repr=False, factory=list, converter=optional(list_converter(to_snowflake))
-    )
-    _guild_id: "Snowflake_Type" = attrs.field(repr=False, default=None, converter=to_snowflake)
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        creator_dict = data.pop("user", None)
-        data["creator_id"] = client.cache.place_user_data(creator_dict).id if creator_dict else None
-
-        if "roles" in data:
-            data["role_ids"] = data.pop("roles")
-
-        return data
-
-    @classmethod
-    def from_dict(cls, data: Dict[str, Any], client: "Client", guild_id: int) -> "CustomEmoji":
-        data = cls._process_dict(data, client)
-        return cls(client=client, guild_id=guild_id, **cls._filter_kwargs(data, cls._get_init_keys()))
-
-    @property
-    def guild(self) -> "Guild":
-        """The guild this emoji belongs to."""
-        return self._client.cache.get_guild(self._guild_id)
-
-    @property
-    def creator(self) -> Optional[Union["Member", "User"]]:
-        """The member that created this emoji."""
-        return self._client.cache.get_member(self._creator_id, self._guild_id) or self._client.cache.get_user(
-            self._creator_id
-        )
-
-    @property
-    def roles(self) -> List["Role"]:
-        """The roles allowed to use this emoji."""
-        return [self._client.cache.get_role(role_id) for role_id in self._role_ids]
-
-    @property
-    def is_usable(self) -> bool:
-        """Determines if this emoji is usable by the current user."""
-        if not self.available:
-            return False
-
-        guild = self.guild
-        return any(e_role_id in guild.me._role_ids for e_role_id in self._role_ids)
-
-    async def edit(
-        self,
-        *,
-        name: Optional[str] = None,
-        roles: Optional[List[Union["Snowflake_Type", "Role"]]] = None,
-        reason: Optional[str] = None,
-    ) -> "CustomEmoji":
-        """
-        Modify the custom emoji information.
-
-        Args:
-            name: The name of the emoji.
-            roles: The roles allowed to use this emoji.
-            reason: Attach a reason to this action, used for audit logs.
-
-        Returns:
-            The newly modified custom emoji.
-
-        """
-        data_payload = dict_filter_none(
-            {
-                "name": name,
-                "roles": roles,
-            }
-        )
-
-        updated_data = await self._client.http.modify_guild_emoji(data_payload, self._guild_id, self.id, reason=reason)
-        self.update_from_dict(updated_data)
-        return self
-
-    async def delete(self, reason: Optional[str] = None) -> None:
-        """
-        Deletes the custom emoji from the guild.
-
-        Args:
-            reason: Attach a reason to this action, used for audit logs.
-
-        """
-        if not self._guild_id:
-            raise ValueError("Cannot delete emoji, no guild id set.")
-
-        await self._client.http.delete_guild_emoji(self._guild_id, self.id, reason=reason)
-
-
-def process_emoji_req_format(emoji: Optional[Union[PartialEmoji, dict, str]]) -> Optional[str]:
-    """
-    Processes the emoji parameter into the str format required by the API.
-
-    Args:
-        emoji: The emoji to process.
-
-    Returns:
-        formatted string for discord
-
-    """
-    if not emoji:
-        return emoji
-
-    if isinstance(emoji, str):
-        emoji = PartialEmoji.from_str(emoji)
-
-    if isinstance(emoji, dict):
-        emoji = PartialEmoji.from_dict(emoji)
-
-    if isinstance(emoji, PartialEmoji):
-        return emoji.req_format
-
-    raise ValueError(f"Invalid emoji: {emoji}")
-
-
-def process_emoji(emoji: Optional[Union[PartialEmoji, dict, str]]) -> Optional[dict]:
-    """
-    Processes the emoji parameter into the dictionary format required by the API.
-
-    Args:
-        emoji: The emoji to process.
-
-    Returns:
-        formatted dictionary for discord
-
-    """
-    if not emoji:
-        return emoji
-
-    if isinstance(emoji, dict):
-        return emoji
-
-    if isinstance(emoji, str):
-        emoji = PartialEmoji.from_str(emoji)
-
-    if isinstance(emoji, PartialEmoji):
-        return emoji.to_dict()
-
-    raise ValueError(f"Invalid emoji: {emoji}")
+import re
+import string
+import unicodedata
+from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union
+
+import attrs
+import emoji
+
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.attr_converters import list_converter
+from interactions.client.utils.attr_converters import optional
+from interactions.client.utils.serializer import dict_filter_none, no_export_meta
+from interactions.models.discord.base import ClientObject
+from interactions.models.discord.snowflake import SnowflakeObject, to_snowflake, to_snowflake_list
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+    from interactions.models.discord.guild import Guild
+    from interactions.models.discord.user import User, Member
+    from interactions.models.discord.role import Role
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+__all__ = ("PartialEmoji", "CustomEmoji", "process_emoji_req_format", "process_emoji")
+
+emoji_regex = re.compile(r"<?(a)?:(\w*):(\d*)>?")
+unicode_emoji_reg = re.compile(r"[^\w\s,’‘“”…–—•◦‣⁃⁎⁏⁒⁓⁺⁻⁼⁽⁾ⁿ₊₋₌₍₎]")  # noqa: RUF001
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class PartialEmoji(SnowflakeObject, DictSerializationMixin):
+    """Represent a basic ("partial") emoji used in discord."""
+
+    id: Optional["Snowflake_Type"] = attrs.field(
+        repr=True, default=None, converter=optional(to_snowflake)
+    )  # can be None for Standard Emoji
+    """The custom emoji id. Leave empty if you are using standard unicode emoji."""
+    name: Optional[str] = attrs.field(repr=True, default=None)
+    """The custom emoji name, or standard unicode emoji in string"""
+    animated: bool = attrs.field(repr=True, default=False)
+    """Whether this emoji is animated"""
+
+    @classmethod
+    def from_str(cls, emoji_str: str, *, language: str = "alias") -> Optional["PartialEmoji"]:
+        """
+        Generate a PartialEmoji from a discord Emoji string representation, or unicode emoji.
+
+        Handles:
+            <:emoji_name:emoji_id>
+            :emoji_name:emoji_id
+            <a:emoji_name:emoji_id>
+            a:emoji_name:emoji_id
+            👋
+            :wave:
+
+        Args:
+            emoji_str: The string representation an emoji
+            language: The language to use for the unicode emoji parsing
+
+        Returns:
+            A PartialEmoji object
+
+        Raises:
+            ValueError: if the string cannot be parsed
+
+        """
+        if parsed := emoji_regex.findall(emoji_str):
+            parsed = tuple(filter(None, parsed[0]))
+            if len(parsed) == 3:
+                return cls(name=parsed[1], id=parsed[2], animated=True)
+            if len(parsed) == 2:
+                return cls(name=parsed[0], id=parsed[1])
+            _name = emoji.emojize(emoji_str, language=language)
+            if _emoji_list := emoji.distinct_emoji_list(_name):
+                return cls(name=_emoji_list[0])
+        else:
+            if _emoji_list := emoji.distinct_emoji_list(emoji_str):
+                return cls(name=_emoji_list[0])
+
+            # the emoji lib handles *most* emoji, however there are certain ones that it misses
+            # this acts as a fallback check
+            if matches := unicode_emoji_reg.search(emoji_str):
+                match = matches.group()
+
+                # the regex will match certain special characters, so this acts as a final failsafe
+                if match not in string.printable and unicodedata.category(match) == "So":
+                    return cls(name=match)
+        return None
+
+    def __str__(self) -> str:
+        s = self.req_format
+        if self.id:
+            s = f"<{'a:' if self.animated else ':'}{s}>"
+        return s
+
+    def __eq__(self, other) -> bool:
+        if not isinstance(other, PartialEmoji):
+            return False
+        return self.id == other.id if self.id else self.name == other.name
+
+    @property
+    def req_format(self) -> str:
+        """Format used for web request."""
+        return f"{self.name}:{self.id}" if self.id else self.name
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class CustomEmoji(PartialEmoji, ClientObject):
+    """Represent a custom emoji in a guild with all its properties."""
+
+    _client: "Client" = attrs.field(repr=False, metadata=no_export_meta)
+
+    require_colons: bool = attrs.field(repr=False, default=False)
+    """Whether this emoji must be wrapped in colons"""
+    managed: bool = attrs.field(repr=False, default=False)
+    """Whether this emoji is managed"""
+    available: bool = attrs.field(repr=False, default=False)
+    """Whether this emoji can be used, may be false due to loss of Server Boosts."""
+
+    _creator_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
+    _role_ids: List["Snowflake_Type"] = attrs.field(
+        repr=False, factory=list, converter=optional(list_converter(to_snowflake))
+    )
+    _guild_id: "Snowflake_Type" = attrs.field(repr=False, default=None, converter=to_snowflake)
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        creator_dict = data.pop("user", None)
+        data["creator_id"] = client.cache.place_user_data(creator_dict).id if creator_dict else None
+
+        if "roles" in data:
+            data["role_ids"] = data.pop("roles")
+
+        return data
+
+    @classmethod
+    def from_dict(cls, data: Dict[str, Any], client: "Client", guild_id: int) -> "CustomEmoji":
+        data = cls._process_dict(data, client)
+        return cls(client=client, guild_id=guild_id, **cls._filter_kwargs(data, cls._get_init_keys()))
+
+    @property
+    def guild(self) -> "Guild":
+        """The guild this emoji belongs to."""
+        return self._client.cache.get_guild(self._guild_id)
+
+    @property
+    def creator(self) -> Optional[Union["Member", "User"]]:
+        """The member that created this emoji."""
+        return self._client.cache.get_member(self._creator_id, self._guild_id) or self._client.cache.get_user(
+            self._creator_id
+        )
+
+    @property
+    def roles(self) -> List["Role"]:
+        """The roles allowed to use this emoji."""
+        return [self._client.cache.get_role(role_id) for role_id in self._role_ids]
+
+    @property
+    def is_usable(self) -> bool:
+        """Determines if this emoji is usable by the current user."""
+        if not self.available:
+            return False
+
+        guild = self.guild
+        return any(e_role_id in guild.me._role_ids for e_role_id in self._role_ids)
+
+    async def edit(
+        self,
+        *,
+        name: Optional[str] = None,
+        roles: Optional[List[Union["Snowflake_Type", "Role"]]] = None,
+        reason: Optional[str] = None,
+    ) -> "CustomEmoji":
+        """
+        Modify the custom emoji information.
+
+        Args:
+            name: The name of the emoji.
+            roles: The roles allowed to use this emoji.
+            reason: Attach a reason to this action, used for audit logs.
+
+        Returns:
+            The newly modified custom emoji.
+
+        """
+        data_payload = dict_filter_none(
+            {
+                "name": name,
+                "roles": to_snowflake_list(roles) if roles else None,
+            }
+        )
+
+        updated_data = await self._client.http.modify_guild_emoji(data_payload, self._guild_id, self.id, reason=reason)
+        self.update_from_dict(updated_data)
+        return self
+
+    async def delete(self, reason: Optional[str] = None) -> None:
+        """
+        Deletes the custom emoji from the guild.
+
+        Args:
+            reason: Attach a reason to this action, used for audit logs.
+
+        """
+        if not self._guild_id:
+            raise ValueError("Cannot delete emoji, no guild id set.")
+
+        await self._client.http.delete_guild_emoji(self._guild_id, self.id, reason=reason)
+
+
+def process_emoji_req_format(emoji: Optional[Union[PartialEmoji, dict, str]]) -> Optional[str]:
+    """
+    Processes the emoji parameter into the str format required by the API.
+
+    Args:
+        emoji: The emoji to process.
+
+    Returns:
+        formatted string for discord
+
+    """
+    if not emoji:
+        return emoji
+
+    if isinstance(emoji, str):
+        emoji = PartialEmoji.from_str(emoji)
+
+    if isinstance(emoji, dict):
+        emoji = PartialEmoji.from_dict(emoji)
+
+    if isinstance(emoji, PartialEmoji):
+        return emoji.req_format
+
+    raise ValueError(f"Invalid emoji: {emoji}")
+
+
+def process_emoji(emoji: Optional[Union[PartialEmoji, dict, str]]) -> Optional[dict]:
+    """
+    Processes the emoji parameter into the dictionary format required by the API.
+
+    Args:
+        emoji: The emoji to process.
+
+    Returns:
+        formatted dictionary for discord
+
+    """
+    if not emoji:
+        return emoji
+
+    if isinstance(emoji, dict):
+        return emoji
+
+    if isinstance(emoji, str):
+        emoji = PartialEmoji.from_str(emoji)
+
+    if isinstance(emoji, PartialEmoji):
+        return emoji.to_dict()
+
+    raise ValueError(f"Invalid emoji: {emoji}")
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/invite.py` & `discord-py-interactions-5.6.0/interactions/models/discord/invite.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,134 +1,134 @@
-from typing import TYPE_CHECKING, Optional, Union, Dict, Any
-
-import attrs
-
-from interactions.client.const import MISSING, Absent
-from interactions.client.utils.attr_converters import optional as optional_c
-from interactions.client.utils.attr_converters import timestamp_converter
-from interactions.models.discord.application import Application
-from interactions.models.discord.enums import InviteTargetType
-from interactions.models.discord.guild import GuildPreview
-from interactions.models.discord.snowflake import to_snowflake
-from interactions.models.discord.stage_instance import StageInstance
-from interactions.models.discord.timestamp import Timestamp
-from .base import ClientObject
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-    from interactions.models import TYPE_GUILD_CHANNEL
-    from interactions.models.discord.user import User
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-__all__ = ("Invite",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Invite(ClientObject):
-    code: str = attrs.field(repr=True)
-    """the invite code (unique ID)"""
-
-    # metadata
-    uses: int = attrs.field(default=0, repr=True)
-    """the guild this invite is for"""
-    max_uses: int = attrs.field(repr=False, default=0)
-    """max number of times this invite can be used"""
-    max_age: int = attrs.field(repr=False, default=0)
-    """duration (in seconds) after which the invite expires"""
-    created_at: Timestamp = attrs.field(default=MISSING, converter=optional_c(timestamp_converter), repr=True)
-    """when this invite was created"""
-    temporary: bool = attrs.field(default=False, repr=True)
-    """whether this invite only grants temporary membership"""
-
-    # target data
-    target_type: Optional[Union[InviteTargetType, int]] = attrs.field(
-        default=None, converter=optional_c(InviteTargetType), repr=True
-    )
-    """the type of target for this voice channel invite"""
-    approximate_presence_count: Optional[int] = attrs.field(repr=False, default=MISSING)
-    """approximate count of online members, returned from the `GET /invites/<code>` endpoint when `with_counts` is `True`"""
-    approximate_member_count: Optional[int] = attrs.field(repr=False, default=MISSING)
-    """approximate count of total members, returned from the `GET /invites/<code>` endpoint when `with_counts` is `True`"""
-    scheduled_event: Optional["Snowflake_Type"] = attrs.field(
-        default=None, converter=optional_c(to_snowflake), repr=True
-    )
-    """guild scheduled event data, only included if `guild_scheduled_event_id` contains a valid guild scheduled event id"""
-    expires_at: Optional[Timestamp] = attrs.field(default=None, converter=optional_c(timestamp_converter), repr=True)
-    """the expiration date of this invite, returned from the `GET /invites/<code>` endpoint when `with_expiration` is `True`"""
-    stage_instance: Optional[StageInstance] = attrs.field(repr=False, default=None)
-    """stage instance data if there is a public Stage instance in the Stage channel this invite is for (deprecated)"""
-    target_application: Optional[dict] = attrs.field(repr=False, default=None)
-    """the embedded application to open for this voice channel embedded application invite"""
-    guild_preview: Optional[GuildPreview] = attrs.field(repr=False, default=MISSING)
-    """the guild this invite is for"""
-
-    # internal for props
-    _channel_id: "Snowflake_Type" = attrs.field(converter=to_snowflake, repr=True)
-    _inviter_id: Optional["Snowflake_Type"] = attrs.field(default=None, converter=optional_c(to_snowflake), repr=True)
-    _target_user_id: Optional["Snowflake_Type"] = attrs.field(
-        repr=False, default=None, converter=optional_c(to_snowflake)
-    )
-
-    @property
-    def channel(self) -> "TYPE_GUILD_CHANNEL":
-        """The channel the invite is for."""
-        return self._client.cache.get_channel(self._channel_id)
-
-    @property
-    def inviter(self) -> Optional["User"]:
-        """The user that created the invite or None."""
-        return self._client.cache.get_user(self._inviter_id) if self._inviter_id else None
-
-    @property
-    def target_user(self) -> Optional["User"]:
-        """The user whose stream to display for this voice channel stream invite or None."""
-        return self._client.cache.get_user(self._target_user_id) if self._target_user_id else None
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        if "stage_instance" in data:
-            data["stage_instance"] = StageInstance.from_dict(data, client)
-
-        if "target_application" in data:
-            data["target_application"] = Application.from_dict(data, client)
-
-        if "target_event_id" in data:
-            data["scheduled_event"] = data["target_event_id"]
-
-        if channel := data.pop("channel", None):
-            # invite metadata does not contain enough info to create a channel object
-            data["channel_id"] = channel["id"]
-
-        if guild := data.pop("guild", None):
-            data["guild_preview"] = GuildPreview.from_dict(guild, client)
-
-        if inviter := data.pop("inviter", None):
-            inviter = client.cache.place_user_data(inviter)
-            data["inviter_id"] = inviter.id
-
-        return data
-
-    def __str__(self) -> str:
-        return self.link
-
-    @property
-    def link(self) -> str:
-        """The invite link."""
-        if self.scheduled_event:
-            return f"https://discord.gg/{self.code}?event={self.scheduled_event}"
-        return f"https://discord.gg/{self.code}"
-
-    async def delete(self, reason: Absent[str] = MISSING) -> None:
-        """
-        Delete this invite.
-
-        !!! note
-            You must have the `manage_channels` permission on the channel this invite belongs to.
-
-        !!! note
-            With `manage_guild` permission, you can delete any invite across the guild.
-
-        Args:
-            reason: The reason for the deletion of invite.
-
-        """
-        await self._client.http.delete_invite(self.code, reason=reason)
+from typing import TYPE_CHECKING, Optional, Union, Dict, Any
+
+import attrs
+
+from interactions.client.const import MISSING, Absent
+from interactions.client.utils.attr_converters import optional as optional_c
+from interactions.client.utils.attr_converters import timestamp_converter
+from interactions.models.discord.application import Application
+from interactions.models.discord.enums import InviteTargetType
+from interactions.models.discord.guild import GuildPreview
+from interactions.models.discord.snowflake import to_snowflake
+from interactions.models.discord.stage_instance import StageInstance
+from interactions.models.discord.timestamp import Timestamp
+from .base import ClientObject
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+    from interactions.models import TYPE_GUILD_CHANNEL
+    from interactions.models.discord.user import User
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+__all__ = ("Invite",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Invite(ClientObject):
+    code: str = attrs.field(repr=True)
+    """the invite code (unique ID)"""
+
+    # metadata
+    uses: int = attrs.field(default=0, repr=True)
+    """the guild this invite is for"""
+    max_uses: int = attrs.field(repr=False, default=0)
+    """max number of times this invite can be used"""
+    max_age: int = attrs.field(repr=False, default=0)
+    """duration (in seconds) after which the invite expires"""
+    created_at: Timestamp = attrs.field(default=MISSING, converter=optional_c(timestamp_converter), repr=True)
+    """when this invite was created"""
+    temporary: bool = attrs.field(default=False, repr=True)
+    """whether this invite only grants temporary membership"""
+
+    # target data
+    target_type: Optional[Union[InviteTargetType, int]] = attrs.field(
+        default=None, converter=optional_c(InviteTargetType), repr=True
+    )
+    """the type of target for this voice channel invite"""
+    approximate_presence_count: Optional[int] = attrs.field(repr=False, default=MISSING)
+    """approximate count of online members, returned from the `GET /invites/<code>` endpoint when `with_counts` is `True`"""
+    approximate_member_count: Optional[int] = attrs.field(repr=False, default=MISSING)
+    """approximate count of total members, returned from the `GET /invites/<code>` endpoint when `with_counts` is `True`"""
+    scheduled_event: Optional["Snowflake_Type"] = attrs.field(
+        default=None, converter=optional_c(to_snowflake), repr=True
+    )
+    """guild scheduled event data, only included if `guild_scheduled_event_id` contains a valid guild scheduled event id"""
+    expires_at: Optional[Timestamp] = attrs.field(default=None, converter=optional_c(timestamp_converter), repr=True)
+    """the expiration date of this invite, returned from the `GET /invites/<code>` endpoint when `with_expiration` is `True`"""
+    stage_instance: Optional[StageInstance] = attrs.field(repr=False, default=None)
+    """stage instance data if there is a public Stage instance in the Stage channel this invite is for (deprecated)"""
+    target_application: Optional[dict] = attrs.field(repr=False, default=None)
+    """the embedded application to open for this voice channel embedded application invite"""
+    guild_preview: Optional[GuildPreview] = attrs.field(repr=False, default=MISSING)
+    """the guild this invite is for"""
+
+    # internal for props
+    _channel_id: "Snowflake_Type" = attrs.field(converter=to_snowflake, repr=True)
+    _inviter_id: Optional["Snowflake_Type"] = attrs.field(default=None, converter=optional_c(to_snowflake), repr=True)
+    _target_user_id: Optional["Snowflake_Type"] = attrs.field(
+        repr=False, default=None, converter=optional_c(to_snowflake)
+    )
+
+    @property
+    def channel(self) -> "TYPE_GUILD_CHANNEL":
+        """The channel the invite is for."""
+        return self._client.cache.get_channel(self._channel_id)
+
+    @property
+    def inviter(self) -> Optional["User"]:
+        """The user that created the invite or None."""
+        return self._client.cache.get_user(self._inviter_id) if self._inviter_id else None
+
+    @property
+    def target_user(self) -> Optional["User"]:
+        """The user whose stream to display for this voice channel stream invite or None."""
+        return self._client.cache.get_user(self._target_user_id) if self._target_user_id else None
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        if "stage_instance" in data:
+            data["stage_instance"] = StageInstance.from_dict(data, client)
+
+        if "target_application" in data:
+            data["target_application"] = Application.from_dict(data, client)
+
+        if "target_event_id" in data:
+            data["scheduled_event"] = data["target_event_id"]
+
+        if channel := data.pop("channel", None):
+            # invite metadata does not contain enough info to create a channel object
+            data["channel_id"] = channel["id"]
+
+        if guild := data.pop("guild", None):
+            data["guild_preview"] = GuildPreview.from_dict(guild, client)
+
+        if inviter := data.pop("inviter", None):
+            inviter = client.cache.place_user_data(inviter)
+            data["inviter_id"] = inviter.id
+
+        return data
+
+    def __str__(self) -> str:
+        return self.link
+
+    @property
+    def link(self) -> str:
+        """The invite link."""
+        if self.scheduled_event:
+            return f"https://discord.gg/{self.code}?event={self.scheduled_event}"
+        return f"https://discord.gg/{self.code}"
+
+    async def delete(self, reason: Absent[str] = MISSING) -> None:
+        """
+        Delete this invite.
+
+        !!! note
+            You must have the `manage_channels` permission on the channel this invite belongs to.
+
+        !!! note
+            With `manage_guild` permission, you can delete any invite across the guild.
+
+        Args:
+            reason: The reason for the deletion of invite.
+
+        """
+        await self._client.http.delete_invite(self.code, reason=reason)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/reaction.py` & `discord-py-interactions-5.6.0/interactions/models/discord/reaction.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,97 +1,97 @@
-from asyncio import QueueEmpty
-from collections import namedtuple
-from typing import TYPE_CHECKING, List, Optional
-
-import attrs
-
-from interactions.client.const import MISSING
-from interactions.models.discord.emoji import PartialEmoji
-from interactions.models.discord.snowflake import to_snowflake
-from interactions.models.misc.iterator import AsyncIterator
-from .base import ClientObject
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-    from interactions.models import Message, TYPE_ALL_CHANNEL
-    from interactions.models.discord.user import User
-
-__all__ = ("ReactionUsers", "Reaction")
-
-
-class ReactionUsers(AsyncIterator):
-    """
-    An async iterator for searching through a channel's history.
-
-    Attributes:
-        reaction: The reaction to search through
-        limit: The maximum number of users to return (set to 0 for no limit)
-        after: get users after this message ID
-
-    """
-
-    def __init__(self, reaction: "Reaction", limit: int = 50, after: Optional["Snowflake_Type"] = None) -> None:
-        self.reaction: "Reaction" = reaction
-        self.after: "Snowflake_Type" = after
-        self._more = True
-        super().__init__(limit)
-
-    async def fetch(self) -> List["User"]:
-        """
-        Gets all the users who reacted to the message. Requests user data from discord API if not cached.
-
-        Returns:
-            A list of users who reacted to the message.
-
-        """
-        if self._more:
-            expected = self.get_limit
-
-            if self.after and not self.last:
-                self.last = namedtuple("temp", "id")
-                self.last.id = self.after
-
-            users = await self.reaction._client.http.get_reactions(
-                self.reaction._channel_id,
-                self.reaction._message_id,
-                self.reaction.emoji.req_format,
-                limit=expected,
-                after=self.last.id or MISSING,
-            )
-            if not users:
-                raise QueueEmpty
-            self._more = len(users) == expected
-            return [self.reaction._client.cache.place_user_data(u) for u in users]
-        raise QueueEmpty
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Reaction(ClientObject):
-    count: int = attrs.field(
-        repr=False,
-    )
-    """times this emoji has been used to react"""
-    me: bool = attrs.field(repr=False, default=False)
-    """whether the current user reacted using this emoji"""
-    emoji: "PartialEmoji" = attrs.field(repr=False, converter=PartialEmoji.from_dict)
-    """emoji information"""
-
-    _channel_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-    _message_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-
-    def users(self, limit: int = 0, after: "Snowflake_Type" = None) -> ReactionUsers:
-        """Users who reacted using this emoji."""
-        return ReactionUsers(self, limit, after)
-
-    @property
-    def message(self) -> "Message":
-        """The message this reaction is on."""
-        return self._client.cache.get_message(self._channel_id, self._message_id)
-
-    @property
-    def channel(self) -> "TYPE_ALL_CHANNEL":
-        """The channel this reaction is on."""
-        return self._client.cache.get_channel(self._channel_id)
-
-    async def remove(self) -> None:
-        """Remove all this emoji's reactions from the message."""
-        await self._client.http.clear_reaction(self._channel_id, self._message_id, self.emoji.req_format)
+from asyncio import QueueEmpty
+from collections import namedtuple
+from typing import TYPE_CHECKING, List, Optional
+
+import attrs
+
+from interactions.client.const import MISSING
+from interactions.models.discord.emoji import PartialEmoji
+from interactions.models.discord.snowflake import to_snowflake
+from interactions.models.misc.iterator import AsyncIterator
+from .base import ClientObject
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+    from interactions.models import Message, TYPE_ALL_CHANNEL
+    from interactions.models.discord.user import User
+
+__all__ = ("ReactionUsers", "Reaction")
+
+
+class ReactionUsers(AsyncIterator):
+    """
+    An async iterator for searching through a channel's history.
+
+    Attributes:
+        reaction: The reaction to search through
+        limit: The maximum number of users to return (set to 0 for no limit)
+        after: get users after this message ID
+
+    """
+
+    def __init__(self, reaction: "Reaction", limit: int = 50, after: Optional["Snowflake_Type"] = None) -> None:
+        self.reaction: "Reaction" = reaction
+        self.after: "Snowflake_Type" = after
+        self._more = True
+        super().__init__(limit)
+
+    async def fetch(self) -> List["User"]:
+        """
+        Gets all the users who reacted to the message. Requests user data from discord API if not cached.
+
+        Returns:
+            A list of users who reacted to the message.
+
+        """
+        if self._more:
+            expected = self.get_limit
+
+            if self.after and not self.last:
+                self.last = namedtuple("temp", "id")
+                self.last.id = self.after
+
+            users = await self.reaction._client.http.get_reactions(
+                self.reaction._channel_id,
+                self.reaction._message_id,
+                self.reaction.emoji.req_format,
+                limit=expected,
+                after=self.last.id or MISSING,
+            )
+            if not users:
+                raise QueueEmpty
+            self._more = len(users) == expected
+            return [self.reaction._client.cache.place_user_data(u) for u in users]
+        raise QueueEmpty
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Reaction(ClientObject):
+    count: int = attrs.field(
+        repr=False,
+    )
+    """times this emoji has been used to react"""
+    me: bool = attrs.field(repr=False, default=False)
+    """whether the current user reacted using this emoji"""
+    emoji: "PartialEmoji" = attrs.field(repr=False, converter=PartialEmoji.from_dict)
+    """emoji information"""
+
+    _channel_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+    _message_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+
+    def users(self, limit: int = 0, after: "Snowflake_Type" = None) -> ReactionUsers:
+        """Users who reacted using this emoji."""
+        return ReactionUsers(self, limit, after)
+
+    @property
+    def message(self) -> "Message":
+        """The message this reaction is on."""
+        return self._client.cache.get_message(self._channel_id, self._message_id)
+
+    @property
+    def channel(self) -> "TYPE_ALL_CHANNEL":
+        """The channel this reaction is on."""
+        return self._client.cache.get_channel(self._channel_id)
+
+    async def remove(self) -> None:
+        """Remove all this emoji's reactions from the message."""
+        await self._client.http.clear_reaction(self._channel_id, self._message_id, self.emoji.req_format)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/role.py` & `discord-py-interactions-5.6.0/interactions/models/discord/role.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,237 +1,237 @@
-from functools import partial, total_ordering
-from typing import Any, TYPE_CHECKING
-
-import attrs
-
-from interactions.client.const import MISSING, T, Missing
-from interactions.client.utils import nulled_boolean_get
-from interactions.client.utils.attr_converters import optional as optional_c
-from interactions.client.utils.serializer import dict_filter
-from interactions.models.discord.asset import Asset
-from interactions.models.discord.color import COLOR_TYPES, Color, process_color
-from interactions.models.discord.emoji import PartialEmoji
-from interactions.models.discord.enums import Permissions
-from .base import DiscordObject
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-    from interactions.models.discord.guild import Guild
-    from interactions.models.discord.user import Member
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-__all__ = ("Role",)
-
-
-def sentinel_converter(value: bool | T | None, sentinel: T = attrs.NOTHING) -> bool | T:
-    if value is sentinel:
-        return False
-    return True if value is None else value
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-@total_ordering
-class Role(DiscordObject):
-    _sentinel = object()
-
-    name: str = attrs.field(repr=True)
-    color: "Color" = attrs.field(repr=False, converter=Color)
-    hoist: bool = attrs.field(repr=False, default=False)
-    position: int = attrs.field(repr=True)
-    permissions: "Permissions" = attrs.field(repr=False, converter=Permissions)
-    managed: bool = attrs.field(repr=False, default=False)
-    mentionable: bool = attrs.field(repr=False, default=True)
-    premium_subscriber: bool = attrs.field(
-        repr=False, default=_sentinel, converter=partial(sentinel_converter, sentinel=_sentinel)
-    )
-    subscription_listing_id: "Snowflake_Type | None" = attrs.field(default=None, repr=False)
-    purchasable_or_has_subscribers: bool = attrs.field(default=False)
-    _icon: Asset | None = attrs.field(repr=False, default=None)
-    _unicode_emoji: PartialEmoji | None = attrs.field(
-        repr=False, default=None, converter=optional_c(PartialEmoji.from_str)
-    )
-    _guild_id: "Snowflake_Type" = attrs.field(
-        repr=False,
-    )
-    _bot_id: "Snowflake_Type | None" = attrs.field(repr=False, default=None)
-    _integration_id: "Snowflake_Type | None" = attrs.field(repr=False, default=None)  # todo integration object?
-    _guild_connections: bool = attrs.field(repr=False, default=False)
-
-    def __lt__(self: "Role", other: "Role") -> bool:
-        if not isinstance(self, Role) or not isinstance(other, Role):
-            return NotImplemented
-
-        if self._guild_id != other._guild_id:
-            raise RuntimeError("Unable to compare Roles from different guilds.")
-
-        if self.id == self._guild_id:  # everyone role
-            # everyone role is on the bottom, so check if the other role is, well, not it
-            # because then it must be higher than it
-            return other.id != self.id
-
-        if self.position < other.position:
-            return True
-
-        return self.id < other.id if self.position == other.position else False
-
-    @classmethod
-    def _process_dict(cls, data: dict[str, Any], client: "Client") -> dict[str, Any]:
-        data |= data.pop("tags", {})
-
-        if icon_hash := data.get("icon"):
-            data["icon"] = Asset.from_path_hash(client, f"role-icons/{data['id']}/{{}}", icon_hash)
-
-        data["premium_subscriber"] = nulled_boolean_get(data, "premium_subscriber")
-        data["guild_connections"] = nulled_boolean_get(data, "guild_connections")
-        data["available_for_purchase"] = nulled_boolean_get(data, "available_for_purchase")
-
-        return data
-
-    async def fetch_bot(self, *, force: bool = False) -> "Member | None":
-        """
-        Fetch the bot associated with this role if any.
-
-        Args:
-            force: Whether to force fetch the bot from the API.
-
-        Returns:
-            Member object if any
-
-        """
-        if self._bot_id is None:
-            return None
-        return await self._client.cache.fetch_member(self._guild_id, self._bot_id, force=force)
-
-    def get_bot(self) -> "Member | None":
-        """
-        Get the bot associated with this role if any.
-
-        Returns:
-            Member object if any
-
-        """
-        if self._bot_id is None:
-            return None
-        return self._client.cache.get_member(self._guild_id, self._bot_id)
-
-    @property
-    def guild(self) -> "Guild":
-        """The guild object this role is from."""
-        return self._client.cache.get_guild(self._guild_id)  # pyright: ignore [reportGeneralTypeIssues]
-
-    @property
-    def default(self) -> bool:
-        """Is this the `@everyone` role."""
-        return self.id == self._guild_id
-
-    @property
-    def bot_managed(self) -> bool:
-        """Is this role owned/managed by a bot."""
-        return self._bot_id is not None
-
-    @property
-    def is_linked_role(self) -> bool:
-        """Is this role a linked role."""
-        return self._guild_connections
-
-    @property
-    def mention(self) -> str:
-        """Returns a string that would mention the role."""
-        return f"<@&{self.id}>" if self.id != self._guild_id else "@everyone"
-
-    @property
-    def integration(self) -> bool:
-        """Is this role owned/managed by an integration."""
-        return self._integration_id is not None
-
-    @property
-    def members(self) -> list["Member"]:
-        """List of members with this role"""
-        return [member for member in self.guild.members if member.has_role(self)]
-
-    @property
-    def icon(self) -> Asset | PartialEmoji | None:
-        """
-        The icon of this role
-
-        !!! note
-            You have to use this method instead of the `_icon` attribute, because the first does account for unicode emojis
-        """
-        return self._icon or self._unicode_emoji
-
-    @property
-    def is_assignable(self) -> bool:
-        """
-        Can this role be assigned or removed by this bot?
-
-        !!! note
-            This does not account for permissions, only the role hierarchy
-
-        """
-        return (self.default or self.guild.me.top_role > self) and not self.managed
-
-    async def delete(self, reason: str | Missing = MISSING) -> None:
-        """
-        Delete this role.
-
-        Args:
-            reason: An optional reason for this deletion
-
-        """
-        await self._client.http.delete_guild_role(self._guild_id, self.id, reason)
-
-    async def edit(
-        self,
-        *,
-        name: str | None = None,
-        permissions: str | None = None,
-        color: Color | COLOR_TYPES | None = None,
-        hoist: bool | None = None,
-        mentionable: bool | None = None,
-    ) -> "Role":
-        """
-        Edit this role, all arguments are optional.
-
-        Args:
-            name: name of the role
-            permissions: New permissions to use
-            color: The color of the role
-            hoist: whether the role should be displayed separately in the sidebar
-            mentionable: whether the role should be mentionable
-
-        Returns:
-            Role with updated information
-
-        """
-        color = process_color(color)
-
-        payload = dict_filter(
-            {
-                "name": name,
-                "permissions": permissions,
-                "color": color,
-                "hoist": hoist,
-                "mentionable": mentionable,
-            }
-        )
-
-        r_data = await self._client.http.modify_guild_role(self._guild_id, self.id, payload)
-        r_data = dict(r_data)  # to convert typed dict to regular dict
-        r_data["guild_id"] = self._guild_id
-        return self.from_dict(r_data, self._client)
-
-    async def move(self, position: int, reason: str | Missing = MISSING) -> "Role":
-        """
-        Move this role to a new position.
-
-        Args:
-            position: The new position of the role
-            reason: An optional reason for this move
-
-        Returns:
-            The role object
-
-        """
-        await self._client.http.modify_guild_role_positions(
-            self._guild_id, [{"id": self.id, "position": position}], reason
-        )
-        return self
+from functools import partial, total_ordering
+from typing import Any, TYPE_CHECKING
+
+import attrs
+
+from interactions.client.const import MISSING, T, Missing
+from interactions.client.utils import nulled_boolean_get
+from interactions.client.utils.attr_converters import optional as optional_c
+from interactions.client.utils.serializer import dict_filter
+from interactions.models.discord.asset import Asset
+from interactions.models.discord.color import COLOR_TYPES, Color, process_color
+from interactions.models.discord.emoji import PartialEmoji
+from interactions.models.discord.enums import Permissions
+from .base import DiscordObject
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+    from interactions.models.discord.guild import Guild
+    from interactions.models.discord.user import Member
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+__all__ = ("Role",)
+
+
+def sentinel_converter(value: bool | T | None, sentinel: T = attrs.NOTHING) -> bool | T:
+    if value is sentinel:
+        return False
+    return True if value is None else value
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+@total_ordering
+class Role(DiscordObject):
+    _sentinel = object()
+
+    name: str = attrs.field(repr=True)
+    color: "Color" = attrs.field(repr=False, converter=Color)
+    hoist: bool = attrs.field(repr=False, default=False)
+    position: int = attrs.field(repr=True)
+    permissions: "Permissions" = attrs.field(repr=False, converter=Permissions)
+    managed: bool = attrs.field(repr=False, default=False)
+    mentionable: bool = attrs.field(repr=False, default=True)
+    premium_subscriber: bool = attrs.field(
+        repr=False, default=_sentinel, converter=partial(sentinel_converter, sentinel=_sentinel)
+    )
+    subscription_listing_id: "Snowflake_Type | None" = attrs.field(default=None, repr=False)
+    purchasable_or_has_subscribers: bool = attrs.field(default=False)
+    _icon: Asset | None = attrs.field(repr=False, default=None)
+    _unicode_emoji: PartialEmoji | None = attrs.field(
+        repr=False, default=None, converter=optional_c(PartialEmoji.from_str)
+    )
+    _guild_id: "Snowflake_Type" = attrs.field(
+        repr=False,
+    )
+    _bot_id: "Snowflake_Type | None" = attrs.field(repr=False, default=None)
+    _integration_id: "Snowflake_Type | None" = attrs.field(repr=False, default=None)  # todo integration object?
+    _guild_connections: bool = attrs.field(repr=False, default=False)
+
+    def __lt__(self: "Role", other: "Role") -> bool:
+        if not isinstance(self, Role) or not isinstance(other, Role):
+            return NotImplemented
+
+        if self._guild_id != other._guild_id:
+            raise RuntimeError("Unable to compare Roles from different guilds.")
+
+        if self.id == self._guild_id:  # everyone role
+            # everyone role is on the bottom, so check if the other role is, well, not it
+            # because then it must be higher than it
+            return other.id != self.id
+
+        if self.position < other.position:
+            return True
+
+        return self.id < other.id if self.position == other.position else False
+
+    @classmethod
+    def _process_dict(cls, data: dict[str, Any], client: "Client") -> dict[str, Any]:
+        data |= data.pop("tags", {})
+
+        if icon_hash := data.get("icon"):
+            data["icon"] = Asset.from_path_hash(client, f"role-icons/{data['id']}/{{}}", icon_hash)
+
+        data["premium_subscriber"] = nulled_boolean_get(data, "premium_subscriber")
+        data["guild_connections"] = nulled_boolean_get(data, "guild_connections")
+        data["available_for_purchase"] = nulled_boolean_get(data, "available_for_purchase")
+
+        return data
+
+    async def fetch_bot(self, *, force: bool = False) -> "Member | None":
+        """
+        Fetch the bot associated with this role if any.
+
+        Args:
+            force: Whether to force fetch the bot from the API.
+
+        Returns:
+            Member object if any
+
+        """
+        if self._bot_id is None:
+            return None
+        return await self._client.cache.fetch_member(self._guild_id, self._bot_id, force=force)
+
+    def get_bot(self) -> "Member | None":
+        """
+        Get the bot associated with this role if any.
+
+        Returns:
+            Member object if any
+
+        """
+        if self._bot_id is None:
+            return None
+        return self._client.cache.get_member(self._guild_id, self._bot_id)
+
+    @property
+    def guild(self) -> "Guild":
+        """The guild object this role is from."""
+        return self._client.cache.get_guild(self._guild_id)  # pyright: ignore [reportGeneralTypeIssues]
+
+    @property
+    def default(self) -> bool:
+        """Is this the `@everyone` role."""
+        return self.id == self._guild_id
+
+    @property
+    def bot_managed(self) -> bool:
+        """Is this role owned/managed by a bot."""
+        return self._bot_id is not None
+
+    @property
+    def is_linked_role(self) -> bool:
+        """Is this role a linked role."""
+        return self._guild_connections
+
+    @property
+    def mention(self) -> str:
+        """Returns a string that would mention the role."""
+        return f"<@&{self.id}>" if self.id != self._guild_id else "@everyone"
+
+    @property
+    def integration(self) -> bool:
+        """Is this role owned/managed by an integration."""
+        return self._integration_id is not None
+
+    @property
+    def members(self) -> list["Member"]:
+        """List of members with this role"""
+        return [member for member in self.guild.members if member.has_role(self)]
+
+    @property
+    def icon(self) -> Asset | PartialEmoji | None:
+        """
+        The icon of this role
+
+        !!! note
+            You have to use this method instead of the `_icon` attribute, because the first does account for unicode emojis
+        """
+        return self._icon or self._unicode_emoji
+
+    @property
+    def is_assignable(self) -> bool:
+        """
+        Can this role be assigned or removed by this bot?
+
+        !!! note
+            This does not account for permissions, only the role hierarchy
+
+        """
+        return (self.default or self.guild.me.top_role > self) and not self.managed
+
+    async def delete(self, reason: str | Missing = MISSING) -> None:
+        """
+        Delete this role.
+
+        Args:
+            reason: An optional reason for this deletion
+
+        """
+        await self._client.http.delete_guild_role(self._guild_id, self.id, reason)
+
+    async def edit(
+        self,
+        *,
+        name: str | None = None,
+        permissions: str | None = None,
+        color: Color | COLOR_TYPES | None = None,
+        hoist: bool | None = None,
+        mentionable: bool | None = None,
+    ) -> "Role":
+        """
+        Edit this role, all arguments are optional.
+
+        Args:
+            name: name of the role
+            permissions: New permissions to use
+            color: The color of the role
+            hoist: whether the role should be displayed separately in the sidebar
+            mentionable: whether the role should be mentionable
+
+        Returns:
+            Role with updated information
+
+        """
+        color = process_color(color)
+
+        payload = dict_filter(
+            {
+                "name": name,
+                "permissions": permissions,
+                "color": color,
+                "hoist": hoist,
+                "mentionable": mentionable,
+            }
+        )
+
+        r_data = await self._client.http.modify_guild_role(self._guild_id, self.id, payload)
+        r_data = dict(r_data)  # to convert typed dict to regular dict
+        r_data["guild_id"] = self._guild_id
+        return self.from_dict(r_data, self._client)
+
+    async def move(self, position: int, reason: str | Missing = MISSING) -> "Role":
+        """
+        Move this role to a new position.
+
+        Args:
+            position: The new position of the role
+            reason: An optional reason for this move
+
+        Returns:
+            The role object
+
+        """
+        await self._client.http.modify_guild_role_positions(
+            self._guild_id, [{"id": self.id, "position": position}], reason
+        )
+        return self
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/scheduled_event.py` & `discord-py-interactions-5.6.0/interactions/models/discord/scheduled_event.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,227 +1,227 @@
-from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union
-
-import attrs
-
-from interactions.client.const import MISSING, Absent
-from interactions.client.errors import EventLocationNotProvided
-from interactions.client.utils import to_image_data
-from interactions.client.utils.attr_converters import optional
-from interactions.client.utils.attr_converters import timestamp_converter
-from interactions.models.discord.asset import Asset
-from interactions.models.discord.file import UPLOADABLE_TYPE
-from interactions.models.discord.snowflake import Snowflake_Type, to_snowflake
-from interactions.models.discord.timestamp import Timestamp
-from .base import DiscordObject
-from .enums import ScheduledEventPrivacyLevel, ScheduledEventType, ScheduledEventStatus
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-    from interactions.models.discord.channel import GuildStageVoice, GuildVoice
-    from interactions.models.discord.guild import Guild
-    from interactions.models.discord.user import Member
-    from interactions.models.discord.user import User
-
-__all__ = ("ScheduledEvent",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ScheduledEvent(DiscordObject):
-    name: str = attrs.field(repr=True)
-    description: str = attrs.field(repr=False, default=MISSING)
-    entity_type: Union[ScheduledEventType, int] = attrs.field(repr=False, converter=ScheduledEventType)
-    """The type of the scheduled event"""
-    start_time: Timestamp = attrs.field(repr=False, converter=timestamp_converter)
-    """A Timestamp object representing the scheduled start time of the event """
-    end_time: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))
-    """Optional Timstamp object representing the scheduled end time, required if entity_type is EXTERNAL"""
-    privacy_level: Union[ScheduledEventPrivacyLevel, int] = attrs.field(
-        repr=False, converter=ScheduledEventPrivacyLevel
-    )
-    """
-    Privacy level of the scheduled event
-
-    ??? note
-        Discord only has `GUILD_ONLY` at the momment.
-    """
-    status: Union[ScheduledEventStatus, int] = attrs.field(repr=False, converter=ScheduledEventStatus)
-    """Current status of the scheduled event"""
-    entity_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))
-    """The id of an entity associated with a guild scheduled event"""
-    entity_metadata: Optional[Dict[str, Any]] = attrs.field(repr=False, default=MISSING)  # TODO make this
-    """The metadata associated with the entity_type"""
-    user_count: int = attrs.field(repr=False, default=MISSING)
-    """Amount of users subscribed to the scheduled event"""
-    cover: Asset | None = attrs.field(repr=False, default=None)
-    """The cover image of this event"""
-
-    _guild_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-    _creator: Optional["User"] = attrs.field(repr=False, default=MISSING)
-    _creator_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))
-    _channel_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
-
-    @property
-    async def creator(self) -> Optional["User"]:
-        """
-        Returns the user who created this event.
-
-        !!! note
-            Events made before October 25th, 2021 will not have a creator.
-
-        """
-        return await self._client.cache.fetch_user(self._creator_id) if self._creator_id else None
-
-    @property
-    def guild(self) -> "Guild":
-        return self._client.cache.get_guild(self._guild_id)
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        if data.get("creator"):
-            data["creator"] = client.cache.place_user_data(data["creator"])
-
-        if data.get("channel_id"):
-            data["channel"] = client.cache.get_channel(data["channel_id"])
-
-        data["start_time"] = data.get("scheduled_start_time")
-
-        if end_time := data.get("scheduled_end_time"):
-            data["end_time"] = end_time
-        else:
-            data["end_time"] = None
-
-        if image := data.get("image"):
-            data["cover"] = Asset.from_path_hash(client, f"guild-events/{data['id']}/{{}}", image)
-
-        data = super()._process_dict(data, client)
-        return data
-
-    @property
-    def location(self) -> Optional[str]:
-        """Returns the external locatian of this event."""
-        if self.entity_type == ScheduledEventType.EXTERNAL:
-            return self.entity_metadata["location"]
-        return None
-
-    async def fetch_channel(self, *, force: bool = False) -> Optional[Union["GuildVoice", "GuildStageVoice"]]:
-        """
-        Returns the channel this event is scheduled in if it is scheduled in a channel.
-
-        Args:
-            force: Whether to force fetch the channel from the API
-        """
-        if self._channel_id:
-            return await self._client.cache.fetch_channel(self._channel_id, force=force)
-        return None
-
-    def get_channel(self) -> Optional[Union["GuildVoice", "GuildStageVoice"]]:
-        """Returns the channel this event is scheduled in if it is scheduled in a channel."""
-        if self._channel_id:
-            return self._client.cache.get_channel(self._channel_id)
-        return None
-
-    async def fetch_event_users(
-        self,
-        limit: Optional[int] = 100,
-        with_member_data: bool = False,
-        before: Absent[Optional["Snowflake_Type"]] = MISSING,
-        after: Absent[Optional["Snowflake_Type"]] = MISSING,
-    ) -> List[Union["Member", "User"]]:
-        """
-        Fetch event users.
-
-        Args:
-            limit: Discord defualts to 100
-            with_member_data: Whether to include guild member data
-            before: Snowflake of a user to get before
-            after: Snowflake of a user to get after
-
-        !!! note
-            This method is paginated
-
-        """
-        event_users = await self._client.http.get_scheduled_event_users(
-            self._guild_id, self.id, limit, with_member_data, before, after
-        )
-        participants = []
-        for u in event_users:
-            if member := u.get("member"):
-                u["member"]["user"] = u["user"]
-                participants.append(self._client.cache.place_member_data(self._guild_id, member))
-            else:
-                participants.append(self._client.cache.place_user_data(u["user"]))
-
-        return participants
-
-    async def delete(self, reason: Absent[str] = MISSING) -> None:
-        """
-        Deletes this event.
-
-        Args:
-            reason: The reason for deleting this event
-
-        """
-        await self._client.http.delete_scheduled_event(self._guild_id, self.id, reason)
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        start_time: Absent["Timestamp"] = MISSING,
-        end_time: Absent["Timestamp"] = MISSING,
-        status: Absent[ScheduledEventStatus] = MISSING,
-        description: Absent[str] = MISSING,
-        channel_id: Absent[Optional["Snowflake_Type"]] = MISSING,
-        event_type: Absent[ScheduledEventType] = MISSING,
-        external_location: Absent[Optional[str]] = MISSING,
-        entity_metadata: Absent[dict] = MISSING,
-        privacy_level: Absent[ScheduledEventPrivacyLevel] = MISSING,
-        cover_image: Absent[UPLOADABLE_TYPE] = MISSING,
-        reason: Absent[str] = MISSING,
-    ) -> None:
-        """
-        Edits this event.
-
-        Args:
-            name: The name of the event
-            description: The description of the event
-            channel_id: The channel id of the event
-            event_type: The type of the event
-            start_time: The scheduled start time of the event
-            end_time: The scheduled end time of the event
-            status: The status of the event
-            external_location: The location of the event (1-100 characters)
-            entity_metadata: The metadata of the event
-            privacy_level: The privacy level of the event
-            cover_image: the cover image of the scheduled event
-            reason: The reason for editing the event
-
-        !!! note
-            If updating event_type to EXTERNAL:
-                `channel_id` is required and must be set to null
-
-                `external_location` or `entity_metadata` with a location field must be provided
-
-                `end_time` must be provided
-
-        """
-        if external_location is not MISSING:
-            entity_metadata = {"location": external_location}
-
-        if event_type == ScheduledEventType.EXTERNAL:
-            channel_id = None
-            if external_location == MISSING:
-                raise EventLocationNotProvided("Location is required for external events")
-
-        payload = {
-            "name": name,
-            "description": description,
-            "channel_id": channel_id,
-            "entity_type": event_type,
-            "scheduled_start_time": start_time.isoformat() if start_time else MISSING,
-            "scheduled_end_time": end_time.isoformat() if end_time else MISSING,
-            "status": status,
-            "entity_metadata": entity_metadata,
-            "privacy_level": privacy_level,
-            "image": to_image_data(cover_image) if cover_image else MISSING,
-        }
-        await self._client.http.modify_scheduled_event(self._guild_id, self.id, payload, reason)
+from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union
+
+import attrs
+
+from interactions.client.const import MISSING, Absent
+from interactions.client.errors import EventLocationNotProvided
+from interactions.client.utils import to_image_data
+from interactions.client.utils.attr_converters import optional
+from interactions.client.utils.attr_converters import timestamp_converter
+from interactions.models.discord.asset import Asset
+from interactions.models.discord.file import UPLOADABLE_TYPE
+from interactions.models.discord.snowflake import Snowflake_Type, to_snowflake
+from interactions.models.discord.timestamp import Timestamp
+from .base import DiscordObject
+from .enums import ScheduledEventPrivacyLevel, ScheduledEventType, ScheduledEventStatus
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+    from interactions.models.discord.channel import GuildStageVoice, GuildVoice
+    from interactions.models.discord.guild import Guild
+    from interactions.models.discord.user import Member
+    from interactions.models.discord.user import User
+
+__all__ = ("ScheduledEvent",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ScheduledEvent(DiscordObject):
+    name: str = attrs.field(repr=True)
+    description: str = attrs.field(repr=False, default=MISSING)
+    entity_type: Union[ScheduledEventType, int] = attrs.field(repr=False, converter=ScheduledEventType)
+    """The type of the scheduled event"""
+    start_time: Timestamp = attrs.field(repr=False, converter=timestamp_converter)
+    """A Timestamp object representing the scheduled start time of the event """
+    end_time: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))
+    """Optional Timstamp object representing the scheduled end time, required if entity_type is EXTERNAL"""
+    privacy_level: Union[ScheduledEventPrivacyLevel, int] = attrs.field(
+        repr=False, converter=ScheduledEventPrivacyLevel
+    )
+    """
+    Privacy level of the scheduled event
+
+    ??? note
+        Discord only has `GUILD_ONLY` at the momment.
+    """
+    status: Union[ScheduledEventStatus, int] = attrs.field(repr=False, converter=ScheduledEventStatus)
+    """Current status of the scheduled event"""
+    entity_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))
+    """The id of an entity associated with a guild scheduled event"""
+    entity_metadata: Optional[Dict[str, Any]] = attrs.field(repr=False, default=MISSING)  # TODO make this
+    """The metadata associated with the entity_type"""
+    user_count: int = attrs.field(repr=False, default=MISSING)
+    """Amount of users subscribed to the scheduled event"""
+    cover: Asset | None = attrs.field(repr=False, default=None)
+    """The cover image of this event"""
+
+    _guild_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+    _creator: Optional["User"] = attrs.field(repr=False, default=MISSING)
+    _creator_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))
+    _channel_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
+
+    @property
+    async def creator(self) -> Optional["User"]:
+        """
+        Returns the user who created this event.
+
+        !!! note
+            Events made before October 25th, 2021 will not have a creator.
+
+        """
+        return await self._client.cache.fetch_user(self._creator_id) if self._creator_id else None
+
+    @property
+    def guild(self) -> "Guild":
+        return self._client.cache.get_guild(self._guild_id)
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        if data.get("creator"):
+            data["creator"] = client.cache.place_user_data(data["creator"])
+
+        if data.get("channel_id"):
+            data["channel"] = client.cache.get_channel(data["channel_id"])
+
+        data["start_time"] = data.get("scheduled_start_time")
+
+        if end_time := data.get("scheduled_end_time"):
+            data["end_time"] = end_time
+        else:
+            data["end_time"] = None
+
+        if image := data.get("image"):
+            data["cover"] = Asset.from_path_hash(client, f"guild-events/{data['id']}/{{}}", image)
+
+        data = super()._process_dict(data, client)
+        return data
+
+    @property
+    def location(self) -> Optional[str]:
+        """Returns the external locatian of this event."""
+        if self.entity_type == ScheduledEventType.EXTERNAL:
+            return self.entity_metadata["location"]
+        return None
+
+    async def fetch_channel(self, *, force: bool = False) -> Optional[Union["GuildVoice", "GuildStageVoice"]]:
+        """
+        Returns the channel this event is scheduled in if it is scheduled in a channel.
+
+        Args:
+            force: Whether to force fetch the channel from the API
+        """
+        if self._channel_id:
+            return await self._client.cache.fetch_channel(self._channel_id, force=force)
+        return None
+
+    def get_channel(self) -> Optional[Union["GuildVoice", "GuildStageVoice"]]:
+        """Returns the channel this event is scheduled in if it is scheduled in a channel."""
+        if self._channel_id:
+            return self._client.cache.get_channel(self._channel_id)
+        return None
+
+    async def fetch_event_users(
+        self,
+        limit: Optional[int] = 100,
+        with_member_data: bool = False,
+        before: Absent[Optional["Snowflake_Type"]] = MISSING,
+        after: Absent[Optional["Snowflake_Type"]] = MISSING,
+    ) -> List[Union["Member", "User"]]:
+        """
+        Fetch event users.
+
+        Args:
+            limit: Discord defualts to 100
+            with_member_data: Whether to include guild member data
+            before: Snowflake of a user to get before
+            after: Snowflake of a user to get after
+
+        !!! note
+            This method is paginated
+
+        """
+        event_users = await self._client.http.get_scheduled_event_users(
+            self._guild_id, self.id, limit, with_member_data, before, after
+        )
+        participants = []
+        for u in event_users:
+            if member := u.get("member"):
+                u["member"]["user"] = u["user"]
+                participants.append(self._client.cache.place_member_data(self._guild_id, member))
+            else:
+                participants.append(self._client.cache.place_user_data(u["user"]))
+
+        return participants
+
+    async def delete(self, reason: Absent[str] = MISSING) -> None:
+        """
+        Deletes this event.
+
+        Args:
+            reason: The reason for deleting this event
+
+        """
+        await self._client.http.delete_scheduled_event(self._guild_id, self.id, reason)
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        start_time: Absent["Timestamp"] = MISSING,
+        end_time: Absent["Timestamp"] = MISSING,
+        status: Absent[ScheduledEventStatus] = MISSING,
+        description: Absent[str] = MISSING,
+        channel_id: Absent[Optional["Snowflake_Type"]] = MISSING,
+        event_type: Absent[ScheduledEventType] = MISSING,
+        external_location: Absent[Optional[str]] = MISSING,
+        entity_metadata: Absent[dict] = MISSING,
+        privacy_level: Absent[ScheduledEventPrivacyLevel] = MISSING,
+        cover_image: Absent[UPLOADABLE_TYPE] = MISSING,
+        reason: Absent[str] = MISSING,
+    ) -> None:
+        """
+        Edits this event.
+
+        Args:
+            name: The name of the event
+            description: The description of the event
+            channel_id: The channel id of the event
+            event_type: The type of the event
+            start_time: The scheduled start time of the event
+            end_time: The scheduled end time of the event
+            status: The status of the event
+            external_location: The location of the event (1-100 characters)
+            entity_metadata: The metadata of the event
+            privacy_level: The privacy level of the event
+            cover_image: the cover image of the scheduled event
+            reason: The reason for editing the event
+
+        !!! note
+            If updating event_type to EXTERNAL:
+                `channel_id` is required and must be set to null
+
+                `external_location` or `entity_metadata` with a location field must be provided
+
+                `end_time` must be provided
+
+        """
+        if external_location is not MISSING:
+            entity_metadata = {"location": external_location}
+
+        if event_type == ScheduledEventType.EXTERNAL:
+            channel_id = None
+            if external_location == MISSING:
+                raise EventLocationNotProvided("Location is required for external events")
+
+        payload = {
+            "name": name,
+            "description": description,
+            "channel_id": channel_id,
+            "entity_type": event_type,
+            "scheduled_start_time": start_time.isoformat() if start_time else MISSING,
+            "scheduled_end_time": end_time.isoformat() if end_time else MISSING,
+            "status": status,
+            "entity_metadata": entity_metadata,
+            "privacy_level": privacy_level,
+            "image": to_image_data(cover_image) if cover_image else MISSING,
+        }
+        await self._client.http.modify_scheduled_event(self._guild_id, self.id, payload, reason)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/snowflake.py` & `discord-py-interactions-5.6.0/interactions/models/discord/snowflake.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,166 +1,166 @@
-import datetime
-from typing import Union, List, SupportsInt, Optional
-
-import attrs
-
-import interactions.models as models
-from interactions.client.const import MISSING, Absent, DISCORD_EPOCH
-
-__all__ = (
-    "to_snowflake",
-    "to_optional_snowflake",
-    "to_snowflake_list",
-    "Snowflake",
-    "SnowflakeObject",
-    "Snowflake_Type",
-)
-
-
-# Snowflake_Type should be used in FUNCTION args of user-facing APIs (combined with to_snowflake to sanitize input)
-# For MODEL id fields, just use int as type-hinting instead;
-# For attr convertors: Use int() when API-facing conversion is expected,
-# use to_snowflake when user should create this object
-Snowflake_Type = Union[int, str, "SnowflakeObject", SupportsInt, "Snowflake"]
-
-
-def to_snowflake(snowflake: Snowflake_Type) -> "Snowflake":
-    """
-    Helper function to convert something into correct Discord snowflake int, gives more helpful errors Use internally to sanitize user input or in user- facing APIs (a must).
-
-    For Discord-API - facing code, just int() is sufficient
-
-    """
-    try:
-        snowflake = Snowflake(snowflake)
-    except TypeError as e:
-        raise TypeError(
-            f"ID (snowflake) should be instance of int, str, SnowflakeObject, or support __int__. "
-            f"Got '{snowflake}' ({type(snowflake)}) instead."
-        ) from e
-    except ValueError as e:
-        raise ValueError(f"ID (snowflake) should represent int. Got '{snowflake}' ({type(snowflake)}) instead.") from e
-
-    if 22 > snowflake.bit_length() > 64:
-        raise ValueError(
-            f"ID (snowflake) is not in correct Discord format! Bit length of int should be from 22 to 64 "
-            f"Got '{snowflake}' (bit length {snowflake.bit_length()})"
-        )
-
-    return snowflake
-
-
-def to_optional_snowflake(
-    snowflake: Absent[Optional[Snowflake_Type]] = MISSING,
-) -> "Optional[Snowflake]":
-    if snowflake is MISSING:
-        return MISSING
-    return None if snowflake is None else to_snowflake(snowflake)
-
-
-def to_snowflake_list(snowflakes: List[Snowflake_Type]) -> "list[Snowflake]":
-    return [to_snowflake(c) for c in snowflakes]
-
-
-class Snowflake(int):
-    def __new__(cls, id: int) -> "Snowflake":
-        return int.__new__(cls, id)
-
-    def __iadd__(self, other) -> "Snowflake":
-        return Snowflake(int(self) + other)
-
-    def __isub__(self, other) -> "Snowflake":
-        return Snowflake(int(self) - other)
-
-    def __add__(self, other) -> "Snowflake":
-        return Snowflake(int(self) + other)
-
-    def __sub__(self, other) -> "Snowflake":
-        return Snowflake(int(self) - other)
-
-    @classmethod
-    def from_datetime(cls, dt: datetime.datetime, *, high: bool = False) -> "Snowflake":
-        """
-        Creates a snowflake from a datetime object.
-
-        Args:
-            dt: The datetime object to create the snowflake from.
-            high: Set to True if you're creating a snowflake in the discord future.
-        """
-        timestamp = dt.timestamp()
-        ms = int(timestamp * 1000 - DISCORD_EPOCH)
-
-        return cls((ms << 22) + (2**22 - 1 if high else 0))
-
-    @property
-    def created_at(self) -> "models.Timestamp":
-        """
-        Returns a timestamp representing the date-time this discord object was created.
-
-        :Returns:
-        """
-        from interactions.models import (
-            Timestamp,
-        )  # dirty i know; but it's an unavoidable circular import
-
-        return Timestamp.from_snowflake(self)
-
-    @property
-    def worker_id(self) -> int:
-        """The internal worker ID of the snowflake."""
-        return (int(self) & 0x3E0000) >> 17
-
-    @property
-    def process_id(self) -> int:
-        """The internal process ID of the snowflake."""
-        return (int(self) & 0x1F000) >> 12
-
-    @property
-    def increment(self) -> int:
-        """
-        The internal incrementation number of the snowflake.
-
-        This value will only increment when a process has been
-        generated on this snowflake, e.g. a resource.
-        """
-        return int(self) & 0xFFF
-
-    def difference(self, other: Union["Snowflake", int, str]) -> datetime.timedelta:
-        """
-        Returns the difference between two snowflakes.
-
-        Args:
-            other: The other snowflake to compare to.
-
-        """
-        if not isinstance(other, Snowflake):
-            other = Snowflake(other)
-        return abs(self.created_at - other.created_at)
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False)
-class SnowflakeObject:
-    id: Snowflake = attrs.field(repr=True, converter=Snowflake, metadata={"docs": "Discord unique snowflake ID"})
-
-    def __eq__(self, other: "SnowflakeObject") -> bool:
-        if hasattr(other, "id"):
-            other = other.id
-        return self.id == other
-
-    def __ne__(self, other: "SnowflakeObject") -> bool:
-        return not self.__eq__(other)
-
-    def __hash__(self) -> int:
-        return self.id << 32
-
-    def __int__(self) -> int:
-        return self.id
-
-    @property
-    def created_at(self) -> "models.Timestamp":
-        """
-        Returns a timestamp representing the date-time this discord object was created.
-
-        :Returns:
-
-        """
-        return self.id.created_at
+import datetime
+from typing import Union, List, SupportsInt, Optional
+
+import attrs
+
+import interactions.models as models
+from interactions.client.const import MISSING, Absent, DISCORD_EPOCH
+
+__all__ = (
+    "to_snowflake",
+    "to_optional_snowflake",
+    "to_snowflake_list",
+    "Snowflake",
+    "SnowflakeObject",
+    "Snowflake_Type",
+)
+
+
+# Snowflake_Type should be used in FUNCTION args of user-facing APIs (combined with to_snowflake to sanitize input)
+# For MODEL id fields, just use int as type-hinting instead;
+# For attr convertors: Use int() when API-facing conversion is expected,
+# use to_snowflake when user should create this object
+Snowflake_Type = Union[int, str, "SnowflakeObject", SupportsInt, "Snowflake"]
+
+
+def to_snowflake(snowflake: Snowflake_Type) -> "Snowflake":
+    """
+    Helper function to convert something into correct Discord snowflake int, gives more helpful errors Use internally to sanitize user input or in user- facing APIs (a must).
+
+    For Discord-API - facing code, just int() is sufficient
+
+    """
+    try:
+        snowflake = Snowflake(snowflake)
+    except TypeError as e:
+        raise TypeError(
+            f"ID (snowflake) should be instance of int, str, SnowflakeObject, or support __int__. "
+            f"Got '{snowflake}' ({type(snowflake)}) instead."
+        ) from e
+    except ValueError as e:
+        raise ValueError(f"ID (snowflake) should represent int. Got '{snowflake}' ({type(snowflake)}) instead.") from e
+
+    if 22 > snowflake.bit_length() > 64:
+        raise ValueError(
+            f"ID (snowflake) is not in correct Discord format! Bit length of int should be from 22 to 64 "
+            f"Got '{snowflake}' (bit length {snowflake.bit_length()})"
+        )
+
+    return snowflake
+
+
+def to_optional_snowflake(
+    snowflake: Absent[Optional[Snowflake_Type]] = MISSING,
+) -> "Optional[Snowflake]":
+    if snowflake is MISSING:
+        return MISSING
+    return None if snowflake is None else to_snowflake(snowflake)
+
+
+def to_snowflake_list(snowflakes: List[Snowflake_Type]) -> "list[Snowflake]":
+    return [to_snowflake(c) for c in snowflakes]
+
+
+class Snowflake(int):
+    def __new__(cls, id: int) -> "Snowflake":
+        return int.__new__(cls, id)
+
+    def __iadd__(self, other) -> "Snowflake":
+        return Snowflake(int(self) + other)
+
+    def __isub__(self, other) -> "Snowflake":
+        return Snowflake(int(self) - other)
+
+    def __add__(self, other) -> "Snowflake":
+        return Snowflake(int(self) + other)
+
+    def __sub__(self, other) -> "Snowflake":
+        return Snowflake(int(self) - other)
+
+    @classmethod
+    def from_datetime(cls, dt: datetime.datetime, *, high: bool = False) -> "Snowflake":
+        """
+        Creates a snowflake from a datetime object.
+
+        Args:
+            dt: The datetime object to create the snowflake from.
+            high: Set to True if you're creating a snowflake in the discord future.
+        """
+        timestamp = dt.timestamp()
+        ms = int(timestamp * 1000 - DISCORD_EPOCH)
+
+        return cls((ms << 22) + (2**22 - 1 if high else 0))
+
+    @property
+    def created_at(self) -> "models.Timestamp":
+        """
+        Returns a timestamp representing the date-time this discord object was created.
+
+        :Returns:
+        """
+        from interactions.models import (
+            Timestamp,
+        )  # dirty i know; but it's an unavoidable circular import
+
+        return Timestamp.from_snowflake(self)
+
+    @property
+    def worker_id(self) -> int:
+        """The internal worker ID of the snowflake."""
+        return (int(self) & 0x3E0000) >> 17
+
+    @property
+    def process_id(self) -> int:
+        """The internal process ID of the snowflake."""
+        return (int(self) & 0x1F000) >> 12
+
+    @property
+    def increment(self) -> int:
+        """
+        The internal incrementation number of the snowflake.
+
+        This value will only increment when a process has been
+        generated on this snowflake, e.g. a resource.
+        """
+        return int(self) & 0xFFF
+
+    def difference(self, other: Union["Snowflake", int, str]) -> datetime.timedelta:
+        """
+        Returns the difference between two snowflakes.
+
+        Args:
+            other: The other snowflake to compare to.
+
+        """
+        if not isinstance(other, Snowflake):
+            other = Snowflake(other)
+        return abs(self.created_at - other.created_at)
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False)
+class SnowflakeObject:
+    id: Snowflake = attrs.field(repr=True, converter=Snowflake, metadata={"docs": "Discord unique snowflake ID"})
+
+    def __eq__(self, other: "SnowflakeObject") -> bool:
+        if hasattr(other, "id"):
+            other = other.id
+        return self.id == other
+
+    def __ne__(self, other: "SnowflakeObject") -> bool:
+        return not self.__eq__(other)
+
+    def __hash__(self) -> int:
+        return self.id << 32
+
+    def __int__(self) -> int:
+        return self.id
+
+    @property
+    def created_at(self) -> "models.Timestamp":
+        """
+        Returns a timestamp representing the date-time this discord object was created.
+
+        :Returns:
+
+        """
+        return self.id.created_at
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/stage_instance.py` & `discord-py-interactions-5.6.0/interactions/models/discord/stage_instance.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,47 +1,47 @@
-from typing import TYPE_CHECKING, Optional
-
-import attrs
-
-from interactions.client.const import MISSING, Absent
-from interactions.models.discord.enums import StagePrivacyLevel
-from interactions.models.discord.snowflake import to_snowflake
-from .base import DiscordObject
-
-if TYPE_CHECKING:
-    from interactions.models import Guild, GuildStageVoice, Snowflake_Type
-
-__all__ = ("StageInstance",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class StageInstance(DiscordObject):
-    topic: str = attrs.field(
-        repr=False,
-    )
-    privacy_level: StagePrivacyLevel = attrs.field(
-        repr=False,
-    )
-    discoverable_disabled: bool = attrs.field(
-        repr=False,
-    )
-
-    _guild_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-    _channel_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-
-    @property
-    def guild(self) -> "Guild":
-        return self._client.cache.get_guild(self._guild_id)
-
-    @property
-    def channel(self) -> "GuildStageVoice":
-        return self._client.cache.get_channel(self._channel_id)
-
-    async def delete(self, reason: Absent[Optional[str]] = MISSING) -> None:
-        """
-        Delete this stage instance. Effectively closes the stage.
-
-        Args:
-            reason: The reason for this deletion, for the audit log
-
-        """
-        await self._client.http.delete_stage_instance(self._channel_id, reason)
+from typing import TYPE_CHECKING, Optional
+
+import attrs
+
+from interactions.client.const import MISSING, Absent
+from interactions.models.discord.enums import StagePrivacyLevel
+from interactions.models.discord.snowflake import to_snowflake
+from .base import DiscordObject
+
+if TYPE_CHECKING:
+    from interactions.models import Guild, GuildStageVoice, Snowflake_Type
+
+__all__ = ("StageInstance",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class StageInstance(DiscordObject):
+    topic: str = attrs.field(
+        repr=False,
+    )
+    privacy_level: StagePrivacyLevel = attrs.field(
+        repr=False,
+    )
+    discoverable_disabled: bool = attrs.field(
+        repr=False,
+    )
+
+    _guild_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+    _channel_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+
+    @property
+    def guild(self) -> "Guild":
+        return self._client.cache.get_guild(self._guild_id)
+
+    @property
+    def channel(self) -> "GuildStageVoice":
+        return self._client.cache.get_channel(self._channel_id)
+
+    async def delete(self, reason: Absent[Optional[str]] = MISSING) -> None:
+        """
+        Delete this stage instance. Effectively closes the stage.
+
+        Args:
+            reason: The reason for this deletion, for the audit log
+
+        """
+        await self._client.http.delete_stage_instance(self._channel_id, reason)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/sticker.py` & `discord-py-interactions-5.6.0/interactions/models/discord/sticker.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,154 +1,154 @@
-from typing import TYPE_CHECKING, List, Optional, Union
-
-import attrs
-
-from interactions.client.const import MISSING, Absent
-from interactions.client.utils.attr_converters import optional
-from interactions.client.utils.serializer import dict_filter_none
-from interactions.models.discord.snowflake import to_snowflake
-from .base import DiscordObject
-from interactions.models.discord.enums import StickerTypes, StickerFormatType
-
-if TYPE_CHECKING:
-    from interactions.models.discord.guild import Guild
-    from interactions.models.discord.user import User
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-__all__ = ("StickerItem", "Sticker", "StickerPack")
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class StickerItem(DiscordObject):
-    name: str = attrs.field(repr=True)
-    """Name of the sticker."""
-    format_type: StickerFormatType = attrs.field(repr=True, converter=StickerFormatType)
-    """Type of sticker image format."""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Sticker(StickerItem):
-    """Represents a sticker that can be sent in messages."""
-
-    pack_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
-    """For standard stickers, id of the pack the sticker is from."""
-    description: Optional[str] = attrs.field(repr=False, default=None)
-    """Description of the sticker."""
-    tags: str = attrs.field(repr=False)
-    """autocomplete/suggestion tags for the sticker (max 200 characters)"""
-    type: Union[StickerTypes, int] = attrs.field(repr=False, converter=StickerTypes)
-    """Type of sticker."""
-    available: Optional[bool] = attrs.field(repr=False, default=True)
-    """Whether this guild sticker can be used, may be false due to loss of Server Boosts."""
-    sort_value: Optional[int] = attrs.field(repr=False, default=None)
-    """The standard sticker's sort order within its pack."""
-
-    _user_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
-    _guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
-
-    async def fetch_creator(self, *, force: bool = False) -> "User":
-        """
-        Fetch the user who created this emoji.
-
-        Args:
-            force: Whether to force a fetch from the API
-
-        Returns:
-            User object
-
-        """
-        return await self._client.cache.fetch_user(self._user_id, force=force)
-
-    def get_creator(self) -> "User":
-        """
-        Get the user who created this emoji.
-
-        Returns:
-            User object
-
-        """
-        return self._client.cache.get_user(self._user_id)
-
-    async def fetch_guild(self, *, force: bool = False) -> "Guild":
-        """
-        Fetch the guild associated with this emoji.
-
-        Args:
-            force: Whether to force a fetch from the API
-
-        Returns:
-            Guild object
-
-        """
-        return await self._client.cache.fetch_guild(self._guild_id, force=force)
-
-    def get_guild(self) -> "Guild":
-        """
-        Get the guild associated with this emoji.
-
-        Returns:
-            Guild object
-
-        """
-        return self._client.cache.get_guild(self._guild_id)
-
-    async def edit(
-        self,
-        *,
-        name: Absent[Optional[str]] = MISSING,
-        description: Absent[Optional[str]] = MISSING,
-        tags: Absent[Optional[str]] = MISSING,
-        reason: Absent[Optional[str]] = MISSING,
-    ) -> "Sticker":
-        """
-        Edit a sticker.
-
-        Args:
-            name: New name of the sticker
-            description: New description of the sticker
-            tags: New tags of the sticker
-            reason: Reason for the edit
-
-        Returns:
-            The updated sticker instance
-
-        """
-        if not self._guild_id:
-            raise ValueError("You can only edit guild stickers.")
-
-        payload = dict_filter_none({"name": name, "description": description, "tags": tags})
-        sticker_data = await self._client.http.modify_guild_sticker(payload, self._guild_id, self.id, reason)
-        return self.update_from_dict(sticker_data)
-
-    async def delete(self, reason: Optional[str] = MISSING) -> None:
-        """
-        Delete a sticker.
-
-        Args:
-            reason: Reason for the deletion
-
-        Raises:
-            ValueError: If you attempt to delete a non-guild sticker
-
-        """
-        if not self._guild_id:
-            raise ValueError("You can only delete guild stickers.")
-
-        await self._client.http.delete_guild_sticker(self._guild_id, self.id, reason)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class StickerPack(DiscordObject):
-    """Represents a pack of standard stickers."""
-
-    stickers: List["Sticker"] = attrs.field(repr=False, factory=list)
-    """The stickers in the pack."""
-    name: str = attrs.field(repr=True)
-    """Name of the sticker pack."""
-    sku_id: "Snowflake_Type" = attrs.field(repr=True)
-    """id of the pack's SKU."""
-    cover_sticker_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """id of a sticker in the pack which is shown as the pack's icon."""
-    description: str = attrs.field(repr=False)
-    """Description of the sticker pack."""
-    banner_asset_id: "Snowflake_Type" = attrs.field(repr=False)  # TODO CDN Asset
-    """id of the sticker pack's banner image."""
+from typing import TYPE_CHECKING, List, Optional, Union
+
+import attrs
+
+from interactions.client.const import MISSING, Absent
+from interactions.client.utils.attr_converters import optional
+from interactions.client.utils.serializer import dict_filter_none
+from interactions.models.discord.snowflake import to_snowflake
+from .base import DiscordObject
+from interactions.models.discord.enums import StickerTypes, StickerFormatType
+
+if TYPE_CHECKING:
+    from interactions.models.discord.guild import Guild
+    from interactions.models.discord.user import User
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+__all__ = ("StickerItem", "Sticker", "StickerPack")
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class StickerItem(DiscordObject):
+    name: str = attrs.field(repr=True)
+    """Name of the sticker."""
+    format_type: StickerFormatType = attrs.field(repr=True, converter=StickerFormatType)
+    """Type of sticker image format."""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Sticker(StickerItem):
+    """Represents a sticker that can be sent in messages."""
+
+    pack_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
+    """For standard stickers, id of the pack the sticker is from."""
+    description: Optional[str] = attrs.field(repr=False, default=None)
+    """Description of the sticker."""
+    tags: str = attrs.field(repr=False)
+    """autocomplete/suggestion tags for the sticker (max 200 characters)"""
+    type: Union[StickerTypes, int] = attrs.field(repr=False, converter=StickerTypes)
+    """Type of sticker."""
+    available: Optional[bool] = attrs.field(repr=False, default=True)
+    """Whether this guild sticker can be used, may be false due to loss of Server Boosts."""
+    sort_value: Optional[int] = attrs.field(repr=False, default=None)
+    """The standard sticker's sort order within its pack."""
+
+    _user_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
+    _guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
+
+    async def fetch_creator(self, *, force: bool = False) -> "User":
+        """
+        Fetch the user who created this emoji.
+
+        Args:
+            force: Whether to force a fetch from the API
+
+        Returns:
+            User object
+
+        """
+        return await self._client.cache.fetch_user(self._user_id, force=force)
+
+    def get_creator(self) -> "User":
+        """
+        Get the user who created this emoji.
+
+        Returns:
+            User object
+
+        """
+        return self._client.cache.get_user(self._user_id)
+
+    async def fetch_guild(self, *, force: bool = False) -> "Guild":
+        """
+        Fetch the guild associated with this emoji.
+
+        Args:
+            force: Whether to force a fetch from the API
+
+        Returns:
+            Guild object
+
+        """
+        return await self._client.cache.fetch_guild(self._guild_id, force=force)
+
+    def get_guild(self) -> "Guild":
+        """
+        Get the guild associated with this emoji.
+
+        Returns:
+            Guild object
+
+        """
+        return self._client.cache.get_guild(self._guild_id)
+
+    async def edit(
+        self,
+        *,
+        name: Absent[Optional[str]] = MISSING,
+        description: Absent[Optional[str]] = MISSING,
+        tags: Absent[Optional[str]] = MISSING,
+        reason: Absent[Optional[str]] = MISSING,
+    ) -> "Sticker":
+        """
+        Edit a sticker.
+
+        Args:
+            name: New name of the sticker
+            description: New description of the sticker
+            tags: New tags of the sticker
+            reason: Reason for the edit
+
+        Returns:
+            The updated sticker instance
+
+        """
+        if not self._guild_id:
+            raise ValueError("You can only edit guild stickers.")
+
+        payload = dict_filter_none({"name": name, "description": description, "tags": tags})
+        sticker_data = await self._client.http.modify_guild_sticker(payload, self._guild_id, self.id, reason)
+        return self.update_from_dict(sticker_data)
+
+    async def delete(self, reason: Optional[str] = MISSING) -> None:
+        """
+        Delete a sticker.
+
+        Args:
+            reason: Reason for the deletion
+
+        Raises:
+            ValueError: If you attempt to delete a non-guild sticker
+
+        """
+        if not self._guild_id:
+            raise ValueError("You can only delete guild stickers.")
+
+        await self._client.http.delete_guild_sticker(self._guild_id, self.id, reason)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class StickerPack(DiscordObject):
+    """Represents a pack of standard stickers."""
+
+    stickers: List["Sticker"] = attrs.field(repr=False, factory=list)
+    """The stickers in the pack."""
+    name: str = attrs.field(repr=True)
+    """Name of the sticker pack."""
+    sku_id: "Snowflake_Type" = attrs.field(repr=True)
+    """id of the pack's SKU."""
+    cover_sticker_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """id of a sticker in the pack which is shown as the pack's icon."""
+    description: str = attrs.field(repr=False)
+    """Description of the sticker pack."""
+    banner_asset_id: "Snowflake_Type" = attrs.field(repr=False)  # TODO CDN Asset
+    """id of the sticker pack's banner image."""
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/team.py` & `discord-py-interactions-5.6.0/interactions/models/discord/team.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,70 +1,70 @@
-from typing import TYPE_CHECKING, List, Optional, Dict, Any, Union
-
-import attrs
-
-from interactions.models.discord.asset import Asset
-from interactions.models.discord.enums import TeamMembershipState
-from interactions.models.discord.snowflake import to_snowflake
-from .base import DiscordObject
-
-if TYPE_CHECKING:
-    from interactions.models.discord.user import User
-    from interactions.models.discord.snowflake import Snowflake_Type, SnowflakeObject
-    from interactions.client import Client
-
-__all__ = ("TeamMember", "Team")
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class TeamMember(DiscordObject):
-    membership_state: TeamMembershipState = attrs.field(repr=False, converter=TeamMembershipState)
-    """Rhe user's membership state on the team"""
-    # permissions: List[str] = attrs.field(repr=False, default=["*"])  # disabled until discord adds more team roles
-    team_id: "Snowflake_Type" = attrs.field(repr=True)
-    """Rhe id of the parent team of which they are a member"""
-    user: "User" = attrs.field(
-        repr=False,
-    )  # TODO: cache partial user (avatar, discrim, id, username)
-    """Rhe avatar, discriminator, id, and username of the user"""
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        data["user"] = client.cache.place_user_data(data["user"])
-        data["id"] = data["user"].id
-        return data
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Team(DiscordObject):
-    icon: Optional[Asset] = attrs.field(repr=False, default=None)
-    """A hash of the image of the team's icon"""
-    members: List[TeamMember] = attrs.field(repr=False, factory=list)
-    """The members of the team"""
-    name: str = attrs.field(repr=True)
-    """The name of the team"""
-    owner_user_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-    """The user id of the current team owner"""
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        data["members"] = TeamMember.from_list(data["members"], client)
-        if data["icon"]:
-            data["icon"] = Asset.from_path_hash(client, f"team-icons/{data['id']}/{{}}", data["icon"])
-        return data
-
-    @property
-    def owner(self) -> "User":
-        """The owner of the team"""
-        return self._client.cache.get_user(self.owner_user_id)
-
-    def is_in_team(self, user: Union["SnowflakeObject", "Snowflake_Type"]) -> bool:
-        """
-        Returns True if the passed user or ID is a member within the team.
-
-        Args:
-            user: The user or user ID to check
-
-        Returns:
-            Boolean indicating whether the user is in the team
-        """
-        return to_snowflake(user) in [m.id for m in self.members]
+from typing import TYPE_CHECKING, List, Optional, Dict, Any, Union
+
+import attrs
+
+from interactions.models.discord.asset import Asset
+from interactions.models.discord.enums import TeamMembershipState
+from interactions.models.discord.snowflake import to_snowflake
+from .base import DiscordObject
+
+if TYPE_CHECKING:
+    from interactions.models.discord.user import User
+    from interactions.models.discord.snowflake import Snowflake_Type, SnowflakeObject
+    from interactions.client import Client
+
+__all__ = ("TeamMember", "Team")
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class TeamMember(DiscordObject):
+    membership_state: TeamMembershipState = attrs.field(repr=False, converter=TeamMembershipState)
+    """Rhe user's membership state on the team"""
+    # permissions: List[str] = attrs.field(repr=False, default=["*"])  # disabled until discord adds more team roles
+    team_id: "Snowflake_Type" = attrs.field(repr=True)
+    """Rhe id of the parent team of which they are a member"""
+    user: "User" = attrs.field(
+        repr=False,
+    )  # TODO: cache partial user (avatar, discrim, id, username)
+    """Rhe avatar, discriminator, id, and username of the user"""
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        data["user"] = client.cache.place_user_data(data["user"])
+        data["id"] = data["user"].id
+        return data
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Team(DiscordObject):
+    icon: Optional[Asset] = attrs.field(repr=False, default=None)
+    """A hash of the image of the team's icon"""
+    members: List[TeamMember] = attrs.field(repr=False, factory=list)
+    """The members of the team"""
+    name: str = attrs.field(repr=True)
+    """The name of the team"""
+    owner_user_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+    """The user id of the current team owner"""
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        data["members"] = TeamMember.from_list(data["members"], client)
+        if data["icon"]:
+            data["icon"] = Asset.from_path_hash(client, f"team-icons/{data['id']}/{{}}", data["icon"])
+        return data
+
+    @property
+    def owner(self) -> "User":
+        """The owner of the team"""
+        return self._client.cache.get_user(self.owner_user_id)
+
+    def is_in_team(self, user: Union["SnowflakeObject", "Snowflake_Type"]) -> bool:
+        """
+        Returns True if the passed user or ID is a member within the team.
+
+        Args:
+            user: The user or user ID to check
+
+        Returns:
+            Boolean indicating whether the user is in the team
+        """
+        return to_snowflake(user) in [m.id for m in self.members]
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/timestamp.py` & `discord-py-interactions-5.6.0/interactions/models/discord/timestamp.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,136 +1,136 @@
-import time
-from datetime import datetime, timezone
-from enum import Enum
-from typing import TYPE_CHECKING, Optional, Union
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type, Snowflake
-
-__all__ = ("TimestampStyles", "Timestamp")
-
-DISCORD_EPOCH = 1420070400000
-
-
-class TimestampStyles(str, Enum):
-    ShortTime = "t"
-    LongTime = "T"
-    ShortDate = "d"
-    LongDate = "D"
-    ShortDateTime = "f"  # default
-    LongDateTime = "F"
-    RelativeTime = "R"
-
-    def __str__(self) -> str:
-        return self.value
-
-
-class Timestamp(datetime):
-    """
-    A special class that represents Discord timestamps.
-
-    Assumes that all naive datetimes are based on local timezone.
-
-    """
-
-    @classmethod
-    def fromdatetime(cls, dt: datetime) -> "Timestamp":
-        """Construct a timezone-aware UTC datetime from a datetime object."""
-        timestamp = cls.fromtimestamp(dt.timestamp(), tz=dt.tzinfo)
-
-        return timestamp.astimezone() if timestamp.tzinfo is None else timestamp
-
-    @classmethod
-    def utcfromtimestamp(cls, t: float) -> "Timestamp":
-        """Construct a timezone-aware UTC datetime from a POSIX timestamp."""
-        return super().utcfromtimestamp(t).replace(tzinfo=timezone.utc)
-
-    @classmethod
-    def fromisoformat(cls, date_string: str) -> "Timestamp":
-        timestamp = super().fromisoformat(date_string)
-
-        return timestamp.astimezone() if timestamp.tzinfo is None else timestamp
-
-    @classmethod
-    def fromisocalendar(cls, year: int, week: int, day: int) -> "Timestamp":
-        return super().fromisocalendar(year, week, day).astimezone()
-
-    @classmethod
-    def fromtimestamp(cls, t: float, tz=None) -> "Timestamp":
-        try:
-            timestamp = super().fromtimestamp(t, tz=tz)
-        except Exception:
-            # May be in milliseconds instead of seconds
-            timestamp = super().fromtimestamp(t / 1000, tz=tz)
-
-        return timestamp.astimezone() if timestamp.tzinfo is None else timestamp
-
-    @classmethod
-    def fromordinal(cls, n: int) -> "Timestamp":
-        return super().fromordinal(n).astimezone()
-
-    @classmethod
-    def now(cls, tz=None) -> "Timestamp":
-        """
-        Construct a datetime from time.time() and optional time zone info.
-
-        If no timezone is provided, the time is assumed to be from the computer's
-        local timezone.
-        """
-        t = time.time()
-        return cls.fromtimestamp(t, tz)
-
-    @classmethod
-    def utcnow(cls) -> "Timestamp":
-        """Construct a timezone-aware UTC datetime from time.time()."""
-        t = time.time()
-        return cls.utcfromtimestamp(t)
-
-    def to_snowflake(self, high: bool = False) -> Union[str, "Snowflake"]:
-        """
-        Returns a numeric snowflake pretending to be created at the given date.
-
-        When using as the lower end of a range, use ``tosnowflake(high=False) - 1``
-        to be inclusive, ``high=True`` to be exclusive.
-        When using as the higher end of a range, use ``tosnowflake(high=True) + 1``
-        to be inclusive, ``high=False`` to be exclusive
-
-        """
-        discord_millis = int(self.timestamp() * 1000 - DISCORD_EPOCH)
-        return (discord_millis << 22) + (2**22 - 1 if high else 0)
-
-    @classmethod
-    def from_snowflake(cls, snowflake: "Snowflake_Type") -> "Timestamp":
-        """
-        Construct a timezone-aware UTC datetime from a snowflake.
-
-        Args:
-            snowflake: The snowflake to convert.
-
-        Returns:
-            A timezone-aware UTC datetime.
-
-        ??? Info
-            https://discord.com/developers/docs/reference#convert-snowflake-to-datetime
-
-        """
-        if isinstance(snowflake, str):
-            snowflake = int(snowflake)
-
-        timestamp = ((snowflake >> 22) + DISCORD_EPOCH) / 1000
-        return cls.utcfromtimestamp(timestamp)
-
-    def format(self, style: Optional[Union[TimestampStyles, str]] = None) -> str:
-        """
-        Format the timestamp for discord client to display.
-
-        Args:
-            style: The style to format the timestamp with.
-
-        Returns:
-            The formatted timestamp.
-
-        """
-        return f"<t:{self.timestamp():.0f}:{style}>" if style else f"<t:{self.timestamp():.0f}>"
-
-    def __str__(self) -> str:
-        return self.format()
+import time
+from datetime import datetime, timezone
+from enum import Enum
+from typing import TYPE_CHECKING, Optional, Union
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type, Snowflake
+
+__all__ = ("TimestampStyles", "Timestamp")
+
+DISCORD_EPOCH = 1420070400000
+
+
+class TimestampStyles(str, Enum):
+    ShortTime = "t"
+    LongTime = "T"
+    ShortDate = "d"
+    LongDate = "D"
+    ShortDateTime = "f"  # default
+    LongDateTime = "F"
+    RelativeTime = "R"
+
+    def __str__(self) -> str:
+        return self.value
+
+
+class Timestamp(datetime):
+    """
+    A special class that represents Discord timestamps.
+
+    Assumes that all naive datetimes are based on local timezone.
+
+    """
+
+    @classmethod
+    def fromdatetime(cls, dt: datetime) -> "Timestamp":
+        """Construct a timezone-aware UTC datetime from a datetime object."""
+        timestamp = cls.fromtimestamp(dt.timestamp(), tz=dt.tzinfo)
+
+        return timestamp.astimezone() if timestamp.tzinfo is None else timestamp
+
+    @classmethod
+    def utcfromtimestamp(cls, t: float) -> "Timestamp":
+        """Construct a timezone-aware UTC datetime from a POSIX timestamp."""
+        return super().utcfromtimestamp(t).replace(tzinfo=timezone.utc)
+
+    @classmethod
+    def fromisoformat(cls, date_string: str) -> "Timestamp":
+        timestamp = super().fromisoformat(date_string)
+
+        return timestamp.astimezone() if timestamp.tzinfo is None else timestamp
+
+    @classmethod
+    def fromisocalendar(cls, year: int, week: int, day: int) -> "Timestamp":
+        return super().fromisocalendar(year, week, day).astimezone()
+
+    @classmethod
+    def fromtimestamp(cls, t: float, tz=None) -> "Timestamp":
+        try:
+            timestamp = super().fromtimestamp(t, tz=tz)
+        except Exception:
+            # May be in milliseconds instead of seconds
+            timestamp = super().fromtimestamp(t / 1000, tz=tz)
+
+        return timestamp.astimezone() if timestamp.tzinfo is None else timestamp
+
+    @classmethod
+    def fromordinal(cls, n: int) -> "Timestamp":
+        return super().fromordinal(n).astimezone()
+
+    @classmethod
+    def now(cls, tz=None) -> "Timestamp":
+        """
+        Construct a datetime from time.time() and optional time zone info.
+
+        If no timezone is provided, the time is assumed to be from the computer's
+        local timezone.
+        """
+        t = time.time()
+        return cls.fromtimestamp(t, tz)
+
+    @classmethod
+    def utcnow(cls) -> "Timestamp":
+        """Construct a timezone-aware UTC datetime from time.time()."""
+        t = time.time()
+        return cls.utcfromtimestamp(t)
+
+    def to_snowflake(self, high: bool = False) -> Union[str, "Snowflake"]:
+        """
+        Returns a numeric snowflake pretending to be created at the given date.
+
+        When using as the lower end of a range, use ``tosnowflake(high=False) - 1``
+        to be inclusive, ``high=True`` to be exclusive.
+        When using as the higher end of a range, use ``tosnowflake(high=True) + 1``
+        to be inclusive, ``high=False`` to be exclusive
+
+        """
+        discord_millis = int(self.timestamp() * 1000 - DISCORD_EPOCH)
+        return (discord_millis << 22) + (2**22 - 1 if high else 0)
+
+    @classmethod
+    def from_snowflake(cls, snowflake: "Snowflake_Type") -> "Timestamp":
+        """
+        Construct a timezone-aware UTC datetime from a snowflake.
+
+        Args:
+            snowflake: The snowflake to convert.
+
+        Returns:
+            A timezone-aware UTC datetime.
+
+        ??? Info
+            https://discord.com/developers/docs/reference#convert-snowflake-to-datetime
+
+        """
+        if isinstance(snowflake, str):
+            snowflake = int(snowflake)
+
+        timestamp = ((snowflake >> 22) + DISCORD_EPOCH) / 1000
+        return cls.utcfromtimestamp(timestamp)
+
+    def format(self, style: Optional[Union[TimestampStyles, str]] = None) -> str:
+        """
+        Format the timestamp for discord client to display.
+
+        Args:
+            style: The style to format the timestamp with.
+
+        Returns:
+            The formatted timestamp.
+
+        """
+        return f"<t:{self.timestamp():.0f}:{style}>" if style else f"<t:{self.timestamp():.0f}>"
+
+    def __str__(self) -> str:
+        return self.format()
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/user.pyi` & `discord-py-interactions-5.6.0/interactions/models/discord/user.pyi`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,165 +1,165 @@
-from .base import DiscordObject
-from aiohttp import FormData
-from datetime import datetime
-from typing import type_check_only
-import attrs
-
-from interactions.client import Client
-from interactions.client.const import Absent
-from interactions.client.mixins.send import SendMixin
-from interactions.models.discord.activity import Activity
-from interactions.models.discord.asset import Asset
-from interactions.models.discord.channel import DM, TYPE_GUILD_CHANNEL
-from interactions.models.discord.color import Color
-from interactions.models.discord.enums import MemberFlags, Permissions, PremiumType, Status, UserFlags
-from interactions.models.discord.file import UPLOADABLE_TYPE
-from interactions.models.discord.guild import Guild
-from interactions.models.discord.role import Role
-from interactions.models.discord.snowflake import Snowflake_Type
-from interactions.models.discord.timestamp import Timestamp
-from interactions.models.discord.voice_state import VoiceState
-from typing import Any, Dict, Iterable, List, Optional, Set, Union
-
-class _SendDMMixin(SendMixin):
-    id: Snowflake_Type
-    async def _send_http_request(
-        self, message_payload: Union[dict, "FormData"], files: Union[list["UPLOADABLE_TYPE"], None] = ...
-    ) -> dict: ...
-
-# note: what we're trying to achieve here is making isinstance checks as accurate as possible when typehinting
-# Member, while "having" the attributes of User (because of __getattr__), is not actually a subclass of either
-# BaseUser or User - it's its own seperate class
-# we still want to typehint Member with all of the User attributes though, so what we do is create fake
-# mixins that actually don't exist, and make BaseUser and User inherit from that
-# then, we can make Member inheir the fake user mixin, and now we have a Member class with User attributes
-# and that understands isinstance(member, User) is false
-
-@type_check_only
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)  # properly typehints added attributes by attrs
-class FakeBaseUserMixin(DiscordObject, _SendDMMixin):
-    username: str
-    global_name: str | None
-    discriminator: str
-    avatar: Asset
-    def __str__(self) -> str: ...
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: Client) -> Dict[str, Any]: ...
-    @property
-    def tag(self) -> str: ...
-    @property
-    def mention(self) -> str: ...
-    @property
-    def display_name(self) -> str: ...
-    @property
-    def display_avatar(self) -> Asset: ...
-    async def fetch_dm(self, *, force: bool) -> DM: ...
-    def get_dm(self) -> Optional["DM"]: ...
-    @property
-    def mutual_guilds(self) -> List["Guild"]: ...
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class BaseUser(FakeBaseUserMixin): ...
-
-@type_check_only
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class FakeUserMixin(FakeBaseUserMixin):
-    bot: bool
-    system: bool
-    public_flags: UserFlags
-    premium_type: PremiumType
-    banner: Optional["Asset"]
-    accent_color: Optional["Color"]
-    activities: list[Activity]
-    status: Absent[Status]
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: Client) -> Dict[str, Any]: ...
-    @property
-    def member_instances(self) -> List["Member"]: ...
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class User(FakeUserMixin, BaseUser): ...
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ClientUser(User):
-    verified: bool
-    mfa_enabled: bool
-    email: Optional[str]
-    locale: Optional[str]
-    bio: Optional[str]
-    flags: UserFlags
-    _guild_ids: Set["Snowflake_Type"]
-    def _add_guilds(self, guild_ids: Set["Snowflake_Type"]) -> None: ...
-    @property
-    def guilds(self) -> List["Guild"]: ...
-    async def edit(self, *, username: Absent[str] = ..., avatar: Absent[UPLOADABLE_TYPE] = ...) -> None: ...
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Member(FakeUserMixin):
-    bot: bool
-    nick: Optional[str]
-    deaf: bool
-    mute: bool
-    flags: MemberFlags
-    joined_at: Timestamp
-    premium_since: Optional["Timestamp"]
-    pending: Optional[bool]
-    guild_avatar: Asset
-    communication_disabled_until: Optional["Timestamp"]
-    _guild_id: Snowflake_Type
-    _role_ids: List["Snowflake_Type"]
-    _user_ref: frozenset
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: Client) -> Dict[str, Any]: ...
-    def update_from_dict(self, data) -> None: ...
-    @property
-    def user(self) -> User: ...
-    def __str__(self) -> str: ...
-    @property
-    def nickname(self) -> str: ...
-    @nickname.setter
-    def nickname(self, nickname: str) -> None: ...
-    @property
-    def guild(self) -> Guild: ...
-    @property
-    def roles(self) -> List["Role"]: ...
-    @property
-    def top_role(self) -> Role: ...
-    @property
-    def display_name(self) -> str: ...
-    @property
-    def display_avatar(self) -> Asset: ...
-    @property
-    def premium(self) -> bool: ...
-    @property
-    def guild_permissions(self) -> Permissions: ...
-    @property
-    def voice(self) -> Optional["VoiceState"]: ...
-    def has_permission(self, *permissions: Permissions) -> bool: ...
-    def channel_permissions(self, channel: TYPE_GUILD_CHANNEL) -> Permissions: ...
-    async def edit_nickname(self, new_nickname: Absent[str] = ..., reason: Absent[str] = ...) -> None: ...
-    async def add_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = ...) -> None: ...
-    async def add_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = ...) -> None: ...
-    async def remove_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = ...) -> None: ...
-    async def remove_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = ...) -> None: ...
-    def has_role(self, *roles: Union[Snowflake_Type, Role]) -> bool: ...
-    async def timeout(
-        self,
-        communication_disabled_until: Union["Timestamp", datetime, int, float, str, None],
-        reason: Absent[str] = ...,
-    ) -> dict: ...
-    async def move(self, channel_id: Snowflake_Type) -> None: ...
-    async def edit(
-        self,
-        *,
-        nickname: Absent[str] = ...,
-        roles: Absent[Iterable["Snowflake_Type"]] = ...,
-        mute: Absent[bool] = ...,
-        deaf: Absent[bool] = ...,
-        channel_id: Absent["Snowflake_Type"] = ...,
-        communication_disabled_until: Absent[Union["Timestamp", None]] = ...,
-        reason: Absent[str] = ...
-    ) -> None: ...
-    async def kick(self, reason: Absent[str] = ...) -> None: ...
-    async def ban(
-        self, delete_message_days: Absent[int] = ..., delete_message_seconds: int = ..., reason: Absent[str] = ...
-    ) -> None: ...
+from .base import DiscordObject
+from aiohttp import FormData
+from datetime import datetime
+from typing import type_check_only
+import attrs
+
+from interactions.client import Client
+from interactions.client.const import Absent
+from interactions.client.mixins.send import SendMixin
+from interactions.models.discord.activity import Activity
+from interactions.models.discord.asset import Asset
+from interactions.models.discord.channel import DM, TYPE_GUILD_CHANNEL
+from interactions.models.discord.color import Color
+from interactions.models.discord.enums import MemberFlags, Permissions, PremiumType, Status, UserFlags
+from interactions.models.discord.file import UPLOADABLE_TYPE
+from interactions.models.discord.guild import Guild
+from interactions.models.discord.role import Role
+from interactions.models.discord.snowflake import Snowflake_Type
+from interactions.models.discord.timestamp import Timestamp
+from interactions.models.discord.voice_state import VoiceState
+from typing import Any, Dict, Iterable, List, Optional, Set, Union
+
+class _SendDMMixin(SendMixin):
+    id: Snowflake_Type
+    async def _send_http_request(
+        self, message_payload: Union[dict, "FormData"], files: Union[list["UPLOADABLE_TYPE"], None] = ...
+    ) -> dict: ...
+
+# note: what we're trying to achieve here is making isinstance checks as accurate as possible when typehinting
+# Member, while "having" the attributes of User (because of __getattr__), is not actually a subclass of either
+# BaseUser or User - it's its own seperate class
+# we still want to typehint Member with all of the User attributes though, so what we do is create fake
+# mixins that actually don't exist, and make BaseUser and User inherit from that
+# then, we can make Member inheir the fake user mixin, and now we have a Member class with User attributes
+# and that understands isinstance(member, User) is false
+
+@type_check_only
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)  # properly typehints added attributes by attrs
+class FakeBaseUserMixin(DiscordObject, _SendDMMixin):
+    username: str
+    global_name: str | None
+    discriminator: str
+    avatar: Asset
+    def __str__(self) -> str: ...
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: Client) -> Dict[str, Any]: ...
+    @property
+    def tag(self) -> str: ...
+    @property
+    def mention(self) -> str: ...
+    @property
+    def display_name(self) -> str: ...
+    @property
+    def display_avatar(self) -> Asset: ...
+    async def fetch_dm(self, *, force: bool) -> DM: ...
+    def get_dm(self) -> Optional["DM"]: ...
+    @property
+    def mutual_guilds(self) -> List["Guild"]: ...
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class BaseUser(FakeBaseUserMixin): ...
+
+@type_check_only
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class FakeUserMixin(FakeBaseUserMixin):
+    bot: bool
+    system: bool
+    public_flags: UserFlags
+    premium_type: PremiumType
+    banner: Optional["Asset"]
+    accent_color: Optional["Color"]
+    activities: list[Activity]
+    status: Absent[Status]
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: Client) -> Dict[str, Any]: ...
+    @property
+    def member_instances(self) -> List["Member"]: ...
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class User(FakeUserMixin, BaseUser): ...
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ClientUser(User):
+    verified: bool
+    mfa_enabled: bool
+    email: Optional[str]
+    locale: Optional[str]
+    bio: Optional[str]
+    flags: UserFlags
+    _guild_ids: Set["Snowflake_Type"]
+    def _add_guilds(self, guild_ids: Set["Snowflake_Type"]) -> None: ...
+    @property
+    def guilds(self) -> List["Guild"]: ...
+    async def edit(self, *, username: Absent[str] = ..., avatar: Absent[UPLOADABLE_TYPE] = ...) -> None: ...
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Member(FakeUserMixin):
+    bot: bool
+    nick: Optional[str]
+    deaf: bool
+    mute: bool
+    flags: MemberFlags
+    joined_at: Timestamp
+    premium_since: Optional["Timestamp"]
+    pending: Optional[bool]
+    guild_avatar: Asset
+    communication_disabled_until: Optional["Timestamp"]
+    _guild_id: Snowflake_Type
+    _role_ids: List["Snowflake_Type"]
+    _user_ref: frozenset
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: Client) -> Dict[str, Any]: ...
+    def update_from_dict(self, data) -> None: ...
+    @property
+    def user(self) -> User: ...
+    def __str__(self) -> str: ...
+    @property
+    def nickname(self) -> str: ...
+    @nickname.setter
+    def nickname(self, nickname: str) -> None: ...
+    @property
+    def guild(self) -> Guild: ...
+    @property
+    def roles(self) -> List["Role"]: ...
+    @property
+    def top_role(self) -> Role: ...
+    @property
+    def display_name(self) -> str: ...
+    @property
+    def display_avatar(self) -> Asset: ...
+    @property
+    def premium(self) -> bool: ...
+    @property
+    def guild_permissions(self) -> Permissions: ...
+    @property
+    def voice(self) -> Optional["VoiceState"]: ...
+    def has_permission(self, *permissions: Permissions) -> bool: ...
+    def channel_permissions(self, channel: TYPE_GUILD_CHANNEL) -> Permissions: ...
+    async def edit_nickname(self, new_nickname: Absent[str] = ..., reason: Absent[str] = ...) -> None: ...
+    async def add_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = ...) -> None: ...
+    async def add_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = ...) -> None: ...
+    async def remove_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = ...) -> None: ...
+    async def remove_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = ...) -> None: ...
+    def has_role(self, *roles: Union[Snowflake_Type, Role]) -> bool: ...
+    async def timeout(
+        self,
+        communication_disabled_until: Union["Timestamp", datetime, int, float, str, None],
+        reason: Absent[str] = ...,
+    ) -> dict: ...
+    async def move(self, channel_id: Snowflake_Type) -> None: ...
+    async def edit(
+        self,
+        *,
+        nickname: Absent[str] = ...,
+        roles: Absent[Iterable["Snowflake_Type"]] = ...,
+        mute: Absent[bool] = ...,
+        deaf: Absent[bool] = ...,
+        channel_id: Absent["Snowflake_Type"] = ...,
+        communication_disabled_until: Absent[Union["Timestamp", None]] = ...,
+        reason: Absent[str] = ...
+    ) -> None: ...
+    async def kick(self, reason: Absent[str] = ...) -> None: ...
+    async def ban(
+        self, delete_message_days: Absent[int] = ..., delete_message_seconds: int = ..., reason: Absent[str] = ...
+    ) -> None: ...
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/voice_state.py` & `discord-py-interactions-5.6.0/interactions/models/discord/voice_state.py`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,111 +1,111 @@
-import copy
-from typing import TYPE_CHECKING, Optional, Dict, Any
-
-import attrs
-
-from interactions.client.const import MISSING
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.attr_converters import optional as optional_c
-from interactions.client.utils.attr_converters import timestamp_converter
-from interactions.models.discord.snowflake import to_snowflake
-from interactions.models.discord.timestamp import Timestamp
-from .base import ClientObject
-
-if TYPE_CHECKING:
-    from interactions.client import Client
-    from interactions.models import Guild, TYPE_VOICE_CHANNEL
-    from interactions.models.discord.user import Member
-    from interactions.models.discord.snowflake import Snowflake_Type
-
-__all__ = ("VoiceState", "VoiceRegion")
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class VoiceState(ClientObject):
-    user_id: "Snowflake_Type" = attrs.field(repr=False, default=MISSING, converter=to_snowflake)
-    """the user id this voice state is for"""
-    session_id: str = attrs.field(repr=False, default=MISSING)
-    """the session id for this voice state"""
-    deaf: bool = attrs.field(repr=False, default=False)
-    """whether this user is deafened by the server"""
-    mute: bool = attrs.field(repr=False, default=False)
-    """whether this user is muted by the server"""
-    self_deaf: bool = attrs.field(repr=False, default=False)
-    """whether this user is locally deafened"""
-    self_mute: bool = attrs.field(repr=False, default=False)
-    """whether this user is locally muted"""
-    self_stream: Optional[bool] = attrs.field(repr=False, default=False)
-    """whether this user is streaming using "Go Live\""""
-    self_video: bool = attrs.field(repr=False, default=False)
-    """whether this user's camera is enabled"""
-    suppress: bool = attrs.field(repr=False, default=False)
-    """whether this user is muted by the current user"""
-    request_to_speak_timestamp: Optional[Timestamp] = attrs.field(
-        repr=False, default=None, converter=optional_c(timestamp_converter)
-    )
-    """the time at which the user requested to speak"""
-
-    # internal for props
-    _guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=to_snowflake)
-    _channel_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
-    _member_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=to_snowflake)
-
-    @property
-    def guild(self) -> "Guild":
-        """The guild this voice state is for."""
-        return self._client.cache.get_guild(self._guild_id) if self._guild_id else None
-
-    @property
-    def channel(self) -> "TYPE_VOICE_CHANNEL":
-        """The channel the user is connected to."""
-        channel: "TYPE_VOICE_CHANNEL" = self._client.cache.get_channel(self._channel_id)
-
-        if channel and self._member_id not in channel._voice_member_ids:
-            # the list of voice members need to be deepcopied, otherwise the cached obj will be updated
-            # noinspection PyProtectedMember
-            voice_member_ids = copy.deepcopy(channel._voice_member_ids)
-
-            # create a copy of the obj
-            channel = copy.copy(channel)
-            channel._voice_member_ids = voice_member_ids
-
-            # add the member to that list
-            # noinspection PyProtectedMember
-            channel._voice_member_ids.append(self._member_id)
-
-        return channel
-
-    @property
-    def member(self) -> "Member":
-        """The member this voice state is for."""
-        return self._client.cache.get_member(self._guild_id, self._member_id) if self._guild_id else None
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        if member := data.pop("member", None):
-            member = client.cache.place_member_data(data["guild_id"], member)
-            data["member_id"] = member.id
-        else:
-            data["member_id"] = data["user_id"]
-        return data
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class VoiceRegion(DictSerializationMixin):
-    """A voice region."""
-
-    id: str = attrs.field(repr=True)
-    """unique ID for the region"""
-    name: str = attrs.field(repr=True)
-    """name of the region"""
-    vip: bool = attrs.field(default=False, repr=True)
-    """whether this is a VIP-only voice region"""
-    optimal: bool = attrs.field(repr=False, default=False)
-    """true for a single server that is closest to the current user's client"""
-    deprecated: bool = attrs.field(repr=False, default=False)
-    """whether this is a deprecated voice region (avoid switching to these)"""
-    custom: bool = attrs.field(repr=False, default=False)
-    """whether this is a custom voice region (used for events/etc)"""
-
-    def __str__(self) -> str:
-        return self.name
+import copy
+from typing import TYPE_CHECKING, Optional, Dict, Any
+
+import attrs
+
+from interactions.client.const import MISSING
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.attr_converters import optional as optional_c
+from interactions.client.utils.attr_converters import timestamp_converter
+from interactions.models.discord.snowflake import to_snowflake
+from interactions.models.discord.timestamp import Timestamp
+from .base import ClientObject
+
+if TYPE_CHECKING:
+    from interactions.client import Client
+    from interactions.models import Guild, TYPE_VOICE_CHANNEL
+    from interactions.models.discord.user import Member
+    from interactions.models.discord.snowflake import Snowflake_Type
+
+__all__ = ("VoiceState", "VoiceRegion")
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class VoiceState(ClientObject):
+    user_id: "Snowflake_Type" = attrs.field(repr=False, default=MISSING, converter=to_snowflake)
+    """the user id this voice state is for"""
+    session_id: str = attrs.field(repr=False, default=MISSING)
+    """the session id for this voice state"""
+    deaf: bool = attrs.field(repr=False, default=False)
+    """whether this user is deafened by the server"""
+    mute: bool = attrs.field(repr=False, default=False)
+    """whether this user is muted by the server"""
+    self_deaf: bool = attrs.field(repr=False, default=False)
+    """whether this user is locally deafened"""
+    self_mute: bool = attrs.field(repr=False, default=False)
+    """whether this user is locally muted"""
+    self_stream: Optional[bool] = attrs.field(repr=False, default=False)
+    """whether this user is streaming using "Go Live\""""
+    self_video: bool = attrs.field(repr=False, default=False)
+    """whether this user's camera is enabled"""
+    suppress: bool = attrs.field(repr=False, default=False)
+    """whether this user is muted by the current user"""
+    request_to_speak_timestamp: Optional[Timestamp] = attrs.field(
+        repr=False, default=None, converter=optional_c(timestamp_converter)
+    )
+    """the time at which the user requested to speak"""
+
+    # internal for props
+    _guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=to_snowflake)
+    _channel_id: "Snowflake_Type" = attrs.field(repr=False, converter=to_snowflake)
+    _member_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None, converter=to_snowflake)
+
+    @property
+    def guild(self) -> "Guild":
+        """The guild this voice state is for."""
+        return self._client.cache.get_guild(self._guild_id) if self._guild_id else None
+
+    @property
+    def channel(self) -> "TYPE_VOICE_CHANNEL":
+        """The channel the user is connected to."""
+        channel: "TYPE_VOICE_CHANNEL" = self._client.cache.get_channel(self._channel_id)
+
+        if channel and self._member_id not in channel._voice_member_ids:
+            # the list of voice members need to be deepcopied, otherwise the cached obj will be updated
+            # noinspection PyProtectedMember
+            voice_member_ids = copy.deepcopy(channel._voice_member_ids)
+
+            # create a copy of the obj
+            channel = copy.copy(channel)
+            channel._voice_member_ids = voice_member_ids
+
+            # add the member to that list
+            # noinspection PyProtectedMember
+            channel._voice_member_ids.append(self._member_id)
+
+        return channel
+
+    @property
+    def member(self) -> "Member":
+        """The member this voice state is for."""
+        return self._client.cache.get_member(self._guild_id, self._member_id) if self._guild_id else None
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        if member := data.pop("member", None):
+            member = client.cache.place_member_data(data["guild_id"], member)
+            data["member_id"] = member.id
+        else:
+            data["member_id"] = data["user_id"]
+        return data
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class VoiceRegion(DictSerializationMixin):
+    """A voice region."""
+
+    id: str = attrs.field(repr=True)
+    """unique ID for the region"""
+    name: str = attrs.field(repr=True)
+    """name of the region"""
+    vip: bool = attrs.field(default=False, repr=True)
+    """whether this is a VIP-only voice region"""
+    optimal: bool = attrs.field(repr=False, default=False)
+    """true for a single server that is closest to the current user's client"""
+    deprecated: bool = attrs.field(repr=False, default=False)
+    """whether this is a deprecated voice region (avoid switching to these)"""
+    custom: bool = attrs.field(repr=False, default=False)
+    """whether this is a custom voice region (used for events/etc)"""
+
+    def __str__(self) -> str:
+        return self.name
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/discord/webhooks.py` & `discord-py-interactions-5.6.0/interactions/models/discord/webhooks.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,315 +1,315 @@
-import re
-from enum import IntEnum
-from typing import Optional, TYPE_CHECKING, Union, Dict, Any, List
-
-import attrs
-
-from interactions.client.const import MISSING, Absent
-from interactions.client.errors import ForeignWebhookException, EmptyMessageException
-from interactions.client.mixins.send import SendMixin
-from interactions.client.utils.serializer import to_image_data
-from interactions.models.discord.message import process_message_payload
-from interactions.models.discord.snowflake import to_snowflake, to_optional_snowflake
-from .base import DiscordObject
-
-if TYPE_CHECKING:
-    from interactions.models.discord.file import UPLOADABLE_TYPE
-    from interactions.client import Client
-    from interactions.models.discord.enums import MessageFlags
-    from interactions.models.discord.snowflake import Snowflake_Type
-    from interactions.models.discord.channel import TYPE_MESSAGEABLE_CHANNEL
-    from interactions.models.discord.components import BaseComponent
-    from interactions.models.discord.embed import Embed
-
-    from interactions.models.discord.message import (
-        AllowedMentions,
-        Message,
-        MessageReference,
-    )
-    from interactions.models.discord.sticker import Sticker
-
-__all__ = ("WebhookTypes", "Webhook")
-
-
-class WebhookTypes(IntEnum):
-    INCOMING = 1
-    """Incoming Webhooks can post messages to channels with a generated token"""
-    CHANNEL_FOLLOWER = 2
-    """Channel Follower Webhooks are internal webhooks used with Channel Following to post new messages into channels"""
-    APPLICATION = 3
-    """Application webhooks are webhooks used with Interactions"""
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class Webhook(DiscordObject, SendMixin):
-    type: WebhookTypes = attrs.field(
-        repr=False,
-    )
-    """The type of webhook"""
-
-    application_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """the bot/OAuth2 application that created this webhook"""
-
-    guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """the guild id this webhook is for, if any"""
-    channel_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """the channel id this webhook is for, if any"""
-    user_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """the user this webhook was created by"""
-
-    name: Optional[str] = attrs.field(repr=False, default=None)
-    """the default name of the webhook"""
-    avatar: Optional[str] = attrs.field(repr=False, default=None)
-    """the default user avatar hash of the webhook"""
-    token: str = attrs.field(repr=False, default=MISSING)
-    """the secure token of the webhook (returned for Incoming Webhooks)"""
-    url: Optional[str] = attrs.field(repr=False, default=None)
-    """the url used for executing the webhook (returned by the webhooks OAuth2 flow)"""
-
-    source_guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """the guild of the channel that this webhook is following (returned for Channel Follower Webhooks)"""
-    source_channel_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
-    """the channel that this webhook is following (returned for Channel Follower Webhooks)"""
-
-    @classmethod
-    def from_url(cls, url: str, client: "Client") -> "Webhook":
-        """
-        Webhook object from a URL.
-
-        Args:
-            client: The client to use to make the request.
-            url: Webhook URL
-
-        Returns:
-            A Webhook object.
-
-        """
-        match = re.search(r"discord(?:app)?\.com/api/webhooks/(?P<id>[0-9]{17,})/(?P<token>[\w\-.]{60,68})", url)
-        if match is None:
-            raise ValueError("Invalid webhook URL given.")
-
-        data: Dict[str, Any] = match.groupdict()
-        data["type"] = WebhookTypes.INCOMING
-        return cls.from_dict(data, client)
-
-    @classmethod
-    async def create(
-        cls,
-        client: "Client",
-        channel: Union["Snowflake_Type", "TYPE_MESSAGEABLE_CHANNEL"],
-        name: str,
-        avatar: Absent["UPLOADABLE_TYPE"] = MISSING,
-    ) -> "Webhook":
-        """
-        Create a webhook.
-
-        Args:
-            client: The bot's client
-            channel: The channel to create the webhook in
-            name: The name of the webhook
-            avatar: An optional default avatar to use
-
-        Returns:
-            New webhook object
-
-        Raises:
-            ValueError: If you try to name the webhook "Clyde"
-
-        """
-        if name.lower() == "clyde":
-            raise ValueError('Webhook names cannot be "Clyde"')
-
-        if not isinstance(channel, (str, int)):
-            channel = to_snowflake(channel)
-
-        if avatar:
-            avatar = to_image_data(avatar)
-
-        data = await client.http.create_webhook(channel, name, avatar)
-
-        return cls.from_dict(data, client)
-
-    @classmethod
-    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
-        if data.get("user"):
-            user = client.cache.place_user_data(data.pop("user"))
-            data["user_id"] = user.id
-        return data
-
-    async def edit(
-        self,
-        *,
-        name: Absent[str] = MISSING,
-        avatar: Absent["UPLOADABLE_TYPE"] = MISSING,
-        channel_id: Absent["Snowflake_Type"] = MISSING,
-    ) -> None:
-        """
-        Edit this webhook.
-
-        Args:
-            name: The default name of the webhook.
-            avatar: The image for the default webhook avatar.
-            channel_id: The new channel id this webhook should be moved to.
-
-        Raises:
-            ValueError: If you try to name the webhook "Clyde"
-
-        """
-        if name.lower() == "clyde":
-            raise ValueError('Webhook names cannot be "Clyde"')
-
-        data = await self._client.http.modify_webhook(
-            self.id, name, to_image_data(avatar), to_optional_snowflake(channel_id), self.token
-        )
-        self.update_from_dict(data)
-
-    async def delete(self) -> None:
-        """Delete this webhook."""
-        await self._client.http.delete_webhook(self.id, self.token)
-
-    async def send(
-        self,
-        content: Optional[str] = None,
-        *,
-        embed: Optional[Union["Embed", dict]] = None,
-        embeds: Optional[Union[List[Union["Embed", dict]], Union["Embed", dict]]] = None,
-        components: Optional[
-            Union[
-                List[List[Union["BaseComponent", dict]]],
-                List[Union["BaseComponent", dict]],
-                "BaseComponent",
-                dict,
-            ]
-        ] = None,
-        stickers: Optional[Union[List[Union["Sticker", "Snowflake_Type"]], "Sticker", "Snowflake_Type"]] = None,
-        allowed_mentions: Optional[Union["AllowedMentions", dict]] = None,
-        reply_to: Optional[Union["MessageReference", "Message", dict, "Snowflake_Type"]] = None,
-        files: Optional[Union["UPLOADABLE_TYPE", List["UPLOADABLE_TYPE"]]] = None,
-        file: Optional["UPLOADABLE_TYPE"] = None,
-        tts: bool = False,
-        suppress_embeds: bool = False,
-        flags: Optional[Union[int, "MessageFlags"]] = None,
-        username: str = None,
-        avatar_url: str = None,
-        wait: bool = False,
-        thread: "Snowflake_Type" = None,
-        **kwargs,
-    ) -> Optional["Message"]:
-        """
-        Send a message as this webhook.
-
-        Args:
-            content: Message text content.
-            embeds: Embedded rich content (up to 6000 characters).
-            embed: Embedded rich content (up to 6000 characters).
-            components: The components to include with the message.
-            stickers: IDs of up to 3 stickers in the server to send in the message.
-            allowed_mentions: Allowed mentions for the message.
-            reply_to: Message to reference, must be from the same channel.
-            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            tts: Should this message use Text To Speech.
-            suppress_embeds: Should embeds be suppressed on this send
-            flags: Message flags to apply.
-            username: The username to use
-            avatar_url: The url of an image to use as the avatar
-            wait: Waits for confirmation of delivery. Set this to True if you intend to edit the message
-            thread: Send this webhook to a thread channel
-
-        Returns:
-            New message object that was sent if `wait` is set to True
-
-        """
-        if not self.token:
-            raise ForeignWebhookException("You cannot send messages with a webhook without a token!")
-
-        if not content and not embeds and not embed and not files and not file and not stickers:
-            raise EmptyMessageException("You cannot send a message without any content, embeds, files, or stickers")
-
-        if suppress_embeds:
-            if isinstance(flags, int):
-                flags = MessageFlags(flags)
-            flags = flags | MessageFlags.SUPPRESS_EMBEDS
-
-        message_payload = process_message_payload(
-            content=content,
-            embeds=embeds or embed,
-            components=components,
-            stickers=stickers,
-            allowed_mentions=allowed_mentions,
-            reply_to=reply_to,
-            tts=tts,
-            flags=flags,
-            username=username,
-            avatar_url=avatar_url,
-            **kwargs,
-        )
-
-        message_data = await self._client.http.execute_webhook(
-            self.id,
-            self.token,
-            message_payload,
-            wait,
-            to_optional_snowflake(thread),
-            files=files or file,
-        )
-        if message_data:
-            return self._client.cache.place_message_data(message_data)
-
-    async def edit_message(
-        self,
-        message: Union["Message", "Snowflake_Type"],
-        *,
-        content: Optional[str] = None,
-        embeds: Optional[Union[List[Union["Embed", dict]], Union["Embed", dict]]] = None,
-        components: Optional[
-            Union[
-                List[List[Union["BaseComponent", dict]]],
-                List[Union["BaseComponent", dict]],
-                "BaseComponent",
-                dict,
-            ]
-        ] = None,
-        stickers: Optional[Union[List[Union["Sticker", "Snowflake_Type"]], "Sticker", "Snowflake_Type"]] = None,
-        allowed_mentions: Optional[Union["AllowedMentions", dict]] = None,
-        reply_to: Optional[Union["MessageReference", "Message", dict, "Snowflake_Type"]] = None,
-        files: Optional[Union["UPLOADABLE_TYPE", List["UPLOADABLE_TYPE"]]] = None,
-        file: Optional["UPLOADABLE_TYPE"] = None,
-        tts: bool = False,
-        flags: Optional[Union[int, "MessageFlags"]] = None,
-    ) -> Optional["Message"]:
-        """
-        Edit a message as this webhook.
-
-        Args:
-            message: Message to edit
-            content: Message text content.
-            embeds: Embedded rich content (up to 6000 characters).
-            components: The components to include with the message.
-            stickers: IDs of up to 3 stickers in the server to send in the message.
-            allowed_mentions: Allowed mentions for the message.
-            reply_to: Message to reference, must be from the same channel.
-            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            tts: Should this message use Text To Speech.
-            flags: Message flags to apply.
-
-        Returns:
-            Updated message object that was sent if `wait` is set to True
-
-        """
-        message_payload = process_message_payload(
-            content=content,
-            embeds=embeds,
-            components=components,
-            stickers=stickers,
-            allowed_mentions=allowed_mentions,
-            reply_to=reply_to,
-            tts=tts,
-            flags=flags,
-        )
-        msg_data = await self._client.http.edit_webhook_message(
-            self.id, self.token, to_snowflake(message), message_payload, files=files or file
-        )
-        if msg_data:
-            return self._client.cache.place_message_data(msg_data)
+import re
+from enum import IntEnum
+from typing import Optional, TYPE_CHECKING, Union, Dict, Any, List
+
+import attrs
+
+from interactions.client.const import MISSING, Absent
+from interactions.client.errors import ForeignWebhookException, EmptyMessageException
+from interactions.client.mixins.send import SendMixin
+from interactions.client.utils.serializer import to_image_data
+from interactions.models.discord.message import process_message_payload
+from interactions.models.discord.snowflake import to_snowflake, to_optional_snowflake
+from .base import DiscordObject
+
+if TYPE_CHECKING:
+    from interactions.models.discord.file import UPLOADABLE_TYPE
+    from interactions.client import Client
+    from interactions.models.discord.enums import MessageFlags
+    from interactions.models.discord.snowflake import Snowflake_Type
+    from interactions.models.discord.channel import TYPE_MESSAGEABLE_CHANNEL
+    from interactions.models.discord.components import BaseComponent
+    from interactions.models.discord.embed import Embed
+
+    from interactions.models.discord.message import (
+        AllowedMentions,
+        Message,
+        MessageReference,
+    )
+    from interactions.models.discord.sticker import Sticker
+
+__all__ = ("WebhookTypes", "Webhook")
+
+
+class WebhookTypes(IntEnum):
+    INCOMING = 1
+    """Incoming Webhooks can post messages to channels with a generated token"""
+    CHANNEL_FOLLOWER = 2
+    """Channel Follower Webhooks are internal webhooks used with Channel Following to post new messages into channels"""
+    APPLICATION = 3
+    """Application webhooks are webhooks used with Interactions"""
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class Webhook(DiscordObject, SendMixin):
+    type: WebhookTypes = attrs.field(
+        repr=False,
+    )
+    """The type of webhook"""
+
+    application_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """the bot/OAuth2 application that created this webhook"""
+
+    guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """the guild id this webhook is for, if any"""
+    channel_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """the channel id this webhook is for, if any"""
+    user_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """the user this webhook was created by"""
+
+    name: Optional[str] = attrs.field(repr=False, default=None)
+    """the default name of the webhook"""
+    avatar: Optional[str] = attrs.field(repr=False, default=None)
+    """the default user avatar hash of the webhook"""
+    token: str = attrs.field(repr=False, default=MISSING)
+    """the secure token of the webhook (returned for Incoming Webhooks)"""
+    url: Optional[str] = attrs.field(repr=False, default=None)
+    """the url used for executing the webhook (returned by the webhooks OAuth2 flow)"""
+
+    source_guild_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """the guild of the channel that this webhook is following (returned for Channel Follower Webhooks)"""
+    source_channel_id: Optional["Snowflake_Type"] = attrs.field(repr=False, default=None)
+    """the channel that this webhook is following (returned for Channel Follower Webhooks)"""
+
+    @classmethod
+    def from_url(cls, url: str, client: "Client") -> "Webhook":
+        """
+        Webhook object from a URL.
+
+        Args:
+            client: The client to use to make the request.
+            url: Webhook URL
+
+        Returns:
+            A Webhook object.
+
+        """
+        match = re.search(r"discord(?:app)?\.com/api/webhooks/(?P<id>[0-9]{17,})/(?P<token>[\w\-.]{60,68})", url)
+        if match is None:
+            raise ValueError("Invalid webhook URL given.")
+
+        data: Dict[str, Any] = match.groupdict()
+        data["type"] = WebhookTypes.INCOMING
+        return cls.from_dict(data, client)
+
+    @classmethod
+    async def create(
+        cls,
+        client: "Client",
+        channel: Union["Snowflake_Type", "TYPE_MESSAGEABLE_CHANNEL"],
+        name: str,
+        avatar: Absent["UPLOADABLE_TYPE"] = MISSING,
+    ) -> "Webhook":
+        """
+        Create a webhook.
+
+        Args:
+            client: The bot's client
+            channel: The channel to create the webhook in
+            name: The name of the webhook
+            avatar: An optional default avatar to use
+
+        Returns:
+            New webhook object
+
+        Raises:
+            ValueError: If you try to name the webhook "Clyde"
+
+        """
+        if name.lower() == "clyde":
+            raise ValueError('Webhook names cannot be "Clyde"')
+
+        if not isinstance(channel, (str, int)):
+            channel = to_snowflake(channel)
+
+        if avatar:
+            avatar = to_image_data(avatar)
+
+        data = await client.http.create_webhook(channel, name, avatar)
+
+        return cls.from_dict(data, client)
+
+    @classmethod
+    def _process_dict(cls, data: Dict[str, Any], client: "Client") -> Dict[str, Any]:
+        if data.get("user"):
+            user = client.cache.place_user_data(data.pop("user"))
+            data["user_id"] = user.id
+        return data
+
+    async def edit(
+        self,
+        *,
+        name: Absent[str] = MISSING,
+        avatar: Absent["UPLOADABLE_TYPE"] = MISSING,
+        channel_id: Absent["Snowflake_Type"] = MISSING,
+    ) -> None:
+        """
+        Edit this webhook.
+
+        Args:
+            name: The default name of the webhook.
+            avatar: The image for the default webhook avatar.
+            channel_id: The new channel id this webhook should be moved to.
+
+        Raises:
+            ValueError: If you try to name the webhook "Clyde"
+
+        """
+        if name.lower() == "clyde":
+            raise ValueError('Webhook names cannot be "Clyde"')
+
+        data = await self._client.http.modify_webhook(
+            self.id, name, to_image_data(avatar), to_optional_snowflake(channel_id), self.token
+        )
+        self.update_from_dict(data)
+
+    async def delete(self) -> None:
+        """Delete this webhook."""
+        await self._client.http.delete_webhook(self.id, self.token)
+
+    async def send(
+        self,
+        content: Optional[str] = None,
+        *,
+        embed: Optional[Union["Embed", dict]] = None,
+        embeds: Optional[Union[List[Union["Embed", dict]], Union["Embed", dict]]] = None,
+        components: Optional[
+            Union[
+                List[List[Union["BaseComponent", dict]]],
+                List[Union["BaseComponent", dict]],
+                "BaseComponent",
+                dict,
+            ]
+        ] = None,
+        stickers: Optional[Union[List[Union["Sticker", "Snowflake_Type"]], "Sticker", "Snowflake_Type"]] = None,
+        allowed_mentions: Optional[Union["AllowedMentions", dict]] = None,
+        reply_to: Optional[Union["MessageReference", "Message", dict, "Snowflake_Type"]] = None,
+        files: Optional[Union["UPLOADABLE_TYPE", List["UPLOADABLE_TYPE"]]] = None,
+        file: Optional["UPLOADABLE_TYPE"] = None,
+        tts: bool = False,
+        suppress_embeds: bool = False,
+        flags: Optional[Union[int, "MessageFlags"]] = None,
+        username: str = None,
+        avatar_url: str = None,
+        wait: bool = False,
+        thread: "Snowflake_Type" = None,
+        **kwargs,
+    ) -> Optional["Message"]:
+        """
+        Send a message as this webhook.
+
+        Args:
+            content: Message text content.
+            embeds: Embedded rich content (up to 6000 characters).
+            embed: Embedded rich content (up to 6000 characters).
+            components: The components to include with the message.
+            stickers: IDs of up to 3 stickers in the server to send in the message.
+            allowed_mentions: Allowed mentions for the message.
+            reply_to: Message to reference, must be from the same channel.
+            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            tts: Should this message use Text To Speech.
+            suppress_embeds: Should embeds be suppressed on this send
+            flags: Message flags to apply.
+            username: The username to use
+            avatar_url: The url of an image to use as the avatar
+            wait: Waits for confirmation of delivery. Set this to True if you intend to edit the message
+            thread: Send this webhook to a thread channel
+
+        Returns:
+            New message object that was sent if `wait` is set to True
+
+        """
+        if not self.token:
+            raise ForeignWebhookException("You cannot send messages with a webhook without a token!")
+
+        if not content and not embeds and not embed and not files and not file and not stickers:
+            raise EmptyMessageException("You cannot send a message without any content, embeds, files, or stickers")
+
+        if suppress_embeds:
+            if isinstance(flags, int):
+                flags = MessageFlags(flags)
+            flags = flags | MessageFlags.SUPPRESS_EMBEDS
+
+        message_payload = process_message_payload(
+            content=content,
+            embeds=embeds or embed,
+            components=components,
+            stickers=stickers,
+            allowed_mentions=allowed_mentions,
+            reply_to=reply_to,
+            tts=tts,
+            flags=flags,
+            username=username,
+            avatar_url=avatar_url,
+            **kwargs,
+        )
+
+        message_data = await self._client.http.execute_webhook(
+            self.id,
+            self.token,
+            message_payload,
+            wait,
+            to_optional_snowflake(thread),
+            files=files or file,
+        )
+        if message_data:
+            return self._client.cache.place_message_data(message_data)
+
+    async def edit_message(
+        self,
+        message: Union["Message", "Snowflake_Type"],
+        *,
+        content: Optional[str] = None,
+        embeds: Optional[Union[List[Union["Embed", dict]], Union["Embed", dict]]] = None,
+        components: Optional[
+            Union[
+                List[List[Union["BaseComponent", dict]]],
+                List[Union["BaseComponent", dict]],
+                "BaseComponent",
+                dict,
+            ]
+        ] = None,
+        stickers: Optional[Union[List[Union["Sticker", "Snowflake_Type"]], "Sticker", "Snowflake_Type"]] = None,
+        allowed_mentions: Optional[Union["AllowedMentions", dict]] = None,
+        reply_to: Optional[Union["MessageReference", "Message", dict, "Snowflake_Type"]] = None,
+        files: Optional[Union["UPLOADABLE_TYPE", List["UPLOADABLE_TYPE"]]] = None,
+        file: Optional["UPLOADABLE_TYPE"] = None,
+        tts: bool = False,
+        flags: Optional[Union[int, "MessageFlags"]] = None,
+    ) -> Optional["Message"]:
+        """
+        Edit a message as this webhook.
+
+        Args:
+            message: Message to edit
+            content: Message text content.
+            embeds: Embedded rich content (up to 6000 characters).
+            components: The components to include with the message.
+            stickers: IDs of up to 3 stickers in the server to send in the message.
+            allowed_mentions: Allowed mentions for the message.
+            reply_to: Message to reference, must be from the same channel.
+            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            tts: Should this message use Text To Speech.
+            flags: Message flags to apply.
+
+        Returns:
+            Updated message object that was sent if `wait` is set to True
+
+        """
+        message_payload = process_message_payload(
+            content=content,
+            embeds=embeds,
+            components=components,
+            stickers=stickers,
+            allowed_mentions=allowed_mentions,
+            reply_to=reply_to,
+            tts=tts,
+            flags=flags,
+        )
+        msg_data = await self._client.http.edit_webhook_message(
+            self.id, self.token, to_snowflake(message), message_payload, files=files or file
+        )
+        if msg_data:
+            return self._client.cache.place_message_data(msg_data)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/__init__.py` & `discord-py-interactions-5.6.0/interactions/models/internal/__init__.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,213 +1,213 @@
-from .annotations import (
-    slash_attachment_option,
-    slash_bool_option,
-    slash_channel_option,
-    slash_float_option,
-    slash_int_option,
-    slash_mentionable_option,
-    slash_role_option,
-    slash_str_option,
-    slash_user_option,
-)
-from .callback import CallbackObject
-from .active_voice_state import ActiveVoiceState
-from .application_commands import (
-    application_commands_to_dict,
-    auto_defer,
-    CallbackType,
-    component_callback,
-    ComponentCommand,
-    context_menu,
-    user_context_menu,
-    message_context_menu,
-    ContextMenu,
-    global_autocomplete,
-    GlobalAutoComplete,
-    InteractionCommand,
-    LocalisedDesc,
-    LocalisedName,
-    LocalizedDesc,
-    LocalizedName,
-    modal_callback,
-    ModalCommand,
-    OptionType,
-    slash_command,
-    slash_default_member_permission,
-    slash_option,
-    SlashCommand,
-    SlashCommandChoice,
-    SlashCommandOption,
-    SlashCommandParameter,
-    subcommand,
-    sync_needed,
-)
-from .auto_defer import AutoDefer
-from .checks import dm_only, guild_only, has_any_role, has_id, has_role, is_owner
-from .command import BaseCommand, check, cooldown, max_concurrency
-from .context import (
-    AutocompleteContext,
-    BaseContext,
-    BaseInteractionContext,
-    ComponentContext,
-    ContextMenuContext,
-    InteractionContext,
-    ModalContext,
-    Resolved,
-    SlashContext,
-)
-from .converters import (
-    BaseChannelConverter,
-    ChannelConverter,
-    CustomEmojiConverter,
-    DMChannelConverter,
-    DMConverter,
-    DMGroupConverter,
-    Greedy,
-    GuildCategoryConverter,
-    GuildChannelConverter,
-    GuildConverter,
-    GuildNewsConverter,
-    GuildNewsThreadConverter,
-    GuildPrivateThreadConverter,
-    GuildPublicThreadConverter,
-    GuildStageVoiceConverter,
-    GuildTextConverter,
-    GuildVoiceConverter,
-    IDConverter,
-    MemberConverter,
-    MessageableChannelConverter,
-    MessageConverter,
-    MODEL_TO_CONVERTER,
-    NoArgumentConverter,
-    PartialEmojiConverter,
-    RoleConverter,
-    SnowflakeConverter,
-    ThreadChannelConverter,
-    UserConverter,
-    VoiceChannelConverter,
-)
-from .cooldowns import (
-    Buckets,
-    Cooldown,
-    CooldownSystem,
-    MaxConcurrency,
-    SlidingWindowSystem,
-    ExponentialBackoffSystem,
-    LeakyBucketSystem,
-    TokenBucketSystem,
-)
-from .listener import listen, Listener
-from .protocols import Converter
-from .extension import Extension
-from .wait import Wait
-from .tasks import BaseTrigger, DateTrigger, IntervalTrigger, OrTrigger, Task, TimeTrigger
-
-__all__ = (
-    "ActiveVoiceState",
-    "application_commands_to_dict",
-    "auto_defer",
-    "AutocompleteContext",
-    "AutoDefer",
-    "BaseChannelConverter",
-    "BaseCommand",
-    "BaseContext",
-    "BaseInteractionContext",
-    "BaseTrigger",
-    "Buckets",
-    "CallbackObject",
-    "CallbackType",
-    "ChannelConverter",
-    "check",
-    "component_callback",
-    "ComponentCommand",
-    "ComponentContext",
-    "context_menu",
-    "user_context_menu",
-    "message_context_menu",
-    "ContextMenu",
-    "ContextMenuContext",
-    "Converter",
-    "cooldown",
-    "Cooldown",
-    "CooldownSystem",
-    "SlidingWindowSystem",
-    "ExponentialBackoffSystem",
-    "LeakyBucketSystem",
-    "TokenBucketSystem",
-    "CustomEmojiConverter",
-    "DateTrigger",
-    "dm_only",
-    "DMChannelConverter",
-    "DMConverter",
-    "DMGroupConverter",
-    "Extension",
-    "global_autocomplete",
-    "GlobalAutoComplete",
-    "Greedy",
-    "guild_only",
-    "GuildCategoryConverter",
-    "GuildChannelConverter",
-    "GuildConverter",
-    "GuildNewsConverter",
-    "GuildNewsThreadConverter",
-    "GuildPrivateThreadConverter",
-    "GuildPublicThreadConverter",
-    "GuildStageVoiceConverter",
-    "GuildTextConverter",
-    "GuildVoiceConverter",
-    "has_any_role",
-    "has_id",
-    "has_role",
-    "IDConverter",
-    "InteractionCommand",
-    "InteractionContext",
-    "IntervalTrigger",
-    "is_owner",
-    "listen",
-    "Listener",
-    "LocalisedDesc",
-    "LocalisedName",
-    "LocalizedDesc",
-    "LocalizedName",
-    "max_concurrency",
-    "MaxConcurrency",
-    "MemberConverter",
-    "MessageableChannelConverter",
-    "MessageConverter",
-    "modal_callback",
-    "ModalCommand",
-    "ModalContext",
-    "MODEL_TO_CONVERTER",
-    "NoArgumentConverter",
-    "OptionType",
-    "OrTrigger",
-    "PartialEmojiConverter",
-    "Resolved",
-    "RoleConverter",
-    "slash_attachment_option",
-    "slash_bool_option",
-    "slash_channel_option",
-    "slash_command",
-    "slash_default_member_permission",
-    "slash_float_option",
-    "slash_int_option",
-    "slash_mentionable_option",
-    "slash_option",
-    "slash_role_option",
-    "slash_str_option",
-    "slash_user_option",
-    "SlashCommand",
-    "SlashCommandChoice",
-    "SlashCommandOption",
-    "SlashCommandParameter",
-    "SlashContext",
-    "SnowflakeConverter",
-    "subcommand",
-    "sync_needed",
-    "Task",
-    "ThreadChannelConverter",
-    "TimeTrigger",
-    "UserConverter",
-    "VoiceChannelConverter",
-    "Wait",
-)
+from .annotations import (
+    slash_attachment_option,
+    slash_bool_option,
+    slash_channel_option,
+    slash_float_option,
+    slash_int_option,
+    slash_mentionable_option,
+    slash_role_option,
+    slash_str_option,
+    slash_user_option,
+)
+from .callback import CallbackObject
+from .active_voice_state import ActiveVoiceState
+from .application_commands import (
+    application_commands_to_dict,
+    auto_defer,
+    CallbackType,
+    component_callback,
+    ComponentCommand,
+    context_menu,
+    user_context_menu,
+    message_context_menu,
+    ContextMenu,
+    global_autocomplete,
+    GlobalAutoComplete,
+    InteractionCommand,
+    LocalisedDesc,
+    LocalisedName,
+    LocalizedDesc,
+    LocalizedName,
+    modal_callback,
+    ModalCommand,
+    OptionType,
+    slash_command,
+    slash_default_member_permission,
+    slash_option,
+    SlashCommand,
+    SlashCommandChoice,
+    SlashCommandOption,
+    SlashCommandParameter,
+    subcommand,
+    sync_needed,
+)
+from .auto_defer import AutoDefer
+from .checks import dm_only, guild_only, has_any_role, has_id, has_role, is_owner
+from .command import BaseCommand, check, cooldown, max_concurrency
+from .context import (
+    AutocompleteContext,
+    BaseContext,
+    BaseInteractionContext,
+    ComponentContext,
+    ContextMenuContext,
+    InteractionContext,
+    ModalContext,
+    Resolved,
+    SlashContext,
+)
+from .converters import (
+    BaseChannelConverter,
+    ChannelConverter,
+    CustomEmojiConverter,
+    DMChannelConverter,
+    DMConverter,
+    DMGroupConverter,
+    Greedy,
+    GuildCategoryConverter,
+    GuildChannelConverter,
+    GuildConverter,
+    GuildNewsConverter,
+    GuildNewsThreadConverter,
+    GuildPrivateThreadConverter,
+    GuildPublicThreadConverter,
+    GuildStageVoiceConverter,
+    GuildTextConverter,
+    GuildVoiceConverter,
+    IDConverter,
+    MemberConverter,
+    MessageableChannelConverter,
+    MessageConverter,
+    MODEL_TO_CONVERTER,
+    NoArgumentConverter,
+    PartialEmojiConverter,
+    RoleConverter,
+    SnowflakeConverter,
+    ThreadChannelConverter,
+    UserConverter,
+    VoiceChannelConverter,
+)
+from .cooldowns import (
+    Buckets,
+    Cooldown,
+    CooldownSystem,
+    MaxConcurrency,
+    SlidingWindowSystem,
+    ExponentialBackoffSystem,
+    LeakyBucketSystem,
+    TokenBucketSystem,
+)
+from .listener import listen, Listener
+from .protocols import Converter
+from .extension import Extension
+from .wait import Wait
+from .tasks import BaseTrigger, DateTrigger, IntervalTrigger, OrTrigger, Task, TimeTrigger
+
+__all__ = (
+    "ActiveVoiceState",
+    "application_commands_to_dict",
+    "auto_defer",
+    "AutocompleteContext",
+    "AutoDefer",
+    "BaseChannelConverter",
+    "BaseCommand",
+    "BaseContext",
+    "BaseInteractionContext",
+    "BaseTrigger",
+    "Buckets",
+    "CallbackObject",
+    "CallbackType",
+    "ChannelConverter",
+    "check",
+    "component_callback",
+    "ComponentCommand",
+    "ComponentContext",
+    "context_menu",
+    "user_context_menu",
+    "message_context_menu",
+    "ContextMenu",
+    "ContextMenuContext",
+    "Converter",
+    "cooldown",
+    "Cooldown",
+    "CooldownSystem",
+    "SlidingWindowSystem",
+    "ExponentialBackoffSystem",
+    "LeakyBucketSystem",
+    "TokenBucketSystem",
+    "CustomEmojiConverter",
+    "DateTrigger",
+    "dm_only",
+    "DMChannelConverter",
+    "DMConverter",
+    "DMGroupConverter",
+    "Extension",
+    "global_autocomplete",
+    "GlobalAutoComplete",
+    "Greedy",
+    "guild_only",
+    "GuildCategoryConverter",
+    "GuildChannelConverter",
+    "GuildConverter",
+    "GuildNewsConverter",
+    "GuildNewsThreadConverter",
+    "GuildPrivateThreadConverter",
+    "GuildPublicThreadConverter",
+    "GuildStageVoiceConverter",
+    "GuildTextConverter",
+    "GuildVoiceConverter",
+    "has_any_role",
+    "has_id",
+    "has_role",
+    "IDConverter",
+    "InteractionCommand",
+    "InteractionContext",
+    "IntervalTrigger",
+    "is_owner",
+    "listen",
+    "Listener",
+    "LocalisedDesc",
+    "LocalisedName",
+    "LocalizedDesc",
+    "LocalizedName",
+    "max_concurrency",
+    "MaxConcurrency",
+    "MemberConverter",
+    "MessageableChannelConverter",
+    "MessageConverter",
+    "modal_callback",
+    "ModalCommand",
+    "ModalContext",
+    "MODEL_TO_CONVERTER",
+    "NoArgumentConverter",
+    "OptionType",
+    "OrTrigger",
+    "PartialEmojiConverter",
+    "Resolved",
+    "RoleConverter",
+    "slash_attachment_option",
+    "slash_bool_option",
+    "slash_channel_option",
+    "slash_command",
+    "slash_default_member_permission",
+    "slash_float_option",
+    "slash_int_option",
+    "slash_mentionable_option",
+    "slash_option",
+    "slash_role_option",
+    "slash_str_option",
+    "slash_user_option",
+    "SlashCommand",
+    "SlashCommandChoice",
+    "SlashCommandOption",
+    "SlashCommandParameter",
+    "SlashContext",
+    "SnowflakeConverter",
+    "subcommand",
+    "sync_needed",
+    "Task",
+    "ThreadChannelConverter",
+    "TimeTrigger",
+    "UserConverter",
+    "VoiceChannelConverter",
+    "Wait",
+)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/application_commands.py` & `discord-py-interactions-5.6.0/interactions/models/internal/application_commands.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,1495 +1,1495 @@
-import asyncio
-import inspect
-import re
-import typing
-import types
-import functools
-from enum import IntEnum
-from typing import (
-    TYPE_CHECKING,
-    Annotated,
-    Callable,
-    Coroutine,
-    Dict,
-    List,
-    Union,
-    Optional,
-    Any,
-    TypeVar,
-)
-
-import attrs
-from attr import Attribute
-
-import interactions.models.discord.channel as channel
-from interactions.client.const import (
-    GLOBAL_SCOPE,
-    SLASH_CMD_NAME_LENGTH,
-    SLASH_CMD_MAX_OPTIONS,
-    SLASH_CMD_MAX_DESC_LENGTH,
-    MISSING,
-    Absent,
-    AsyncCallable,
-)
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils import optional
-from interactions.client.utils.attr_utils import attrs_validator, docs
-from interactions.client.utils.misc_utils import get_parameters, maybe_coroutine
-from interactions.client.utils.serializer import no_export_meta
-from interactions.models.discord.enums import ChannelType, CommandType, Permissions
-from interactions.models.discord.role import Role
-from interactions.models.discord.snowflake import to_snowflake_list, to_snowflake
-from interactions.models.discord.user import BaseUser
-from interactions.models.internal.auto_defer import AutoDefer
-from interactions.models.internal.callback import CallbackObject
-from interactions.models.internal.command import BaseCommand
-from interactions.models.internal.localisation import LocalisedField
-from interactions.models.internal.protocols import Converter
-
-if TYPE_CHECKING:
-    from interactions.models.discord.snowflake import Snowflake_Type
-    from interactions.models.internal.context import BaseContext, InteractionContext
-    from interactions import Client
-
-__all__ = (
-    "application_commands_to_dict",
-    "auto_defer",
-    "CallbackType",
-    "component_callback",
-    "ComponentCommand",
-    "context_menu",
-    "user_context_menu",
-    "message_context_menu",
-    "ContextMenu",
-    "global_autocomplete",
-    "GlobalAutoComplete",
-    "InteractionCommand",
-    "LocalisedDesc",
-    "LocalisedName",
-    "LocalizedDesc",
-    "LocalizedName",
-    "modal_callback",
-    "ModalCommand",
-    "OptionType",
-    "slash_command",
-    "slash_default_member_permission",
-    "slash_option",
-    "SlashCommand",
-    "SlashCommandChoice",
-    "SlashCommandOption",
-    "SlashCommandParameter",
-    "subcommand",
-    "sync_needed",
-)
-
-
-def name_validator(_: Any, attr: Attribute, value: str) -> None:
-    if value:
-        if not re.match(f"^[\\w-]{{1,{SLASH_CMD_NAME_LENGTH}}}$", value) or value != value.lower():
-            raise ValueError(
-                f"Slash Command names must be lower case and match this regex: ^[\\w-]{1, {SLASH_CMD_NAME_LENGTH} }$"
-            )
-
-
-def desc_validator(_: Any, attr: Attribute, value: str) -> None:
-    if value and not 1 <= len(value) <= SLASH_CMD_MAX_DESC_LENGTH:
-        raise ValueError(f"Description must be between 1 and {SLASH_CMD_MAX_DESC_LENGTH} characters long")
-
-
-def custom_ids_validator(*custom_id: str | re.Pattern) -> None:
-    if not (all(isinstance(i, re.Pattern) for i in custom_id) or all(isinstance(i, str) for i in custom_id)):
-        raise ValueError("All custom IDs be either a string or a regex pattern, not a mix of both.")
-
-
-@attrs.define(
-    eq=False,
-    order=False,
-    hash=False,
-    field_transformer=attrs_validator(name_validator, skip_fields=["default_locale"]),
-)
-class LocalisedName(LocalisedField):
-    """A localisation object for names."""
-
-    def __repr__(self) -> str:
-        return super().__repr__()
-
-
-@attrs.define(
-    eq=False,
-    order=False,
-    hash=False,
-    field_transformer=attrs_validator(desc_validator, skip_fields=["default_locale"]),
-)
-class LocalisedDesc(LocalisedField):
-    """A localisation object for descriptions."""
-
-    def __repr__(self) -> str:
-        return super().__repr__()
-
-
-LocalizedName = LocalisedName
-LocalizedDesc = LocalisedDesc
-
-
-class OptionType(IntEnum):
-    """Option types supported by slash commands."""
-
-    SUB_COMMAND = 1
-    SUB_COMMAND_GROUP = 2
-    STRING = 3
-    INTEGER = 4
-    BOOLEAN = 5
-    USER = 6
-    CHANNEL = 7
-    ROLE = 8
-    MENTIONABLE = 9
-    NUMBER = 10
-    ATTACHMENT = 11
-
-    @classmethod
-    def resolvable_types(cls) -> tuple["OptionType", ...]:
-        """A tuple of all resolvable types."""
-        return cls.USER, cls.CHANNEL, cls.ROLE, cls.MENTIONABLE, cls.ATTACHMENT
-
-    @classmethod
-    def static_types(cls) -> tuple["OptionType", ...]:
-        """A tuple of all static types."""
-        return cls.STRING, cls.INTEGER, cls.BOOLEAN, cls.NUMBER
-
-    @classmethod
-    def command_types(cls) -> tuple["OptionType", ...]:
-        """A tuple of all command types."""
-        return cls.SUB_COMMAND, cls.SUB_COMMAND_GROUP
-
-    @classmethod
-    def from_type(cls, t: type) -> "OptionType | None":
-        """
-        Convert data types to their corresponding OptionType.
-
-        Args:
-            t: The datatype to convert
-
-        Returns:
-            OptionType or None
-
-        """
-        if issubclass(t, str):
-            return cls.STRING
-        if issubclass(t, int):
-            return cls.INTEGER
-        if issubclass(t, bool):
-            return cls.BOOLEAN
-        if issubclass(t, BaseUser):
-            return cls.USER
-        if issubclass(t, channel.BaseChannel):
-            return cls.CHANNEL
-        if issubclass(t, Role):
-            return cls.ROLE
-        if issubclass(t, float):
-            return cls.NUMBER
-
-
-class CallbackType(IntEnum):
-    """Types of callback supported by interaction response."""
-
-    PONG = 1
-    CHANNEL_MESSAGE_WITH_SOURCE = 4
-    DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE = 5
-    DEFERRED_UPDATE_MESSAGE = 6
-    UPDATE_MESSAGE = 7
-    AUTOCOMPLETE_RESULT = 8
-    MODAL = 9
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class InteractionCommand(BaseCommand):
-    """
-    Represents a discord abstract interaction command.
-
-    Attributes:
-        scope: Denotes whether its global or for specific guild.
-        default_member_permissions: What permissions members need to have by default to use this command.
-        dm_permission: Should this command be available in DMs.
-        cmd_id: The id of this command given by discord.
-        callback: The coroutine to callback when this interaction is received.
-
-    """
-
-    name: LocalisedName | str = attrs.field(
-        repr=False,
-        metadata=docs("1-32 character name") | no_export_meta,
-        converter=LocalisedName.converter,
-    )
-    scopes: List["Snowflake_Type"] = attrs.field(
-        default=[GLOBAL_SCOPE],
-        converter=to_snowflake_list,
-        metadata=docs("The scopes of this interaction. Global or guild ids") | no_export_meta,
-    )
-    default_member_permissions: Optional["Permissions"] = attrs.field(
-        repr=False,
-        default=None,
-        metadata=docs("What permissions members need to have by default to use this command"),
-    )
-    dm_permission: bool = attrs.field(repr=False, default=True, metadata=docs("Whether this command is enabled in DMs"))
-    cmd_id: Dict[str, "Snowflake_Type"] = attrs.field(
-        repr=False, factory=dict, metadata=docs("The unique IDs of this commands") | no_export_meta
-    )  # scope: cmd_id
-    callback: Callable[..., Coroutine] = attrs.field(
-        repr=False,
-        default=None,
-        metadata=docs("The coroutine to call when this interaction is received") | no_export_meta,
-    )
-    auto_defer: "AutoDefer" = attrs.field(
-        default=MISSING,
-        metadata=docs("A system to automatically defer this command after a set duration") | no_export_meta,
-    )
-    nsfw: bool = attrs.field(repr=False, default=False, metadata=docs("This command should only work in NSFW channels"))
-    _application_id: "Snowflake_Type" = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
-
-    def __attrs_post_init__(self) -> None:
-        if self.callback is not None and hasattr(self.callback, "auto_defer"):
-            self.auto_defer = self.callback.auto_defer
-
-        super().__attrs_post_init__()
-
-    def to_dict(self) -> dict:
-        data = super().to_dict()
-
-        if self.default_member_permissions is not None:
-            data["default_member_permissions"] = str(int(self.default_member_permissions))
-        else:
-            data["default_member_permissions"] = None
-
-        return data
-
-    def mention(self, scope: Optional["Snowflake_Type"] = None) -> str:
-        """
-        Returns a string that would mention the interaction.
-
-        Args:
-            scope: If the command is available in multiple scope, specify which scope to get the mention for. Defaults to the first available one if not specified.
-
-        Returns:
-            The markdown mention.
-        """
-        if scope:
-            cmd_id = self.get_cmd_id(scope=scope)
-        else:
-            cmd_id = list(self.cmd_id.values())[0]
-
-        return f"</{self.resolved_name}:{cmd_id}>"
-
-    @property
-    def resolved_name(self) -> str:
-        """A representation of this interaction's name."""
-        return str(self.name)
-
-    def get_localised_name(self, locale: str) -> str:
-        return self.name.get_locale(locale)
-
-    def get_cmd_id(self, scope: "Snowflake_Type") -> "Snowflake_Type":
-        return self.cmd_id.get(scope, self.cmd_id.get(GLOBAL_SCOPE, None))
-
-    @property
-    def is_subcommand(self) -> bool:
-        return False
-
-    async def _permission_enforcer(self, ctx: "BaseContext") -> bool:
-        """A check that enforces Discord permissions."""
-        # I wish this wasn't needed, but unfortunately Discord permissions cant be trusted to actually prevent usage
-        return ctx.guild is not None if self.dm_permission is False else True
-
-    def is_enabled(self, ctx: "BaseContext") -> bool:
-        """
-        Check if this command is enabled in the given context.
-
-        Args:
-            ctx: The context to check.
-
-        Returns:
-            Whether this command is enabled in the given context.
-        """
-        if not self.dm_permission and ctx.guild is None:
-            return False
-        if self.dm_permission and ctx.guild is None:
-            # remaining checks are impossible if this is a DM and DMs are enabled
-            return True
-
-        if self.nsfw and not ctx.channel.is_nsfw():
-            return False
-        if cmd_perms := ctx.guild.command_permissions.get(self.get_cmd_id(ctx.guild.id)):
-            if not cmd_perms.is_enabled_in_context(ctx):
-                return False
-        if self.default_member_permissions is not None:
-            channel_perms = ctx.author.channel_permissions(ctx.channel)
-            if any(perm not in channel_perms for perm in self.default_member_permissions):
-                return False
-        return True
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ContextMenu(InteractionCommand):
-    """
-    Represents a discord context menu.
-
-    Attributes:
-        name: The name of this entry.
-        type: The type of entry (user or message).
-
-    """
-
-    name: LocalisedField = attrs.field(
-        repr=False, metadata=docs("1-32 character name"), converter=LocalisedField.converter
-    )
-    type: CommandType = attrs.field(repr=False, metadata=docs("The type of command, defaults to 1 if not specified"))
-
-    @type.validator
-    def _type_validator(self, attribute: str, value: int) -> None:
-        if not isinstance(value, CommandType):
-            if value not in CommandType.__members__.values():
-                raise ValueError("Context Menu type not recognised, please consult the docs.")
-        elif value == CommandType.CHAT_INPUT:
-            raise ValueError(
-                "The CHAT_INPUT type is basically slash commands. Please use the @slash_command() " "decorator instead."
-            )
-
-    def to_dict(self) -> dict:
-        data = super().to_dict()
-
-        data["name"] = str(self.name)
-        return data
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class SlashCommandChoice(DictSerializationMixin):
-    """
-    Represents a discord slash command choice.
-
-    Attributes:
-        name: The name the user will see
-        value: The data sent to your code when this choice is used
-
-    """
-
-    name: LocalisedField | str = attrs.field(repr=False, converter=LocalisedField.converter)
-    value: Union[str, int, float] = attrs.field(
-        repr=False,
-    )
-
-    def as_dict(self) -> dict:
-        return {
-            "name": str(self.name),
-            "value": self.value,
-            "name_localizations": self.name.to_locale_dict(),
-        }
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=False)
-class SlashCommandOption(DictSerializationMixin):
-    """
-    Represents a discord slash command option.
-
-    Attributes:
-        name: The name of this option
-        type: The type of option
-        description: The description of this option
-        required: "This option must be filled to use the command"
-        choices: A list of choices the user has to pick between
-        channel_types: The channel types permitted. The option needs to be a channel
-        min_value: The minimum value permitted. The option needs to be an integer or float
-        max_value: The maximum value permitted. The option needs to be an integer or float
-        min_length: The minimum length of text a user can input. The option needs to be a string
-        max_length: The maximum length of text a user can input. The option needs to be a string
-
-    """
-
-    name: LocalisedName | str = attrs.field(repr=False, converter=LocalisedName.converter)
-    type: Union[OptionType, int] = attrs.field(
-        repr=False,
-    )
-    description: LocalisedDesc | str | str = attrs.field(
-        repr=False, default="No Description Set", converter=LocalisedDesc.converter
-    )
-    required: bool = attrs.field(repr=False, default=True)
-    autocomplete: bool = attrs.field(repr=False, default=False)
-    choices: List[Union[SlashCommandChoice, Dict]] = attrs.field(repr=False, factory=list)
-    channel_types: Optional[list[Union[ChannelType, int]]] = attrs.field(repr=False, default=None)
-    min_value: Optional[float] = attrs.field(repr=False, default=None)
-    max_value: Optional[float] = attrs.field(repr=False, default=None)
-    min_length: Optional[int] = attrs.field(repr=False, default=None)
-    max_length: Optional[int] = attrs.field(repr=False, default=None)
-
-    @type.validator
-    def _type_validator(self, attribute: str, value: int) -> None:
-        if value in (OptionType.SUB_COMMAND, OptionType.SUB_COMMAND_GROUP):
-            raise ValueError(
-                "Options cannot be SUB_COMMAND or SUB_COMMAND_GROUP. If you want to use subcommands, "
-                "see the @sub_command() decorator."
-            )
-
-    @channel_types.validator
-    def _channel_types_validator(self, attribute: str, value: Optional[list[OptionType]]) -> None:
-        if value is not None:
-            if self.type != OptionType.CHANNEL:
-                raise ValueError("The option needs to be CHANNEL to use this")
-
-            allowed_int = [channel_type.value for channel_type in ChannelType]
-            for item in value:
-                if (item not in allowed_int) and (item not in ChannelType):
-                    raise ValueError(f"{value} is not allowed here")
-
-    @min_value.validator
-    def _min_value_validator(self, attribute: str, value: Optional[float]) -> None:
-        if value is not None:
-            if self.type not in [OptionType.INTEGER, OptionType.NUMBER]:
-                raise ValueError("`min_value` can only be supplied with int or float options")
-
-            if self.type == OptionType.INTEGER and isinstance(value, float):
-                raise ValueError("`min_value` needs to be an int in an int option")
-
-            if self.max_value is not None and self.min_value is not None and self.max_value < self.min_value:
-                raise ValueError("`min_value` needs to be <= than `max_value`")
-
-    @max_value.validator
-    def _max_value_validator(self, attribute: str, value: Optional[float]) -> None:
-        if value is not None:
-            if self.type not in (OptionType.INTEGER, OptionType.NUMBER):
-                raise ValueError("`max_value` can only be supplied with int or float options")
-
-            if self.type == OptionType.INTEGER and isinstance(value, float):
-                raise ValueError("`max_value` needs to be an int in an int option")
-
-            if self.max_value and self.min_value and self.max_value < self.min_value:
-                raise ValueError("`min_value` needs to be <= than `max_value`")
-
-    @min_length.validator
-    def _min_length_validator(self, attribute: str, value: Optional[int]) -> None:
-        if value is not None:
-            if self.type != OptionType.STRING:
-                raise ValueError("`min_length` can only be supplied with string options")
-
-            if self.max_length is not None and self.min_length is not None and self.max_length < self.min_length:
-                raise ValueError("`min_length` needs to be <= than `max_length`")
-
-            if self.min_length < 0:
-                raise ValueError("`min_length` needs to be >= 0")
-
-    @max_length.validator
-    def _max_length_validator(self, attribute: str, value: Optional[int]) -> None:
-        if value is not None:
-            if self.type != OptionType.STRING:
-                raise ValueError("`max_length` can only be supplied with string options")
-
-            if self.min_length is not None and self.max_length is not None and self.max_length < self.min_length:
-                raise ValueError("`min_length` needs to be <= than `max_length`")
-
-            if self.max_length < 1:
-                raise ValueError("`max_length` needs to be >= 1")
-
-    def as_dict(self) -> dict:
-        data = attrs.asdict(self)
-        data["name"] = str(self.name)
-        data["description"] = str(self.description)
-        data["choices"] = [
-            choice.as_dict() if isinstance(choice, SlashCommandChoice) else choice for choice in self.choices
-        ]
-        data["name_localizations"] = self.name.to_locale_dict()
-        data["description_localizations"] = self.description.to_locale_dict()
-
-        return data
-
-
-@attrs.define()
-class SlashCommandParameter:
-    name: str = attrs.field()
-    type: typing.Any = attrs.field()
-    kind: inspect._ParameterKind = attrs.field()
-    default: typing.Any = attrs.field(default=MISSING)
-    converter: typing.Optional[typing.Callable] = attrs.field(default=None)
-
-
-def _get_option_from_annotated(annotated: Annotated) -> SlashCommandOption | None:
-    args = typing.get_args(annotated)
-    return next((a for a in args if isinstance(a, SlashCommandOption)), None)
-
-
-def _get_converter_from_annotated(annotated: Annotated) -> Converter | None:
-    args = typing.get_args(annotated)
-    return next((a for a in args if isinstance(a, Converter)), None)
-
-
-def _is_union(anno: typing.Any) -> bool:
-    return typing.get_origin(anno) in {Union, types.UnionType}
-
-
-def _is_optional(anno: typing.Any) -> bool:
-    return _is_union(anno) and types.NoneType in typing.get_args(anno)
-
-
-def _remove_optional(t: OptionType | type) -> Any:
-    non_optional_args: tuple[type] = tuple(a for a in typing.get_args(t) if a is not types.NoneType)  # noqa
-    if len(non_optional_args) == 1:
-        return non_optional_args[0]
-    return typing.Union[non_optional_args]  # type: ignore
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class SlashCommand(InteractionCommand):
-    name: LocalisedName | str = attrs.field(repr=False, converter=LocalisedName.converter)
-    description: LocalisedDesc | str = attrs.field(
-        repr=False, default="No Description Set", converter=LocalisedDesc.converter
-    )
-
-    group_name: LocalisedName | str = attrs.field(
-        repr=False, default=None, metadata=no_export_meta, converter=LocalisedName.converter
-    )
-    group_description: LocalisedDesc | str = attrs.field(
-        repr=False,
-        default="No Description Set",
-        metadata=no_export_meta,
-        converter=LocalisedDesc.converter,
-    )
-
-    sub_cmd_name: LocalisedName | str = attrs.field(
-        repr=False, default=None, metadata=no_export_meta, converter=LocalisedName.converter
-    )
-    sub_cmd_description: LocalisedDesc | str = attrs.field(
-        repr=False,
-        default="No Description Set",
-        metadata=no_export_meta,
-        converter=LocalisedDesc.converter,
-    )
-
-    options: List[Union[SlashCommandOption, Dict]] = attrs.field(repr=False, factory=list)
-    autocomplete_callbacks: dict = attrs.field(repr=False, factory=dict, metadata=no_export_meta)
-
-    parameters: dict[str, SlashCommandParameter] = attrs.field(
-        repr=False,
-        factory=dict,
-        metadata=no_export_meta,
-    )
-    _uses_arg: bool = attrs.field(repr=False, default=False, metadata=no_export_meta)
-
-    @property
-    def resolved_name(self) -> str:
-        return (
-            f"{self.name}"
-            f"{f' {self.group_name}' if bool(self.group_name) else ''}"
-            f"{f' {self.sub_cmd_name}' if bool(self.sub_cmd_name) else ''}"
-        )
-
-    def get_localised_name(self, locale: str) -> str:
-        return (
-            f"{self.name.get_locale(locale)}"
-            f"{f' {self.group_name.get_locale(locale)}' if bool(self.group_name) else ''}"
-            f"{f' {self.sub_cmd_name.get_locale(locale)}' if bool(self.sub_cmd_name) else ''}"
-        )
-
-    @property
-    def is_subcommand(self) -> bool:
-        return bool(self.sub_cmd_name)
-
-    def __attrs_post_init__(self) -> None:
-        if self.callback is not None and hasattr(self.callback, "options"):
-            if not self.options:
-                self.options = []
-            self.options += self.callback.options
-
-        super().__attrs_post_init__()
-
-    def _add_option_from_anno_method(self, name: str, option: SlashCommandOption) -> None:
-        if not self.options:
-            self.options = []
-
-        option.name = name
-        self.options.append(option)
-
-    def _parse_parameters(self) -> None:
-        """
-        Parses the parameters that this command has into a form i.py can use.
-
-        This is purposely separated like this to allow "lazy parsing" - parsing
-        as the command is added to a bot rather than being parsed immediately.
-        This allows variables like "self" to be filtered out, and is useful for
-        potential future additions.
-
-        For slash commands, it is also much faster than inspecting the parameters
-        each time the command is called.
-        It also allows for us to deal with the "annotation method", where users
-        put their options in the annotations itself.
-        """
-        if self.callback is None or self.parameters:
-            return
-
-        if self.has_binding:
-            callback = functools.partial(self.callback, None, None)
-        else:
-            callback = functools.partial(self.callback, None)
-
-        for param in get_parameters(callback).values():
-            if param.kind == inspect._ParameterKind.VAR_POSITIONAL:
-                self._uses_arg = True
-                continue
-
-            if param.kind == inspect._ParameterKind.VAR_KEYWORD:
-                # in case it was set before
-                # we prioritize **kwargs over *args
-                self._uses_arg = False
-                continue
-
-            our_param = SlashCommandParameter(param.name, param.annotation, param.kind)
-            our_param.default = param.default if param.default is not inspect._empty else MISSING
-
-            if param.annotation is not inspect._empty:
-                anno = param.annotation
-                converter = None
-
-                if _is_optional(anno):
-                    anno = _remove_optional(anno)
-
-                if isinstance(anno, SlashCommandOption):
-                    # annotation method, get option and add it in
-                    self._add_option_from_anno_method(param.name, anno)
-
-                if isinstance(anno, Converter):
-                    converter = anno
-                elif typing.get_origin(anno) == Annotated:
-                    if option := _get_option_from_annotated(anno):
-                        # also annotation method
-                        self._add_option_from_anno_method(param.name, option)
-
-                    converter = _get_converter_from_annotated(anno)
-
-                if converter:
-                    our_param.converter = self._get_converter_function(converter, our_param.name)
-
-            self.parameters[param.name] = our_param
-
-    def to_dict(self) -> dict:
-        data = super().to_dict()
-
-        if self.is_subcommand:
-            data["name"] = str(self.sub_cmd_name)
-            data["description"] = str(self.sub_cmd_description)
-            data["name_localizations"] = self.sub_cmd_name.to_locale_dict()
-            data["description_localizations"] = self.sub_cmd_description.to_locale_dict()
-            data.pop("default_member_permissions", None)
-            data.pop("dm_permission", None)
-            data.pop("nsfw", None)
-        else:
-            data["name_localizations"] = self.name.to_locale_dict()
-            data["description_localizations"] = self.description.to_locale_dict()
-        return data
-
-    @options.validator
-    def options_validator(self, attribute: str, value: List) -> None:
-        if value:
-            if not isinstance(value, list):
-                raise TypeError("Options attribute must be either None or a list of options")
-            if len(value) > SLASH_CMD_MAX_OPTIONS:
-                raise ValueError(f"Slash commands can only hold {SLASH_CMD_MAX_OPTIONS} options")
-            if value != sorted(
-                value,
-                key=lambda x: x.required if isinstance(x, SlashCommandOption) else x["required"],
-                reverse=True,
-            ):
-                raise ValueError("Required options must go before optional options")
-
-    def autocomplete(self, option_name: str) -> Callable[..., Coroutine]:
-        """A decorator to declare a coroutine as an option autocomplete."""
-
-        def wrapper(call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
-            if not asyncio.iscoroutinefunction(call):
-                raise TypeError("autocomplete must be coroutine")
-            self.autocomplete_callbacks[option_name] = call
-
-            if self.options:
-                # automatically set the option's autocomplete attribute to True
-                for opt in self.options:
-                    if isinstance(opt, dict) and str(opt["name"]) == option_name:
-                        opt["autocomplete"] = True
-                    elif isinstance(opt, SlashCommandOption) and str(opt.name) == option_name:
-                        opt.autocomplete = True
-
-            return call
-
-        option_name = option_name.lower()
-        return wrapper
-
-    def group(
-        self, name: str = None, description: str = "No Description Set", inherit_checks: bool = True
-    ) -> "SlashCommand":
-        return SlashCommand(
-            name=self.name,
-            description=self.description,
-            group_name=name,
-            group_description=description,
-            scopes=self.scopes,
-            default_member_permissions=self.default_member_permissions,
-            dm_permission=self.dm_permission,
-            checks=self.checks.copy() if inherit_checks else [],
-        )
-
-    def subcommand(
-        self,
-        sub_cmd_name: Absent[LocalisedName | str] = MISSING,
-        group_name: LocalisedName | str = None,
-        sub_cmd_description: Absent[LocalisedDesc | str] = MISSING,
-        group_description: Absent[LocalisedDesc | str] = MISSING,
-        options: List[Union[SlashCommandOption, Dict]] = None,
-        nsfw: bool = False,
-        inherit_checks: bool = True,
-    ) -> Callable[..., "SlashCommand"]:
-        def wrapper(call: Callable[..., Coroutine]) -> "SlashCommand":
-            nonlocal sub_cmd_name, sub_cmd_description
-
-            if not asyncio.iscoroutinefunction(call):
-                raise TypeError("Subcommand must be coroutine")
-
-            if sub_cmd_description is MISSING:
-                sub_cmd_description = call.__doc__ or "No Description Set"
-            if sub_cmd_name is MISSING:
-                sub_cmd_name = call.__name__
-
-            return SlashCommand(
-                name=self.name,
-                description=self.description,
-                group_name=group_name or self.group_name,
-                group_description=group_description or self.group_description,
-                sub_cmd_name=sub_cmd_name,
-                sub_cmd_description=sub_cmd_description,
-                default_member_permissions=self.default_member_permissions,
-                dm_permission=self.dm_permission,
-                options=options,
-                callback=call,
-                scopes=self.scopes,
-                nsfw=nsfw,
-                checks=self.checks.copy() if inherit_checks else [],
-            )
-
-        return wrapper
-
-    async def call_callback(self, callback: typing.Callable, ctx: "InteractionContext") -> None:
-        if not self.parameters:
-            if self._uses_arg:
-                return await self.call_with_binding(callback, ctx, *ctx.args)
-            return await self.call_with_binding(callback, ctx)
-
-        kwargs_copy = ctx.kwargs.copy()
-
-        new_args = []
-        new_kwargs = {}
-
-        for name, param in self.parameters.items():
-            value = kwargs_copy.pop(name, MISSING)
-            if value is MISSING:
-                continue
-
-            if converter := param.converter:
-                value = await maybe_coroutine(converter, ctx, value)
-
-            if param.kind == inspect.Parameter.POSITIONAL_ONLY:
-                new_args.append(value)
-            else:
-                new_kwargs[name] = value
-
-        # i do want to address one thing: what happens if you have both *args and **kwargs
-        # in your argument?
-        # i would say passing in values for both makes sense... but they're very likely
-        # going to overlap and cause issues and confusion
-        # for the sake of simplicty, i.py assumes kwargs takes priority over args
-        if kwargs_copy:
-            if self._uses_arg:
-                new_args.extend(kwargs_copy.values())
-            else:
-                new_kwargs |= kwargs_copy
-
-        return await self.call_with_binding(callback, ctx, *new_args, **new_kwargs)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ComponentCommand(InteractionCommand):
-    # right now this adds no extra functionality, but for future dev ive implemented it
-    name: str = attrs.field(
-        repr=False,
-    )
-    listeners: list[str | re.Pattern] = attrs.field(repr=False, factory=list)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class ModalCommand(ComponentCommand):
-    ...
-
-
-def _unpack_helper(iterable: typing.Iterable[str]) -> list[str]:
-    """
-    Unpacks all types of iterable into a list of strings. Primarily to flatten generators.
-
-    Args:
-        iterable: The iterable of strings to unpack
-
-    Returns:
-        A list of strings
-    """
-    unpack = []
-    for c in iterable:
-        if inspect.isgenerator(c):
-            unpack += list(c)
-        else:
-            unpack.append(c)
-    return unpack
-
-
-class GlobalAutoComplete(CallbackObject):
-    def __init__(self, option_name: str, callback: Callable) -> None:
-        self.callback = callback
-        self.option_name = option_name
-
-
-##############
-# Decorators #
-##############
-
-
-def global_autocomplete(option_name: str) -> Callable[[AsyncCallable], GlobalAutoComplete]:
-    """
-    Decorator for global autocomplete functions
-
-    Args:
-        option_name: The name of the option to register the autocomplete function for
-
-    Returns:
-        The decorator
-    """
-
-    def decorator(func: Callable) -> GlobalAutoComplete:
-        if not asyncio.iscoroutinefunction(func):
-            raise TypeError("Autocomplete functions must be coroutines")
-        return GlobalAutoComplete(option_name, func)
-
-    return decorator
-
-
-def slash_command(
-    name: Absent[str | LocalisedName] = MISSING,
-    *,
-    description: Absent[str | LocalisedDesc] = MISSING,
-    scopes: Absent[List["Snowflake_Type"]] = MISSING,
-    options: Optional[List[Union[SlashCommandOption, Dict]]] = None,
-    default_member_permissions: Optional["Permissions"] = None,
-    dm_permission: bool = True,
-    sub_cmd_name: str | LocalisedName = None,
-    group_name: str | LocalisedName = None,
-    sub_cmd_description: str | LocalisedDesc = "No Description Set",
-    group_description: str | LocalisedDesc = "No Description Set",
-    nsfw: bool = False,
-) -> Callable[[AsyncCallable], SlashCommand]:
-    """
-    A decorator to declare a coroutine as a slash command.
-
-    !!! note
-        While the base and group descriptions arent visible in the discord client, currently.
-        We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in
-        one of the future ui updates.
-
-    Args:
-        name: 1-32 character name of the command, defaults to the name of the coroutine.
-        description: 1-100 character description of the command
-        scopes: The scope this command exists within
-        options: The parameters for the command, max 25
-        default_member_permissions: What permissions members need to have by default to use this command.
-        dm_permission: Should this command be available in DMs.
-        sub_cmd_name: 1-32 character name of the subcommand
-        sub_cmd_description: 1-100 character description of the subcommand
-        group_name: 1-32 character name of the group
-        group_description: 1-100 character description of the group
-        nsfw: This command should only work in NSFW channels
-
-    Returns:
-        SlashCommand Object
-
-    """
-
-    def wrapper(func: AsyncCallable) -> SlashCommand:
-        if not asyncio.iscoroutinefunction(func):
-            raise ValueError("Commands must be coroutines")
-
-        perm = default_member_permissions
-        if hasattr(func, "default_member_permissions"):
-            if perm:
-                perm = perm | func.default_member_permissions
-            else:
-                perm = func.default_member_permissions
-
-        _name = name
-        if _name is MISSING:
-            _name = func.__name__
-
-        _description = description
-        if _description is MISSING:
-            _description = func.__doc__ or "No Description Set"
-
-        cmd = SlashCommand(
-            name=_name,
-            group_name=group_name,
-            group_description=group_description,
-            sub_cmd_name=sub_cmd_name,
-            sub_cmd_description=sub_cmd_description,
-            description=_description,
-            scopes=scopes or [GLOBAL_SCOPE],
-            default_member_permissions=perm,
-            dm_permission=dm_permission,
-            callback=func,
-            options=options,
-            nsfw=nsfw,
-        )
-
-        return cmd
-
-    return wrapper
-
-
-def subcommand(
-    base: str | LocalisedName,
-    *,
-    subcommand_group: Optional[str | LocalisedName] = None,
-    name: Absent[str | LocalisedName] = MISSING,
-    description: Absent[str | LocalisedDesc] = MISSING,
-    base_description: Optional[str | LocalisedDesc] = None,
-    base_desc: Optional[str | LocalisedDesc] = None,
-    base_default_member_permissions: Optional["Permissions"] = None,
-    base_dm_permission: bool = True,
-    subcommand_group_description: Optional[str | LocalisedDesc] = None,
-    sub_group_desc: Optional[str | LocalisedDesc] = None,
-    scopes: List["Snowflake_Type"] = None,
-    options: List[dict] = None,
-    nsfw: bool = False,
-) -> Callable[[AsyncCallable], SlashCommand]:
-    """
-    A decorator specifically tailored for creating subcommands.
-
-    Args:
-        base: The name of the base command
-        subcommand_group: The name of the subcommand group, if any.
-        name: The name of the subcommand, defaults to the name of the coroutine.
-        description: The description of the subcommand
-        base_description: The description of the base command
-        base_desc: An alias of `base_description`
-        base_default_member_permissions: What permissions members need to have by default to use this command.
-        base_dm_permission: Should this command be available in DMs.
-        subcommand_group_description: Description of the subcommand group
-        sub_group_desc: An alias for `subcommand_group_description`
-        scopes: The scopes of which this command is available, defaults to GLOBAL_SCOPE
-        options: The options for this command
-        nsfw: This command should only work in NSFW channels
-
-    Returns:
-        A SlashCommand object
-
-    """
-
-    def wrapper(func: AsyncCallable) -> SlashCommand:
-        if not asyncio.iscoroutinefunction(func):
-            raise ValueError("Commands must be coroutines")
-
-        _name = name
-        if _name is MISSING:
-            _name = func.__name__
-
-        _description = description
-        if _description is MISSING:
-            _description = func.__doc__ or "No Description Set"
-
-        cmd = SlashCommand(
-            name=base,
-            description=(base_description or base_desc) or "No Description Set",
-            group_name=subcommand_group,
-            group_description=(subcommand_group_description or sub_group_desc) or "No Description Set",
-            sub_cmd_name=_name,
-            sub_cmd_description=_description,
-            default_member_permissions=base_default_member_permissions,
-            dm_permission=base_dm_permission,
-            scopes=scopes or [GLOBAL_SCOPE],
-            callback=func,
-            options=options,
-            nsfw=nsfw,
-        )
-        return cmd
-
-    return wrapper
-
-
-def context_menu(
-    name: Absent[str | LocalisedName] = MISSING,
-    *,
-    context_type: "CommandType",
-    scopes: Absent[List["Snowflake_Type"]] = MISSING,
-    default_member_permissions: Optional["Permissions"] = None,
-    dm_permission: bool = True,
-) -> Callable[[AsyncCallable], ContextMenu]:
-    """
-    A decorator to declare a coroutine as a Context Menu.
-
-    Args:
-        name: 1-32 character name of the context menu, defaults to the name of the coroutine.
-        context_type: The type of context menu
-        scopes: The scope this command exists within
-        default_member_permissions: What permissions members need to have by default to use this command.
-        dm_permission: Should this command be available in DMs.
-
-    Returns:
-        ContextMenu object
-
-    """
-
-    def wrapper(func: AsyncCallable) -> ContextMenu:
-        if not asyncio.iscoroutinefunction(func):
-            raise ValueError("Commands must be coroutines")
-
-        perm = default_member_permissions
-        if hasattr(func, "default_member_permissions"):
-            if perm:
-                perm = perm | func.default_member_permissions
-            else:
-                perm = func.default_member_permissions
-
-        _name = name
-        if _name is MISSING:
-            _name = func.__name__
-
-        cmd = ContextMenu(
-            name=_name,
-            type=context_type,
-            scopes=scopes or [GLOBAL_SCOPE],
-            default_member_permissions=perm,
-            dm_permission=dm_permission,
-            callback=func,
-        )
-        return cmd
-
-    return wrapper
-
-
-def user_context_menu(
-    name: Absent[str | LocalisedName] = MISSING,
-    *,
-    scopes: Absent[List["Snowflake_Type"]] = MISSING,
-    default_member_permissions: Optional["Permissions"] = None,
-    dm_permission: bool = True,
-) -> Callable[[AsyncCallable], ContextMenu]:
-    """
-    A decorator to declare a coroutine as a User Context Menu.
-
-    Args:
-        name: 1-32 character name of the context menu, defaults to the name of the coroutine.
-        scopes: The scope this command exists within
-        default_member_permissions: What permissions members need to have by default to use this command.
-        dm_permission: Should this command be available in DMs.
-
-    Returns:
-        ContextMenu object
-
-    """
-    return context_menu(
-        name,
-        context_type=CommandType.USER,
-        scopes=scopes,
-        default_member_permissions=default_member_permissions,
-        dm_permission=dm_permission,
-    )
-
-
-def message_context_menu(
-    name: Absent[str | LocalisedName] = MISSING,
-    *,
-    scopes: Absent[List["Snowflake_Type"]] = MISSING,
-    default_member_permissions: Optional["Permissions"] = None,
-    dm_permission: bool = True,
-) -> Callable[[AsyncCallable], ContextMenu]:
-    """
-    A decorator to declare a coroutine as a Message Context Menu.
-
-    Args:
-        name: 1-32 character name of the context menu, defaults to the name of the coroutine.
-        scopes: The scope this command exists within
-        default_member_permissions: What permissions members need to have by default to use this command.
-        dm_permission: Should this command be available in DMs.
-
-    Returns:
-        ContextMenu object
-
-    """
-    return context_menu(
-        name,
-        context_type=CommandType.MESSAGE,
-        scopes=scopes,
-        default_member_permissions=default_member_permissions,
-        dm_permission=dm_permission,
-    )
-
-
-def component_callback(*custom_id: str | re.Pattern) -> Callable[[AsyncCallable], ComponentCommand]:
-    """
-    Register a coroutine as a component callback.
-
-    Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages.
-    Your callback will be given a single argument, `ComponentContext`
-
-    Note:
-        This can optionally take a regex pattern, which will be used to match against the custom ID of the component
-
-    Args:
-        *custom_id: The custom ID of the component to wait for
-
-    """
-
-    def wrapper(func: AsyncCallable) -> ComponentCommand:
-        if not asyncio.iscoroutinefunction(func):
-            raise ValueError("Commands must be coroutines")
-
-        return ComponentCommand(name=f"ComponentCallback::{custom_id}", callback=func, listeners=custom_id)
-
-    custom_id = _unpack_helper(custom_id)
-    custom_ids_validator(*custom_id)
-    return wrapper
-
-
-def modal_callback(*custom_id: str | re.Pattern) -> Callable[[AsyncCallable], ModalCommand]:
-    """
-    Register a coroutine as a modal callback.
-
-    Modal callbacks work the same way as commands, just using modals as a way of invoking, instead of messages.
-    Your callback will be given a single argument, `ModalContext`
-
-    Note:
-        This can optionally take a regex pattern, which will be used to match against the custom ID of the modal
-
-
-    Args:
-        *custom_id: The custom ID of the modal to wait for
-    """
-
-    def wrapper(func: AsyncCallable) -> ModalCommand:
-        if not asyncio.iscoroutinefunction(func):
-            raise ValueError("Commands must be coroutines")
-
-        return ModalCommand(name=f"ModalCallback::{custom_id}", callback=func, listeners=custom_id)
-
-    custom_id = _unpack_helper(custom_id)
-    custom_ids_validator(*custom_id)
-    return wrapper
-
-
-InterCommandT = TypeVar("InterCommandT", InteractionCommand, AsyncCallable)
-SlashCommandT = TypeVar("SlashCommandT", SlashCommand, AsyncCallable)
-
-
-def slash_option(
-    name: str,
-    description: str,
-    opt_type: Union[OptionType, int],
-    required: bool = False,
-    autocomplete: bool = False,
-    choices: List[Union[SlashCommandChoice, dict]] = None,
-    channel_types: Optional[list[Union[ChannelType, int]]] = None,
-    min_value: Optional[float] = None,
-    max_value: Optional[float] = None,
-    min_length: Optional[int] = None,
-    max_length: Optional[int] = None,
-) -> Callable[[SlashCommandT], SlashCommandT]:
-    r"""
-    A decorator to add an option to a slash command.
-
-    Args:
-        name: 1-32 lowercase character name matching ^[\w-]{1,32}$
-        opt_type: The type of option
-        description: 1-100 character description of option
-        required: If the parameter is required or optional--default false
-        autocomplete: If autocomplete interactions are enabled for this STRING, INTEGER, or NUMBER type option
-        choices: A list of choices the user has to pick between (max 25)
-        channel_types: The channel types permitted. The option needs to be a channel
-        min_value: The minimum value permitted. The option needs to be an integer or float
-        max_value: The maximum value permitted. The option needs to be an integer or float
-        min_length: The minimum length of text a user can input. The option needs to be a string
-        max_length: The maximum length of text a user can input. The option needs to be a string
-    """
-
-    def wrapper(func: SlashCommandT) -> SlashCommandT:
-        if hasattr(func, "cmd_id"):
-            raise ValueError("slash_option decorators must be positioned under a slash_command decorator")
-
-        option = SlashCommandOption(
-            name=name,
-            type=opt_type,
-            description=description,
-            required=required,
-            autocomplete=autocomplete,
-            choices=choices or [],
-            channel_types=channel_types,
-            min_value=min_value,
-            max_value=max_value,
-            min_length=min_length,
-            max_length=max_length,
-        )
-        if not hasattr(func, "options"):
-            func.options = []
-        func.options.insert(0, option)
-        return func
-
-    return wrapper
-
-
-def slash_default_member_permission(
-    permission: "Permissions",
-) -> Callable[[SlashCommandT], SlashCommandT]:
-    """
-    A decorator to permissions members need to have by default to use a command.
-
-    Args:
-        permission: The permissions to require for to this command
-
-    """
-
-    def wrapper(func: SlashCommandT) -> SlashCommandT:
-        if hasattr(func, "cmd_id"):
-            raise ValueError(
-                "slash_default_member_permission decorators must be positioned under a slash_command decorator"
-            )
-
-        if not hasattr(func, "default_member_permissions") or func.default_member_permissions is None:
-            func.default_member_permissions = permission
-        else:
-            func.default_member_permissions = func.default_member_permissions | permission
-        return func
-
-    return wrapper
-
-
-def auto_defer(
-    enabled: bool = True, ephemeral: bool = False, time_until_defer: float = 0.0
-) -> Callable[[InterCommandT], InterCommandT]:
-    """
-    A decorator to add an auto defer to a application command.
-
-    Args:
-        enabled: Should the command be deferred automatically
-        ephemeral: Should the command be deferred as ephemeral
-        time_until_defer: How long to wait before deferring automatically
-
-    """
-
-    def wrapper(func: InterCommandT) -> InterCommandT:
-        if hasattr(func, "cmd_id"):
-            raise ValueError("auto_defer decorators must be positioned under a slash_command decorator")
-        func.auto_defer = AutoDefer(enabled=enabled, ephemeral=ephemeral, time_until_defer=time_until_defer)
-        return func
-
-    return wrapper
-
-
-def application_commands_to_dict(  # noqa: C901
-    commands: Dict["Snowflake_Type", Dict[str, InteractionCommand]], client: "Client"
-) -> dict:
-    """
-    Convert the command list into a format that would be accepted by discord.
-
-    `Client.interactions` should be the variable passed to this
-
-    """
-    cmd_bases = {}  # {cmd_base: [commands]}
-    """A store of commands organised by their base command"""
-    output = {}
-    """The output dictionary"""
-
-    def squash_subcommand(subcommands: List) -> Dict:
-        output_data = {}
-        groups = {}
-        sub_cmds = []
-        for subcommand in subcommands:
-            if not output_data:
-                output_data = {
-                    "name": str(subcommand.name),
-                    "description": str(subcommand.description),
-                    "options": [],
-                    "default_member_permissions": str(int(subcommand.default_member_permissions))
-                    if subcommand.default_member_permissions
-                    else None,
-                    "dm_permission": subcommand.dm_permission,
-                    "name_localizations": subcommand.name.to_locale_dict(),
-                    "description_localizations": subcommand.description.to_locale_dict(),
-                    "nsfw": subcommand.nsfw,
-                }
-            if bool(subcommand.group_name):
-                if str(subcommand.group_name) not in groups:
-                    groups[str(subcommand.group_name)] = {
-                        "name": str(subcommand.group_name),
-                        "description": str(subcommand.group_description),
-                        "type": int(OptionType.SUB_COMMAND_GROUP),
-                        "options": [],
-                        "name_localizations": subcommand.group_name.to_locale_dict(),
-                        "description_localizations": subcommand.group_description.to_locale_dict(),
-                    }
-                groups[str(subcommand.group_name)]["options"].append(
-                    subcommand.to_dict() | {"type": int(OptionType.SUB_COMMAND)}
-                )
-            elif subcommand.is_subcommand:
-                sub_cmds.append(subcommand.to_dict() | {"type": int(OptionType.SUB_COMMAND)})
-        options = list(groups.values()) + sub_cmds
-        output_data["options"] = options
-        return output_data
-
-    for _scope, cmds in commands.items():
-        for cmd in cmds.values():
-            cmd_name = str(cmd.name)
-            if cmd_name not in cmd_bases:
-                cmd_bases[cmd_name] = [cmd]
-                continue
-            if cmd not in cmd_bases[cmd_name]:
-                cmd_bases[cmd_name].append(cmd)
-
-    for cmd_list in cmd_bases.values():
-        if any(c.is_subcommand for c in cmd_list):
-            # validate all commands share required attributes
-            scopes: list[Snowflake_Type] = list({s for c in cmd_list for s in c.scopes})
-            base_description = next(
-                (
-                    c.description
-                    for c in cmd_list
-                    if str(c.description) is not None and str(c.description) != "No Description Set"
-                ),
-                "No Description Set",
-            )
-            nsfw = cmd_list[0].nsfw
-
-            if any(str(c.description) not in (str(base_description), "No Description Set") for c in cmd_list):
-                client.logger.warning(
-                    f"Conflicting descriptions found in `{cmd_list[0].name}` subcommands; `{str(base_description)}` will be used"
-                )
-            if any(c.default_member_permissions != cmd_list[0].default_member_permissions for c in cmd_list):
-                raise ValueError(f"Conflicting `default_member_permissions` values found in `{cmd_list[0].name}`")
-            if any(c.dm_permission != cmd_list[0].dm_permission for c in cmd_list):
-                raise ValueError(f"Conflicting `dm_permission` values found in `{cmd_list[0].name}`")
-            if any(c.nsfw != nsfw for c in cmd_list):
-                client.logger.warning(f"Conflicting `nsfw` values found in {cmd_list[0].name} - `True` will be used")
-                nsfw = True
-
-            for cmd in cmd_list:
-                cmd.scopes = list(scopes)
-                cmd.description = base_description
-                cmd.nsfw = nsfw
-            # end validation of attributes
-            cmd_data = squash_subcommand(cmd_list)
-        else:
-            scopes = cmd_list[0].scopes
-            cmd_data = cmd_list[0].to_dict()
-        for s in scopes:
-            if s not in output:
-                output[s] = [cmd_data]
-                continue
-            output[s].append(cmd_data)
-    return output
-
-
-def _compare_commands(local_cmd: dict, remote_cmd: dict) -> bool:
-    """
-    Compares remote and local commands
-
-    Args:
-        local_cmd: The local command
-        remote_cmd: The remote command from discord
-
-    Returns:
-        True if the commands are the same
-    """
-    lookup: dict[str, tuple[str, any]] = {
-        "name": ("name", ""),
-        "description": ("description", ""),
-        "default_member_permissions": ("default_member_permissions", None),
-        "dm_permission": ("dm_permission", True),
-        "name_localized": ("name_localizations", None),
-        "description_localized": ("description_localizations", None),
-    }
-    if remote_cmd.get("guild_id"):
-        # non-global command
-        del lookup["dm_permission"]
-
-    for local_name, comparison_data in lookup.items():
-        remote_name, default_value = comparison_data
-        if local_cmd.get(local_name, default_value) != remote_cmd.get(remote_name, default_value):
-            return False
-    return True
-
-
-def _compare_options(local_opt_list: dict, remote_opt_list: dict) -> bool:
-    if local_opt_list != remote_opt_list:
-        post_process: Dict[str, Callable] = {
-            "choices": lambda l10n: [d | {"name_localizations": {}} if len(d) == 2 else d for d in l10n],
-        }
-
-        if len(local_opt_list) != len(remote_opt_list):
-            return False
-        options_lookup: dict[str, tuple[str, any]] = {
-            "name": ("name", ""),
-            "description": ("description", ""),
-            "required": ("required", False),
-            "autocomplete": ("autocomplete", False),
-            "name_localized": ("name_localizations", None),
-            "description_localized": ("description_localizations", None),
-            "channel_types": ("channel_types", None),
-            "choices": ("choices", []),
-            "max_value": ("max_value", None),
-            "min_value": ("min_value", None),
-            "max_length": ("max_length", None),
-            "min_length": ("min_length", None),
-        }
-        for i in range(len(local_opt_list)):
-            local_option = local_opt_list[i]
-            remote_option = remote_opt_list[i]
-
-            if local_option["type"] != remote_option["type"]:
-                return False
-            if local_option["type"] in (OptionType.SUB_COMMAND_GROUP, OptionType.SUB_COMMAND):
-                if not _compare_commands(local_option, remote_option) or not _compare_options(
-                    local_option.get("options", []), remote_option.get("options", [])
-                ):
-                    return False
-            else:
-                for local_name, comparison_data in options_lookup.items():
-                    remote_name, default_value = comparison_data
-                    if local_option.get(local_name, default_value) != post_process.get(remote_name, lambda name: name)(
-                        remote_option.get(remote_name, default_value)
-                    ):
-                        return False
-
-    return True
-
-
-def sync_needed(local_cmd: dict, remote_cmd: Optional[dict] = None) -> bool:
-    """
-    Compares a local application command to its remote counterpart to determine if a sync is required.
-
-    Args:
-        local_cmd: The local json representation of the command
-        remote_cmd: The json representation of the command from Discord
-
-    Returns:
-        Boolean indicating if a sync is needed
-    """
-    if not remote_cmd:
-        # No remote version, command must be new
-        return True
-
-    if not _compare_commands(local_cmd, remote_cmd):
-        # basic comparison of attributes
-        return True
-
-    if remote_cmd["type"] == CommandType.CHAT_INPUT:
-        try:
-            if not _compare_options(local_cmd["options"], remote_cmd["options"]):
-                # options are not the same, sync needed
-                return True
-        except KeyError:
-            if "options" in local_cmd or "options" in remote_cmd:
-                return True
-
-    return False
+import asyncio
+import inspect
+import re
+import typing
+import types
+import functools
+from enum import IntEnum
+from typing import (
+    TYPE_CHECKING,
+    Annotated,
+    Callable,
+    Coroutine,
+    Dict,
+    List,
+    Union,
+    Optional,
+    Any,
+    TypeVar,
+)
+
+import attrs
+from attr import Attribute
+
+import interactions.models.discord.channel as channel
+from interactions.client.const import (
+    GLOBAL_SCOPE,
+    SLASH_CMD_NAME_LENGTH,
+    SLASH_CMD_MAX_OPTIONS,
+    SLASH_CMD_MAX_DESC_LENGTH,
+    MISSING,
+    Absent,
+    AsyncCallable,
+)
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils import optional
+from interactions.client.utils.attr_utils import attrs_validator, docs
+from interactions.client.utils.misc_utils import get_parameters, maybe_coroutine
+from interactions.client.utils.serializer import no_export_meta
+from interactions.models.discord.enums import ChannelType, CommandType, Permissions
+from interactions.models.discord.role import Role
+from interactions.models.discord.snowflake import to_snowflake_list, to_snowflake
+from interactions.models.discord.user import BaseUser
+from interactions.models.internal.auto_defer import AutoDefer
+from interactions.models.internal.callback import CallbackObject
+from interactions.models.internal.command import BaseCommand
+from interactions.models.internal.localisation import LocalisedField
+from interactions.models.internal.protocols import Converter
+
+if TYPE_CHECKING:
+    from interactions.models.discord.snowflake import Snowflake_Type
+    from interactions.models.internal.context import BaseContext, InteractionContext
+    from interactions import Client
+
+__all__ = (
+    "application_commands_to_dict",
+    "auto_defer",
+    "CallbackType",
+    "component_callback",
+    "ComponentCommand",
+    "context_menu",
+    "user_context_menu",
+    "message_context_menu",
+    "ContextMenu",
+    "global_autocomplete",
+    "GlobalAutoComplete",
+    "InteractionCommand",
+    "LocalisedDesc",
+    "LocalisedName",
+    "LocalizedDesc",
+    "LocalizedName",
+    "modal_callback",
+    "ModalCommand",
+    "OptionType",
+    "slash_command",
+    "slash_default_member_permission",
+    "slash_option",
+    "SlashCommand",
+    "SlashCommandChoice",
+    "SlashCommandOption",
+    "SlashCommandParameter",
+    "subcommand",
+    "sync_needed",
+)
+
+
+def name_validator(_: Any, attr: Attribute, value: str) -> None:
+    if value:
+        if not re.match(f"^[\\w-]{{1,{SLASH_CMD_NAME_LENGTH}}}$", value) or value != value.lower():
+            raise ValueError(
+                f"Slash Command names must be lower case and match this regex: ^[\\w-]{1, {SLASH_CMD_NAME_LENGTH} }$"
+            )
+
+
+def desc_validator(_: Any, attr: Attribute, value: str) -> None:
+    if value and not 1 <= len(value) <= SLASH_CMD_MAX_DESC_LENGTH:
+        raise ValueError(f"Description must be between 1 and {SLASH_CMD_MAX_DESC_LENGTH} characters long")
+
+
+def custom_ids_validator(*custom_id: str | re.Pattern) -> None:
+    if not (all(isinstance(i, re.Pattern) for i in custom_id) or all(isinstance(i, str) for i in custom_id)):
+        raise ValueError("All custom IDs be either a string or a regex pattern, not a mix of both.")
+
+
+@attrs.define(
+    eq=False,
+    order=False,
+    hash=False,
+    field_transformer=attrs_validator(name_validator, skip_fields=["default_locale"]),
+)
+class LocalisedName(LocalisedField):
+    """A localisation object for names."""
+
+    def __repr__(self) -> str:
+        return super().__repr__()
+
+
+@attrs.define(
+    eq=False,
+    order=False,
+    hash=False,
+    field_transformer=attrs_validator(desc_validator, skip_fields=["default_locale"]),
+)
+class LocalisedDesc(LocalisedField):
+    """A localisation object for descriptions."""
+
+    def __repr__(self) -> str:
+        return super().__repr__()
+
+
+LocalizedName = LocalisedName
+LocalizedDesc = LocalisedDesc
+
+
+class OptionType(IntEnum):
+    """Option types supported by slash commands."""
+
+    SUB_COMMAND = 1
+    SUB_COMMAND_GROUP = 2
+    STRING = 3
+    INTEGER = 4
+    BOOLEAN = 5
+    USER = 6
+    CHANNEL = 7
+    ROLE = 8
+    MENTIONABLE = 9
+    NUMBER = 10
+    ATTACHMENT = 11
+
+    @classmethod
+    def resolvable_types(cls) -> tuple["OptionType", ...]:
+        """A tuple of all resolvable types."""
+        return cls.USER, cls.CHANNEL, cls.ROLE, cls.MENTIONABLE, cls.ATTACHMENT
+
+    @classmethod
+    def static_types(cls) -> tuple["OptionType", ...]:
+        """A tuple of all static types."""
+        return cls.STRING, cls.INTEGER, cls.BOOLEAN, cls.NUMBER
+
+    @classmethod
+    def command_types(cls) -> tuple["OptionType", ...]:
+        """A tuple of all command types."""
+        return cls.SUB_COMMAND, cls.SUB_COMMAND_GROUP
+
+    @classmethod
+    def from_type(cls, t: type) -> "OptionType | None":
+        """
+        Convert data types to their corresponding OptionType.
+
+        Args:
+            t: The datatype to convert
+
+        Returns:
+            OptionType or None
+
+        """
+        if issubclass(t, str):
+            return cls.STRING
+        if issubclass(t, int):
+            return cls.INTEGER
+        if issubclass(t, bool):
+            return cls.BOOLEAN
+        if issubclass(t, BaseUser):
+            return cls.USER
+        if issubclass(t, channel.BaseChannel):
+            return cls.CHANNEL
+        if issubclass(t, Role):
+            return cls.ROLE
+        if issubclass(t, float):
+            return cls.NUMBER
+
+
+class CallbackType(IntEnum):
+    """Types of callback supported by interaction response."""
+
+    PONG = 1
+    CHANNEL_MESSAGE_WITH_SOURCE = 4
+    DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE = 5
+    DEFERRED_UPDATE_MESSAGE = 6
+    UPDATE_MESSAGE = 7
+    AUTOCOMPLETE_RESULT = 8
+    MODAL = 9
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class InteractionCommand(BaseCommand):
+    """
+    Represents a discord abstract interaction command.
+
+    Attributes:
+        scope: Denotes whether its global or for specific guild.
+        default_member_permissions: What permissions members need to have by default to use this command.
+        dm_permission: Should this command be available in DMs.
+        cmd_id: The id of this command given by discord.
+        callback: The coroutine to callback when this interaction is received.
+
+    """
+
+    name: LocalisedName | str = attrs.field(
+        repr=False,
+        metadata=docs("1-32 character name") | no_export_meta,
+        converter=LocalisedName.converter,
+    )
+    scopes: List["Snowflake_Type"] = attrs.field(
+        default=[GLOBAL_SCOPE],
+        converter=to_snowflake_list,
+        metadata=docs("The scopes of this interaction. Global or guild ids") | no_export_meta,
+    )
+    default_member_permissions: Optional["Permissions"] = attrs.field(
+        repr=False,
+        default=None,
+        metadata=docs("What permissions members need to have by default to use this command"),
+    )
+    dm_permission: bool = attrs.field(repr=False, default=True, metadata=docs("Whether this command is enabled in DMs"))
+    cmd_id: Dict[str, "Snowflake_Type"] = attrs.field(
+        repr=False, factory=dict, metadata=docs("The unique IDs of this commands") | no_export_meta
+    )  # scope: cmd_id
+    callback: Callable[..., Coroutine] = attrs.field(
+        repr=False,
+        default=None,
+        metadata=docs("The coroutine to call when this interaction is received") | no_export_meta,
+    )
+    auto_defer: "AutoDefer" = attrs.field(
+        default=MISSING,
+        metadata=docs("A system to automatically defer this command after a set duration") | no_export_meta,
+    )
+    nsfw: bool = attrs.field(repr=False, default=False, metadata=docs("This command should only work in NSFW channels"))
+    _application_id: "Snowflake_Type" = attrs.field(repr=False, default=None, converter=optional(to_snowflake))
+
+    def __attrs_post_init__(self) -> None:
+        if self.callback is not None and hasattr(self.callback, "auto_defer"):
+            self.auto_defer = self.callback.auto_defer
+
+        super().__attrs_post_init__()
+
+    def to_dict(self) -> dict:
+        data = super().to_dict()
+
+        if self.default_member_permissions is not None:
+            data["default_member_permissions"] = str(int(self.default_member_permissions))
+        else:
+            data["default_member_permissions"] = None
+
+        return data
+
+    def mention(self, scope: Optional["Snowflake_Type"] = None) -> str:
+        """
+        Returns a string that would mention the interaction.
+
+        Args:
+            scope: If the command is available in multiple scope, specify which scope to get the mention for. Defaults to the first available one if not specified.
+
+        Returns:
+            The markdown mention.
+        """
+        if scope:
+            cmd_id = self.get_cmd_id(scope=scope)
+        else:
+            cmd_id = list(self.cmd_id.values())[0]
+
+        return f"</{self.resolved_name}:{cmd_id}>"
+
+    @property
+    def resolved_name(self) -> str:
+        """A representation of this interaction's name."""
+        return str(self.name)
+
+    def get_localised_name(self, locale: str) -> str:
+        return self.name.get_locale(locale)
+
+    def get_cmd_id(self, scope: "Snowflake_Type") -> "Snowflake_Type":
+        return self.cmd_id.get(scope, self.cmd_id.get(GLOBAL_SCOPE, None))
+
+    @property
+    def is_subcommand(self) -> bool:
+        return False
+
+    async def _permission_enforcer(self, ctx: "BaseContext") -> bool:
+        """A check that enforces Discord permissions."""
+        # I wish this wasn't needed, but unfortunately Discord permissions cant be trusted to actually prevent usage
+        return ctx.guild is not None if self.dm_permission is False else True
+
+    def is_enabled(self, ctx: "BaseContext") -> bool:
+        """
+        Check if this command is enabled in the given context.
+
+        Args:
+            ctx: The context to check.
+
+        Returns:
+            Whether this command is enabled in the given context.
+        """
+        if not self.dm_permission and ctx.guild is None:
+            return False
+        if self.dm_permission and ctx.guild is None:
+            # remaining checks are impossible if this is a DM and DMs are enabled
+            return True
+
+        if self.nsfw and not ctx.channel.is_nsfw():
+            return False
+        if cmd_perms := ctx.guild.command_permissions.get(self.get_cmd_id(ctx.guild.id)):
+            if not cmd_perms.is_enabled_in_context(ctx):
+                return False
+        if self.default_member_permissions is not None:
+            channel_perms = ctx.author.channel_permissions(ctx.channel)
+            if any(perm not in channel_perms for perm in self.default_member_permissions):
+                return False
+        return True
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ContextMenu(InteractionCommand):
+    """
+    Represents a discord context menu.
+
+    Attributes:
+        name: The name of this entry.
+        type: The type of entry (user or message).
+
+    """
+
+    name: LocalisedField = attrs.field(
+        repr=False, metadata=docs("1-32 character name"), converter=LocalisedField.converter
+    )
+    type: CommandType = attrs.field(repr=False, metadata=docs("The type of command, defaults to 1 if not specified"))
+
+    @type.validator
+    def _type_validator(self, attribute: str, value: int) -> None:
+        if not isinstance(value, CommandType):
+            if value not in CommandType.__members__.values():
+                raise ValueError("Context Menu type not recognised, please consult the docs.")
+        elif value == CommandType.CHAT_INPUT:
+            raise ValueError(
+                "The CHAT_INPUT type is basically slash commands. Please use the @slash_command() " "decorator instead."
+            )
+
+    def to_dict(self) -> dict:
+        data = super().to_dict()
+
+        data["name"] = str(self.name)
+        return data
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class SlashCommandChoice(DictSerializationMixin):
+    """
+    Represents a discord slash command choice.
+
+    Attributes:
+        name: The name the user will see
+        value: The data sent to your code when this choice is used
+
+    """
+
+    name: LocalisedField | str = attrs.field(repr=False, converter=LocalisedField.converter)
+    value: Union[str, int, float] = attrs.field(
+        repr=False,
+    )
+
+    def as_dict(self) -> dict:
+        return {
+            "name": str(self.name),
+            "value": self.value,
+            "name_localizations": self.name.to_locale_dict(),
+        }
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=False)
+class SlashCommandOption(DictSerializationMixin):
+    """
+    Represents a discord slash command option.
+
+    Attributes:
+        name: The name of this option
+        type: The type of option
+        description: The description of this option
+        required: "This option must be filled to use the command"
+        choices: A list of choices the user has to pick between
+        channel_types: The channel types permitted. The option needs to be a channel
+        min_value: The minimum value permitted. The option needs to be an integer or float
+        max_value: The maximum value permitted. The option needs to be an integer or float
+        min_length: The minimum length of text a user can input. The option needs to be a string
+        max_length: The maximum length of text a user can input. The option needs to be a string
+
+    """
+
+    name: LocalisedName | str = attrs.field(repr=False, converter=LocalisedName.converter)
+    type: Union[OptionType, int] = attrs.field(
+        repr=False,
+    )
+    description: LocalisedDesc | str | str = attrs.field(
+        repr=False, default="No Description Set", converter=LocalisedDesc.converter
+    )
+    required: bool = attrs.field(repr=False, default=True)
+    autocomplete: bool = attrs.field(repr=False, default=False)
+    choices: List[Union[SlashCommandChoice, Dict]] = attrs.field(repr=False, factory=list)
+    channel_types: Optional[list[Union[ChannelType, int]]] = attrs.field(repr=False, default=None)
+    min_value: Optional[float] = attrs.field(repr=False, default=None)
+    max_value: Optional[float] = attrs.field(repr=False, default=None)
+    min_length: Optional[int] = attrs.field(repr=False, default=None)
+    max_length: Optional[int] = attrs.field(repr=False, default=None)
+
+    @type.validator
+    def _type_validator(self, attribute: str, value: int) -> None:
+        if value in (OptionType.SUB_COMMAND, OptionType.SUB_COMMAND_GROUP):
+            raise ValueError(
+                "Options cannot be SUB_COMMAND or SUB_COMMAND_GROUP. If you want to use subcommands, "
+                "see the @sub_command() decorator."
+            )
+
+    @channel_types.validator
+    def _channel_types_validator(self, attribute: str, value: Optional[list[OptionType]]) -> None:
+        if value is not None:
+            if self.type != OptionType.CHANNEL:
+                raise ValueError("The option needs to be CHANNEL to use this")
+
+            allowed_int = [channel_type.value for channel_type in ChannelType]
+            for item in value:
+                if (item not in allowed_int) and (item not in ChannelType):
+                    raise ValueError(f"{value} is not allowed here")
+
+    @min_value.validator
+    def _min_value_validator(self, attribute: str, value: Optional[float]) -> None:
+        if value is not None:
+            if self.type not in [OptionType.INTEGER, OptionType.NUMBER]:
+                raise ValueError("`min_value` can only be supplied with int or float options")
+
+            if self.type == OptionType.INTEGER and isinstance(value, float):
+                raise ValueError("`min_value` needs to be an int in an int option")
+
+            if self.max_value is not None and self.min_value is not None and self.max_value < self.min_value:
+                raise ValueError("`min_value` needs to be <= than `max_value`")
+
+    @max_value.validator
+    def _max_value_validator(self, attribute: str, value: Optional[float]) -> None:
+        if value is not None:
+            if self.type not in (OptionType.INTEGER, OptionType.NUMBER):
+                raise ValueError("`max_value` can only be supplied with int or float options")
+
+            if self.type == OptionType.INTEGER and isinstance(value, float):
+                raise ValueError("`max_value` needs to be an int in an int option")
+
+            if self.max_value and self.min_value and self.max_value < self.min_value:
+                raise ValueError("`min_value` needs to be <= than `max_value`")
+
+    @min_length.validator
+    def _min_length_validator(self, attribute: str, value: Optional[int]) -> None:
+        if value is not None:
+            if self.type != OptionType.STRING:
+                raise ValueError("`min_length` can only be supplied with string options")
+
+            if self.max_length is not None and self.min_length is not None and self.max_length < self.min_length:
+                raise ValueError("`min_length` needs to be <= than `max_length`")
+
+            if self.min_length < 0:
+                raise ValueError("`min_length` needs to be >= 0")
+
+    @max_length.validator
+    def _max_length_validator(self, attribute: str, value: Optional[int]) -> None:
+        if value is not None:
+            if self.type != OptionType.STRING:
+                raise ValueError("`max_length` can only be supplied with string options")
+
+            if self.min_length is not None and self.max_length is not None and self.max_length < self.min_length:
+                raise ValueError("`min_length` needs to be <= than `max_length`")
+
+            if self.max_length < 1:
+                raise ValueError("`max_length` needs to be >= 1")
+
+    def as_dict(self) -> dict:
+        data = attrs.asdict(self)
+        data["name"] = str(self.name)
+        data["description"] = str(self.description)
+        data["choices"] = [
+            choice.as_dict() if isinstance(choice, SlashCommandChoice) else choice for choice in self.choices
+        ]
+        data["name_localizations"] = self.name.to_locale_dict()
+        data["description_localizations"] = self.description.to_locale_dict()
+
+        return data
+
+
+@attrs.define()
+class SlashCommandParameter:
+    name: str = attrs.field()
+    type: typing.Any = attrs.field()
+    kind: inspect._ParameterKind = attrs.field()
+    default: typing.Any = attrs.field(default=MISSING)
+    converter: typing.Optional[typing.Callable] = attrs.field(default=None)
+
+
+def _get_option_from_annotated(annotated: Annotated) -> SlashCommandOption | None:
+    args = typing.get_args(annotated)
+    return next((a for a in args if isinstance(a, SlashCommandOption)), None)
+
+
+def _get_converter_from_annotated(annotated: Annotated) -> Converter | None:
+    args = typing.get_args(annotated)
+    return next((a for a in args if isinstance(a, Converter)), None)
+
+
+def _is_union(anno: typing.Any) -> bool:
+    return typing.get_origin(anno) in {Union, types.UnionType}
+
+
+def _is_optional(anno: typing.Any) -> bool:
+    return _is_union(anno) and types.NoneType in typing.get_args(anno)
+
+
+def _remove_optional(t: OptionType | type) -> Any:
+    non_optional_args: tuple[type] = tuple(a for a in typing.get_args(t) if a is not types.NoneType)  # noqa
+    if len(non_optional_args) == 1:
+        return non_optional_args[0]
+    return typing.Union[non_optional_args]  # type: ignore
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class SlashCommand(InteractionCommand):
+    name: LocalisedName | str = attrs.field(repr=False, converter=LocalisedName.converter)
+    description: LocalisedDesc | str = attrs.field(
+        repr=False, default="No Description Set", converter=LocalisedDesc.converter
+    )
+
+    group_name: LocalisedName | str = attrs.field(
+        repr=False, default=None, metadata=no_export_meta, converter=LocalisedName.converter
+    )
+    group_description: LocalisedDesc | str = attrs.field(
+        repr=False,
+        default="No Description Set",
+        metadata=no_export_meta,
+        converter=LocalisedDesc.converter,
+    )
+
+    sub_cmd_name: LocalisedName | str = attrs.field(
+        repr=False, default=None, metadata=no_export_meta, converter=LocalisedName.converter
+    )
+    sub_cmd_description: LocalisedDesc | str = attrs.field(
+        repr=False,
+        default="No Description Set",
+        metadata=no_export_meta,
+        converter=LocalisedDesc.converter,
+    )
+
+    options: List[Union[SlashCommandOption, Dict]] = attrs.field(repr=False, factory=list)
+    autocomplete_callbacks: dict = attrs.field(repr=False, factory=dict, metadata=no_export_meta)
+
+    parameters: dict[str, SlashCommandParameter] = attrs.field(
+        repr=False,
+        factory=dict,
+        metadata=no_export_meta,
+    )
+    _uses_arg: bool = attrs.field(repr=False, default=False, metadata=no_export_meta)
+
+    @property
+    def resolved_name(self) -> str:
+        return (
+            f"{self.name}"
+            f"{f' {self.group_name}' if bool(self.group_name) else ''}"
+            f"{f' {self.sub_cmd_name}' if bool(self.sub_cmd_name) else ''}"
+        )
+
+    def get_localised_name(self, locale: str) -> str:
+        return (
+            f"{self.name.get_locale(locale)}"
+            f"{f' {self.group_name.get_locale(locale)}' if bool(self.group_name) else ''}"
+            f"{f' {self.sub_cmd_name.get_locale(locale)}' if bool(self.sub_cmd_name) else ''}"
+        )
+
+    @property
+    def is_subcommand(self) -> bool:
+        return bool(self.sub_cmd_name)
+
+    def __attrs_post_init__(self) -> None:
+        if self.callback is not None and hasattr(self.callback, "options"):
+            if not self.options:
+                self.options = []
+            self.options += self.callback.options
+
+        super().__attrs_post_init__()
+
+    def _add_option_from_anno_method(self, name: str, option: SlashCommandOption) -> None:
+        if not self.options:
+            self.options = []
+
+        option.name = name
+        self.options.append(option)
+
+    def _parse_parameters(self) -> None:
+        """
+        Parses the parameters that this command has into a form i.py can use.
+
+        This is purposely separated like this to allow "lazy parsing" - parsing
+        as the command is added to a bot rather than being parsed immediately.
+        This allows variables like "self" to be filtered out, and is useful for
+        potential future additions.
+
+        For slash commands, it is also much faster than inspecting the parameters
+        each time the command is called.
+        It also allows for us to deal with the "annotation method", where users
+        put their options in the annotations itself.
+        """
+        if self.callback is None or self.parameters:
+            return
+
+        if self.has_binding:
+            callback = functools.partial(self.callback, None, None)
+        else:
+            callback = functools.partial(self.callback, None)
+
+        for param in get_parameters(callback).values():
+            if param.kind == inspect._ParameterKind.VAR_POSITIONAL:
+                self._uses_arg = True
+                continue
+
+            if param.kind == inspect._ParameterKind.VAR_KEYWORD:
+                # in case it was set before
+                # we prioritize **kwargs over *args
+                self._uses_arg = False
+                continue
+
+            our_param = SlashCommandParameter(param.name, param.annotation, param.kind)
+            our_param.default = param.default if param.default is not inspect._empty else MISSING
+
+            if param.annotation is not inspect._empty:
+                anno = param.annotation
+                converter = None
+
+                if _is_optional(anno):
+                    anno = _remove_optional(anno)
+
+                if isinstance(anno, SlashCommandOption):
+                    # annotation method, get option and add it in
+                    self._add_option_from_anno_method(param.name, anno)
+
+                if isinstance(anno, Converter):
+                    converter = anno
+                elif typing.get_origin(anno) == Annotated:
+                    if option := _get_option_from_annotated(anno):
+                        # also annotation method
+                        self._add_option_from_anno_method(param.name, option)
+
+                    converter = _get_converter_from_annotated(anno)
+
+                if converter:
+                    our_param.converter = self._get_converter_function(converter, our_param.name)
+
+            self.parameters[param.name] = our_param
+
+    def to_dict(self) -> dict:
+        data = super().to_dict()
+
+        if self.is_subcommand:
+            data["name"] = str(self.sub_cmd_name)
+            data["description"] = str(self.sub_cmd_description)
+            data["name_localizations"] = self.sub_cmd_name.to_locale_dict()
+            data["description_localizations"] = self.sub_cmd_description.to_locale_dict()
+            data.pop("default_member_permissions", None)
+            data.pop("dm_permission", None)
+            data.pop("nsfw", None)
+        else:
+            data["name_localizations"] = self.name.to_locale_dict()
+            data["description_localizations"] = self.description.to_locale_dict()
+        return data
+
+    @options.validator
+    def options_validator(self, attribute: str, value: List) -> None:
+        if value:
+            if not isinstance(value, list):
+                raise TypeError("Options attribute must be either None or a list of options")
+            if len(value) > SLASH_CMD_MAX_OPTIONS:
+                raise ValueError(f"Slash commands can only hold {SLASH_CMD_MAX_OPTIONS} options")
+            if value != sorted(
+                value,
+                key=lambda x: x.required if isinstance(x, SlashCommandOption) else x["required"],
+                reverse=True,
+            ):
+                raise ValueError("Required options must go before optional options")
+
+    def autocomplete(self, option_name: str) -> Callable[..., Coroutine]:
+        """A decorator to declare a coroutine as an option autocomplete."""
+
+        def wrapper(call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
+            if not asyncio.iscoroutinefunction(call):
+                raise TypeError("autocomplete must be coroutine")
+            self.autocomplete_callbacks[option_name] = call
+
+            if self.options:
+                # automatically set the option's autocomplete attribute to True
+                for opt in self.options:
+                    if isinstance(opt, dict) and str(opt["name"]) == option_name:
+                        opt["autocomplete"] = True
+                    elif isinstance(opt, SlashCommandOption) and str(opt.name) == option_name:
+                        opt.autocomplete = True
+
+            return call
+
+        option_name = option_name.lower()
+        return wrapper
+
+    def group(
+        self, name: str = None, description: str = "No Description Set", inherit_checks: bool = True
+    ) -> "SlashCommand":
+        return SlashCommand(
+            name=self.name,
+            description=self.description,
+            group_name=name,
+            group_description=description,
+            scopes=self.scopes,
+            default_member_permissions=self.default_member_permissions,
+            dm_permission=self.dm_permission,
+            checks=self.checks.copy() if inherit_checks else [],
+        )
+
+    def subcommand(
+        self,
+        sub_cmd_name: Absent[LocalisedName | str] = MISSING,
+        group_name: LocalisedName | str = None,
+        sub_cmd_description: Absent[LocalisedDesc | str] = MISSING,
+        group_description: Absent[LocalisedDesc | str] = MISSING,
+        options: List[Union[SlashCommandOption, Dict]] = None,
+        nsfw: bool = False,
+        inherit_checks: bool = True,
+    ) -> Callable[..., "SlashCommand"]:
+        def wrapper(call: Callable[..., Coroutine]) -> "SlashCommand":
+            nonlocal sub_cmd_name, sub_cmd_description
+
+            if not asyncio.iscoroutinefunction(call):
+                raise TypeError("Subcommand must be coroutine")
+
+            if sub_cmd_description is MISSING:
+                sub_cmd_description = call.__doc__ or "No Description Set"
+            if sub_cmd_name is MISSING:
+                sub_cmd_name = call.__name__
+
+            return SlashCommand(
+                name=self.name,
+                description=self.description,
+                group_name=group_name or self.group_name,
+                group_description=group_description or self.group_description,
+                sub_cmd_name=sub_cmd_name,
+                sub_cmd_description=sub_cmd_description,
+                default_member_permissions=self.default_member_permissions,
+                dm_permission=self.dm_permission,
+                options=options,
+                callback=call,
+                scopes=self.scopes,
+                nsfw=nsfw,
+                checks=self.checks.copy() if inherit_checks else [],
+            )
+
+        return wrapper
+
+    async def call_callback(self, callback: typing.Callable, ctx: "InteractionContext") -> None:
+        if not self.parameters:
+            if self._uses_arg:
+                return await self.call_with_binding(callback, ctx, *ctx.args)
+            return await self.call_with_binding(callback, ctx)
+
+        kwargs_copy = ctx.kwargs.copy()
+
+        new_args = []
+        new_kwargs = {}
+
+        for name, param in self.parameters.items():
+            value = kwargs_copy.pop(name, MISSING)
+            if value is MISSING:
+                continue
+
+            if converter := param.converter:
+                value = await maybe_coroutine(converter, ctx, value)
+
+            if param.kind == inspect.Parameter.POSITIONAL_ONLY:
+                new_args.append(value)
+            else:
+                new_kwargs[name] = value
+
+        # i do want to address one thing: what happens if you have both *args and **kwargs
+        # in your argument?
+        # i would say passing in values for both makes sense... but they're very likely
+        # going to overlap and cause issues and confusion
+        # for the sake of simplicty, i.py assumes kwargs takes priority over args
+        if kwargs_copy:
+            if self._uses_arg:
+                new_args.extend(kwargs_copy.values())
+            else:
+                new_kwargs |= kwargs_copy
+
+        return await self.call_with_binding(callback, ctx, *new_args, **new_kwargs)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ComponentCommand(InteractionCommand):
+    # right now this adds no extra functionality, but for future dev ive implemented it
+    name: str = attrs.field(
+        repr=False,
+    )
+    listeners: list[str | re.Pattern] = attrs.field(repr=False, factory=list)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class ModalCommand(ComponentCommand):
+    ...
+
+
+def _unpack_helper(iterable: typing.Iterable[str]) -> list[str]:
+    """
+    Unpacks all types of iterable into a list of strings. Primarily to flatten generators.
+
+    Args:
+        iterable: The iterable of strings to unpack
+
+    Returns:
+        A list of strings
+    """
+    unpack = []
+    for c in iterable:
+        if inspect.isgenerator(c):
+            unpack += list(c)
+        else:
+            unpack.append(c)
+    return unpack
+
+
+class GlobalAutoComplete(CallbackObject):
+    def __init__(self, option_name: str, callback: Callable) -> None:
+        self.callback = callback
+        self.option_name = option_name
+
+
+##############
+# Decorators #
+##############
+
+
+def global_autocomplete(option_name: str) -> Callable[[AsyncCallable], GlobalAutoComplete]:
+    """
+    Decorator for global autocomplete functions
+
+    Args:
+        option_name: The name of the option to register the autocomplete function for
+
+    Returns:
+        The decorator
+    """
+
+    def decorator(func: Callable) -> GlobalAutoComplete:
+        if not asyncio.iscoroutinefunction(func):
+            raise TypeError("Autocomplete functions must be coroutines")
+        return GlobalAutoComplete(option_name, func)
+
+    return decorator
+
+
+def slash_command(
+    name: Absent[str | LocalisedName] = MISSING,
+    *,
+    description: Absent[str | LocalisedDesc] = MISSING,
+    scopes: Absent[List["Snowflake_Type"]] = MISSING,
+    options: Optional[List[Union[SlashCommandOption, Dict]]] = None,
+    default_member_permissions: Optional["Permissions"] = None,
+    dm_permission: bool = True,
+    sub_cmd_name: str | LocalisedName = None,
+    group_name: str | LocalisedName = None,
+    sub_cmd_description: str | LocalisedDesc = "No Description Set",
+    group_description: str | LocalisedDesc = "No Description Set",
+    nsfw: bool = False,
+) -> Callable[[AsyncCallable], SlashCommand]:
+    """
+    A decorator to declare a coroutine as a slash command.
+
+    !!! note
+        While the base and group descriptions arent visible in the discord client, currently.
+        We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in
+        one of the future ui updates.
+
+    Args:
+        name: 1-32 character name of the command, defaults to the name of the coroutine.
+        description: 1-100 character description of the command
+        scopes: The scope this command exists within
+        options: The parameters for the command, max 25
+        default_member_permissions: What permissions members need to have by default to use this command.
+        dm_permission: Should this command be available in DMs.
+        sub_cmd_name: 1-32 character name of the subcommand
+        sub_cmd_description: 1-100 character description of the subcommand
+        group_name: 1-32 character name of the group
+        group_description: 1-100 character description of the group
+        nsfw: This command should only work in NSFW channels
+
+    Returns:
+        SlashCommand Object
+
+    """
+
+    def wrapper(func: AsyncCallable) -> SlashCommand:
+        if not asyncio.iscoroutinefunction(func):
+            raise ValueError("Commands must be coroutines")
+
+        perm = default_member_permissions
+        if hasattr(func, "default_member_permissions"):
+            if perm:
+                perm = perm | func.default_member_permissions
+            else:
+                perm = func.default_member_permissions
+
+        _name = name
+        if _name is MISSING:
+            _name = func.__name__
+
+        _description = description
+        if _description is MISSING:
+            _description = func.__doc__ or "No Description Set"
+
+        cmd = SlashCommand(
+            name=_name,
+            group_name=group_name,
+            group_description=group_description,
+            sub_cmd_name=sub_cmd_name,
+            sub_cmd_description=sub_cmd_description,
+            description=_description,
+            scopes=scopes or [GLOBAL_SCOPE],
+            default_member_permissions=perm,
+            dm_permission=dm_permission,
+            callback=func,
+            options=options,
+            nsfw=nsfw,
+        )
+
+        return cmd
+
+    return wrapper
+
+
+def subcommand(
+    base: str | LocalisedName,
+    *,
+    subcommand_group: Optional[str | LocalisedName] = None,
+    name: Absent[str | LocalisedName] = MISSING,
+    description: Absent[str | LocalisedDesc] = MISSING,
+    base_description: Optional[str | LocalisedDesc] = None,
+    base_desc: Optional[str | LocalisedDesc] = None,
+    base_default_member_permissions: Optional["Permissions"] = None,
+    base_dm_permission: bool = True,
+    subcommand_group_description: Optional[str | LocalisedDesc] = None,
+    sub_group_desc: Optional[str | LocalisedDesc] = None,
+    scopes: List["Snowflake_Type"] = None,
+    options: List[dict] = None,
+    nsfw: bool = False,
+) -> Callable[[AsyncCallable], SlashCommand]:
+    """
+    A decorator specifically tailored for creating subcommands.
+
+    Args:
+        base: The name of the base command
+        subcommand_group: The name of the subcommand group, if any.
+        name: The name of the subcommand, defaults to the name of the coroutine.
+        description: The description of the subcommand
+        base_description: The description of the base command
+        base_desc: An alias of `base_description`
+        base_default_member_permissions: What permissions members need to have by default to use this command.
+        base_dm_permission: Should this command be available in DMs.
+        subcommand_group_description: Description of the subcommand group
+        sub_group_desc: An alias for `subcommand_group_description`
+        scopes: The scopes of which this command is available, defaults to GLOBAL_SCOPE
+        options: The options for this command
+        nsfw: This command should only work in NSFW channels
+
+    Returns:
+        A SlashCommand object
+
+    """
+
+    def wrapper(func: AsyncCallable) -> SlashCommand:
+        if not asyncio.iscoroutinefunction(func):
+            raise ValueError("Commands must be coroutines")
+
+        _name = name
+        if _name is MISSING:
+            _name = func.__name__
+
+        _description = description
+        if _description is MISSING:
+            _description = func.__doc__ or "No Description Set"
+
+        cmd = SlashCommand(
+            name=base,
+            description=(base_description or base_desc) or "No Description Set",
+            group_name=subcommand_group,
+            group_description=(subcommand_group_description or sub_group_desc) or "No Description Set",
+            sub_cmd_name=_name,
+            sub_cmd_description=_description,
+            default_member_permissions=base_default_member_permissions,
+            dm_permission=base_dm_permission,
+            scopes=scopes or [GLOBAL_SCOPE],
+            callback=func,
+            options=options,
+            nsfw=nsfw,
+        )
+        return cmd
+
+    return wrapper
+
+
+def context_menu(
+    name: Absent[str | LocalisedName] = MISSING,
+    *,
+    context_type: "CommandType",
+    scopes: Absent[List["Snowflake_Type"]] = MISSING,
+    default_member_permissions: Optional["Permissions"] = None,
+    dm_permission: bool = True,
+) -> Callable[[AsyncCallable], ContextMenu]:
+    """
+    A decorator to declare a coroutine as a Context Menu.
+
+    Args:
+        name: 1-32 character name of the context menu, defaults to the name of the coroutine.
+        context_type: The type of context menu
+        scopes: The scope this command exists within
+        default_member_permissions: What permissions members need to have by default to use this command.
+        dm_permission: Should this command be available in DMs.
+
+    Returns:
+        ContextMenu object
+
+    """
+
+    def wrapper(func: AsyncCallable) -> ContextMenu:
+        if not asyncio.iscoroutinefunction(func):
+            raise ValueError("Commands must be coroutines")
+
+        perm = default_member_permissions
+        if hasattr(func, "default_member_permissions"):
+            if perm:
+                perm = perm | func.default_member_permissions
+            else:
+                perm = func.default_member_permissions
+
+        _name = name
+        if _name is MISSING:
+            _name = func.__name__
+
+        cmd = ContextMenu(
+            name=_name,
+            type=context_type,
+            scopes=scopes or [GLOBAL_SCOPE],
+            default_member_permissions=perm,
+            dm_permission=dm_permission,
+            callback=func,
+        )
+        return cmd
+
+    return wrapper
+
+
+def user_context_menu(
+    name: Absent[str | LocalisedName] = MISSING,
+    *,
+    scopes: Absent[List["Snowflake_Type"]] = MISSING,
+    default_member_permissions: Optional["Permissions"] = None,
+    dm_permission: bool = True,
+) -> Callable[[AsyncCallable], ContextMenu]:
+    """
+    A decorator to declare a coroutine as a User Context Menu.
+
+    Args:
+        name: 1-32 character name of the context menu, defaults to the name of the coroutine.
+        scopes: The scope this command exists within
+        default_member_permissions: What permissions members need to have by default to use this command.
+        dm_permission: Should this command be available in DMs.
+
+    Returns:
+        ContextMenu object
+
+    """
+    return context_menu(
+        name,
+        context_type=CommandType.USER,
+        scopes=scopes,
+        default_member_permissions=default_member_permissions,
+        dm_permission=dm_permission,
+    )
+
+
+def message_context_menu(
+    name: Absent[str | LocalisedName] = MISSING,
+    *,
+    scopes: Absent[List["Snowflake_Type"]] = MISSING,
+    default_member_permissions: Optional["Permissions"] = None,
+    dm_permission: bool = True,
+) -> Callable[[AsyncCallable], ContextMenu]:
+    """
+    A decorator to declare a coroutine as a Message Context Menu.
+
+    Args:
+        name: 1-32 character name of the context menu, defaults to the name of the coroutine.
+        scopes: The scope this command exists within
+        default_member_permissions: What permissions members need to have by default to use this command.
+        dm_permission: Should this command be available in DMs.
+
+    Returns:
+        ContextMenu object
+
+    """
+    return context_menu(
+        name,
+        context_type=CommandType.MESSAGE,
+        scopes=scopes,
+        default_member_permissions=default_member_permissions,
+        dm_permission=dm_permission,
+    )
+
+
+def component_callback(*custom_id: str | re.Pattern) -> Callable[[AsyncCallable], ComponentCommand]:
+    """
+    Register a coroutine as a component callback.
+
+    Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages.
+    Your callback will be given a single argument, `ComponentContext`
+
+    Note:
+        This can optionally take a regex pattern, which will be used to match against the custom ID of the component
+
+    Args:
+        *custom_id: The custom ID of the component to wait for
+
+    """
+
+    def wrapper(func: AsyncCallable) -> ComponentCommand:
+        if not asyncio.iscoroutinefunction(func):
+            raise ValueError("Commands must be coroutines")
+
+        return ComponentCommand(name=f"ComponentCallback::{custom_id}", callback=func, listeners=custom_id)
+
+    custom_id = _unpack_helper(custom_id)
+    custom_ids_validator(*custom_id)
+    return wrapper
+
+
+def modal_callback(*custom_id: str | re.Pattern) -> Callable[[AsyncCallable], ModalCommand]:
+    """
+    Register a coroutine as a modal callback.
+
+    Modal callbacks work the same way as commands, just using modals as a way of invoking, instead of messages.
+    Your callback will be given a single argument, `ModalContext`
+
+    Note:
+        This can optionally take a regex pattern, which will be used to match against the custom ID of the modal
+
+
+    Args:
+        *custom_id: The custom ID of the modal to wait for
+    """
+
+    def wrapper(func: AsyncCallable) -> ModalCommand:
+        if not asyncio.iscoroutinefunction(func):
+            raise ValueError("Commands must be coroutines")
+
+        return ModalCommand(name=f"ModalCallback::{custom_id}", callback=func, listeners=custom_id)
+
+    custom_id = _unpack_helper(custom_id)
+    custom_ids_validator(*custom_id)
+    return wrapper
+
+
+InterCommandT = TypeVar("InterCommandT", InteractionCommand, AsyncCallable)
+SlashCommandT = TypeVar("SlashCommandT", SlashCommand, AsyncCallable)
+
+
+def slash_option(
+    name: str,
+    description: str,
+    opt_type: Union[OptionType, int],
+    required: bool = False,
+    autocomplete: bool = False,
+    choices: List[Union[SlashCommandChoice, dict]] = None,
+    channel_types: Optional[list[Union[ChannelType, int]]] = None,
+    min_value: Optional[float] = None,
+    max_value: Optional[float] = None,
+    min_length: Optional[int] = None,
+    max_length: Optional[int] = None,
+) -> Callable[[SlashCommandT], SlashCommandT]:
+    r"""
+    A decorator to add an option to a slash command.
+
+    Args:
+        name: 1-32 lowercase character name matching ^[\w-]{1,32}$
+        opt_type: The type of option
+        description: 1-100 character description of option
+        required: If the parameter is required or optional--default false
+        autocomplete: If autocomplete interactions are enabled for this STRING, INTEGER, or NUMBER type option
+        choices: A list of choices the user has to pick between (max 25)
+        channel_types: The channel types permitted. The option needs to be a channel
+        min_value: The minimum value permitted. The option needs to be an integer or float
+        max_value: The maximum value permitted. The option needs to be an integer or float
+        min_length: The minimum length of text a user can input. The option needs to be a string
+        max_length: The maximum length of text a user can input. The option needs to be a string
+    """
+
+    def wrapper(func: SlashCommandT) -> SlashCommandT:
+        if hasattr(func, "cmd_id"):
+            raise ValueError("slash_option decorators must be positioned under a slash_command decorator")
+
+        option = SlashCommandOption(
+            name=name,
+            type=opt_type,
+            description=description,
+            required=required,
+            autocomplete=autocomplete,
+            choices=choices or [],
+            channel_types=channel_types,
+            min_value=min_value,
+            max_value=max_value,
+            min_length=min_length,
+            max_length=max_length,
+        )
+        if not hasattr(func, "options"):
+            func.options = []
+        func.options.insert(0, option)
+        return func
+
+    return wrapper
+
+
+def slash_default_member_permission(
+    permission: "Permissions",
+) -> Callable[[SlashCommandT], SlashCommandT]:
+    """
+    A decorator to permissions members need to have by default to use a command.
+
+    Args:
+        permission: The permissions to require for to this command
+
+    """
+
+    def wrapper(func: SlashCommandT) -> SlashCommandT:
+        if hasattr(func, "cmd_id"):
+            raise ValueError(
+                "slash_default_member_permission decorators must be positioned under a slash_command decorator"
+            )
+
+        if not hasattr(func, "default_member_permissions") or func.default_member_permissions is None:
+            func.default_member_permissions = permission
+        else:
+            func.default_member_permissions = func.default_member_permissions | permission
+        return func
+
+    return wrapper
+
+
+def auto_defer(
+    enabled: bool = True, ephemeral: bool = False, time_until_defer: float = 0.0
+) -> Callable[[InterCommandT], InterCommandT]:
+    """
+    A decorator to add an auto defer to a application command.
+
+    Args:
+        enabled: Should the command be deferred automatically
+        ephemeral: Should the command be deferred as ephemeral
+        time_until_defer: How long to wait before deferring automatically
+
+    """
+
+    def wrapper(func: InterCommandT) -> InterCommandT:
+        if hasattr(func, "cmd_id"):
+            raise ValueError("auto_defer decorators must be positioned under a slash_command decorator")
+        func.auto_defer = AutoDefer(enabled=enabled, ephemeral=ephemeral, time_until_defer=time_until_defer)
+        return func
+
+    return wrapper
+
+
+def application_commands_to_dict(  # noqa: C901
+    commands: Dict["Snowflake_Type", Dict[str, InteractionCommand]], client: "Client"
+) -> dict:
+    """
+    Convert the command list into a format that would be accepted by discord.
+
+    `Client.interactions` should be the variable passed to this
+
+    """
+    cmd_bases = {}  # {cmd_base: [commands]}
+    """A store of commands organised by their base command"""
+    output = {}
+    """The output dictionary"""
+
+    def squash_subcommand(subcommands: List) -> Dict:
+        output_data = {}
+        groups = {}
+        sub_cmds = []
+        for subcommand in subcommands:
+            if not output_data:
+                output_data = {
+                    "name": str(subcommand.name),
+                    "description": str(subcommand.description),
+                    "options": [],
+                    "default_member_permissions": str(int(subcommand.default_member_permissions))
+                    if subcommand.default_member_permissions
+                    else None,
+                    "dm_permission": subcommand.dm_permission,
+                    "name_localizations": subcommand.name.to_locale_dict(),
+                    "description_localizations": subcommand.description.to_locale_dict(),
+                    "nsfw": subcommand.nsfw,
+                }
+            if bool(subcommand.group_name):
+                if str(subcommand.group_name) not in groups:
+                    groups[str(subcommand.group_name)] = {
+                        "name": str(subcommand.group_name),
+                        "description": str(subcommand.group_description),
+                        "type": int(OptionType.SUB_COMMAND_GROUP),
+                        "options": [],
+                        "name_localizations": subcommand.group_name.to_locale_dict(),
+                        "description_localizations": subcommand.group_description.to_locale_dict(),
+                    }
+                groups[str(subcommand.group_name)]["options"].append(
+                    subcommand.to_dict() | {"type": int(OptionType.SUB_COMMAND)}
+                )
+            elif subcommand.is_subcommand:
+                sub_cmds.append(subcommand.to_dict() | {"type": int(OptionType.SUB_COMMAND)})
+        options = list(groups.values()) + sub_cmds
+        output_data["options"] = options
+        return output_data
+
+    for _scope, cmds in commands.items():
+        for cmd in cmds.values():
+            cmd_name = str(cmd.name)
+            if cmd_name not in cmd_bases:
+                cmd_bases[cmd_name] = [cmd]
+                continue
+            if cmd not in cmd_bases[cmd_name]:
+                cmd_bases[cmd_name].append(cmd)
+
+    for cmd_list in cmd_bases.values():
+        if any(c.is_subcommand for c in cmd_list):
+            # validate all commands share required attributes
+            scopes: list[Snowflake_Type] = list({s for c in cmd_list for s in c.scopes})
+            base_description = next(
+                (
+                    c.description
+                    for c in cmd_list
+                    if str(c.description) is not None and str(c.description) != "No Description Set"
+                ),
+                "No Description Set",
+            )
+            nsfw = cmd_list[0].nsfw
+
+            if any(str(c.description) not in (str(base_description), "No Description Set") for c in cmd_list):
+                client.logger.warning(
+                    f"Conflicting descriptions found in `{cmd_list[0].name}` subcommands; `{base_description!s}` will be used"
+                )
+            if any(c.default_member_permissions != cmd_list[0].default_member_permissions for c in cmd_list):
+                raise ValueError(f"Conflicting `default_member_permissions` values found in `{cmd_list[0].name}`")
+            if any(c.dm_permission != cmd_list[0].dm_permission for c in cmd_list):
+                raise ValueError(f"Conflicting `dm_permission` values found in `{cmd_list[0].name}`")
+            if any(c.nsfw != nsfw for c in cmd_list):
+                client.logger.warning(f"Conflicting `nsfw` values found in {cmd_list[0].name} - `True` will be used")
+                nsfw = True
+
+            for cmd in cmd_list:
+                cmd.scopes = list(scopes)
+                cmd.description = base_description
+                cmd.nsfw = nsfw
+            # end validation of attributes
+            cmd_data = squash_subcommand(cmd_list)
+        else:
+            scopes = cmd_list[0].scopes
+            cmd_data = cmd_list[0].to_dict()
+        for s in scopes:
+            if s not in output:
+                output[s] = [cmd_data]
+                continue
+            output[s].append(cmd_data)
+    return output
+
+
+def _compare_commands(local_cmd: dict, remote_cmd: dict) -> bool:
+    """
+    Compares remote and local commands
+
+    Args:
+        local_cmd: The local command
+        remote_cmd: The remote command from discord
+
+    Returns:
+        True if the commands are the same
+    """
+    lookup: dict[str, tuple[str, any]] = {
+        "name": ("name", ""),
+        "description": ("description", ""),
+        "default_member_permissions": ("default_member_permissions", None),
+        "dm_permission": ("dm_permission", True),
+        "name_localized": ("name_localizations", None),
+        "description_localized": ("description_localizations", None),
+    }
+    if remote_cmd.get("guild_id"):
+        # non-global command
+        del lookup["dm_permission"]
+
+    for local_name, comparison_data in lookup.items():
+        remote_name, default_value = comparison_data
+        if local_cmd.get(local_name, default_value) != remote_cmd.get(remote_name, default_value):
+            return False
+    return True
+
+
+def _compare_options(local_opt_list: dict, remote_opt_list: dict) -> bool:
+    if local_opt_list != remote_opt_list:
+        post_process: Dict[str, Callable] = {
+            "choices": lambda l10n: [d | {"name_localizations": {}} if len(d) == 2 else d for d in l10n],
+        }
+
+        if len(local_opt_list) != len(remote_opt_list):
+            return False
+        options_lookup: dict[str, tuple[str, any]] = {
+            "name": ("name", ""),
+            "description": ("description", ""),
+            "required": ("required", False),
+            "autocomplete": ("autocomplete", False),
+            "name_localized": ("name_localizations", None),
+            "description_localized": ("description_localizations", None),
+            "channel_types": ("channel_types", None),
+            "choices": ("choices", []),
+            "max_value": ("max_value", None),
+            "min_value": ("min_value", None),
+            "max_length": ("max_length", None),
+            "min_length": ("min_length", None),
+        }
+        for i in range(len(local_opt_list)):
+            local_option = local_opt_list[i]
+            remote_option = remote_opt_list[i]
+
+            if local_option["type"] != remote_option["type"]:
+                return False
+            if local_option["type"] in (OptionType.SUB_COMMAND_GROUP, OptionType.SUB_COMMAND):
+                if not _compare_commands(local_option, remote_option) or not _compare_options(
+                    local_option.get("options", []), remote_option.get("options", [])
+                ):
+                    return False
+            else:
+                for local_name, comparison_data in options_lookup.items():
+                    remote_name, default_value = comparison_data
+                    if local_option.get(local_name, default_value) != post_process.get(remote_name, lambda name: name)(
+                        remote_option.get(remote_name, default_value)
+                    ):
+                        return False
+
+    return True
+
+
+def sync_needed(local_cmd: dict, remote_cmd: Optional[dict] = None) -> bool:
+    """
+    Compares a local application command to its remote counterpart to determine if a sync is required.
+
+    Args:
+        local_cmd: The local json representation of the command
+        remote_cmd: The json representation of the command from Discord
+
+    Returns:
+        Boolean indicating if a sync is needed
+    """
+    if not remote_cmd:
+        # No remote version, command must be new
+        return True
+
+    if not _compare_commands(local_cmd, remote_cmd):
+        # basic comparison of attributes
+        return True
+
+    if remote_cmd["type"] == CommandType.CHAT_INPUT:
+        try:
+            if not _compare_options(local_cmd["options"], remote_cmd["options"]):
+                # options are not the same, sync needed
+                return True
+        except KeyError:
+            if "options" in local_cmd or "options" in remote_cmd:
+                return True
+
+    return False
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/auto_defer.py` & `discord-py-interactions-5.6.0/interactions/models/internal/auto_defer.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-import asyncio
-import contextlib
-from typing import TYPE_CHECKING
-
-import attrs
-
-from interactions.client.errors import AlreadyDeferred, NotFound, BadRequest, HTTPException
-
-if TYPE_CHECKING:
-    from interactions.models.internal.context import InteractionContext
-
-__all__ = ("AutoDefer",)
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class AutoDefer:
-    """Automatically defer application commands for you!"""
-
-    enabled: bool = attrs.field(repr=False, default=False)
-    """Whether or not auto-defer is enabled"""
-
-    ephemeral: bool = attrs.field(repr=False, default=False)
-    """Should the command be deferred as ephemeral or not"""
-
-    time_until_defer: float = attrs.field(repr=False, default=1.5)
-    """How long to wait before automatically deferring"""
-
-    async def __call__(self, ctx: "InteractionContext") -> None:
-        if self.enabled:
-            if self.time_until_defer > 0:
-                loop = asyncio.get_event_loop()
-                loop.call_later(self.time_until_defer, loop.create_task, self.defer(ctx))
-            else:
-                await ctx.defer(ephemeral=self.ephemeral)
-
-    async def defer(self, ctx: "InteractionContext") -> None:
-        """Defer the command"""
-        if not ctx.responded or not ctx.deferred:
-            with contextlib.suppress(AlreadyDeferred, NotFound, BadRequest, HTTPException):
-                await ctx.defer(ephemeral=self.ephemeral)
+import asyncio
+import contextlib
+from typing import TYPE_CHECKING
+
+import attrs
+
+from interactions.client.errors import AlreadyDeferred, NotFound, BadRequest, HTTPException
+
+if TYPE_CHECKING:
+    from interactions.models.internal.context import InteractionContext
+
+__all__ = ("AutoDefer",)
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class AutoDefer:
+    """Automatically defer application commands for you!"""
+
+    enabled: bool = attrs.field(repr=False, default=False)
+    """Whether or not auto-defer is enabled"""
+
+    ephemeral: bool = attrs.field(repr=False, default=False)
+    """Should the command be deferred as ephemeral or not"""
+
+    time_until_defer: float = attrs.field(repr=False, default=1.5)
+    """How long to wait before automatically deferring"""
+
+    async def __call__(self, ctx: "InteractionContext") -> None:
+        if self.enabled:
+            if self.time_until_defer > 0:
+                loop = asyncio.get_event_loop()
+                loop.call_later(self.time_until_defer, loop.create_task, self.defer(ctx))
+            else:
+                await ctx.defer(ephemeral=self.ephemeral)
+
+    async def defer(self, ctx: "InteractionContext") -> None:
+        """Defer the command"""
+        if not ctx.responded or not ctx.deferred:
+            with contextlib.suppress(AlreadyDeferred, NotFound, BadRequest, HTTPException):
+                await ctx.defer(ephemeral=self.ephemeral)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/checks.py` & `discord-py-interactions-5.6.0/interactions/models/internal/checks.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,91 +1,91 @@
-from typing import Awaitable, Callable
-
-from interactions.models.discord.role import Role
-from interactions.models.discord.snowflake import Snowflake_Type, to_snowflake
-from interactions.models.discord.user import Member
-from interactions.models.internal.context import BaseContext
-
-__all__ = ("has_role", "has_any_role", "has_id", "is_owner", "guild_only", "dm_only")
-
-TYPE_CHECK_FUNCTION = Callable[[BaseContext], Awaitable[bool]]
-
-
-def has_role(role: Snowflake_Type | Role) -> TYPE_CHECK_FUNCTION:
-    """
-    Check if the user has the given role.
-
-    Args:
-        role: The Role or role id to check for
-
-    """
-
-    async def check(ctx: BaseContext) -> bool:
-        if ctx.guild is None:
-            return False
-        author: Member = ctx.author  # pyright: ignore [reportGeneralTypeIssues]
-        return author.has_role(role)
-
-    return check
-
-
-def has_any_role(*roles: Snowflake_Type | Role) -> TYPE_CHECK_FUNCTION:
-    """
-    Checks if the user has any of the given roles.
-
-    Args:
-        *roles: The Role(s) or role id(s) to check for
-    """
-
-    async def check(ctx: BaseContext) -> bool:
-        if ctx.guild is None:
-            return False
-
-        author: Member = ctx.author  # pyright: ignore [reportGeneralTypeIssues]
-        return any((author.has_role(to_snowflake(r)) for r in roles))
-
-    return check
-
-
-def has_id(user_id: int) -> TYPE_CHECK_FUNCTION:
-    """
-    Checks if the author has the desired ID.
-
-    Args:
-        user_id: id of the user to check for
-
-    """
-
-    async def check(ctx: BaseContext) -> bool:
-        return ctx.author.id == user_id
-
-    return check
-
-
-def is_owner() -> TYPE_CHECK_FUNCTION:
-    """Checks if the author is the owner of the bot. This respects the `client.owner_ids` list."""
-
-    async def check(ctx: BaseContext) -> bool:
-        _owner_ids: set = ctx.bot.owner_ids.copy()
-        if ctx.bot.app.team:
-            [_owner_ids.add(m.id) for m in ctx.bot.app.team.members]
-        return ctx.author.id in _owner_ids
-
-    return check
-
-
-def guild_only() -> TYPE_CHECK_FUNCTION:
-    """This command may only be ran in a guild."""
-
-    async def check(ctx: BaseContext) -> bool:
-        return ctx.guild is not None
-
-    return check
-
-
-def dm_only() -> TYPE_CHECK_FUNCTION:
-    """This command may only be ran in a dm."""
-
-    async def check(ctx: BaseContext) -> bool:
-        return ctx.guild is None
-
-    return check
+from typing import Awaitable, Callable
+
+from interactions.models.discord.role import Role
+from interactions.models.discord.snowflake import Snowflake_Type, to_snowflake
+from interactions.models.discord.user import Member
+from interactions.models.internal.context import BaseContext
+
+__all__ = ("has_role", "has_any_role", "has_id", "is_owner", "guild_only", "dm_only")
+
+TYPE_CHECK_FUNCTION = Callable[[BaseContext], Awaitable[bool]]
+
+
+def has_role(role: Snowflake_Type | Role) -> TYPE_CHECK_FUNCTION:
+    """
+    Check if the user has the given role.
+
+    Args:
+        role: The Role or role id to check for
+
+    """
+
+    async def check(ctx: BaseContext) -> bool:
+        if ctx.guild is None:
+            return False
+        author: Member = ctx.author  # pyright: ignore [reportGeneralTypeIssues]
+        return author.has_role(role)
+
+    return check
+
+
+def has_any_role(*roles: Snowflake_Type | Role) -> TYPE_CHECK_FUNCTION:
+    """
+    Checks if the user has any of the given roles.
+
+    Args:
+        *roles: The Role(s) or role id(s) to check for
+    """
+
+    async def check(ctx: BaseContext) -> bool:
+        if ctx.guild is None:
+            return False
+
+        author: Member = ctx.author  # pyright: ignore [reportGeneralTypeIssues]
+        return any((author.has_role(to_snowflake(r)) for r in roles))
+
+    return check
+
+
+def has_id(user_id: int) -> TYPE_CHECK_FUNCTION:
+    """
+    Checks if the author has the desired ID.
+
+    Args:
+        user_id: id of the user to check for
+
+    """
+
+    async def check(ctx: BaseContext) -> bool:
+        return ctx.author.id == user_id
+
+    return check
+
+
+def is_owner() -> TYPE_CHECK_FUNCTION:
+    """Checks if the author is the owner of the bot. This respects the `client.owner_ids` list."""
+
+    async def check(ctx: BaseContext) -> bool:
+        _owner_ids: set = ctx.bot.owner_ids.copy()
+        if ctx.bot.app.team:
+            [_owner_ids.add(m.id) for m in ctx.bot.app.team.members]
+        return ctx.author.id in _owner_ids
+
+    return check
+
+
+def guild_only() -> TYPE_CHECK_FUNCTION:
+    """This command may only be ran in a guild."""
+
+    async def check(ctx: BaseContext) -> bool:
+        return ctx.guild is not None
+
+    return check
+
+
+def dm_only() -> TYPE_CHECK_FUNCTION:
+    """This command may only be ran in a dm."""
+
+    async def check(ctx: BaseContext) -> bool:
+        return ctx.guild is None
+
+    return check
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/command.py` & `discord-py-interactions-5.6.0/interactions/models/internal/command.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,326 +1,326 @@
-from __future__ import annotations
-
-import asyncio
-import typing
-from typing import (
-    Annotated,
-    Awaitable,
-    Callable,
-    Coroutine,
-    Optional,
-    Tuple,
-    Any,
-    TYPE_CHECKING,
-    TypeVar,
-)
-
-import attrs
-
-from interactions.client.const import MISSING, AsyncCallable
-from interactions.client.errors import CommandOnCooldown, CommandCheckFailure, MaxConcurrencyReached
-from interactions.client.mixins.serialization import DictSerializationMixin
-from interactions.client.utils.attr_utils import docs
-from interactions.client.utils.misc_utils import get_parameters, get_object_name, maybe_coroutine
-from interactions.client.utils.serializer import no_export_meta
-from interactions.models.internal.callback import CallbackObject
-from interactions.models.internal.cooldowns import Cooldown, Buckets, MaxConcurrency, CooldownSystem
-from interactions.models.internal.protocols import Converter
-
-if TYPE_CHECKING:
-    from interactions.models.internal.extension import Extension
-    from interactions.models.internal.context import BaseContext
-
-__all__ = ("BaseCommand", "check", "cooldown", "max_concurrency")
-
-
-@attrs.define(eq=False, order=False, hash=False, kw_only=True)
-class BaseCommand(DictSerializationMixin, CallbackObject):
-    """
-    An object all commands inherit from. Outlines the basic structure of a command, and handles checks.
-
-    Attributes:
-        extension: The extension this command belongs to.
-        enabled: Whether this command is enabled
-        checks: Any checks that must be run before this command can be run
-        callback: The coroutine to be called for this command
-        error_callback: The coroutine to be called when an error occurs
-        pre_run_callback: A coroutine to be called before this command is run **but** after the checks
-        post_run_callback: A coroutine to be called after this command has run
-
-    """
-
-    extension: "Optional[Extension]" = attrs.field(
-        repr=False,
-        default=None,
-        metadata=docs("The extension this command belongs to") | no_export_meta,
-    )
-
-    enabled: bool = attrs.field(
-        repr=False, default=True, metadata=docs("Whether this can be run at all") | no_export_meta
-    )
-    checks: list = attrs.field(
-        repr=False,
-        factory=list,
-        metadata=docs("Any checks that must be *checked* before the command can run") | no_export_meta,
-    )
-    cooldown: Cooldown = attrs.field(
-        repr=False,
-        default=MISSING,
-        metadata=docs("An optional cooldown to apply to the command") | no_export_meta,
-    )
-    max_concurrency: MaxConcurrency = attrs.field(
-        default=MISSING,
-        metadata=docs("An optional maximum number of concurrent instances to apply to the command") | no_export_meta,
-    )
-
-    callback: Callable[..., Coroutine] = attrs.field(
-        repr=False,
-        default=None,
-        metadata=docs("The coroutine to be called for this command") | no_export_meta,
-    )
-    error_callback: Callable[..., Coroutine] = attrs.field(
-        repr=False,
-        default=None,
-        metadata=no_export_meta | docs("The coroutine to be called when an error occurs"),
-    )
-    pre_run_callback: Callable[..., Coroutine] = attrs.field(
-        default=None,
-        metadata=no_export_meta
-        | docs("The coroutine to be called before the command is executed, **but** after the checks"),
-    )
-    post_run_callback: Callable[..., Coroutine] = attrs.field(
-        repr=False,
-        default=None,
-        metadata=no_export_meta | docs("The coroutine to be called after the command has executed"),
-    )
-
-    def __attrs_post_init__(self) -> None:
-        if self.callback is not None:
-            if hasattr(self.callback, "checks"):
-                self.checks += self.callback.checks
-            if hasattr(self.callback, "cooldown"):
-                self.cooldown = self.callback.cooldown
-            if hasattr(self.callback, "max_concurrency"):
-                self.max_concurrency = self.callback.max_concurrency
-
-    def __hash__(self) -> int:
-        return id(self)
-
-    async def __call__(self, context: "BaseContext", *args, **kwargs) -> None:
-        """
-        Calls this command.
-
-        Args:
-            context: The context of this command
-            args: Any
-            kwargs: Any
-
-        """
-        # signals if a semaphore has been acquired, for exception handling
-        # if present assume one will be acquired
-        max_conc_acquired = self.max_concurrency is not MISSING
-
-        try:
-            if await self._can_run(context):
-                if self.pre_run_callback is not None:
-                    await self.call_with_binding(self.pre_run_callback, context, *args, **kwargs)
-
-                if self.extension is not None and self.extension.extension_prerun:
-                    for prerun in self.extension.extension_prerun:
-                        await prerun(context, *args, **kwargs)
-
-                await self.call_callback(self.callback, context)
-
-                if self.post_run_callback is not None:
-                    await self.call_with_binding(self.post_run_callback, context, *args, **kwargs)
-
-                if self.extension is not None and self.extension.extension_postrun:
-                    for postrun in self.extension.extension_postrun:
-                        await postrun(context, *args, **kwargs)
-
-        except Exception as e:
-            # if a MaxConcurrencyReached-exception is raised a connection was never acquired
-            max_conc_acquired = not isinstance(e, MaxConcurrencyReached)
-
-            if self.error_callback:
-                await self.error_callback(e, context, *args, **kwargs)
-            elif self.extension and self.extension.extension_error:
-                await self.extension.extension_error(e, context, *args, **kwargs)
-            else:
-                raise
-        finally:
-            if self.max_concurrency is not MISSING and max_conc_acquired:
-                await self.max_concurrency.release(context)
-
-    @staticmethod
-    def _get_converter_function(anno: type[Converter] | Converter, name: str) -> Callable[[BaseContext, str], Any]:
-        num_params = len(get_parameters(anno.convert))
-
-        # if we have three parameters for the function, it's likely it has a self parameter
-        # so we need to get rid of it by initing - typehinting hates this, btw!
-        # the below line will error out if we aren't supposed to init it, so that works out
-        try:
-            actual_anno: Converter = anno() if num_params == 3 else anno  # type: ignore
-        except TypeError:
-            raise ValueError(
-                f"{get_object_name(anno)} for {name} is invalid: converters must have exactly 2 arguments."
-            ) from None
-
-        # we can only get to this point while having three params if we successfully inited
-        if num_params == 3:
-            num_params -= 1
-
-        if num_params != 2:
-            raise ValueError(
-                f"{get_object_name(anno)} for {name} is invalid: converters must have exactly 2 arguments."
-            )
-
-        return actual_anno.convert
-
-    async def try_convert(self, converter: Optional[Callable], context: "BaseContext", value: Any) -> Any:
-        if converter is None:
-            return value
-        return await maybe_coroutine(converter, context, value)
-
-    def param_config(self, annotation: Any, name: str) -> Tuple[Callable, Optional[dict]]:
-        # This thing is complicated. i.py-annotations can either be annotated directly, or they can be annotated with Annotated[str, CMD_*]
-        # This helper function handles both cases, and returns a tuple of the converter and its config (if any)
-        if annotation is None:
-            return None
-        if typing.get_origin(annotation) is Annotated and (args := typing.get_args(annotation)):
-            for ann in args:
-                v = getattr(ann, name, None)
-                if v is not None:
-                    return (ann, v)
-        return (annotation, getattr(annotation, name, None))
-
-    async def call_callback(self, callback: Callable, context: "BaseContext") -> None:
-        await self.call_with_binding(callback, context, **context.kwargs)  # type: ignore
-
-    async def _can_run(self, context: "BaseContext") -> bool:
-        """
-        Determines if this command can be run.
-
-        Args:
-            context: The context of the command
-
-        """
-        max_conc_acquired = False  # signals if a semaphore has been acquired, for exception handling
-
-        try:
-            if not self.enabled:
-                return False
-
-            for _c in self.checks:
-                if not await _c(context):
-                    raise CommandCheckFailure(self, _c, context)
-
-            if self.extension and self.extension.extension_checks:
-                for _c in self.extension.extension_checks:
-                    if not await _c(context):
-                        raise CommandCheckFailure(self, _c, context)
-
-            if self.max_concurrency is not MISSING and not await self.max_concurrency.acquire(context):
-                raise MaxConcurrencyReached(self, self.max_concurrency)
-
-            if self.cooldown is not MISSING and not await self.cooldown.acquire_token(context):
-                raise CommandOnCooldown(self, await self.cooldown.get_cooldown(context))
-
-            return True
-
-        except Exception:
-            if max_conc_acquired:
-                await self.max_concurrency.release(context)
-            raise
-
-    def add_check(self, check: Callable[..., Awaitable[bool]]) -> None:
-        """Adds a check into the command."""
-        self.checks.append(check)
-
-    def error(self, call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
-        """A decorator to declare a coroutine as one that will be run upon an error."""
-        if not asyncio.iscoroutinefunction(call):
-            raise TypeError("Error handler must be coroutine")
-        self.error_callback = call
-        return call
-
-    def pre_run(self, call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
-        """A decorator to declare a coroutine as one that will be run before the command."""
-        if not asyncio.iscoroutinefunction(call):
-            raise TypeError("pre_run must be coroutine")
-        self.pre_run_callback = call
-        return call
-
-    def post_run(self, call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
-        """A decorator to declare a coroutine as one that will be run after the command has."""
-        if not asyncio.iscoroutinefunction(call):
-            raise TypeError("post_run must be coroutine")
-        self.post_run_callback = call
-        return call
-
-
-CommandT = TypeVar("CommandT", BaseCommand, AsyncCallable)
-
-
-def check(check: Callable[..., Awaitable[bool]]) -> Callable[[CommandT], CommandT]:
-    """
-    Add a check to a command.
-
-    Args:
-        check: A coroutine as a check for this command
-
-    """
-
-    def wrapper(coro: CommandT) -> CommandT:
-        if isinstance(coro, BaseCommand):
-            coro.checks.append(check)
-            return coro
-        if not hasattr(coro, "checks"):
-            coro.checks = []
-        coro.checks.append(check)
-        return coro
-
-    return wrapper
-
-
-def cooldown(
-    bucket: Buckets, rate: int, interval: float, cooldown_system: typing.Type[CooldownSystem] | None = None
-) -> Callable[[CommandT], CommandT]:
-    """
-    Add a cooldown to a command.
-
-    Args:
-        bucket: The bucket used to track cooldowns
-        rate: How many commands may be ran per interval
-        interval: How many seconds to wait for a cooldown
-        cooldown_system: The cooldown system to use
-    """
-
-    def wrapper(coro: CommandT) -> CommandT:
-        cooldown_obj = Cooldown(bucket, rate, interval, cooldown_system=cooldown_system)
-
-        coro.cooldown = cooldown_obj
-
-        return coro
-
-    return wrapper
-
-
-def max_concurrency(bucket: Buckets, concurrent: int) -> Callable[[CommandT], CommandT]:
-    """
-    Add a maximum number of concurrent instances to the command.
-
-    Args:
-        bucket: The bucket to enforce the maximum within
-        concurrent: The maximum number of concurrent instances to allow
-
-    """
-
-    def wrapper(coro: CommandT) -> CommandT:
-        max_conc = MaxConcurrency(concurrent, bucket)
-
-        coro.max_concurrency = max_conc
-
-        return coro
-
-    return wrapper
+from __future__ import annotations
+
+import asyncio
+import typing
+from typing import (
+    Annotated,
+    Awaitable,
+    Callable,
+    Coroutine,
+    Optional,
+    Tuple,
+    Any,
+    TYPE_CHECKING,
+    TypeVar,
+)
+
+import attrs
+
+from interactions.client.const import MISSING, AsyncCallable
+from interactions.client.errors import CommandOnCooldown, CommandCheckFailure, MaxConcurrencyReached
+from interactions.client.mixins.serialization import DictSerializationMixin
+from interactions.client.utils.attr_utils import docs
+from interactions.client.utils.misc_utils import get_parameters, get_object_name, maybe_coroutine
+from interactions.client.utils.serializer import no_export_meta
+from interactions.models.internal.callback import CallbackObject
+from interactions.models.internal.cooldowns import Cooldown, Buckets, MaxConcurrency, CooldownSystem
+from interactions.models.internal.protocols import Converter
+
+if TYPE_CHECKING:
+    from interactions.models.internal.extension import Extension
+    from interactions.models.internal.context import BaseContext
+
+__all__ = ("BaseCommand", "check", "cooldown", "max_concurrency")
+
+
+@attrs.define(eq=False, order=False, hash=False, kw_only=True)
+class BaseCommand(DictSerializationMixin, CallbackObject):
+    """
+    An object all commands inherit from. Outlines the basic structure of a command, and handles checks.
+
+    Attributes:
+        extension: The extension this command belongs to.
+        enabled: Whether this command is enabled
+        checks: Any checks that must be run before this command can be run
+        callback: The coroutine to be called for this command
+        error_callback: The coroutine to be called when an error occurs
+        pre_run_callback: A coroutine to be called before this command is run **but** after the checks
+        post_run_callback: A coroutine to be called after this command has run
+
+    """
+
+    extension: "Optional[Extension]" = attrs.field(
+        repr=False,
+        default=None,
+        metadata=docs("The extension this command belongs to") | no_export_meta,
+    )
+
+    enabled: bool = attrs.field(
+        repr=False, default=True, metadata=docs("Whether this can be run at all") | no_export_meta
+    )
+    checks: list = attrs.field(
+        repr=False,
+        factory=list,
+        metadata=docs("Any checks that must be *checked* before the command can run") | no_export_meta,
+    )
+    cooldown: Cooldown = attrs.field(
+        repr=False,
+        default=MISSING,
+        metadata=docs("An optional cooldown to apply to the command") | no_export_meta,
+    )
+    max_concurrency: MaxConcurrency = attrs.field(
+        default=MISSING,
+        metadata=docs("An optional maximum number of concurrent instances to apply to the command") | no_export_meta,
+    )
+
+    callback: Callable[..., Coroutine] = attrs.field(
+        repr=False,
+        default=None,
+        metadata=docs("The coroutine to be called for this command") | no_export_meta,
+    )
+    error_callback: Callable[..., Coroutine] = attrs.field(
+        repr=False,
+        default=None,
+        metadata=no_export_meta | docs("The coroutine to be called when an error occurs"),
+    )
+    pre_run_callback: Callable[..., Coroutine] = attrs.field(
+        default=None,
+        metadata=no_export_meta
+        | docs("The coroutine to be called before the command is executed, **but** after the checks"),
+    )
+    post_run_callback: Callable[..., Coroutine] = attrs.field(
+        repr=False,
+        default=None,
+        metadata=no_export_meta | docs("The coroutine to be called after the command has executed"),
+    )
+
+    def __attrs_post_init__(self) -> None:
+        if self.callback is not None:
+            if hasattr(self.callback, "checks"):
+                self.checks += self.callback.checks
+            if hasattr(self.callback, "cooldown"):
+                self.cooldown = self.callback.cooldown
+            if hasattr(self.callback, "max_concurrency"):
+                self.max_concurrency = self.callback.max_concurrency
+
+    def __hash__(self) -> int:
+        return id(self)
+
+    async def __call__(self, context: "BaseContext", *args, **kwargs) -> None:
+        """
+        Calls this command.
+
+        Args:
+            context: The context of this command
+            args: Any
+            kwargs: Any
+
+        """
+        # signals if a semaphore has been acquired, for exception handling
+        # if present assume one will be acquired
+        max_conc_acquired = self.max_concurrency is not MISSING
+
+        try:
+            if await self._can_run(context):
+                if self.pre_run_callback is not None:
+                    await self.call_with_binding(self.pre_run_callback, context, *args, **kwargs)
+
+                if self.extension is not None and self.extension.extension_prerun:
+                    for prerun in self.extension.extension_prerun:
+                        await prerun(context, *args, **kwargs)
+
+                await self.call_callback(self.callback, context)
+
+                if self.post_run_callback is not None:
+                    await self.call_with_binding(self.post_run_callback, context, *args, **kwargs)
+
+                if self.extension is not None and self.extension.extension_postrun:
+                    for postrun in self.extension.extension_postrun:
+                        await postrun(context, *args, **kwargs)
+
+        except Exception as e:
+            # if a MaxConcurrencyReached-exception is raised a connection was never acquired
+            max_conc_acquired = not isinstance(e, MaxConcurrencyReached)
+
+            if self.error_callback:
+                await self.error_callback(e, context, *args, **kwargs)
+            elif self.extension and self.extension.extension_error:
+                await self.extension.extension_error(e, context, *args, **kwargs)
+            else:
+                raise
+        finally:
+            if self.max_concurrency is not MISSING and max_conc_acquired:
+                await self.max_concurrency.release(context)
+
+    @staticmethod
+    def _get_converter_function(anno: type[Converter] | Converter, name: str) -> Callable[[BaseContext, str], Any]:
+        num_params = len(get_parameters(anno.convert))
+
+        # if we have three parameters for the function, it's likely it has a self parameter
+        # so we need to get rid of it by initing - typehinting hates this, btw!
+        # the below line will error out if we aren't supposed to init it, so that works out
+        try:
+            actual_anno: Converter = anno() if num_params == 3 else anno  # type: ignore
+        except TypeError:
+            raise ValueError(
+                f"{get_object_name(anno)} for {name} is invalid: converters must have exactly 2 arguments."
+            ) from None
+
+        # we can only get to this point while having three params if we successfully inited
+        if num_params == 3:
+            num_params -= 1
+
+        if num_params != 2:
+            raise ValueError(
+                f"{get_object_name(anno)} for {name} is invalid: converters must have exactly 2 arguments."
+            )
+
+        return actual_anno.convert
+
+    async def try_convert(self, converter: Optional[Callable], context: "BaseContext", value: Any) -> Any:
+        if converter is None:
+            return value
+        return await maybe_coroutine(converter, context, value)
+
+    def param_config(self, annotation: Any, name: str) -> Tuple[Callable, Optional[dict]]:
+        # This thing is complicated. i.py-annotations can either be annotated directly, or they can be annotated with Annotated[str, CMD_*]
+        # This helper function handles both cases, and returns a tuple of the converter and its config (if any)
+        if annotation is None:
+            return None
+        if typing.get_origin(annotation) is Annotated and (args := typing.get_args(annotation)):
+            for ann in args:
+                v = getattr(ann, name, None)
+                if v is not None:
+                    return (ann, v)
+        return (annotation, getattr(annotation, name, None))
+
+    async def call_callback(self, callback: Callable, context: "BaseContext") -> None:
+        await self.call_with_binding(callback, context, **context.kwargs)  # type: ignore
+
+    async def _can_run(self, context: "BaseContext") -> bool:
+        """
+        Determines if this command can be run.
+
+        Args:
+            context: The context of the command
+
+        """
+        max_conc_acquired = False  # signals if a semaphore has been acquired, for exception handling
+
+        try:
+            if not self.enabled:
+                return False
+
+            for _c in self.checks:
+                if not await _c(context):
+                    raise CommandCheckFailure(self, _c, context)
+
+            if self.extension and self.extension.extension_checks:
+                for _c in self.extension.extension_checks:
+                    if not await _c(context):
+                        raise CommandCheckFailure(self, _c, context)
+
+            if self.max_concurrency is not MISSING and not await self.max_concurrency.acquire(context):
+                raise MaxConcurrencyReached(self, self.max_concurrency)
+
+            if self.cooldown is not MISSING and not await self.cooldown.acquire_token(context):
+                raise CommandOnCooldown(self, await self.cooldown.get_cooldown(context))
+
+            return True
+
+        except Exception:
+            if max_conc_acquired:
+                await self.max_concurrency.release(context)
+            raise
+
+    def add_check(self, check: Callable[..., Awaitable[bool]]) -> None:
+        """Adds a check into the command."""
+        self.checks.append(check)
+
+    def error(self, call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
+        """A decorator to declare a coroutine as one that will be run upon an error."""
+        if not asyncio.iscoroutinefunction(call):
+            raise TypeError("Error handler must be coroutine")
+        self.error_callback = call
+        return call
+
+    def pre_run(self, call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
+        """A decorator to declare a coroutine as one that will be run before the command."""
+        if not asyncio.iscoroutinefunction(call):
+            raise TypeError("pre_run must be coroutine")
+        self.pre_run_callback = call
+        return call
+
+    def post_run(self, call: Callable[..., Coroutine]) -> Callable[..., Coroutine]:
+        """A decorator to declare a coroutine as one that will be run after the command has."""
+        if not asyncio.iscoroutinefunction(call):
+            raise TypeError("post_run must be coroutine")
+        self.post_run_callback = call
+        return call
+
+
+CommandT = TypeVar("CommandT", BaseCommand, AsyncCallable)
+
+
+def check(check: Callable[..., Awaitable[bool]]) -> Callable[[CommandT], CommandT]:
+    """
+    Add a check to a command.
+
+    Args:
+        check: A coroutine as a check for this command
+
+    """
+
+    def wrapper(coro: CommandT) -> CommandT:
+        if isinstance(coro, BaseCommand):
+            coro.checks.append(check)
+            return coro
+        if not hasattr(coro, "checks"):
+            coro.checks = []
+        coro.checks.append(check)
+        return coro
+
+    return wrapper
+
+
+def cooldown(
+    bucket: Buckets, rate: int, interval: float, cooldown_system: typing.Type[CooldownSystem] | None = None
+) -> Callable[[CommandT], CommandT]:
+    """
+    Add a cooldown to a command.
+
+    Args:
+        bucket: The bucket used to track cooldowns
+        rate: How many commands may be ran per interval
+        interval: How many seconds to wait for a cooldown
+        cooldown_system: The cooldown system to use
+    """
+
+    def wrapper(coro: CommandT) -> CommandT:
+        cooldown_obj = Cooldown(bucket, rate, interval, cooldown_system=cooldown_system)
+
+        coro.cooldown = cooldown_obj
+
+        return coro
+
+    return wrapper
+
+
+def max_concurrency(bucket: Buckets, concurrent: int) -> Callable[[CommandT], CommandT]:
+    """
+    Add a maximum number of concurrent instances to the command.
+
+    Args:
+        bucket: The bucket to enforce the maximum within
+        concurrent: The maximum number of concurrent instances to allow
+
+    """
+
+    def wrapper(coro: CommandT) -> CommandT:
+        max_conc = MaxConcurrency(concurrent, bucket)
+
+        coro.max_concurrency = max_conc
+
+        return coro
+
+    return wrapper
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/context.py` & `discord-py-interactions-5.6.0/interactions/models/internal/context.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,923 +1,923 @@
-import abc
-import datetime
-import re
-import typing
-from typing_extensions import Self
-
-import discord_typings
-from aiohttp import FormData
-
-from interactions.client import const
-from interactions.client.const import get_logger, MISSING
-from interactions.models.discord.components import BaseComponent
-from interactions.models.discord.file import UPLOADABLE_TYPE
-from interactions.models.discord.sticker import Sticker
-from interactions.models.discord.user import Member, User
-
-from interactions.models.internal.command import BaseCommand
-from interactions.client.mixins.modal import ModalMixin
-
-from interactions.client.errors import HTTPException, AlreadyDeferred, AlreadyResponded
-from interactions.client.mixins.send import SendMixin
-from interactions.models.discord.enums import (
-    Permissions,
-    MessageFlags,
-    InteractionType,
-    ComponentType,
-    CommandType,
-)
-from interactions.models.discord.message import (
-    AllowedMentions,
-    Attachment,
-    Message,
-    MessageReference,
-    process_message_payload,
-)
-from interactions.models.discord.snowflake import Snowflake, Snowflake_Type, to_snowflake, to_optional_snowflake
-from interactions.models.discord.embed import Embed
-from interactions.models.internal.application_commands import (
-    OptionType,
-    CallbackType,
-    SlashCommandChoice,
-    SlashCommandOption,
-    InteractionCommand,
-)
-
-__all__ = (
-    "AutocompleteContext",
-    "BaseContext",
-    "BaseInteractionContext",
-    "ComponentContext",
-    "ContextMenuContext",
-    "InteractionContext",
-    "ModalContext",
-    "Resolved",
-    "SlashContext",
-)
-
-
-if typing.TYPE_CHECKING:
-    import interactions
-
-
-class Resolved:
-    """
-    A class representing the resolved data from an interaction.
-
-    Attributes:
-        channels: A dictionary of channels resolved from the interaction.
-        members: A dictionary of members resolved from the interaction.
-        users: A dictionary of users resolved from the interaction.
-        roles: A dictionary of roles resolved from the interaction.
-        messages: A dictionary of messages resolved from the interaction.
-        attachments: A dictionary of attachments resolved from the interaction.
-    """
-
-    def __init__(self) -> None:
-        self.channels: dict[Snowflake, "interactions.TYPE_MESSAGEABLE_CHANNEL"] = {}
-        self.members: dict[Snowflake, "interactions.Member"] = {}
-        self.users: dict[Snowflake, "interactions.User"] = {}
-        self.roles: dict[Snowflake, "interactions.Role"] = {}
-        self.messages: dict[Snowflake, "interactions.Message"] = {}
-        self.attachments: dict[Snowflake, "interactions.Attachment"] = {}
-
-    def __bool__(self) -> bool:
-        """Returns whether any resolved data is present."""
-        return (
-            bool(self.channels)
-            or bool(self.members)
-            or bool(self.users)
-            or bool(self.roles)
-            or bool(self.messages)
-            or bool(self.attachments)
-        )
-
-    def get(self, snowflake: Snowflake | str, default: typing.Any = None) -> typing.Any:
-        snowflake = Snowflake(snowflake)
-        """Returns the value of the given snowflake."""
-        if channel := self.channels.get(snowflake):
-            return channel
-        if member := self.members.get(snowflake):
-            return member
-        if user := self.users.get(snowflake):
-            return user
-        if role := self.roles.get(snowflake):
-            return role
-        if message := self.messages.get(snowflake):
-            return message
-        if attachment := self.attachments.get(snowflake):
-            return attachment
-        return default
-
-    @classmethod
-    def from_dict(cls, client: "interactions.Client", data: dict, guild_id: None | Snowflake = None) -> Self:
-        instance = cls()
-
-        if channels := data.get("channels"):
-            for key, _channel in channels.items():
-                instance.channels[Snowflake(key)] = client.cache.place_channel_data(_channel)
-
-        if members := data.get("members"):
-            for key, _member in members.items():
-                instance.members[Snowflake(key)] = client.cache.place_member_data(
-                    guild_id, {**_member, "user": {**data["users"][key]}}
-                )
-
-        if users := data.get("users"):
-            for key, _user in users.items():
-                instance.users[Snowflake(key)] = client.cache.place_user_data(_user)
-
-        if roles := data.get("roles"):
-            for key, _role in roles.items():
-                instance.roles[Snowflake(key)] = client.cache.get_role(Snowflake(key))
-
-        if messages := data.get("messages"):
-            for key, _msg in messages.items():
-                instance.messages[Snowflake(key)] = client.cache.place_message_data(_msg)
-
-        if attachments := data.get("attachments"):
-            for key, _attach in attachments.items():
-                instance.attachments[Snowflake(key)] = Attachment.from_dict(_attach, client)
-
-        return instance
-
-
-class BaseContext(metaclass=abc.ABCMeta):
-    """
-    Base context class for all contexts.
-
-    Define your own context class by inheriting from this class. For compatibility with the library, you must define a `from_dict` classmethod that takes a dict and returns an instance of your context class.
-
-    """
-
-    client: "interactions.Client"
-    """The client that created this context."""
-
-    command: BaseCommand
-    """The command this context invokes."""
-
-    author_id: Snowflake
-    """The id of the user that invoked this context."""
-    channel_id: Snowflake
-    """The id of the channel this context was invoked in."""
-    message_id: Snowflake
-    """The id of the message that invoked this context."""
-
-    guild_id: typing.Optional[Snowflake]
-    """The id of the guild this context was invoked in, if any."""
-
-    def __init__(self, client: "interactions.Client") -> None:
-        self.client = client
-        self.author_id = MISSING
-        self.channel_id = MISSING
-        self.message_id = MISSING
-        self.guild_id = MISSING
-
-    @property
-    def guild(self) -> typing.Optional["interactions.Guild"]:
-        """The guild this context was invoked in."""
-        return self.client.cache.get_guild(self.guild_id)
-
-    @property
-    def user(self) -> "interactions.User":
-        """The user that invoked this context."""
-        return self.client.cache.get_user(self.author_id)
-
-    @property
-    def member(self) -> typing.Optional["interactions.Member"]:
-        """The member object that invoked this context."""
-        return self.client.cache.get_member(self.guild_id, self.author_id)
-
-    @property
-    def author(self) -> "interactions.Member | interactions.User":
-        """The member or user that invoked this context."""
-        return self.member or self.user
-
-    @property
-    def channel(self) -> "interactions.TYPE_MESSAGEABLE_CHANNEL":
-        """The channel this context was invoked in."""
-        if self.guild_id:
-            return self.client.cache.get_channel(self.channel_id)
-        return self.client.cache.get_dm_channel(self.author_id)
-
-    @property
-    def message(self) -> typing.Optional["interactions.Message"]:
-        """The message that invoked this context, if any."""
-        return self.client.cache.get_message(self.channel_id, self.message_id)
-
-    @property
-    def voice_state(self) -> typing.Optional["interactions.VoiceState"]:
-        """The current voice state of the bot in the guild this context was invoked in, if any."""
-        return self.client.cache.get_bot_voice_state(self.guild_id)
-
-    @property
-    def bot(self) -> "interactions.Client":
-        return self.client
-
-    @classmethod
-    @abc.abstractmethod
-    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
-        """
-        Create a context instance from a dict.
-
-        Args:
-            client: The client creating this context.
-            payload: The dict to create the context from.
-
-        Returns:
-            The context instance.
-
-        """
-        raise NotImplementedError
-
-
-class BaseInteractionContext(BaseContext):
-    token: str
-    """The interaction token."""
-    id: Snowflake
-    """The interaction ID."""
-
-    app_permissions: Permissions
-    """The permissions available to this interaction"""
-    locale: str
-    """The selected locale of the invoking user (https://discord.com/developers/docs/reference#locales)"""
-    guild_locale: str
-    """The selected locale of the invoking user's guild (https://discord.com/developers/docs/reference#locales)"""
-    resolved: Resolved
-    """The resolved data for this interaction."""
-
-    # state info
-    deferred: bool
-    """Whether the interaction has been deferred."""
-    responded: bool
-    """Whether the interaction has been responded to."""
-    ephemeral: bool
-    """Whether the interaction response is ephemeral."""
-
-    _context_type: int
-    """The context type of the interaction."""
-    command_id: Snowflake
-    """The command ID of the interaction."""
-    _command_name: str
-    """The command name of the interaction."""
-
-    args: list[typing.Any]
-    """The arguments passed to the interaction."""
-    kwargs: dict[str, typing.Any]
-    """The keyword arguments passed to the interaction."""
-
-    def __init__(self, client: "interactions.Client") -> None:
-        super().__init__(client)
-        self.deferred = False
-        self.responded = False
-        self.ephemeral = False
-
-    @classmethod
-    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
-        instance = cls(client=client)
-        instance.token = payload["token"]
-        instance.id = Snowflake(payload["id"])
-        instance.app_permissions = Permissions(payload.get("app_permissions", 0))
-        instance.locale = payload["locale"]
-        instance.guild_locale = payload.get("guild_locale", instance.locale)
-        instance._context_type = payload.get("type", 0)
-        instance.resolved = Resolved.from_dict(client, payload["data"].get("resolved", {}), payload.get("guild_id"))
-
-        instance.channel_id = Snowflake(payload["channel_id"])
-        if member := payload.get("member"):
-            instance.author_id = Snowflake(member["user"]["id"])
-            instance.guild_id = Snowflake(payload["guild_id"])
-            client.cache.place_member_data(instance.guild_id, member)
-        else:
-            instance.author_id = Snowflake(payload["user"]["id"])
-            client.cache.place_user_data(payload["user"])
-
-        if message_data := payload.get("message"):
-            message = client.cache.place_message_data(message_data)
-            instance.message_id = message.id
-
-        instance.guild_id = to_optional_snowflake(payload.get("guild_id"))
-
-        if payload["type"] in (InteractionType.APPLICATION_COMMAND, InteractionType.AUTOCOMPLETE):
-            instance.command_id = Snowflake(payload["data"]["id"])
-            instance._command_name = payload["data"]["name"]
-
-        instance.process_options(payload)
-
-        return instance
-
-    @property
-    def command(self) -> InteractionCommand:
-        return self.client._interaction_lookup[self._command_name]
-
-    @property
-    def expires_at(self) -> typing.Optional[datetime.datetime]:
-        """The time at which the interaction expires."""
-        if self.responded:
-            return self.id.created_at + datetime.timedelta(minutes=15)
-        return self.id.created_at + datetime.timedelta(seconds=3)
-
-    @property
-    def expired(self) -> bool:
-        """Whether the interaction has expired."""
-        return datetime.datetime.utcnow() > self.expires_at
-
-    @property
-    def invoke_target(self) -> str:
-        """The invoke target of the interaction."""
-        return self._command_name
-
-    @property
-    def deferred_ephemeral(self) -> bool:
-        """Whether the interaction has been deferred ephemerally."""
-        return self.deferred and self.ephemeral
-
-    def option_processing_hook(self, option: dict) -> typing.Any:
-        """
-        Hook for extending options processing.
-
-        This is called for each option, before the library processes it. If this returns a value, the library will not process the option further.
-
-        Args:
-            option: The option to process.
-
-        Returns:
-            The processed option.
-
-        """
-        return option
-
-    def process_options(self, data: discord_typings.InteractionCallbackData) -> None:
-        if data["type"] not in (InteractionType.APPLICATION_COMMAND, InteractionType.AUTOCOMPLETE):
-            self.args = []
-            self.kwargs = {}
-            return
-
-        def gather_options(_options: list[dict[str, typing.Any]]) -> dict[str, typing.Any]:
-            """Recursively gather options from an option list."""
-            kwargs = {}
-            for option in _options:
-                if hook_result := self.option_processing_hook(option):
-                    kwargs[option["name"]] = hook_result
-
-                if option["type"] in (OptionType.SUB_COMMAND, OptionType.SUB_COMMAND_GROUP):
-                    self._command_name = f"{self._command_name} {option['name']}"
-                    return gather_options(option["options"])
-
-                value = option.get("value")
-
-                if option["type"] in OptionType.resolvable_types():
-                    value = self.resolved.get(value, value)
-
-                kwargs[option["name"]] = value
-            return kwargs
-
-        if options := data["data"].get("options"):
-            self.kwargs = gather_options(options)  # type: ignore
-        else:
-            self.kwargs = {}
-        self.args = list(self.kwargs.values())
-
-
-class InteractionContext(BaseInteractionContext, SendMixin):
-    async def defer(self, *, ephemeral: bool = False) -> None:
-        """
-        Defer the interaction.
-
-        Args:
-            ephemeral: Whether the interaction response should be ephemeral.
-        """
-        if self.deferred:
-            raise AlreadyDeferred("Interaction has already been responded to.")
-        if self.responded:
-            raise AlreadyResponded("Interaction has already been responded to.")
-
-        payload = {"type": CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE}
-        if ephemeral:
-            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
-
-        await self.client.http.post_initial_response(payload, self.id, self.token)
-        self.deferred = True
-        self.ephemeral = ephemeral
-
-    async def _send_http_request(
-        self, message_payload: dict, files: typing.Iterable["UPLOADABLE_TYPE"] | None = None
-    ) -> dict:
-        if const.has_client_feature("FOLLOWUP_INTERACTIONS_FOR_IMAGES") and not self.deferred:
-            # experimental bypass for discords broken image proxy
-            if embeds := message_payload.get("embeds", {}):
-                if any(e.get("image") for e in embeds) or any(e.get("thumbnail") for e in embeds):
-                    if MessageFlags.EPHEMERAL in message_payload.get("flags", MessageFlags.NONE):
-                        self.ephemeral = True
-                    await self.defer(ephemeral=self.ephemeral)
-
-        if self.responded:
-            message_data = await self.client.http.post_followup(
-                message_payload, self.client.app.id, self.token, files=files
-            )
-        else:
-            if isinstance(message_payload, FormData) and not self.deferred:
-                await self.defer(ephemeral=self.ephemeral)
-            if self.deferred:
-                if const.has_client_feature("FOLLOWUP_INTERACTIONS_FOR_IMAGES"):
-                    message_data = await self.client.http.post_followup(
-                        message_payload, self.client.app.id, self.token, files=files
-                    )
-                else:
-                    message_data = await self.client.http.edit_interaction_message(
-                        message_payload, self.client.app.id, self.token, files=files
-                    )
-            else:
-                payload = {
-                    "type": CallbackType.CHANNEL_MESSAGE_WITH_SOURCE,
-                    "data": message_payload,
-                }
-                message_data = await self.client.http.post_initial_response(payload, self.id, self.token, files=files)
-
-        if not message_data:
-            try:
-                message_data = await self.client.http.get_interaction_message(self.client.app.id, self.token)
-            except HTTPException:
-                pass
-
-        self.responded = True
-        return message_data
-
-    async def send(
-        self,
-        content: typing.Optional[str] = None,
-        *,
-        embeds: typing.Optional[
-            typing.Union[typing.Iterable[typing.Union["Embed", dict]], typing.Union["Embed", dict]]
-        ] = None,
-        embed: typing.Optional[typing.Union["Embed", dict]] = None,
-        components: typing.Optional[
-            typing.Union[
-                typing.Iterable[typing.Iterable[typing.Union["BaseComponent", dict]]],
-                typing.Iterable[typing.Union["BaseComponent", dict]],
-                "BaseComponent",
-                dict,
-            ]
-        ] = None,
-        stickers: typing.Optional[
-            typing.Union[
-                typing.Iterable[typing.Union["Sticker", "Snowflake_Type"]],
-                "Sticker",
-                "Snowflake_Type",
-            ]
-        ] = None,
-        allowed_mentions: typing.Optional[typing.Union["AllowedMentions", dict]] = None,
-        reply_to: typing.Optional[typing.Union["MessageReference", "Message", dict, "Snowflake_Type"]] = None,
-        files: typing.Optional[typing.Union["UPLOADABLE_TYPE", typing.Iterable["UPLOADABLE_TYPE"]]] = None,
-        file: typing.Optional["UPLOADABLE_TYPE"] = None,
-        tts: bool = False,
-        suppress_embeds: bool = False,
-        silent: bool = False,
-        flags: typing.Optional[typing.Union[int, "MessageFlags"]] = None,
-        delete_after: typing.Optional[float] = None,
-        ephemeral: bool = False,
-        **kwargs: typing.Any,
-    ) -> "interactions.Message":
-        """
-        Send a message.
-
-        Args:
-            content: Message text content.
-            embeds: Embedded rich content (up to 6000 characters).
-            embed: Embedded rich content (up to 6000 characters).
-            components: The components to include with the message.
-            stickers: IDs of up to 3 stickers in the server to send in the message.
-            allowed_mentions: Allowed mentions for the message.
-            reply_to: Message to reference, must be from the same channel.
-            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            tts: Should this message use Text To Speech.
-            suppress_embeds: Should embeds be suppressed on this send
-            silent: Should this message be sent without triggering a notification.
-            flags: Message flags to apply.
-            delete_after: Delete message after this many seconds.
-            ephemeral: Whether the response should be ephemeral
-
-        Returns:
-            New message object that was sent.
-        """
-        flags = MessageFlags(flags or 0)
-        if ephemeral:
-            flags |= MessageFlags.EPHEMERAL
-            self.ephemeral = True
-        if suppress_embeds:
-            flags |= MessageFlags.SUPPRESS_EMBEDS
-        if silent:
-            flags |= MessageFlags.SILENT
-
-        return await super().send(
-            content=content,
-            embeds=embeds,
-            embed=embed,
-            components=components,
-            stickers=stickers,
-            allowed_mentions=allowed_mentions,
-            reply_to=reply_to,
-            files=files,
-            file=file,
-            tts=tts,
-            flags=flags,
-            delete_after=delete_after,
-            **kwargs,
-        )
-
-    respond = send
-
-    async def delete(self, message: "Snowflake_Type") -> None:
-        """
-        Delete a message sent in response to this interaction.
-
-        Args:
-            message: The message to delete
-        """
-        await self.client.http.delete_interaction_message(self.client.app.id, self.token, to_snowflake(message))
-
-    async def edit(
-        self,
-        message: "Snowflake_Type",
-        *,
-        content: typing.Optional[str] = None,
-        embeds: typing.Optional[
-            typing.Union[typing.Iterable[typing.Union["Embed", dict]], typing.Union["Embed", dict]]
-        ] = None,
-        embed: typing.Optional[typing.Union["Embed", dict]] = None,
-        components: typing.Optional[
-            typing.Union[
-                typing.Iterable[typing.Iterable[typing.Union["BaseComponent", dict]]],
-                typing.Iterable[typing.Union["BaseComponent", dict]],
-                "BaseComponent",
-                dict,
-            ]
-        ] = None,
-        attachments: typing.Optional[typing.Sequence[Attachment | dict]] = None,
-        allowed_mentions: typing.Optional[typing.Union["AllowedMentions", dict]] = None,
-        files: typing.Optional[typing.Union["UPLOADABLE_TYPE", typing.Iterable["UPLOADABLE_TYPE"]]] = None,
-        file: typing.Optional["UPLOADABLE_TYPE"] = None,
-        tts: bool = False,
-    ) -> "interactions.Message":
-        message_payload = process_message_payload(
-            content=content,
-            embeds=embeds or embed,
-            components=components,
-            allowed_mentions=allowed_mentions,
-            attachments=attachments,
-            tts=tts,
-        )
-
-        if file:
-            files = [file, *files] if files else [file]
-        message_data = await self.client.http.edit_interaction_message(
-            payload=message_payload,
-            application_id=self.client.app.id,
-            token=self.token,
-            message_id=to_snowflake(message),
-            files=files,
-        )
-        if message_data:
-            return self.client.cache.place_message_data(message_data)
-
-
-class SlashContext(InteractionContext, ModalMixin):
-    @classmethod
-    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
-        return super().from_dict(client, payload)
-
-
-class ContextMenuContext(InteractionContext, ModalMixin):
-    target_id: Snowflake
-    """The id of the target of the context menu."""
-    editing_origin: bool
-    """Whether you have deferred the interaction and are editing the original response."""
-    target_type: None | CommandType
-    """The type of the target of the context menu."""
-
-    def __init__(self, client: "interactions.Client") -> None:
-        super().__init__(client)
-        self.editing_origin = False
-
-    @classmethod
-    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
-        instance = super().from_dict(client, payload)
-        instance.target_id = Snowflake(payload["data"]["target_id"])
-        instance.target_type = CommandType(payload["data"]["type"])
-        return instance
-
-    async def defer(self, *, ephemeral: bool = False, edit_origin: bool = False) -> None:
-        """
-        Defer the interaction.
-
-        Args:
-            ephemeral: Whether the interaction response should be ephemeral.
-            edit_origin: Whether to edit the original message instead of sending a new one.
-        """
-        if self.deferred:
-            raise AlreadyDeferred("Interaction has already been responded to.")
-        if self.responded:
-            raise AlreadyResponded("Interaction has already been responded to.")
-
-        payload = {
-            "type": CallbackType.DEFERRED_UPDATE_MESSAGE
-            if edit_origin
-            else CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
-        }
-        if ephemeral:
-            if edit_origin:
-                raise ValueError("Cannot use ephemeral and edit_origin together.")
-            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
-
-        await self.client.http.post_initial_response(payload, self.id, self.token)
-        self.deferred = True
-        self.ephemeral = ephemeral
-        self.editing_origin = edit_origin
-
-    @property
-    def target(self) -> None | Message | User | Member:
-        """
-        The target of the context menu.
-
-        Returns:
-            The target of the context menu.
-        """
-        return self.resolved.get(self.target_id)
-
-
-class ComponentContext(InteractionContext, ModalMixin):
-    values: list[str]
-    """The values of the SelectMenu component, if any."""
-    custom_id: str
-    """The custom_id of the component."""
-    component_type: int
-    """The type of the component."""
-    defer_edit_origin: bool
-    """Whether you have deferred the interaction and are editing the original response."""
-
-    @classmethod
-    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
-        instance = super().from_dict(client, payload)
-        instance.values = payload["data"].get("values", [])
-        instance.custom_id = payload["data"]["custom_id"]
-        instance._command_id = instance.custom_id
-        instance._command_name = instance.custom_id
-        instance.component_type = payload["data"]["component_type"]
-        instance.defer_edit_origin = False
-
-        searches = {
-            "users": instance.component_type in (ComponentType.USER_SELECT, ComponentType.MENTIONABLE_SELECT),
-            "members": instance.guild_id
-            and instance.component_type in (ComponentType.USER_SELECT, ComponentType.MENTIONABLE_SELECT),
-            "channels": instance.component_type in (ComponentType.CHANNEL_SELECT, ComponentType.MENTIONABLE_SELECT),
-            "roles": instance.guild_id
-            and instance.component_type in (ComponentType.ROLE_SELECT, ComponentType.MENTIONABLE_SELECT),
-        }
-
-        if instance.component_type in (
-            ComponentType.USER_SELECT,
-            ComponentType.CHANNEL_SELECT,
-            ComponentType.ROLE_SELECT,
-            ComponentType.MENTIONABLE_SELECT,
-        ):
-            for i, value in enumerate(instance.values):
-                if re.match(r"\d{17,}", value):
-                    key = Snowflake(value)
-
-                    if resolved := instance.resolved.get(key):
-                        instance.values[i] = resolved
-                    elif searches["members"] and (member := instance.client.cache.get_member(instance.guild_id, key)):
-                        instance.values[i] = member
-                    elif searches["users"] and (user := instance.client.cache.get_user(key)):
-                        instance.values[i] = user
-                    elif searches["roles"] and (role := instance.client.cache.get_role(key)):
-                        instance.values[i] = role
-                    elif searches["channels"] and (channel := instance.client.cache.get_channel(key)):
-                        instance.values[i] = channel
-        return instance
-
-    async def defer(self, *, ephemeral: bool = False, edit_origin: bool = False) -> None:
-        """
-        Defer the interaction.
-
-        Args:
-            ephemeral: Whether the interaction response should be ephemeral.
-            edit_origin: Whether to edit the original message instead of sending a new one.
-        """
-        if self.deferred:
-            raise AlreadyDeferred("Interaction has already been responded to.")
-        if self.responded:
-            raise AlreadyResponded("Interaction has already been responded to.")
-
-        payload = {
-            "type": CallbackType.DEFERRED_UPDATE_MESSAGE
-            if edit_origin
-            else CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
-        }
-        if ephemeral:
-            if edit_origin:
-                raise ValueError("Cannot use ephemeral and edit_origin together.")
-            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
-
-        await self.client.http.post_initial_response(payload, self.id, self.token)
-        self.deferred = True
-        self.ephemeral = ephemeral
-        self.editing_origin = edit_origin
-
-    async def edit_origin(
-        self,
-        *,
-        content: typing.Optional[str] = None,
-        embeds: typing.Optional[
-            typing.Union[typing.Iterable[typing.Union["Embed", dict]], typing.Union["Embed", dict]]
-        ] = None,
-        embed: typing.Optional[typing.Union["Embed", dict]] = None,
-        components: typing.Optional[
-            typing.Union[
-                typing.Iterable[typing.Iterable[typing.Union["BaseComponent", dict]]],
-                typing.Iterable[typing.Union["BaseComponent", dict]],
-                "BaseComponent",
-                dict,
-            ]
-        ] = None,
-        allowed_mentions: typing.Optional[typing.Union["AllowedMentions", dict]] = None,
-        files: typing.Optional[typing.Union["UPLOADABLE_TYPE", typing.Iterable["UPLOADABLE_TYPE"]]] = None,
-        file: typing.Optional["UPLOADABLE_TYPE"] = None,
-        tts: bool = False,
-    ) -> "Message":
-        """
-        Edits the original message of the component.
-
-        Args:
-            content: Message text content.
-            embeds: Embedded rich content (up to 6000 characters).
-            embed: Embedded rich content (up to 6000 characters).
-            components: The components to include with the message.
-            allowed_mentions: Allowed mentions for the message.
-            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
-            tts: Should this message use Text To Speech.
-
-        Returns:
-            The message after it was edited.
-        """
-        if not self.responded and not self.deferred and (files or file):
-            # Discord doesn't allow files at initial response, so we defer then edit.
-            await self.defer(edit_origin=True)
-
-        message_payload = process_message_payload(
-            content=content,
-            embeds=embeds or embed,
-            components=components,
-            allowed_mentions=allowed_mentions,
-            tts=tts,
-        )
-
-        message_data = None
-        if self.deferred:
-            if not self.editing_origin:
-                get_logger().warning(
-                    "If you want to edit the original message, and need to defer, you must set the `edit_origin` kwarg to True!"
-                )
-
-            message_data = await self.client.http.edit_interaction_message(
-                message_payload, self.client.app.id, self.token, files=files or file
-            )
-            self.deferred = False
-            self.editing_origin = False
-        else:
-            payload = {"type": CallbackType.UPDATE_MESSAGE, "data": message_payload}
-            await self.client.http.post_initial_response(payload, str(self.id), self.token, files=files or file)
-            message_data = await self.client.http.get_interaction_message(self.client.app.id, self.token)
-
-        if message_data:
-            message = self.client.cache.place_message_data(message_data)
-            self.message_id = message.id
-            return message
-
-    @property
-    def component(self) -> typing.Optional[BaseComponent]:
-        """The component that was interacted with."""
-        if self.message is None or self.message.components is None:
-            return None
-        for action_row in self.message.components:
-            for component in action_row.components:
-                if component.custom_id == self.custom_id:
-                    return component
-
-
-class ModalContext(InteractionContext):
-    responses: dict[str, str]
-    """The responses of the modal. The key is the `custom_id` of the component."""
-    custom_id: str
-    """The developer defined custom ID of this modal"""
-    edit_origin: bool
-    """Whether to edit the original message instead of sending a new one."""
-
-    @classmethod
-    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
-        instance = super().from_dict(client, payload)
-        instance.responses = {
-            comp["components"][0]["custom_id"]: comp["components"][0]["value"] for comp in payload["data"]["components"]
-        }
-        instance.kwargs = instance.responses
-        instance.custom_id = payload["data"]["custom_id"]
-        instance.edit_origin = False
-        return instance
-
-    async def edit(self, message: "Snowflake_Type", **kwargs) -> "interactions.Message":
-        if not self.deferred and not self.responded:
-            await self.defer(edit_origin=True)
-        return await super().edit(message, **kwargs)
-
-    async def defer(self, *, ephemeral: bool = False, edit_origin: bool = False) -> None:
-        """
-        Defer the interaction.
-
-        Args:
-            ephemeral: Whether the interaction response should be ephemeral.
-            edit_origin: Whether to edit the original message instead of sending a followup.
-        """
-        if self.deferred:
-            raise AlreadyDeferred("Interaction has already been responded to.")
-        if self.responded:
-            raise AlreadyResponded("Interaction has already been responded to.")
-
-        payload = {
-            "type": CallbackType.DEFERRED_UPDATE_MESSAGE
-            if edit_origin
-            else CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
-        }
-        if ephemeral:
-            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
-
-        if edit_origin:
-            self.edit_origin = True
-
-        await self.client.http.post_initial_response(payload, self.id, self.token)
-        self.deferred = True
-        self.ephemeral = ephemeral
-
-
-class AutocompleteContext(BaseInteractionContext):
-    focussed_option: SlashCommandOption  # todo: option parsing
-    """The option the user is currently filling in."""
-
-    @classmethod
-    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
-        return super().from_dict(client, payload)
-
-    @property
-    def input_text(self) -> str:
-        """The text the user has already filled in."""
-        return self.kwargs.get(str(self.focussed_option.name), "")
-
-    def option_processing_hook(self, option: dict) -> None:
-        if option.get("focused", False):
-            self.focussed_option = SlashCommandOption.from_dict(option)
-        return
-
-    async def send(
-        self, choices: typing.Iterable[str | int | float | dict[str, int | float | str] | SlashCommandChoice]
-    ) -> None:
-        """
-        Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format:
-
-        ```json
-            {
-              "name": str,
-              "value": str
-            }
-        ```
-        Where name is the text visible in Discord, and value is the data sent back to your client when that choice is
-        chosen.
-
-        Args:
-            choices: 25 choices the user can pick
-        """
-        if self.focussed_option.type == OptionType.STRING:
-            type_cast = str
-        elif self.focussed_option.type == OptionType.INTEGER:
-            type_cast = int
-        elif self.focussed_option.type == OptionType.NUMBER:
-            type_cast = float
-        else:
-            type_cast = None
-
-        processed_choices = []
-        for choice in choices:
-            if isinstance(choice, dict):
-                name = choice["name"]
-                value = choice["value"]
-            elif isinstance(choice, SlashCommandChoice):
-                name = choice.name.get_locale(self.locale)
-                value = choice.value
-            else:
-                name = str(choice)
-                value = choice
-
-            processed_choices.append({"name": name, "value": type_cast(value) if type_cast else value})
-
-        payload = {"type": CallbackType.AUTOCOMPLETE_RESULT, "data": {"choices": processed_choices}}
-        await self.client.http.post_initial_response(payload, self.id, self.token)
+import abc
+import datetime
+import re
+import typing
+from typing_extensions import Self
+
+import discord_typings
+from aiohttp import FormData
+
+from interactions.client import const
+from interactions.client.const import get_logger, MISSING
+from interactions.models.discord.components import BaseComponent
+from interactions.models.discord.file import UPLOADABLE_TYPE
+from interactions.models.discord.sticker import Sticker
+from interactions.models.discord.user import Member, User
+
+from interactions.models.internal.command import BaseCommand
+from interactions.client.mixins.modal import ModalMixin
+
+from interactions.client.errors import HTTPException, AlreadyDeferred, AlreadyResponded
+from interactions.client.mixins.send import SendMixin
+from interactions.models.discord.enums import (
+    Permissions,
+    MessageFlags,
+    InteractionType,
+    ComponentType,
+    CommandType,
+)
+from interactions.models.discord.message import (
+    AllowedMentions,
+    Attachment,
+    Message,
+    MessageReference,
+    process_message_payload,
+)
+from interactions.models.discord.snowflake import Snowflake, Snowflake_Type, to_snowflake, to_optional_snowflake
+from interactions.models.discord.embed import Embed
+from interactions.models.internal.application_commands import (
+    OptionType,
+    CallbackType,
+    SlashCommandChoice,
+    SlashCommandOption,
+    InteractionCommand,
+)
+
+__all__ = (
+    "AutocompleteContext",
+    "BaseContext",
+    "BaseInteractionContext",
+    "ComponentContext",
+    "ContextMenuContext",
+    "InteractionContext",
+    "ModalContext",
+    "Resolved",
+    "SlashContext",
+)
+
+
+if typing.TYPE_CHECKING:
+    import interactions
+
+
+class Resolved:
+    """
+    A class representing the resolved data from an interaction.
+
+    Attributes:
+        channels: A dictionary of channels resolved from the interaction.
+        members: A dictionary of members resolved from the interaction.
+        users: A dictionary of users resolved from the interaction.
+        roles: A dictionary of roles resolved from the interaction.
+        messages: A dictionary of messages resolved from the interaction.
+        attachments: A dictionary of attachments resolved from the interaction.
+    """
+
+    def __init__(self) -> None:
+        self.channels: dict[Snowflake, "interactions.TYPE_MESSAGEABLE_CHANNEL"] = {}
+        self.members: dict[Snowflake, "interactions.Member"] = {}
+        self.users: dict[Snowflake, "interactions.User"] = {}
+        self.roles: dict[Snowflake, "interactions.Role"] = {}
+        self.messages: dict[Snowflake, "interactions.Message"] = {}
+        self.attachments: dict[Snowflake, "interactions.Attachment"] = {}
+
+    def __bool__(self) -> bool:
+        """Returns whether any resolved data is present."""
+        return (
+            bool(self.channels)
+            or bool(self.members)
+            or bool(self.users)
+            or bool(self.roles)
+            or bool(self.messages)
+            or bool(self.attachments)
+        )
+
+    def get(self, snowflake: Snowflake | str, default: typing.Any = None) -> typing.Any:
+        snowflake = Snowflake(snowflake)
+        """Returns the value of the given snowflake."""
+        if channel := self.channels.get(snowflake):
+            return channel
+        if member := self.members.get(snowflake):
+            return member
+        if user := self.users.get(snowflake):
+            return user
+        if role := self.roles.get(snowflake):
+            return role
+        if message := self.messages.get(snowflake):
+            return message
+        if attachment := self.attachments.get(snowflake):
+            return attachment
+        return default
+
+    @classmethod
+    def from_dict(cls, client: "interactions.Client", data: dict, guild_id: None | Snowflake = None) -> Self:
+        instance = cls()
+
+        if channels := data.get("channels"):
+            for key, _channel in channels.items():
+                instance.channels[Snowflake(key)] = client.cache.place_channel_data(_channel)
+
+        if members := data.get("members"):
+            for key, _member in members.items():
+                instance.members[Snowflake(key)] = client.cache.place_member_data(
+                    guild_id, {**_member, "user": {**data["users"][key]}}
+                )
+
+        if users := data.get("users"):
+            for key, _user in users.items():
+                instance.users[Snowflake(key)] = client.cache.place_user_data(_user)
+
+        if roles := data.get("roles"):
+            for key, _role in roles.items():
+                instance.roles[Snowflake(key)] = client.cache.get_role(Snowflake(key))
+
+        if messages := data.get("messages"):
+            for key, _msg in messages.items():
+                instance.messages[Snowflake(key)] = client.cache.place_message_data(_msg)
+
+        if attachments := data.get("attachments"):
+            for key, _attach in attachments.items():
+                instance.attachments[Snowflake(key)] = Attachment.from_dict(_attach, client)
+
+        return instance
+
+
+class BaseContext(metaclass=abc.ABCMeta):
+    """
+    Base context class for all contexts.
+
+    Define your own context class by inheriting from this class. For compatibility with the library, you must define a `from_dict` classmethod that takes a dict and returns an instance of your context class.
+
+    """
+
+    client: "interactions.Client"
+    """The client that created this context."""
+
+    command: BaseCommand
+    """The command this context invokes."""
+
+    author_id: Snowflake
+    """The id of the user that invoked this context."""
+    channel_id: Snowflake
+    """The id of the channel this context was invoked in."""
+    message_id: Snowflake
+    """The id of the message that invoked this context."""
+
+    guild_id: typing.Optional[Snowflake]
+    """The id of the guild this context was invoked in, if any."""
+
+    def __init__(self, client: "interactions.Client") -> None:
+        self.client = client
+        self.author_id = MISSING
+        self.channel_id = MISSING
+        self.message_id = MISSING
+        self.guild_id = MISSING
+
+    @property
+    def guild(self) -> typing.Optional["interactions.Guild"]:
+        """The guild this context was invoked in."""
+        return self.client.cache.get_guild(self.guild_id)
+
+    @property
+    def user(self) -> "interactions.User":
+        """The user that invoked this context."""
+        return self.client.cache.get_user(self.author_id)
+
+    @property
+    def member(self) -> typing.Optional["interactions.Member"]:
+        """The member object that invoked this context."""
+        return self.client.cache.get_member(self.guild_id, self.author_id)
+
+    @property
+    def author(self) -> "interactions.Member | interactions.User":
+        """The member or user that invoked this context."""
+        return self.member or self.user
+
+    @property
+    def channel(self) -> "interactions.TYPE_MESSAGEABLE_CHANNEL":
+        """The channel this context was invoked in."""
+        if self.guild_id:
+            return self.client.cache.get_channel(self.channel_id)
+        return self.client.cache.get_dm_channel(self.author_id)
+
+    @property
+    def message(self) -> typing.Optional["interactions.Message"]:
+        """The message that invoked this context, if any."""
+        return self.client.cache.get_message(self.channel_id, self.message_id)
+
+    @property
+    def voice_state(self) -> typing.Optional["interactions.VoiceState"]:
+        """The current voice state of the bot in the guild this context was invoked in, if any."""
+        return self.client.cache.get_bot_voice_state(self.guild_id)
+
+    @property
+    def bot(self) -> "interactions.Client":
+        return self.client
+
+    @classmethod
+    @abc.abstractmethod
+    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
+        """
+        Create a context instance from a dict.
+
+        Args:
+            client: The client creating this context.
+            payload: The dict to create the context from.
+
+        Returns:
+            The context instance.
+
+        """
+        raise NotImplementedError
+
+
+class BaseInteractionContext(BaseContext):
+    token: str
+    """The interaction token."""
+    id: Snowflake
+    """The interaction ID."""
+
+    app_permissions: Permissions
+    """The permissions available to this interaction"""
+    locale: str
+    """The selected locale of the invoking user (https://discord.com/developers/docs/reference#locales)"""
+    guild_locale: str
+    """The selected locale of the invoking user's guild (https://discord.com/developers/docs/reference#locales)"""
+    resolved: Resolved
+    """The resolved data for this interaction."""
+
+    # state info
+    deferred: bool
+    """Whether the interaction has been deferred."""
+    responded: bool
+    """Whether the interaction has been responded to."""
+    ephemeral: bool
+    """Whether the interaction response is ephemeral."""
+
+    _context_type: int
+    """The context type of the interaction."""
+    command_id: Snowflake
+    """The command ID of the interaction."""
+    _command_name: str
+    """The command name of the interaction."""
+
+    args: list[typing.Any]
+    """The arguments passed to the interaction."""
+    kwargs: dict[str, typing.Any]
+    """The keyword arguments passed to the interaction."""
+
+    def __init__(self, client: "interactions.Client") -> None:
+        super().__init__(client)
+        self.deferred = False
+        self.responded = False
+        self.ephemeral = False
+
+    @classmethod
+    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
+        instance = cls(client=client)
+        instance.token = payload["token"]
+        instance.id = Snowflake(payload["id"])
+        instance.app_permissions = Permissions(payload.get("app_permissions", 0))
+        instance.locale = payload["locale"]
+        instance.guild_locale = payload.get("guild_locale", instance.locale)
+        instance._context_type = payload.get("type", 0)
+        instance.resolved = Resolved.from_dict(client, payload["data"].get("resolved", {}), payload.get("guild_id"))
+
+        instance.channel_id = Snowflake(payload["channel_id"])
+        if member := payload.get("member"):
+            instance.author_id = Snowflake(member["user"]["id"])
+            instance.guild_id = Snowflake(payload["guild_id"])
+            client.cache.place_member_data(instance.guild_id, member)
+        else:
+            instance.author_id = Snowflake(payload["user"]["id"])
+            client.cache.place_user_data(payload["user"])
+
+        if message_data := payload.get("message"):
+            message = client.cache.place_message_data(message_data)
+            instance.message_id = message.id
+
+        instance.guild_id = to_optional_snowflake(payload.get("guild_id"))
+
+        if payload["type"] in (InteractionType.APPLICATION_COMMAND, InteractionType.AUTOCOMPLETE):
+            instance.command_id = Snowflake(payload["data"]["id"])
+            instance._command_name = payload["data"]["name"]
+
+        instance.process_options(payload)
+
+        return instance
+
+    @property
+    def command(self) -> InteractionCommand:
+        return self.client._interaction_lookup[self._command_name]
+
+    @property
+    def expires_at(self) -> typing.Optional[datetime.datetime]:
+        """The time at which the interaction expires."""
+        if self.responded:
+            return self.id.created_at + datetime.timedelta(minutes=15)
+        return self.id.created_at + datetime.timedelta(seconds=3)
+
+    @property
+    def expired(self) -> bool:
+        """Whether the interaction has expired."""
+        return datetime.datetime.utcnow() > self.expires_at
+
+    @property
+    def invoke_target(self) -> str:
+        """The invoke target of the interaction."""
+        return self._command_name
+
+    @property
+    def deferred_ephemeral(self) -> bool:
+        """Whether the interaction has been deferred ephemerally."""
+        return self.deferred and self.ephemeral
+
+    def option_processing_hook(self, option: dict) -> typing.Any:
+        """
+        Hook for extending options processing.
+
+        This is called for each option, before the library processes it. If this returns a value, the library will not process the option further.
+
+        Args:
+            option: The option to process.
+
+        Returns:
+            The processed option.
+
+        """
+        return option
+
+    def process_options(self, data: discord_typings.InteractionCallbackData) -> None:
+        if data["type"] not in (InteractionType.APPLICATION_COMMAND, InteractionType.AUTOCOMPLETE):
+            self.args = []
+            self.kwargs = {}
+            return
+
+        def gather_options(_options: list[dict[str, typing.Any]]) -> dict[str, typing.Any]:
+            """Recursively gather options from an option list."""
+            kwargs = {}
+            for option in _options:
+                if hook_result := self.option_processing_hook(option):
+                    kwargs[option["name"]] = hook_result
+
+                if option["type"] in (OptionType.SUB_COMMAND, OptionType.SUB_COMMAND_GROUP):
+                    self._command_name = f"{self._command_name} {option['name']}"
+                    return gather_options(option["options"])
+
+                value = option.get("value")
+
+                if option["type"] in OptionType.resolvable_types():
+                    value = self.resolved.get(value, value)
+
+                kwargs[option["name"]] = value
+            return kwargs
+
+        if options := data["data"].get("options"):
+            self.kwargs = gather_options(options)  # type: ignore
+        else:
+            self.kwargs = {}
+        self.args = list(self.kwargs.values())
+
+
+class InteractionContext(BaseInteractionContext, SendMixin):
+    async def defer(self, *, ephemeral: bool = False) -> None:
+        """
+        Defer the interaction.
+
+        Args:
+            ephemeral: Whether the interaction response should be ephemeral.
+        """
+        if self.deferred:
+            raise AlreadyDeferred("Interaction has already been responded to.")
+        if self.responded:
+            raise AlreadyResponded("Interaction has already been responded to.")
+
+        payload = {"type": CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE}
+        if ephemeral:
+            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
+
+        await self.client.http.post_initial_response(payload, self.id, self.token)
+        self.deferred = True
+        self.ephemeral = ephemeral
+
+    async def _send_http_request(
+        self, message_payload: dict, files: typing.Iterable["UPLOADABLE_TYPE"] | None = None
+    ) -> dict:
+        if const.has_client_feature("FOLLOWUP_INTERACTIONS_FOR_IMAGES") and not self.deferred and not self.responded:
+            # experimental bypass for discords broken image proxy
+            if embeds := message_payload.get("embeds", {}):
+                if any(e.get("image") for e in embeds) or any(e.get("thumbnail") for e in embeds):
+                    if MessageFlags.EPHEMERAL in message_payload.get("flags", MessageFlags.NONE):
+                        self.ephemeral = True
+                    await self.defer(ephemeral=self.ephemeral)
+
+        if self.responded:
+            message_data = await self.client.http.post_followup(
+                message_payload, self.client.app.id, self.token, files=files
+            )
+        else:
+            if isinstance(message_payload, FormData) and not self.deferred:
+                await self.defer(ephemeral=self.ephemeral)
+            if self.deferred:
+                if const.has_client_feature("FOLLOWUP_INTERACTIONS_FOR_IMAGES"):
+                    message_data = await self.client.http.post_followup(
+                        message_payload, self.client.app.id, self.token, files=files
+                    )
+                else:
+                    message_data = await self.client.http.edit_interaction_message(
+                        message_payload, self.client.app.id, self.token, files=files
+                    )
+            else:
+                payload = {
+                    "type": CallbackType.CHANNEL_MESSAGE_WITH_SOURCE,
+                    "data": message_payload,
+                }
+                message_data = await self.client.http.post_initial_response(payload, self.id, self.token, files=files)
+
+        if not message_data:
+            try:
+                message_data = await self.client.http.get_interaction_message(self.client.app.id, self.token)
+            except HTTPException:
+                pass
+
+        self.responded = True
+        return message_data
+
+    async def send(
+        self,
+        content: typing.Optional[str] = None,
+        *,
+        embeds: typing.Optional[
+            typing.Union[typing.Iterable[typing.Union["Embed", dict]], typing.Union["Embed", dict]]
+        ] = None,
+        embed: typing.Optional[typing.Union["Embed", dict]] = None,
+        components: typing.Optional[
+            typing.Union[
+                typing.Iterable[typing.Iterable[typing.Union["BaseComponent", dict]]],
+                typing.Iterable[typing.Union["BaseComponent", dict]],
+                "BaseComponent",
+                dict,
+            ]
+        ] = None,
+        stickers: typing.Optional[
+            typing.Union[
+                typing.Iterable[typing.Union["Sticker", "Snowflake_Type"]],
+                "Sticker",
+                "Snowflake_Type",
+            ]
+        ] = None,
+        allowed_mentions: typing.Optional[typing.Union["AllowedMentions", dict]] = None,
+        reply_to: typing.Optional[typing.Union["MessageReference", "Message", dict, "Snowflake_Type"]] = None,
+        files: typing.Optional[typing.Union["UPLOADABLE_TYPE", typing.Iterable["UPLOADABLE_TYPE"]]] = None,
+        file: typing.Optional["UPLOADABLE_TYPE"] = None,
+        tts: bool = False,
+        suppress_embeds: bool = False,
+        silent: bool = False,
+        flags: typing.Optional[typing.Union[int, "MessageFlags"]] = None,
+        delete_after: typing.Optional[float] = None,
+        ephemeral: bool = False,
+        **kwargs: typing.Any,
+    ) -> "interactions.Message":
+        """
+        Send a message.
+
+        Args:
+            content: Message text content.
+            embeds: Embedded rich content (up to 6000 characters).
+            embed: Embedded rich content (up to 6000 characters).
+            components: The components to include with the message.
+            stickers: IDs of up to 3 stickers in the server to send in the message.
+            allowed_mentions: Allowed mentions for the message.
+            reply_to: Message to reference, must be from the same channel.
+            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            tts: Should this message use Text To Speech.
+            suppress_embeds: Should embeds be suppressed on this send
+            silent: Should this message be sent without triggering a notification.
+            flags: Message flags to apply.
+            delete_after: Delete message after this many seconds.
+            ephemeral: Whether the response should be ephemeral
+
+        Returns:
+            New message object that was sent.
+        """
+        flags = MessageFlags(flags or 0)
+        if ephemeral:
+            flags |= MessageFlags.EPHEMERAL
+            self.ephemeral = True
+        if suppress_embeds:
+            flags |= MessageFlags.SUPPRESS_EMBEDS
+        if silent:
+            flags |= MessageFlags.SILENT
+
+        return await super().send(
+            content=content,
+            embeds=embeds,
+            embed=embed,
+            components=components,
+            stickers=stickers,
+            allowed_mentions=allowed_mentions,
+            reply_to=reply_to,
+            files=files,
+            file=file,
+            tts=tts,
+            flags=flags,
+            delete_after=delete_after,
+            **kwargs,
+        )
+
+    respond = send
+
+    async def delete(self, message: "Snowflake_Type") -> None:
+        """
+        Delete a message sent in response to this interaction.
+
+        Args:
+            message: The message to delete
+        """
+        await self.client.http.delete_interaction_message(self.client.app.id, self.token, to_snowflake(message))
+
+    async def edit(
+        self,
+        message: "Snowflake_Type",
+        *,
+        content: typing.Optional[str] = None,
+        embeds: typing.Optional[
+            typing.Union[typing.Iterable[typing.Union["Embed", dict]], typing.Union["Embed", dict]]
+        ] = None,
+        embed: typing.Optional[typing.Union["Embed", dict]] = None,
+        components: typing.Optional[
+            typing.Union[
+                typing.Iterable[typing.Iterable[typing.Union["BaseComponent", dict]]],
+                typing.Iterable[typing.Union["BaseComponent", dict]],
+                "BaseComponent",
+                dict,
+            ]
+        ] = None,
+        attachments: typing.Optional[typing.Sequence[Attachment | dict]] = None,
+        allowed_mentions: typing.Optional[typing.Union["AllowedMentions", dict]] = None,
+        files: typing.Optional[typing.Union["UPLOADABLE_TYPE", typing.Iterable["UPLOADABLE_TYPE"]]] = None,
+        file: typing.Optional["UPLOADABLE_TYPE"] = None,
+        tts: bool = False,
+    ) -> "interactions.Message":
+        message_payload = process_message_payload(
+            content=content,
+            embeds=embeds or embed,
+            components=components,
+            allowed_mentions=allowed_mentions,
+            attachments=attachments,
+            tts=tts,
+        )
+
+        if file:
+            files = [file, *files] if files else [file]
+        message_data = await self.client.http.edit_interaction_message(
+            payload=message_payload,
+            application_id=self.client.app.id,
+            token=self.token,
+            message_id=to_snowflake(message),
+            files=files,
+        )
+        if message_data:
+            return self.client.cache.place_message_data(message_data)
+
+
+class SlashContext(InteractionContext, ModalMixin):
+    @classmethod
+    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
+        return super().from_dict(client, payload)
+
+
+class ContextMenuContext(InteractionContext, ModalMixin):
+    target_id: Snowflake
+    """The id of the target of the context menu."""
+    editing_origin: bool
+    """Whether you have deferred the interaction and are editing the original response."""
+    target_type: None | CommandType
+    """The type of the target of the context menu."""
+
+    def __init__(self, client: "interactions.Client") -> None:
+        super().__init__(client)
+        self.editing_origin = False
+
+    @classmethod
+    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
+        instance = super().from_dict(client, payload)
+        instance.target_id = Snowflake(payload["data"]["target_id"])
+        instance.target_type = CommandType(payload["data"]["type"])
+        return instance
+
+    async def defer(self, *, ephemeral: bool = False, edit_origin: bool = False) -> None:
+        """
+        Defer the interaction.
+
+        Args:
+            ephemeral: Whether the interaction response should be ephemeral.
+            edit_origin: Whether to edit the original message instead of sending a new one.
+        """
+        if self.deferred:
+            raise AlreadyDeferred("Interaction has already been responded to.")
+        if self.responded:
+            raise AlreadyResponded("Interaction has already been responded to.")
+
+        payload = {
+            "type": CallbackType.DEFERRED_UPDATE_MESSAGE
+            if edit_origin
+            else CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
+        }
+        if ephemeral:
+            if edit_origin:
+                raise ValueError("Cannot use ephemeral and edit_origin together.")
+            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
+
+        await self.client.http.post_initial_response(payload, self.id, self.token)
+        self.deferred = True
+        self.ephemeral = ephemeral
+        self.editing_origin = edit_origin
+
+    @property
+    def target(self) -> None | Message | User | Member:
+        """
+        The target of the context menu.
+
+        Returns:
+            The target of the context menu.
+        """
+        return self.resolved.get(self.target_id)
+
+
+class ComponentContext(InteractionContext, ModalMixin):
+    values: list[str]
+    """The values of the SelectMenu component, if any."""
+    custom_id: str
+    """The custom_id of the component."""
+    component_type: int
+    """The type of the component."""
+    defer_edit_origin: bool
+    """Whether you have deferred the interaction and are editing the original response."""
+
+    @classmethod
+    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
+        instance = super().from_dict(client, payload)
+        instance.values = payload["data"].get("values", [])
+        instance.custom_id = payload["data"]["custom_id"]
+        instance._command_id = instance.custom_id
+        instance._command_name = instance.custom_id
+        instance.component_type = payload["data"]["component_type"]
+        instance.defer_edit_origin = False
+
+        searches = {
+            "users": instance.component_type in (ComponentType.USER_SELECT, ComponentType.MENTIONABLE_SELECT),
+            "members": instance.guild_id
+            and instance.component_type in (ComponentType.USER_SELECT, ComponentType.MENTIONABLE_SELECT),
+            "channels": instance.component_type in (ComponentType.CHANNEL_SELECT, ComponentType.MENTIONABLE_SELECT),
+            "roles": instance.guild_id
+            and instance.component_type in (ComponentType.ROLE_SELECT, ComponentType.MENTIONABLE_SELECT),
+        }
+
+        if instance.component_type in (
+            ComponentType.USER_SELECT,
+            ComponentType.CHANNEL_SELECT,
+            ComponentType.ROLE_SELECT,
+            ComponentType.MENTIONABLE_SELECT,
+        ):
+            for i, value in enumerate(instance.values):
+                if re.match(r"\d{17,}", value):
+                    key = Snowflake(value)
+
+                    if resolved := instance.resolved.get(key):
+                        instance.values[i] = resolved
+                    elif searches["members"] and (member := instance.client.cache.get_member(instance.guild_id, key)):
+                        instance.values[i] = member
+                    elif searches["users"] and (user := instance.client.cache.get_user(key)):
+                        instance.values[i] = user
+                    elif searches["roles"] and (role := instance.client.cache.get_role(key)):
+                        instance.values[i] = role
+                    elif searches["channels"] and (channel := instance.client.cache.get_channel(key)):
+                        instance.values[i] = channel
+        return instance
+
+    async def defer(self, *, ephemeral: bool = False, edit_origin: bool = False) -> None:
+        """
+        Defer the interaction.
+
+        Args:
+            ephemeral: Whether the interaction response should be ephemeral.
+            edit_origin: Whether to edit the original message instead of sending a new one.
+        """
+        if self.deferred:
+            raise AlreadyDeferred("Interaction has already been responded to.")
+        if self.responded:
+            raise AlreadyResponded("Interaction has already been responded to.")
+
+        payload = {
+            "type": CallbackType.DEFERRED_UPDATE_MESSAGE
+            if edit_origin
+            else CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
+        }
+        if ephemeral:
+            if edit_origin:
+                raise ValueError("Cannot use ephemeral and edit_origin together.")
+            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
+
+        await self.client.http.post_initial_response(payload, self.id, self.token)
+        self.deferred = True
+        self.ephemeral = ephemeral
+        self.editing_origin = edit_origin
+
+    async def edit_origin(
+        self,
+        *,
+        content: typing.Optional[str] = None,
+        embeds: typing.Optional[
+            typing.Union[typing.Iterable[typing.Union["Embed", dict]], typing.Union["Embed", dict]]
+        ] = None,
+        embed: typing.Optional[typing.Union["Embed", dict]] = None,
+        components: typing.Optional[
+            typing.Union[
+                typing.Iterable[typing.Iterable[typing.Union["BaseComponent", dict]]],
+                typing.Iterable[typing.Union["BaseComponent", dict]],
+                "BaseComponent",
+                dict,
+            ]
+        ] = None,
+        allowed_mentions: typing.Optional[typing.Union["AllowedMentions", dict]] = None,
+        files: typing.Optional[typing.Union["UPLOADABLE_TYPE", typing.Iterable["UPLOADABLE_TYPE"]]] = None,
+        file: typing.Optional["UPLOADABLE_TYPE"] = None,
+        tts: bool = False,
+    ) -> "Message":
+        """
+        Edits the original message of the component.
+
+        Args:
+            content: Message text content.
+            embeds: Embedded rich content (up to 6000 characters).
+            embed: Embedded rich content (up to 6000 characters).
+            components: The components to include with the message.
+            allowed_mentions: Allowed mentions for the message.
+            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.
+            tts: Should this message use Text To Speech.
+
+        Returns:
+            The message after it was edited.
+        """
+        if not self.responded and not self.deferred and (files or file):
+            # Discord doesn't allow files at initial response, so we defer then edit.
+            await self.defer(edit_origin=True)
+
+        message_payload = process_message_payload(
+            content=content,
+            embeds=embeds or embed,
+            components=components,
+            allowed_mentions=allowed_mentions,
+            tts=tts,
+        )
+
+        message_data = None
+        if self.deferred:
+            if not self.editing_origin:
+                get_logger().warning(
+                    "If you want to edit the original message, and need to defer, you must set the `edit_origin` kwarg to True!"
+                )
+
+            message_data = await self.client.http.edit_interaction_message(
+                message_payload, self.client.app.id, self.token, files=files or file
+            )
+            self.deferred = False
+            self.editing_origin = False
+        else:
+            payload = {"type": CallbackType.UPDATE_MESSAGE, "data": message_payload}
+            await self.client.http.post_initial_response(payload, str(self.id), self.token, files=files or file)
+            message_data = await self.client.http.get_interaction_message(self.client.app.id, self.token)
+
+        if message_data:
+            message = self.client.cache.place_message_data(message_data)
+            self.message_id = message.id
+            return message
+
+    @property
+    def component(self) -> typing.Optional[BaseComponent]:
+        """The component that was interacted with."""
+        if self.message is None or self.message.components is None:
+            return None
+        for action_row in self.message.components:
+            for component in action_row.components:
+                if component.custom_id == self.custom_id:
+                    return component
+
+
+class ModalContext(InteractionContext):
+    responses: dict[str, str]
+    """The responses of the modal. The key is the `custom_id` of the component."""
+    custom_id: str
+    """The developer defined custom ID of this modal"""
+    edit_origin: bool
+    """Whether to edit the original message instead of sending a new one."""
+
+    @classmethod
+    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
+        instance = super().from_dict(client, payload)
+        instance.responses = {
+            comp["components"][0]["custom_id"]: comp["components"][0]["value"] for comp in payload["data"]["components"]
+        }
+        instance.kwargs = instance.responses
+        instance.custom_id = payload["data"]["custom_id"]
+        instance.edit_origin = False
+        return instance
+
+    async def edit(self, message: "Snowflake_Type", **kwargs) -> "interactions.Message":
+        if not self.deferred and not self.responded:
+            await self.defer(edit_origin=True)
+        return await super().edit(message, **kwargs)
+
+    async def defer(self, *, ephemeral: bool = False, edit_origin: bool = False) -> None:
+        """
+        Defer the interaction.
+
+        Args:
+            ephemeral: Whether the interaction response should be ephemeral.
+            edit_origin: Whether to edit the original message instead of sending a followup.
+        """
+        if self.deferred:
+            raise AlreadyDeferred("Interaction has already been responded to.")
+        if self.responded:
+            raise AlreadyResponded("Interaction has already been responded to.")
+
+        payload = {
+            "type": CallbackType.DEFERRED_UPDATE_MESSAGE
+            if edit_origin
+            else CallbackType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
+        }
+        if ephemeral:
+            payload["data"] = {"flags": MessageFlags.EPHEMERAL}
+
+        if edit_origin:
+            self.edit_origin = True
+
+        await self.client.http.post_initial_response(payload, self.id, self.token)
+        self.deferred = True
+        self.ephemeral = ephemeral
+
+
+class AutocompleteContext(BaseInteractionContext):
+    focussed_option: SlashCommandOption  # todo: option parsing
+    """The option the user is currently filling in."""
+
+    @classmethod
+    def from_dict(cls, client: "interactions.Client", payload: dict) -> Self:
+        return super().from_dict(client, payload)
+
+    @property
+    def input_text(self) -> str:
+        """The text the user has already filled in."""
+        return self.kwargs.get(str(self.focussed_option.name), "")
+
+    def option_processing_hook(self, option: dict) -> None:
+        if option.get("focused", False):
+            self.focussed_option = SlashCommandOption.from_dict(option)
+        return
+
+    async def send(
+        self, choices: typing.Iterable[str | int | float | dict[str, int | float | str] | SlashCommandChoice]
+    ) -> None:
+        """
+        Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format:
+
+        ```json
+            {
+              "name": str,
+              "value": str
+            }
+        ```
+        Where name is the text visible in Discord, and value is the data sent back to your client when that choice is
+        chosen.
+
+        Args:
+            choices: 25 choices the user can pick
+        """
+        if self.focussed_option.type == OptionType.STRING:
+            type_cast = str
+        elif self.focussed_option.type == OptionType.INTEGER:
+            type_cast = int
+        elif self.focussed_option.type == OptionType.NUMBER:
+            type_cast = float
+        else:
+            type_cast = None
+
+        processed_choices = []
+        for choice in choices:
+            if isinstance(choice, dict):
+                name = choice["name"]
+                value = choice["value"]
+            elif isinstance(choice, SlashCommandChoice):
+                name = choice.name.get_locale(self.locale)
+                value = choice.value
+            else:
+                name = str(choice)
+                value = choice
+
+            processed_choices.append({"name": name, "value": type_cast(value) if type_cast else value})
+
+        payload = {"type": CallbackType.AUTOCOMPLETE_RESULT, "data": {"choices": processed_choices}}
+        await self.client.http.post_initial_response(payload, self.id, self.token)
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/converters.py` & `discord-py-interactions-5.6.0/interactions/models/internal/converters.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,606 +1,606 @@
-import re
-import typing
-from typing import Any, Optional, List
-
-from interactions.client.const import T, T_co
-from interactions.client.errors import BadArgument
-from interactions.client.errors import Forbidden, HTTPException
-from interactions.models.discord.channel import (
-    BaseChannel,
-    DMChannel,
-    DM,
-    DMGroup,
-    GuildChannel,
-    GuildCategory,
-    GuildNews,
-    GuildText,
-    ThreadChannel,
-    GuildNewsThread,
-    GuildPublicThread,
-    GuildPrivateThread,
-    VoiceChannel,
-    GuildVoice,
-    GuildStageVoice,
-    TYPE_ALL_CHANNEL,
-    TYPE_DM_CHANNEL,
-    TYPE_GUILD_CHANNEL,
-    TYPE_THREAD_CHANNEL,
-    TYPE_VOICE_CHANNEL,
-    TYPE_MESSAGEABLE_CHANNEL,
-)
-from interactions.models.discord.emoji import PartialEmoji, CustomEmoji
-from interactions.models.discord.guild import Guild
-from interactions.models.discord.message import Message
-from interactions.models.discord.role import Role
-from interactions.models.discord.snowflake import SnowflakeObject
-from interactions.models.discord.user import User, Member
-from interactions.models.internal.context import BaseContext
-from interactions.models.internal.protocols import Converter
-
-__all__ = (
-    "NoArgumentConverter",
-    "IDConverter",
-    "SnowflakeConverter",
-    "MemberConverter",
-    "UserConverter",
-    "ChannelConverter",
-    "BaseChannelConverter",
-    "DMChannelConverter",
-    "DMConverter",
-    "DMGroupConverter",
-    "GuildChannelConverter",
-    "GuildNewsConverter",
-    "GuildCategoryConverter",
-    "GuildTextConverter",
-    "ThreadChannelConverter",
-    "GuildNewsThreadConverter",
-    "GuildPublicThreadConverter",
-    "GuildPrivateThreadConverter",
-    "VoiceChannelConverter",
-    "GuildVoiceConverter",
-    "GuildStageVoiceConverter",
-    "MessageableChannelConverter",
-    "RoleConverter",
-    "GuildConverter",
-    "PartialEmojiConverter",
-    "CustomEmojiConverter",
-    "MessageConverter",
-    "Greedy",
-    "MODEL_TO_CONVERTER",
-)
-
-
-class NoArgumentConverter(Converter[T_co]):
-    """
-    An indicator class for special type of converters that only uses the Context.
-
-    This is mainly needed for prefixed commands, as arguments will be "eaten up" by converters otherwise.
-    """
-
-
-class _LiteralConverter(Converter):
-    values: dict
-
-    def __init__(self, args: Any) -> None:
-        self.values = {arg: type(arg) for arg in args}
-
-    async def convert(self, ctx: BaseContext, argument: str) -> Any:
-        for arg, converter in self.values.items():
-            try:
-                if (converted := converter(argument)) == arg:
-                    return converted
-            except Exception:
-                continue
-
-        literals_list = [str(a) for a in self.values.keys()]
-        literals_str = ", ".join(literals_list[:-1]) + f", or {literals_list[-1]}"
-        raise BadArgument(f'Could not convert "{argument}" into one of {literals_str}.')
-
-
-_ID_REGEX = re.compile(r"([0-9]{15,})$")
-
-
-class IDConverter(Converter[T_co]):
-    """The base converter for objects that have snowflake IDs."""
-
-    @staticmethod
-    def _get_id_match(argument: str) -> Optional[re.Match[str]]:
-        return _ID_REGEX.match(argument)
-
-
-class SnowflakeConverter(IDConverter[SnowflakeObject]):
-    """Converts a string argument to a SnowflakeObject."""
-
-    async def convert(self, ctx: BaseContext, argument: str) -> SnowflakeObject:
-        """
-        Converts a given string to a SnowflakeObject.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID.
-
-        2. By role or channel mention.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            SnowflakeObject: The converted object.
-        """
-        match = self._get_id_match(argument) or re.match(r"<(?:@(?:!|&)?|#)([0-9]{15,})>$", argument)
-
-        if match is None:
-            raise BadArgument(argument)
-
-        return SnowflakeObject(int(match.group(1)))  # type: ignore
-
-
-class ChannelConverter(IDConverter[T_co]):
-    """The base converter for channel objects."""
-
-    def _check(self, result: BaseChannel) -> bool:
-        return True
-
-    async def convert(self, ctx: BaseContext, argument: str) -> T_co:
-        """
-        Converts a given string to a Channel object.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID.
-
-        2. By channel mention.
-
-        3. By name - the bot will search in a guild if the context has it, otherwise it will search globally.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            BaseChannel: The converted object.
-            The channel type will be of the type the converter represents.
-        """
-        match = self._get_id_match(argument) or re.match(r"<#([0-9]{15,})>$", argument)
-        result = None
-
-        if match:
-            result = await ctx.bot.fetch_channel(int(match.group(1)))
-        elif ctx.guild:
-            result = next((c for c in ctx.guild.channels if c.name == argument), None)
-        else:
-            result = next((c for c in ctx.bot.cache.channel_cache.values() if c.name == argument), None)
-
-        if not result:
-            raise BadArgument(f'Channel "{argument}" not found.')
-
-        if self._check(result):
-            return result  # type: ignore
-
-        raise BadArgument(f'Channel "{argument}" not found.')
-
-
-class BaseChannelConverter(ChannelConverter[BaseChannel]):
-    pass
-
-
-class DMChannelConverter(ChannelConverter[DMChannel]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, DMChannel)
-
-
-class DMConverter(ChannelConverter[DM]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, DM)
-
-
-class DMGroupConverter(ChannelConverter[DMGroup]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, DMGroup)
-
-
-class GuildChannelConverter(ChannelConverter[GuildChannel]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildChannel)
-
-
-class GuildNewsConverter(ChannelConverter[GuildNews]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildNews)
-
-
-class GuildCategoryConverter(ChannelConverter[GuildCategory]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildCategory)
-
-
-class GuildTextConverter(ChannelConverter[GuildText]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildText)
-
-
-class ThreadChannelConverter(ChannelConverter[ThreadChannel]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, ThreadChannel)
-
-
-class GuildNewsThreadConverter(ChannelConverter[GuildNewsThread]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildNewsThread)
-
-
-class GuildPublicThreadConverter(ChannelConverter[GuildPublicThread]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildPublicThread)
-
-
-class GuildPrivateThreadConverter(ChannelConverter[GuildPrivateThread]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildPrivateThread)
-
-
-class VoiceChannelConverter(ChannelConverter[VoiceChannel]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, VoiceChannel)
-
-
-class GuildVoiceConverter(ChannelConverter[GuildVoice]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildVoice)
-
-
-class GuildStageVoiceConverter(ChannelConverter[GuildStageVoice]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, GuildStageVoice)
-
-
-_MESSAGEABLE_CHANNEL_TYPES = typing.get_args(TYPE_MESSAGEABLE_CHANNEL)
-
-
-class MessageableChannelConverter(ChannelConverter[TYPE_MESSAGEABLE_CHANNEL]):
-    def _check(self, result: BaseChannel) -> bool:
-        return isinstance(result, _MESSAGEABLE_CHANNEL_TYPES)
-
-
-class UserConverter(IDConverter[User]):
-    """Converts a string argument to a User object."""
-
-    async def convert(self, ctx: BaseContext, argument: str) -> User:
-        """
-        Converts a given string to a User object.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID.
-
-        2. By mention.
-
-        3. By username + tag (ex User#1234).
-
-        4. By username.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            User: The converted object.
-        """
-        match = self._get_id_match(argument) or re.match(r"<@!?([0-9]{15,})>$", argument)
-        result = None
-
-        if match:
-            result = await ctx.bot.fetch_user(int(match.group(1)))
-        else:
-            if len(argument) > 5 and argument[-5] == "#":
-                result = next((u for u in ctx.bot.cache.user_cache.values() if u.tag == argument), None)
-
-            if not result:
-                result = next((u for u in ctx.bot.cache.user_cache.values() if u.username == argument), None)
-
-        if not result:
-            raise BadArgument(f'User "{argument}" not found.')
-
-        return result
-
-
-class MemberConverter(IDConverter[Member]):
-    """Converts a string argument to a Member object."""
-
-    def _get_member_from_list(self, members: list[Member], argument: str) -> Optional[Member]:
-        # sourcery skip: assign-if-exp
-        result = None
-        if len(argument) > 5 and argument[-5] == "#":
-            result = next((m for m in members if m.user.tag == argument), None)
-
-        if not result:
-            result = next(
-                (m for m in members if m.display_name == argument or m.user.username == argument),
-                None,
-            )
-
-        return result
-
-    async def convert(self, ctx: BaseContext, argument: str) -> Member:
-        """
-        Converts a given string to a Member object. This will only work in guilds.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID.
-
-        2. By mention.
-
-        3. By username + tag (ex User#1234).
-
-        4. By nickname.
-
-        5. By username.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            Member: The converted object.
-        """
-        if not ctx.guild:
-            raise BadArgument("This command cannot be used in private messages.")
-
-        match = self._get_id_match(argument) or re.match(r"<@!?([0-9]{15,})>$", argument)
-        result = None
-
-        if match:
-            result = await ctx.guild.fetch_member(int(match.group(1)))
-        elif ctx.guild.chunked:
-            result = self._get_member_from_list(ctx.guild.members, argument)
-        else:
-            query = argument
-            if len(argument) > 5 and argument[-5] == "#":
-                query, _, _ = argument.rpartition("#")
-
-            members = await ctx.guild.search_members(query, limit=100)
-            result = self._get_member_from_list(members, argument)
-
-        if not result:
-            raise BadArgument(f'Member "{argument}" not found.')
-
-        return result
-
-
-class MessageConverter(Converter[Message]):
-    """Converts a string argument to a Message object."""
-
-    # either just the id or <chan_id>-<mes_id>, a format you can get by shift clicking "copy id"
-    _ID_REGEX = re.compile(r"(?:(?P<channel_id>[0-9]{15,})-)?(?P<message_id>[0-9]{15,})")
-    # of course, having a way to get it from a link is nice
-    _MESSAGE_LINK_REGEX = re.compile(
-        r"https?://[\S]*?discord(?:app)?\.com/channels/(?P<guild_id>[0-9]{15,}|@me)/(?P<channel_id>[0-9]{15,})/(?P<message_id>[0-9]{15,})\/?$"
-    )
-
-    async def convert(self, ctx: BaseContext, argument: str) -> Message:
-        """
-        Converts a given string to a Message object.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID. The message must be in the same channel as the context.
-
-        2. By message + channel ID in the format of "{Channel ID}-{Message ID}". This can be obtained by shift clicking "Copy ID" when Developer Mode is enabled.
-
-        3. By message link.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            Message: The converted object.
-        """
-        match = self._ID_REGEX.match(argument) or self._MESSAGE_LINK_REGEX.match(argument)
-        if not match:
-            raise BadArgument(f'Message "{argument}" not found.')
-
-        data = match.groupdict()
-
-        message_id = data["message_id"]
-        channel_id = int(data["channel_id"]) if data.get("channel_id") else ctx.channel.id
-
-        # this guild checking is technically unnecessary, but we do it just in case
-        # it means a user cant just provide an invalid guild id and still get a message
-        guild_id = data["guild_id"] if data.get("guild_id") else ctx.guild_id
-        guild_id = int(guild_id) if guild_id != "@me" else None
-
-        try:
-            # this takes less possible requests than getting the guild and/or channel
-            mes = await ctx.bot.cache.fetch_message(channel_id, message_id)
-            if mes._guild_id != guild_id:
-                raise BadArgument(f'Message "{argument}" not found.')
-            return mes
-        except Forbidden as e:
-            raise BadArgument(f"Cannot read messages for <#{channel_id}>.") from e
-        except HTTPException as e:
-            raise BadArgument(f'Message "{argument}" not found.') from e
-
-
-class GuildConverter(IDConverter[Guild]):
-    """Converts a string argument to a Guild object."""
-
-    async def convert(self, ctx: BaseContext, argument: str) -> Guild:
-        """
-        Converts a given string to a Guild object.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID.
-
-        2. By name.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            Guild: The converted object.
-        """
-        match = self._get_id_match(argument)
-        result = None
-
-        if match:
-            result = await ctx.bot.fetch_guild(int(match.group(1)))
-        else:
-            result = next((g for g in ctx.bot.guilds if g.name == argument), None)
-
-        if not result:
-            raise BadArgument(f'Guild "{argument}" not found.')
-
-        return result
-
-
-class RoleConverter(IDConverter[Role]):
-    """Converts a string argument to a Role object."""
-
-    async def convert(self, ctx: BaseContext, argument: str) -> Role:
-        """
-        Converts a given string to a Role object.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID.
-
-        2. By mention.
-
-        3. By name.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            Role: The converted object.
-        """
-        if not ctx.guild:
-            raise BadArgument("This command cannot be used in private messages.")
-
-        match = self._get_id_match(argument) or re.match(r"<@&([0-9]{15,})>$", argument)
-        result = None
-
-        if match:
-            result = await ctx.guild.fetch_role(int(match.group(1)))
-        else:
-            result = next((r for r in ctx.guild.roles if r.name == argument), None)
-
-        if not result:
-            raise BadArgument(f'Role "{argument}" not found.')
-
-        return result
-
-
-class PartialEmojiConverter(IDConverter[PartialEmoji]):
-    """Converts a string argument to a PartialEmoji object."""
-
-    async def convert(self, ctx: BaseContext, argument: str) -> PartialEmoji:
-        """
-        Converts a given string to a PartialEmoji object.
-
-        This converter only accepts emoji strings.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            PartialEmoji: The converted object.
-        """
-        if match := re.match(r"<a?:[a-zA-Z0-9\_]{1,32}:([0-9]{15,})>$", argument):
-            emoji_animated = bool(match[1])
-            emoji_name = match[2]
-            emoji_id = int(match[3])
-
-            return PartialEmoji(id=emoji_id, name=emoji_name, animated=emoji_animated)  # type: ignore
-
-        raise BadArgument(f'Couldn\'t convert "{argument}" to {PartialEmoji.__name__}.')
-
-
-class CustomEmojiConverter(IDConverter[CustomEmoji]):
-    """Converts a string argument to a CustomEmoji object."""
-
-    async def convert(self, ctx: BaseContext, argument: str) -> CustomEmoji:
-        """
-        Converts a given string to a CustomEmoji object.
-
-        The lookup strategy is as follows:
-
-        1. By raw snowflake ID.
-
-        2. By the emoji string format.
-
-        3. By name.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            CustomEmoji: The converted object.
-        """
-        if not ctx.guild:
-            raise BadArgument("This command cannot be used in private messages.")
-
-        match = self._get_id_match(argument) or re.match(r"<a?:[a-zA-Z0-9\_]{1,32}:([0-9]{15,})>$", argument)
-        result = None
-
-        if match:
-            result = await ctx.guild.fetch_custom_emoji(int(match.group(1)))
-        else:
-            if ctx.bot.cache.enable_emoji_cache:
-                emojis = ctx.bot.cache.emoji_cache.values()  # type: ignore
-                result = next((e for e in emojis if e.name == argument))
-
-            if not result:
-                emojis = await ctx.guild.fetch_all_custom_emojis()
-                result = next((e for e in emojis if e.name == argument))
-
-        if not result:
-            raise BadArgument(f'Emoji "{argument}" not found.')
-
-        return result
-
-
-class Greedy(List[T]):
-    """A special marker class to mark an argument in a prefixed command to repeatedly convert until it fails to convert an argument."""
-
-
-MODEL_TO_CONVERTER: dict[type, type[Converter]] = {
-    SnowflakeObject: SnowflakeConverter,
-    BaseChannel: BaseChannelConverter,
-    DMChannel: DMChannelConverter,
-    DM: DMConverter,
-    DMGroup: DMGroupConverter,
-    GuildChannel: GuildChannelConverter,
-    GuildNews: GuildNewsConverter,
-    GuildCategory: GuildCategoryConverter,
-    GuildText: GuildTextConverter,
-    ThreadChannel: ThreadChannelConverter,
-    GuildNewsThread: GuildNewsThreadConverter,
-    GuildPublicThread: GuildPublicThreadConverter,
-    GuildPrivateThread: GuildPrivateThreadConverter,
-    VoiceChannel: VoiceChannelConverter,
-    GuildVoice: GuildVoiceConverter,
-    GuildStageVoice: GuildStageVoiceConverter,
-    TYPE_ALL_CHANNEL: BaseChannelConverter,
-    TYPE_DM_CHANNEL: DMChannelConverter,
-    TYPE_GUILD_CHANNEL: GuildChannelConverter,
-    TYPE_THREAD_CHANNEL: ThreadChannelConverter,
-    TYPE_VOICE_CHANNEL: VoiceChannelConverter,
-    TYPE_MESSAGEABLE_CHANNEL: MessageableChannelConverter,
-    User: UserConverter,
-    Member: MemberConverter,
-    Message: MessageConverter,
-    Guild: GuildConverter,
-    Role: RoleConverter,
-    PartialEmoji: PartialEmojiConverter,
-    CustomEmoji: CustomEmojiConverter,
-}
-"""A dictionary mapping of interactions objects to their corresponding converters."""
+import re
+import typing
+from typing import Any, Optional, List
+
+from interactions.client.const import T, T_co
+from interactions.client.errors import BadArgument
+from interactions.client.errors import Forbidden, HTTPException
+from interactions.models.discord.channel import (
+    BaseChannel,
+    DMChannel,
+    DM,
+    DMGroup,
+    GuildChannel,
+    GuildCategory,
+    GuildNews,
+    GuildText,
+    ThreadChannel,
+    GuildNewsThread,
+    GuildPublicThread,
+    GuildPrivateThread,
+    VoiceChannel,
+    GuildVoice,
+    GuildStageVoice,
+    TYPE_ALL_CHANNEL,
+    TYPE_DM_CHANNEL,
+    TYPE_GUILD_CHANNEL,
+    TYPE_THREAD_CHANNEL,
+    TYPE_VOICE_CHANNEL,
+    TYPE_MESSAGEABLE_CHANNEL,
+)
+from interactions.models.discord.emoji import PartialEmoji, CustomEmoji
+from interactions.models.discord.guild import Guild
+from interactions.models.discord.message import Message
+from interactions.models.discord.role import Role
+from interactions.models.discord.snowflake import SnowflakeObject
+from interactions.models.discord.user import User, Member
+from interactions.models.internal.context import BaseContext
+from interactions.models.internal.protocols import Converter
+
+__all__ = (
+    "NoArgumentConverter",
+    "IDConverter",
+    "SnowflakeConverter",
+    "MemberConverter",
+    "UserConverter",
+    "ChannelConverter",
+    "BaseChannelConverter",
+    "DMChannelConverter",
+    "DMConverter",
+    "DMGroupConverter",
+    "GuildChannelConverter",
+    "GuildNewsConverter",
+    "GuildCategoryConverter",
+    "GuildTextConverter",
+    "ThreadChannelConverter",
+    "GuildNewsThreadConverter",
+    "GuildPublicThreadConverter",
+    "GuildPrivateThreadConverter",
+    "VoiceChannelConverter",
+    "GuildVoiceConverter",
+    "GuildStageVoiceConverter",
+    "MessageableChannelConverter",
+    "RoleConverter",
+    "GuildConverter",
+    "PartialEmojiConverter",
+    "CustomEmojiConverter",
+    "MessageConverter",
+    "Greedy",
+    "MODEL_TO_CONVERTER",
+)
+
+
+class NoArgumentConverter(Converter[T_co]):
+    """
+    An indicator class for special type of converters that only uses the Context.
+
+    This is mainly needed for prefixed commands, as arguments will be "eaten up" by converters otherwise.
+    """
+
+
+class _LiteralConverter(Converter):
+    values: dict
+
+    def __init__(self, args: Any) -> None:
+        self.values = {arg: type(arg) for arg in args}
+
+    async def convert(self, ctx: BaseContext, argument: str) -> Any:
+        for arg, converter in self.values.items():
+            try:
+                if (converted := converter(argument)) == arg:
+                    return converted
+            except Exception:
+                continue
+
+        literals_list = [str(a) for a in self.values.keys()]
+        literals_str = ", ".join(literals_list[:-1]) + f", or {literals_list[-1]}"
+        raise BadArgument(f'Could not convert "{argument}" into one of {literals_str}.')
+
+
+_ID_REGEX = re.compile(r"([0-9]{15,})$")
+
+
+class IDConverter(Converter[T_co]):
+    """The base converter for objects that have snowflake IDs."""
+
+    @staticmethod
+    def _get_id_match(argument: str) -> Optional[re.Match[str]]:
+        return _ID_REGEX.match(argument)
+
+
+class SnowflakeConverter(IDConverter[SnowflakeObject]):
+    """Converts a string argument to a SnowflakeObject."""
+
+    async def convert(self, ctx: BaseContext, argument: str) -> SnowflakeObject:
+        """
+        Converts a given string to a SnowflakeObject.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID.
+
+        2. By role or channel mention.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            SnowflakeObject: The converted object.
+        """
+        match = self._get_id_match(argument) or re.match(r"<(?:@(?:!|&)?|#)([0-9]{15,})>$", argument)
+
+        if match is None:
+            raise BadArgument(argument)
+
+        return SnowflakeObject(int(match.group(1)))  # type: ignore
+
+
+class ChannelConverter(IDConverter[T_co]):
+    """The base converter for channel objects."""
+
+    def _check(self, result: BaseChannel) -> bool:
+        return True
+
+    async def convert(self, ctx: BaseContext, argument: str) -> T_co:
+        """
+        Converts a given string to a Channel object.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID.
+
+        2. By channel mention.
+
+        3. By name - the bot will search in a guild if the context has it, otherwise it will search globally.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            BaseChannel: The converted object.
+            The channel type will be of the type the converter represents.
+        """
+        match = self._get_id_match(argument) or re.match(r"<#([0-9]{15,})>$", argument)
+        result = None
+
+        if match:
+            result = await ctx.bot.fetch_channel(int(match.group(1)))
+        elif ctx.guild:
+            result = next((c for c in ctx.guild.channels if c.name == argument), None)
+        else:
+            result = next((c for c in ctx.bot.cache.channel_cache.values() if c.name == argument), None)
+
+        if not result:
+            raise BadArgument(f'Channel "{argument}" not found.')
+
+        if self._check(result):
+            return result  # type: ignore
+
+        raise BadArgument(f'Channel "{argument}" not found.')
+
+
+class BaseChannelConverter(ChannelConverter[BaseChannel]):
+    pass
+
+
+class DMChannelConverter(ChannelConverter[DMChannel]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, DMChannel)
+
+
+class DMConverter(ChannelConverter[DM]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, DM)
+
+
+class DMGroupConverter(ChannelConverter[DMGroup]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, DMGroup)
+
+
+class GuildChannelConverter(ChannelConverter[GuildChannel]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildChannel)
+
+
+class GuildNewsConverter(ChannelConverter[GuildNews]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildNews)
+
+
+class GuildCategoryConverter(ChannelConverter[GuildCategory]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildCategory)
+
+
+class GuildTextConverter(ChannelConverter[GuildText]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildText)
+
+
+class ThreadChannelConverter(ChannelConverter[ThreadChannel]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, ThreadChannel)
+
+
+class GuildNewsThreadConverter(ChannelConverter[GuildNewsThread]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildNewsThread)
+
+
+class GuildPublicThreadConverter(ChannelConverter[GuildPublicThread]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildPublicThread)
+
+
+class GuildPrivateThreadConverter(ChannelConverter[GuildPrivateThread]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildPrivateThread)
+
+
+class VoiceChannelConverter(ChannelConverter[VoiceChannel]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, VoiceChannel)
+
+
+class GuildVoiceConverter(ChannelConverter[GuildVoice]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildVoice)
+
+
+class GuildStageVoiceConverter(ChannelConverter[GuildStageVoice]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, GuildStageVoice)
+
+
+_MESSAGEABLE_CHANNEL_TYPES = typing.get_args(TYPE_MESSAGEABLE_CHANNEL)
+
+
+class MessageableChannelConverter(ChannelConverter[TYPE_MESSAGEABLE_CHANNEL]):
+    def _check(self, result: BaseChannel) -> bool:
+        return isinstance(result, _MESSAGEABLE_CHANNEL_TYPES)
+
+
+class UserConverter(IDConverter[User]):
+    """Converts a string argument to a User object."""
+
+    async def convert(self, ctx: BaseContext, argument: str) -> User:
+        """
+        Converts a given string to a User object.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID.
+
+        2. By mention.
+
+        3. By username + tag (ex User#1234).
+
+        4. By username.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            User: The converted object.
+        """
+        match = self._get_id_match(argument) or re.match(r"<@!?([0-9]{15,})>$", argument)
+        result = None
+
+        if match:
+            result = await ctx.bot.fetch_user(int(match.group(1)))
+        else:
+            if len(argument) > 5 and argument[-5] == "#":
+                result = next((u for u in ctx.bot.cache.user_cache.values() if u.tag == argument), None)
+
+            if not result:
+                result = next((u for u in ctx.bot.cache.user_cache.values() if u.username == argument), None)
+
+        if not result:
+            raise BadArgument(f'User "{argument}" not found.')
+
+        return result
+
+
+class MemberConverter(IDConverter[Member]):
+    """Converts a string argument to a Member object."""
+
+    def _get_member_from_list(self, members: list[Member], argument: str) -> Optional[Member]:
+        # sourcery skip: assign-if-exp
+        result = None
+        if len(argument) > 5 and argument[-5] == "#":
+            result = next((m for m in members if m.user.tag == argument), None)
+
+        if not result:
+            result = next(
+                (m for m in members if m.display_name == argument or m.user.username == argument),
+                None,
+            )
+
+        return result
+
+    async def convert(self, ctx: BaseContext, argument: str) -> Member:
+        """
+        Converts a given string to a Member object. This will only work in guilds.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID.
+
+        2. By mention.
+
+        3. By username + tag (ex User#1234).
+
+        4. By nickname.
+
+        5. By username.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            Member: The converted object.
+        """
+        if not ctx.guild:
+            raise BadArgument("This command cannot be used in private messages.")
+
+        match = self._get_id_match(argument) or re.match(r"<@!?([0-9]{15,})>$", argument)
+        result = None
+
+        if match:
+            result = await ctx.guild.fetch_member(int(match.group(1)))
+        elif ctx.guild.chunked:
+            result = self._get_member_from_list(ctx.guild.members, argument)
+        else:
+            query = argument
+            if len(argument) > 5 and argument[-5] == "#":
+                query, _, _ = argument.rpartition("#")
+
+            members = await ctx.guild.search_members(query, limit=100)
+            result = self._get_member_from_list(members, argument)
+
+        if not result:
+            raise BadArgument(f'Member "{argument}" not found.')
+
+        return result
+
+
+class MessageConverter(Converter[Message]):
+    """Converts a string argument to a Message object."""
+
+    # either just the id or <chan_id>-<mes_id>, a format you can get by shift clicking "copy id"
+    _ID_REGEX = re.compile(r"(?:(?P<channel_id>[0-9]{15,})-)?(?P<message_id>[0-9]{15,})")
+    # of course, having a way to get it from a link is nice
+    _MESSAGE_LINK_REGEX = re.compile(
+        r"https?://[\S]*?discord(?:app)?\.com/channels/(?P<guild_id>[0-9]{15,}|@me)/(?P<channel_id>[0-9]{15,})/(?P<message_id>[0-9]{15,})\/?$"
+    )
+
+    async def convert(self, ctx: BaseContext, argument: str) -> Message:
+        """
+        Converts a given string to a Message object.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID. The message must be in the same channel as the context.
+
+        2. By message + channel ID in the format of "{Channel ID}-{Message ID}". This can be obtained by shift clicking "Copy ID" when Developer Mode is enabled.
+
+        3. By message link.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            Message: The converted object.
+        """
+        match = self._ID_REGEX.match(argument) or self._MESSAGE_LINK_REGEX.match(argument)
+        if not match:
+            raise BadArgument(f'Message "{argument}" not found.')
+
+        data = match.groupdict()
+
+        message_id = data["message_id"]
+        channel_id = int(data["channel_id"]) if data.get("channel_id") else ctx.channel.id
+
+        # this guild checking is technically unnecessary, but we do it just in case
+        # it means a user cant just provide an invalid guild id and still get a message
+        guild_id = data["guild_id"] if data.get("guild_id") else ctx.guild_id
+        guild_id = int(guild_id) if guild_id != "@me" else None
+
+        try:
+            # this takes less possible requests than getting the guild and/or channel
+            mes = await ctx.bot.cache.fetch_message(channel_id, message_id)
+            if mes._guild_id != guild_id:
+                raise BadArgument(f'Message "{argument}" not found.')
+            return mes
+        except Forbidden as e:
+            raise BadArgument(f"Cannot read messages for <#{channel_id}>.") from e
+        except HTTPException as e:
+            raise BadArgument(f'Message "{argument}" not found.') from e
+
+
+class GuildConverter(IDConverter[Guild]):
+    """Converts a string argument to a Guild object."""
+
+    async def convert(self, ctx: BaseContext, argument: str) -> Guild:
+        """
+        Converts a given string to a Guild object.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID.
+
+        2. By name.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            Guild: The converted object.
+        """
+        match = self._get_id_match(argument)
+        result = None
+
+        if match:
+            result = await ctx.bot.fetch_guild(int(match.group(1)))
+        else:
+            result = next((g for g in ctx.bot.guilds if g.name == argument), None)
+
+        if not result:
+            raise BadArgument(f'Guild "{argument}" not found.')
+
+        return result
+
+
+class RoleConverter(IDConverter[Role]):
+    """Converts a string argument to a Role object."""
+
+    async def convert(self, ctx: BaseContext, argument: str) -> Role:
+        """
+        Converts a given string to a Role object.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID.
+
+        2. By mention.
+
+        3. By name.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            Role: The converted object.
+        """
+        if not ctx.guild:
+            raise BadArgument("This command cannot be used in private messages.")
+
+        match = self._get_id_match(argument) or re.match(r"<@&([0-9]{15,})>$", argument)
+        result = None
+
+        if match:
+            result = await ctx.guild.fetch_role(int(match.group(1)))
+        else:
+            result = next((r for r in ctx.guild.roles if r.name == argument), None)
+
+        if not result:
+            raise BadArgument(f'Role "{argument}" not found.')
+
+        return result
+
+
+class PartialEmojiConverter(IDConverter[PartialEmoji]):
+    """Converts a string argument to a PartialEmoji object."""
+
+    async def convert(self, ctx: BaseContext, argument: str) -> PartialEmoji:
+        """
+        Converts a given string to a PartialEmoji object.
+
+        This converter only accepts emoji strings.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            PartialEmoji: The converted object.
+        """
+        if match := re.match(r"<a?:[a-zA-Z0-9\_]{1,32}:([0-9]{15,})>$", argument):
+            emoji_animated = bool(match[1])
+            emoji_name = match[2]
+            emoji_id = int(match[3])
+
+            return PartialEmoji(id=emoji_id, name=emoji_name, animated=emoji_animated)  # type: ignore
+
+        raise BadArgument(f'Couldn\'t convert "{argument}" to {PartialEmoji.__name__}.')
+
+
+class CustomEmojiConverter(IDConverter[CustomEmoji]):
+    """Converts a string argument to a CustomEmoji object."""
+
+    async def convert(self, ctx: BaseContext, argument: str) -> CustomEmoji:
+        """
+        Converts a given string to a CustomEmoji object.
+
+        The lookup strategy is as follows:
+
+        1. By raw snowflake ID.
+
+        2. By the emoji string format.
+
+        3. By name.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            CustomEmoji: The converted object.
+        """
+        if not ctx.guild:
+            raise BadArgument("This command cannot be used in private messages.")
+
+        match = self._get_id_match(argument) or re.match(r"<a?:[a-zA-Z0-9\_]{1,32}:([0-9]{15,})>$", argument)
+        result = None
+
+        if match:
+            result = await ctx.guild.fetch_custom_emoji(int(match.group(1)))
+        else:
+            if ctx.bot.cache.enable_emoji_cache:
+                emojis = ctx.bot.cache.emoji_cache.values()  # type: ignore
+                result = next((e for e in emojis if e.name == argument))
+
+            if not result:
+                emojis = await ctx.guild.fetch_all_custom_emojis()
+                result = next((e for e in emojis if e.name == argument))
+
+        if not result:
+            raise BadArgument(f'Emoji "{argument}" not found.')
+
+        return result
+
+
+class Greedy(List[T]):
+    """A special marker class to mark an argument in a prefixed command to repeatedly convert until it fails to convert an argument."""
+
+
+MODEL_TO_CONVERTER: dict[type, type[Converter]] = {
+    SnowflakeObject: SnowflakeConverter,
+    BaseChannel: BaseChannelConverter,
+    DMChannel: DMChannelConverter,
+    DM: DMConverter,
+    DMGroup: DMGroupConverter,
+    GuildChannel: GuildChannelConverter,
+    GuildNews: GuildNewsConverter,
+    GuildCategory: GuildCategoryConverter,
+    GuildText: GuildTextConverter,
+    ThreadChannel: ThreadChannelConverter,
+    GuildNewsThread: GuildNewsThreadConverter,
+    GuildPublicThread: GuildPublicThreadConverter,
+    GuildPrivateThread: GuildPrivateThreadConverter,
+    VoiceChannel: VoiceChannelConverter,
+    GuildVoice: GuildVoiceConverter,
+    GuildStageVoice: GuildStageVoiceConverter,
+    TYPE_ALL_CHANNEL: BaseChannelConverter,
+    TYPE_DM_CHANNEL: DMChannelConverter,
+    TYPE_GUILD_CHANNEL: GuildChannelConverter,
+    TYPE_THREAD_CHANNEL: ThreadChannelConverter,
+    TYPE_VOICE_CHANNEL: VoiceChannelConverter,
+    TYPE_MESSAGEABLE_CHANNEL: MessageableChannelConverter,
+    User: UserConverter,
+    Member: MemberConverter,
+    Message: MessageConverter,
+    Guild: GuildConverter,
+    Role: RoleConverter,
+    PartialEmoji: PartialEmojiConverter,
+    CustomEmoji: CustomEmojiConverter,
+}
+"""A dictionary mapping of interactions objects to their corresponding converters."""
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/cooldowns.py` & `discord-py-interactions-5.6.0/interactions/models/internal/cooldowns.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,523 +1,523 @@
-import asyncio
-import time
-import typing
-from enum import IntEnum
-from typing import TYPE_CHECKING, Any, Dict, Type
-
-if TYPE_CHECKING:
-    from interactions.models.internal.context import BaseContext
-
-__all__ = (
-    "Buckets",
-    "Cooldown",
-    "CooldownSystem",
-    "SlidingWindowSystem",
-    "ExponentialBackoffSystem",
-    "LeakyBucketSystem",
-    "TokenBucketSystem",
-    "MaxConcurrency",
-)
-
-
-class Buckets(IntEnum):
-    """
-    Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used.
-
-    ??? note
-         To add your own, override this
-
-    """
-
-    DEFAULT = 0
-    """Default is the same as user"""
-    USER = 1
-    """Per user cooldowns"""
-    GUILD = 2
-    """Per guild cooldowns"""
-    CHANNEL = 3
-    """Per channel cooldowns"""
-    MEMBER = 4
-    """Per guild member cooldowns"""
-    CATEGORY = 5
-    """Per category cooldowns"""
-    ROLE = 6
-    """Per role cooldowns"""
-
-    async def get_key(self, context: "BaseContext") -> Any:
-        if self is Buckets.USER:
-            return context.author.id
-        if self is Buckets.GUILD:
-            return context.guild_id if context.guild else context.author.id
-        if self is Buckets.CHANNEL:
-            return context.channel.id
-        if self is Buckets.MEMBER:
-            return (context.guild_id, context.author.id) if context.guild else context.author.id
-        if self is Buckets.CATEGORY:
-            return await context.channel.parent_id if context.channel.parent else context.channel.id
-        if self is Buckets.ROLE:
-            return context.author.top_role.id if context.guild else context.channel.id
-        return context.author.id
-
-    def __call__(self, context: "BaseContext") -> Any:
-        return self.get_key(context)
-
-
-class CooldownSystem:
-    """
-    A basic cooldown strategy that allows a specific number of commands to be executed within a given interval. Once the rate is reached, no more tokens can be acquired until the interval has passed.
-
-    Attributes:
-        rate: The number of commands allowed per interval.
-        interval: The time window (in seconds) within which the allowed number of commands can be executed.
-
-    ??? tip "Example Use-case"
-        This strategy is useful for scenarios where you want to limit the number of times a command can be executed within a fixed time frame, such as preventing command spamming or limiting API calls.
-    """
-
-    __slots__ = "rate", "interval", "opened", "_tokens"
-
-    def __init__(self, rate: int, interval: float) -> None:
-        self.rate: int = rate
-        self.interval: float = interval
-        self.opened: float = 0.0
-
-        self._tokens: int = self.rate
-
-        # sanity checks
-        if self.rate == 0:
-            raise ValueError("Cooldown rate must be greater than 0")
-        if self.interval == 0:
-            raise ValueError("Cooldown interval must be greater than 0")
-
-    def reset(self) -> None:
-        """Resets the tokens for this cooldown."""
-        self._tokens = self.rate
-        self.opened = 0.0
-
-    def on_cooldown(self) -> bool:
-        """
-        Returns the cooldown state of the command.
-
-        Returns:
-            boolean state if the command is on cooldown or not
-        """
-        self.determine_cooldown()
-
-        return self._tokens == 0
-
-    def acquire_token(self) -> bool:
-        """
-        Attempt to acquire a token for a command to run.
-
-        Returns:
-            True if a token was acquired, False if not
-
-        """
-        self.determine_cooldown()
-
-        if self._tokens == 0:
-            return False
-        if self._tokens == self.rate:
-            self.opened = time.time()
-        self._tokens -= 1
-
-        return True
-
-    def get_cooldown_time(self) -> float:
-        """
-        Returns how long until the cooldown will reset.
-
-        Returns:
-            remaining cooldown time, will return 0 if the cooldown has not been reached
-
-        """
-        self.determine_cooldown()
-        return 0 if self._tokens != 0 else self.interval - (time.time() - self.opened)
-
-    def determine_cooldown(self) -> None:
-        """Determines the state of the cooldown system."""
-        c_time = time.time()
-
-        if c_time > self.opened + self.interval:
-            # cooldown has expired, reset the cooldown
-            self.reset()
-
-
-class SlidingWindowSystem(CooldownSystem):
-    """
-    A sliding window cooldown strategy that allows a specific number of commands to be executed within a rolling time window.
-
-    The cooldown incrementally resets as commands fall outside of the window.
-
-    Attributes:
-        rate: The number of commands allowed per interval.
-        interval: The time window (in seconds) within which the allowed number of commands can be executed.
-
-    ??? tip "Example Use-case"
-        This strategy is useful for scenarios where you want to limit the rate of commands executed over a continuous time window, such as ensuring consistent usage of resources or controlling chat bot response frequency.
-    """
-
-    __slots__ = "rate", "interval", "timestamps"
-
-    def __init__(self, rate: int, interval: float) -> None:
-        self.rate: int = rate
-        self.interval: float = interval
-        self.timestamps: list[float] = []
-
-        # sanity checks
-        if self.rate == 0:
-            raise ValueError("Cooldown rate must be greater than 0")
-        if self.interval == 0:
-            raise ValueError("Cooldown interval must be greater than 0")
-
-    def on_cooldown(self) -> bool:
-        """
-        Returns the cooldown state of the command.
-
-        Returns:
-            boolean state if the command is on cooldown or not
-        """
-        self._trim()
-
-        return len(self.timestamps) >= self.rate
-
-    def acquire_token(self) -> bool:
-        """
-        Attempt to acquire a token for a command to run.
-
-        Returns:
-            True if a token was acquired, False if not
-
-        """
-        self._trim()
-
-        if len(self.timestamps) >= self.rate:
-            return False
-
-        self.timestamps.append(time.time())
-
-        return True
-
-    def get_cooldown_time(self) -> float:
-        """
-        Returns how long until the cooldown will reset.
-
-        Returns:
-            remaining cooldown time, will return 0 if the cooldown has not been reached
-
-        """
-        self._trim()
-
-        if len(self.timestamps) < self.rate:
-            return 0
-
-        return self.timestamps[0] + self.interval - time.time()
-
-    def reset(self) -> None:
-        """Resets the timestamps for this cooldown."""
-        self.timestamps = []
-
-    def _trim(self) -> None:
-        """Removes all timestamps that are outside the current interval."""
-        cutoff = time.time() - self.interval
-
-        while self.timestamps and self.timestamps[0] < cutoff:
-            self.timestamps.pop(0)
-
-
-class ExponentialBackoffSystem(CooldownSystem):
-    """
-    An exponential backoff cooldown strategy that doubles the interval between allowed commands after each failed attempt, up to a maximum interval.
-
-    Attributes:
-        rate: The number of commands allowed per interval.
-        interval: The initial time window (in seconds) within which the allowed number of commands can be executed.
-        max_interval: The maximum time window (in seconds) between allowed commands.
-        multiplier: The multiplier to apply to the interval after each failed attempt.
-
-    ??? tip "Example Use-case"
-        This strategy is useful for scenarios where you want to progressively slow down repeated attempts at a command, such as preventing brute force attacks or limiting retries on failed operations.
-    """
-
-    def __init__(self, rate: int, interval: float, max_interval: float, multiplier: float = 2) -> None:
-        super().__init__(rate, interval)
-        self.max_interval = max_interval
-        self.multiplier = multiplier
-
-    def determine_cooldown(self) -> None:
-        c_time = time.time()
-
-        if c_time > self.opened + self.interval:
-            if self.interval < self.max_interval:
-                self.interval *= self.multiplier
-            self.reset()
-
-
-class LeakyBucketSystem(CooldownSystem):
-    """
-    A leaky bucket cooldown strategy that gradually replenishes tokens over time, allowing commands to be executed as long as there are available tokens in the bucket.
-
-    Attributes:
-        rate: The number of tokens generated per interval.
-        interval: The time window (in seconds) within which the tokens are generated.
-
-    ??? tip "Example Use-case"
-        This strategy is useful for scenarios where you want to allow a steady flow of commands to be executed while preventing sudden bursts, such as rate limiting API calls or managing user interactions in a chatbot.
-    """
-
-    def determine_cooldown(self) -> None:
-        c_time = time.time()
-
-        tokens_to_recover = (c_time - self.opened) / self.interval
-        if tokens_to_recover >= 1:
-            self._tokens = min(self.rate, self._tokens + int(tokens_to_recover))
-            self.opened = c_time
-
-
-class TokenBucketSystem(CooldownSystem):
-    """
-    A token bucket cooldown strategy that generates tokens at a specific rate up to a burst rate, allowing commands to be executed as long as there are available tokens in the bucket.
-
-    Attributes:
-        rate: The number of tokens generated per interval.
-        interval: The time window (in seconds) within which the tokens are generated.
-        burst_rate: The maximum number of tokens that can be held in the bucket at any given time.
-
-    ??? tip "Example Use-case"
-        This strategy is useful for scenarios where you want to allow a burst of commands to be executed while limiting the overall rate, such as handling peak traffic in an API or permitting rapid user interactions in a game.
-    """
-
-    def __init__(self, rate: int, interval: float, burst_rate: int) -> None:
-        super().__init__(rate, interval)
-        self.burst_rate = burst_rate
-
-    def determine_cooldown(self) -> None:
-        c_time = time.time()
-
-        tokens_to_recover = (c_time - self.opened) / self.interval
-        if tokens_to_recover >= 1:
-            self._tokens = min(self.burst_rate, self._tokens + int(tokens_to_recover))
-            self.opened = c_time
-
-
-class Cooldown:
-    """
-    Manages cooldowns and their respective buckets for a command.
-
-    There are two pre-defined cooldown systems, a sliding window and a standard cooldown system (default);
-    you can specify which one to use by passing in the cooldown_system parameter.
-
-    Attributes:
-        bucket: The bucket to use for this cooldown
-        cooldown_repositories: A dictionary of cooldowns for each bucket
-        rate: How many commands may be ran per interval
-        interval: How many seconds to wait for a cooldown
-        cooldown_system: The cooldown system to use for this cooldown
-    """
-
-    __slots__ = "bucket", "cooldown_repositories", "rate", "interval", "cooldown_system"
-
-    def __init__(
-        self,
-        cooldown_bucket: Buckets,
-        rate: int,
-        interval: float,
-        *,
-        cooldown_system: Type[CooldownSystem] = CooldownSystem,
-    ) -> None:
-        self.bucket: Buckets = cooldown_bucket
-        self.cooldown_repositories = {}
-        self.rate: int = rate
-        self.interval: float = interval
-
-        self.cooldown_system: Type[CooldownSystem] = cooldown_system or CooldownSystem
-
-    async def get_cooldown(self, context: "BaseContext") -> "CooldownSystem":
-        key = await self.bucket(context)
-
-        if key not in self.cooldown_repositories:
-            cooldown = self.cooldown_system(self.rate, self.interval)
-            self.cooldown_repositories[key] = cooldown
-            return cooldown
-        return self.cooldown_repositories.get(await self.bucket(context))
-
-    def get_cooldown_with_key(self, key: Any, *, create: bool = False) -> typing.Optional["CooldownSystem"]:
-        """
-        Get the cooldown system for the command.
-
-        Note:
-            The preferred way to get the cooldown system is to use `get_cooldown` as it will use the context to get the correct key.
-
-        Args:
-            key: The key to get the cooldown system for
-            create: Whether to create a new cooldown system if one does not exist
-        """
-        if key not in self.cooldown_repositories and create:
-            cooldown = self.cooldown_system(self.rate, self.interval)
-            self.cooldown_repositories[key] = cooldown
-            return cooldown
-        return self.cooldown_repositories.get(key)
-
-    async def acquire_token(self, context: "BaseContext") -> bool:
-        """
-        Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownStrategy.
-
-        Args:
-            context: The context of the command
-
-        Returns:
-            True if a token was acquired, False if not
-
-        """
-        cooldown = await self.get_cooldown(context)
-
-        return cooldown.acquire_token()
-
-    async def get_cooldown_time(self, context: "BaseContext") -> float:
-        """
-        Get the remaining cooldown time.
-
-        Args:
-            context: The context of the command
-
-        Returns:
-            remaining cooldown time, will return 0 if the cooldown has not been reached
-
-        """
-        cooldown = await self.get_cooldown(context)
-        return cooldown.get_cooldown_time()
-
-    def get_cooldown_time_with_key(self, key: Any, *, create: bool = False) -> float:
-        """
-        Get the remaining cooldown time with a key instead of the context.
-
-        Note:
-            The preferred way to get the cooldown system is to use `get_cooldown` as it will use the context to get the correct key.
-
-        Args:
-            key: The key to get the cooldown system for
-            create: Whether to create a new cooldown system if one does not exist
-        """
-        cooldown = self.get_cooldown_with_key(key, create=create)
-        if cooldown is not None:
-            return cooldown.get_cooldown_time()
-        return 0
-
-    async def on_cooldown(self, context: "BaseContext") -> bool:
-        """
-        Returns the cooldown state of the command.
-
-        Args:
-            context: The context of the command
-
-        Returns:
-            boolean state if the command is on cooldown or not
-
-        """
-        cooldown = await self.get_cooldown(context)
-        return cooldown.on_cooldown()
-
-    async def reset_all(self) -> None:
-        """
-        Resets this cooldown system to its initial state.
-
-        !!! warning     To be clear, this will reset **all** cooldowns
-        for this command to their initial states
-
-        """
-        # this doesnt need to be async, but for consistency, it is
-        self.cooldown_repositories = {}
-
-    async def reset(self, context: "BaseContext") -> None:
-        """
-        Resets the cooldown for the bucket of which invoked this command.
-
-        Args:
-            context: The context of the command
-
-        """
-        cooldown = await self.get_cooldown(context)
-        cooldown.reset()
-
-    def reset_with_key(self, key: Any) -> bool:
-        """
-        Resets the cooldown for the bucket associated with the provided key.
-
-        Note:
-            The preferred way to reset the cooldown system is to use `reset_cooldown` as it will use the context to reset the correct cooldown.
-
-        Args:
-            key: The key to reset the cooldown system for
-
-        Returns:
-            True if the key existed and was reset successfully, False if the key didn't exist.
-        """
-        cooldown = self.get_cooldown_with_key(key)
-        if cooldown is not None:
-            cooldown.reset()
-            return True
-        return False
-
-
-class MaxConcurrency:
-    """
-    Limits how many instances of a command may be running concurrently.
-
-    Attributes:
-        bucket Buckets: The bucket this concurrency applies to
-        concurrent int: The maximum number of concurrent instances permitted to
-        wait bool: Should we wait until a instance is available
-
-    """
-
-    def __init__(self, concurrent: int, concurrency_bucket: Buckets, wait: bool = False) -> None:
-        self.bucket: Buckets = concurrency_bucket
-        self.concurrency_repository: Dict = {}
-        self.concurrent: int = concurrent
-        self.wait = wait
-
-    async def get_semaphore(self, context: "BaseContext") -> asyncio.Semaphore:
-        """
-        Get the semaphore associated with the given context.
-
-        Args:
-            context: The commands context
-
-        Returns:
-            A semaphore object
-        """
-        key = await self.bucket(context)
-
-        if key not in self.concurrency_repository:
-            semaphore = asyncio.Semaphore(self.concurrent)
-            self.concurrency_repository[key] = semaphore
-            return semaphore
-        return self.concurrency_repository.get(key)
-
-    async def acquire(self, context: "BaseContext") -> bool:
-        """
-        Acquire an instance of the semaphore.
-
-        Args:
-            context:The context of the command
-        Returns:
-            If the semaphore was successfully acquired
-
-        """
-        semaphore = await self.get_semaphore(context)
-
-        if not self.wait and semaphore.locked():
-            return False
-        return await semaphore.acquire()
-
-    async def release(self, context: "BaseContext") -> None:
-        """
-        Release the semaphore.
-
-        Args:
-            context: The context of the command
-
-        """
-        semaphore = await self.get_semaphore(context)
-
-        semaphore.release()
+import asyncio
+import time
+import typing
+from enum import IntEnum
+from typing import TYPE_CHECKING, Any, Dict, Type
+
+if TYPE_CHECKING:
+    from interactions.models.internal.context import BaseContext
+
+__all__ = (
+    "Buckets",
+    "Cooldown",
+    "CooldownSystem",
+    "SlidingWindowSystem",
+    "ExponentialBackoffSystem",
+    "LeakyBucketSystem",
+    "TokenBucketSystem",
+    "MaxConcurrency",
+)
+
+
+class Buckets(IntEnum):
+    """
+    Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used.
+
+    ??? note
+         To add your own, override this
+
+    """
+
+    DEFAULT = 0
+    """Default is the same as user"""
+    USER = 1
+    """Per user cooldowns"""
+    GUILD = 2
+    """Per guild cooldowns"""
+    CHANNEL = 3
+    """Per channel cooldowns"""
+    MEMBER = 4
+    """Per guild member cooldowns"""
+    CATEGORY = 5
+    """Per category cooldowns"""
+    ROLE = 6
+    """Per role cooldowns"""
+
+    async def get_key(self, context: "BaseContext") -> Any:
+        if self is Buckets.USER:
+            return context.author.id
+        if self is Buckets.GUILD:
+            return context.guild_id if context.guild else context.author.id
+        if self is Buckets.CHANNEL:
+            return context.channel.id
+        if self is Buckets.MEMBER:
+            return (context.guild_id, context.author.id) if context.guild else context.author.id
+        if self is Buckets.CATEGORY:
+            return await context.channel.parent_id if context.channel.parent else context.channel.id
+        if self is Buckets.ROLE:
+            return context.author.top_role.id if context.guild else context.channel.id
+        return context.author.id
+
+    def __call__(self, context: "BaseContext") -> Any:
+        return self.get_key(context)
+
+
+class CooldownSystem:
+    """
+    A basic cooldown strategy that allows a specific number of commands to be executed within a given interval. Once the rate is reached, no more tokens can be acquired until the interval has passed.
+
+    Attributes:
+        rate: The number of commands allowed per interval.
+        interval: The time window (in seconds) within which the allowed number of commands can be executed.
+
+    ??? tip "Example Use-case"
+        This strategy is useful for scenarios where you want to limit the number of times a command can be executed within a fixed time frame, such as preventing command spamming or limiting API calls.
+    """
+
+    __slots__ = "rate", "interval", "opened", "_tokens"
+
+    def __init__(self, rate: int, interval: float) -> None:
+        self.rate: int = rate
+        self.interval: float = interval
+        self.opened: float = 0.0
+
+        self._tokens: int = self.rate
+
+        # sanity checks
+        if self.rate == 0:
+            raise ValueError("Cooldown rate must be greater than 0")
+        if self.interval == 0:
+            raise ValueError("Cooldown interval must be greater than 0")
+
+    def reset(self) -> None:
+        """Resets the tokens for this cooldown."""
+        self._tokens = self.rate
+        self.opened = 0.0
+
+    def on_cooldown(self) -> bool:
+        """
+        Returns the cooldown state of the command.
+
+        Returns:
+            boolean state if the command is on cooldown or not
+        """
+        self.determine_cooldown()
+
+        return self._tokens == 0
+
+    def acquire_token(self) -> bool:
+        """
+        Attempt to acquire a token for a command to run.
+
+        Returns:
+            True if a token was acquired, False if not
+
+        """
+        self.determine_cooldown()
+
+        if self._tokens == 0:
+            return False
+        if self._tokens == self.rate:
+            self.opened = time.time()
+        self._tokens -= 1
+
+        return True
+
+    def get_cooldown_time(self) -> float:
+        """
+        Returns how long until the cooldown will reset.
+
+        Returns:
+            remaining cooldown time, will return 0 if the cooldown has not been reached
+
+        """
+        self.determine_cooldown()
+        return 0 if self._tokens != 0 else self.interval - (time.time() - self.opened)
+
+    def determine_cooldown(self) -> None:
+        """Determines the state of the cooldown system."""
+        c_time = time.time()
+
+        if c_time > self.opened + self.interval:
+            # cooldown has expired, reset the cooldown
+            self.reset()
+
+
+class SlidingWindowSystem(CooldownSystem):
+    """
+    A sliding window cooldown strategy that allows a specific number of commands to be executed within a rolling time window.
+
+    The cooldown incrementally resets as commands fall outside of the window.
+
+    Attributes:
+        rate: The number of commands allowed per interval.
+        interval: The time window (in seconds) within which the allowed number of commands can be executed.
+
+    ??? tip "Example Use-case"
+        This strategy is useful for scenarios where you want to limit the rate of commands executed over a continuous time window, such as ensuring consistent usage of resources or controlling chat bot response frequency.
+    """
+
+    __slots__ = "rate", "interval", "timestamps"
+
+    def __init__(self, rate: int, interval: float) -> None:
+        self.rate: int = rate
+        self.interval: float = interval
+        self.timestamps: list[float] = []
+
+        # sanity checks
+        if self.rate == 0:
+            raise ValueError("Cooldown rate must be greater than 0")
+        if self.interval == 0:
+            raise ValueError("Cooldown interval must be greater than 0")
+
+    def on_cooldown(self) -> bool:
+        """
+        Returns the cooldown state of the command.
+
+        Returns:
+            boolean state if the command is on cooldown or not
+        """
+        self._trim()
+
+        return len(self.timestamps) >= self.rate
+
+    def acquire_token(self) -> bool:
+        """
+        Attempt to acquire a token for a command to run.
+
+        Returns:
+            True if a token was acquired, False if not
+
+        """
+        self._trim()
+
+        if len(self.timestamps) >= self.rate:
+            return False
+
+        self.timestamps.append(time.time())
+
+        return True
+
+    def get_cooldown_time(self) -> float:
+        """
+        Returns how long until the cooldown will reset.
+
+        Returns:
+            remaining cooldown time, will return 0 if the cooldown has not been reached
+
+        """
+        self._trim()
+
+        if len(self.timestamps) < self.rate:
+            return 0
+
+        return self.timestamps[0] + self.interval - time.time()
+
+    def reset(self) -> None:
+        """Resets the timestamps for this cooldown."""
+        self.timestamps = []
+
+    def _trim(self) -> None:
+        """Removes all timestamps that are outside the current interval."""
+        cutoff = time.time() - self.interval
+
+        while self.timestamps and self.timestamps[0] < cutoff:
+            self.timestamps.pop(0)
+
+
+class ExponentialBackoffSystem(CooldownSystem):
+    """
+    An exponential backoff cooldown strategy that doubles the interval between allowed commands after each failed attempt, up to a maximum interval.
+
+    Attributes:
+        rate: The number of commands allowed per interval.
+        interval: The initial time window (in seconds) within which the allowed number of commands can be executed.
+        max_interval: The maximum time window (in seconds) between allowed commands.
+        multiplier: The multiplier to apply to the interval after each failed attempt.
+
+    ??? tip "Example Use-case"
+        This strategy is useful for scenarios where you want to progressively slow down repeated attempts at a command, such as preventing brute force attacks or limiting retries on failed operations.
+    """
+
+    def __init__(self, rate: int, interval: float, max_interval: float, multiplier: float = 2) -> None:
+        super().__init__(rate, interval)
+        self.max_interval = max_interval
+        self.multiplier = multiplier
+
+    def determine_cooldown(self) -> None:
+        c_time = time.time()
+
+        if c_time > self.opened + self.interval:
+            if self.interval < self.max_interval:
+                self.interval *= self.multiplier
+            self.reset()
+
+
+class LeakyBucketSystem(CooldownSystem):
+    """
+    A leaky bucket cooldown strategy that gradually replenishes tokens over time, allowing commands to be executed as long as there are available tokens in the bucket.
+
+    Attributes:
+        rate: The number of tokens generated per interval.
+        interval: The time window (in seconds) within which the tokens are generated.
+
+    ??? tip "Example Use-case"
+        This strategy is useful for scenarios where you want to allow a steady flow of commands to be executed while preventing sudden bursts, such as rate limiting API calls or managing user interactions in a chatbot.
+    """
+
+    def determine_cooldown(self) -> None:
+        c_time = time.time()
+
+        tokens_to_recover = (c_time - self.opened) / self.interval
+        if tokens_to_recover >= 1:
+            self._tokens = min(self.rate, self._tokens + int(tokens_to_recover))
+            self.opened = c_time
+
+
+class TokenBucketSystem(CooldownSystem):
+    """
+    A token bucket cooldown strategy that generates tokens at a specific rate up to a burst rate, allowing commands to be executed as long as there are available tokens in the bucket.
+
+    Attributes:
+        rate: The number of tokens generated per interval.
+        interval: The time window (in seconds) within which the tokens are generated.
+        burst_rate: The maximum number of tokens that can be held in the bucket at any given time.
+
+    ??? tip "Example Use-case"
+        This strategy is useful for scenarios where you want to allow a burst of commands to be executed while limiting the overall rate, such as handling peak traffic in an API or permitting rapid user interactions in a game.
+    """
+
+    def __init__(self, rate: int, interval: float, burst_rate: int) -> None:
+        super().__init__(rate, interval)
+        self.burst_rate = burst_rate
+
+    def determine_cooldown(self) -> None:
+        c_time = time.time()
+
+        tokens_to_recover = (c_time - self.opened) / self.interval
+        if tokens_to_recover >= 1:
+            self._tokens = min(self.burst_rate, self._tokens + int(tokens_to_recover))
+            self.opened = c_time
+
+
+class Cooldown:
+    """
+    Manages cooldowns and their respective buckets for a command.
+
+    There are two pre-defined cooldown systems, a sliding window and a standard cooldown system (default);
+    you can specify which one to use by passing in the cooldown_system parameter.
+
+    Attributes:
+        bucket: The bucket to use for this cooldown
+        cooldown_repositories: A dictionary of cooldowns for each bucket
+        rate: How many commands may be ran per interval
+        interval: How many seconds to wait for a cooldown
+        cooldown_system: The cooldown system to use for this cooldown
+    """
+
+    __slots__ = "bucket", "cooldown_repositories", "rate", "interval", "cooldown_system"
+
+    def __init__(
+        self,
+        cooldown_bucket: Buckets,
+        rate: int,
+        interval: float,
+        *,
+        cooldown_system: Type[CooldownSystem] = CooldownSystem,
+    ) -> None:
+        self.bucket: Buckets = cooldown_bucket
+        self.cooldown_repositories = {}
+        self.rate: int = rate
+        self.interval: float = interval
+
+        self.cooldown_system: Type[CooldownSystem] = cooldown_system or CooldownSystem
+
+    async def get_cooldown(self, context: "BaseContext") -> "CooldownSystem":
+        key = await self.bucket(context)
+
+        if key not in self.cooldown_repositories:
+            cooldown = self.cooldown_system(self.rate, self.interval)
+            self.cooldown_repositories[key] = cooldown
+            return cooldown
+        return self.cooldown_repositories.get(await self.bucket(context))
+
+    def get_cooldown_with_key(self, key: Any, *, create: bool = False) -> typing.Optional["CooldownSystem"]:
+        """
+        Get the cooldown system for the command.
+
+        Note:
+            The preferred way to get the cooldown system is to use `get_cooldown` as it will use the context to get the correct key.
+
+        Args:
+            key: The key to get the cooldown system for
+            create: Whether to create a new cooldown system if one does not exist
+        """
+        if key not in self.cooldown_repositories and create:
+            cooldown = self.cooldown_system(self.rate, self.interval)
+            self.cooldown_repositories[key] = cooldown
+            return cooldown
+        return self.cooldown_repositories.get(key)
+
+    async def acquire_token(self, context: "BaseContext") -> bool:
+        """
+        Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownStrategy.
+
+        Args:
+            context: The context of the command
+
+        Returns:
+            True if a token was acquired, False if not
+
+        """
+        cooldown = await self.get_cooldown(context)
+
+        return cooldown.acquire_token()
+
+    async def get_cooldown_time(self, context: "BaseContext") -> float:
+        """
+        Get the remaining cooldown time.
+
+        Args:
+            context: The context of the command
+
+        Returns:
+            remaining cooldown time, will return 0 if the cooldown has not been reached
+
+        """
+        cooldown = await self.get_cooldown(context)
+        return cooldown.get_cooldown_time()
+
+    def get_cooldown_time_with_key(self, key: Any, *, create: bool = False) -> float:
+        """
+        Get the remaining cooldown time with a key instead of the context.
+
+        Note:
+            The preferred way to get the cooldown system is to use `get_cooldown` as it will use the context to get the correct key.
+
+        Args:
+            key: The key to get the cooldown system for
+            create: Whether to create a new cooldown system if one does not exist
+        """
+        cooldown = self.get_cooldown_with_key(key, create=create)
+        if cooldown is not None:
+            return cooldown.get_cooldown_time()
+        return 0
+
+    async def on_cooldown(self, context: "BaseContext") -> bool:
+        """
+        Returns the cooldown state of the command.
+
+        Args:
+            context: The context of the command
+
+        Returns:
+            boolean state if the command is on cooldown or not
+
+        """
+        cooldown = await self.get_cooldown(context)
+        return cooldown.on_cooldown()
+
+    async def reset_all(self) -> None:
+        """
+        Resets this cooldown system to its initial state.
+
+        !!! warning     To be clear, this will reset **all** cooldowns
+        for this command to their initial states
+
+        """
+        # this doesnt need to be async, but for consistency, it is
+        self.cooldown_repositories = {}
+
+    async def reset(self, context: "BaseContext") -> None:
+        """
+        Resets the cooldown for the bucket of which invoked this command.
+
+        Args:
+            context: The context of the command
+
+        """
+        cooldown = await self.get_cooldown(context)
+        cooldown.reset()
+
+    def reset_with_key(self, key: Any) -> bool:
+        """
+        Resets the cooldown for the bucket associated with the provided key.
+
+        Note:
+            The preferred way to reset the cooldown system is to use `reset_cooldown` as it will use the context to reset the correct cooldown.
+
+        Args:
+            key: The key to reset the cooldown system for
+
+        Returns:
+            True if the key existed and was reset successfully, False if the key didn't exist.
+        """
+        cooldown = self.get_cooldown_with_key(key)
+        if cooldown is not None:
+            cooldown.reset()
+            return True
+        return False
+
+
+class MaxConcurrency:
+    """
+    Limits how many instances of a command may be running concurrently.
+
+    Attributes:
+        bucket Buckets: The bucket this concurrency applies to
+        concurrent int: The maximum number of concurrent instances permitted to
+        wait bool: Should we wait until a instance is available
+
+    """
+
+    def __init__(self, concurrent: int, concurrency_bucket: Buckets, wait: bool = False) -> None:
+        self.bucket: Buckets = concurrency_bucket
+        self.concurrency_repository: Dict = {}
+        self.concurrent: int = concurrent
+        self.wait = wait
+
+    async def get_semaphore(self, context: "BaseContext") -> asyncio.Semaphore:
+        """
+        Get the semaphore associated with the given context.
+
+        Args:
+            context: The commands context
+
+        Returns:
+            A semaphore object
+        """
+        key = await self.bucket(context)
+
+        if key not in self.concurrency_repository:
+            semaphore = asyncio.Semaphore(self.concurrent)
+            self.concurrency_repository[key] = semaphore
+            return semaphore
+        return self.concurrency_repository.get(key)
+
+    async def acquire(self, context: "BaseContext") -> bool:
+        """
+        Acquire an instance of the semaphore.
+
+        Args:
+            context:The context of the command
+        Returns:
+            If the semaphore was successfully acquired
+
+        """
+        semaphore = await self.get_semaphore(context)
+
+        if not self.wait and semaphore.locked():
+            return False
+        return await semaphore.acquire()
+
+    async def release(self, context: "BaseContext") -> None:
+        """
+        Release the semaphore.
+
+        Args:
+            context: The context of the command
+
+        """
+        semaphore = await self.get_semaphore(context)
+
+        semaphore.release()
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/listener.py` & `discord-py-interactions-5.6.0/interactions/models/internal/listener.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,144 +1,144 @@
-import asyncio
-import inspect
-from typing import Callable
-
-from interactions.api.events.internal import BaseEvent
-from interactions.client.const import MISSING, Absent, AsyncCallable
-from interactions.client.utils import get_event_name
-from interactions.models.internal.callback import CallbackObject
-
-__all__ = ("Listener", "listen")
-
-
-class Listener(CallbackObject):
-    event: str
-    """Name of the event to listen to."""
-    callback: AsyncCallable
-    """Coroutine to call when the event is triggered."""
-    is_default_listener: bool
-    """Whether this listener is provided automatically by the library, and might be unwanted by users."""
-    disable_default_listeners: bool
-    """Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered."""
-    delay_until_ready: bool
-    """whether to delay the event until the client is ready"""
-
-    def __init__(
-        self,
-        func: AsyncCallable,
-        event: str,
-        *,
-        delay_until_ready: bool = False,
-        is_default_listener: bool = False,
-        disable_default_listeners: bool = False,
-        pass_event_object: Absent[bool] = MISSING,
-    ) -> None:
-        super().__init__()
-
-        if is_default_listener:
-            disable_default_listeners = False
-
-        self.event = event
-        self.callback = func
-        self.delay_until_ready = delay_until_ready
-        self.is_default_listener = is_default_listener
-        self.disable_default_listeners = disable_default_listeners
-
-        self._params = inspect.signature(func).parameters.copy()
-        self.pass_event_object = pass_event_object
-        self.warned_no_event_arg = False
-
-    def __repr__(self) -> str:
-        return f"<Listener event={self.event!r} callback={self.callback!r}>"
-
-    @classmethod
-    def create(
-        cls,
-        event_name: Absent[str | BaseEvent] = MISSING,
-        *,
-        delay_until_ready: bool = False,
-        is_default_listener: bool = False,
-        disable_default_listeners: bool = False,
-    ) -> Callable[[AsyncCallable], "Listener"]:
-        """
-        Decorator for creating an event listener.
-
-        Args:
-            event_name: The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.
-            delay_until_ready: Whether to delay the listener until the client is ready.
-            is_default_listener: Whether this listener is provided automatically by the library, and might be unwanted by users.
-            disable_default_listeners: Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.
-
-
-        Returns:
-            A listener object.
-
-        """
-
-        def wrapper(coro: AsyncCallable) -> "Listener":
-            if not asyncio.iscoroutinefunction(coro):
-                raise TypeError("Listener must be a coroutine")
-
-            name = event_name
-
-            if name is MISSING:
-                for typehint in coro.__annotations__.values():
-                    if (
-                        inspect.isclass(typehint)
-                        and issubclass(typehint, BaseEvent)
-                        and typehint.__name__ != "RawGatewayEvent"
-                    ):
-                        name = typehint.__name__
-                        break
-
-                if not name:
-                    name = coro.__name__
-
-            return cls(
-                coro,
-                get_event_name(name),
-                delay_until_ready=delay_until_ready,
-                is_default_listener=is_default_listener,
-                disable_default_listeners=disable_default_listeners,
-            )
-
-        return wrapper
-
-    def lazy_parse_params(self):
-        """Process the parameters of this listener."""
-        if self.pass_event_object is not MISSING:
-            return
-
-        if self.has_binding:
-            # discard the first parameter, which is the class instance
-            self._params = list(self._params.values())[1:]
-
-        self.pass_event_object = len(self._params) != 0
-
-
-def listen(
-    event_name: Absent[str | BaseEvent] = MISSING,
-    *,
-    delay_until_ready: bool = False,
-    is_default_listener: bool = False,
-    disable_default_listeners: bool = False,
-) -> Callable[[AsyncCallable], Listener]:
-    """
-    Decorator to make a function an event listener.
-
-    Args:
-        event_name: The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.
-        delay_until_ready: Whether to delay the listener until the client is ready.
-        is_default_listener: Whether this listener is provided automatically by the library, and might be unwanted by users.
-        disable_default_listeners: Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.
-
-
-    Returns:
-        A listener object.
-
-    """
-    return Listener.create(
-        event_name,
-        delay_until_ready=delay_until_ready,
-        is_default_listener=is_default_listener,
-        disable_default_listeners=disable_default_listeners,
-    )
+import asyncio
+import inspect
+from typing import Callable
+
+from interactions.api.events.internal import BaseEvent
+from interactions.client.const import MISSING, Absent, AsyncCallable
+from interactions.client.utils import get_event_name
+from interactions.models.internal.callback import CallbackObject
+
+__all__ = ("Listener", "listen")
+
+
+class Listener(CallbackObject):
+    event: str
+    """Name of the event to listen to."""
+    callback: AsyncCallable
+    """Coroutine to call when the event is triggered."""
+    is_default_listener: bool
+    """Whether this listener is provided automatically by the library, and might be unwanted by users."""
+    disable_default_listeners: bool
+    """Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered."""
+    delay_until_ready: bool
+    """whether to delay the event until the client is ready"""
+
+    def __init__(
+        self,
+        func: AsyncCallable,
+        event: str,
+        *,
+        delay_until_ready: bool = False,
+        is_default_listener: bool = False,
+        disable_default_listeners: bool = False,
+        pass_event_object: Absent[bool] = MISSING,
+    ) -> None:
+        super().__init__()
+
+        if is_default_listener:
+            disable_default_listeners = False
+
+        self.event = event
+        self.callback = func
+        self.delay_until_ready = delay_until_ready
+        self.is_default_listener = is_default_listener
+        self.disable_default_listeners = disable_default_listeners
+
+        self._params = inspect.signature(func).parameters.copy()
+        self.pass_event_object = pass_event_object
+        self.warned_no_event_arg = False
+
+    def __repr__(self) -> str:
+        return f"<Listener event={self.event!r} callback={self.callback!r}>"
+
+    @classmethod
+    def create(
+        cls,
+        event_name: Absent[str | BaseEvent] = MISSING,
+        *,
+        delay_until_ready: bool = False,
+        is_default_listener: bool = False,
+        disable_default_listeners: bool = False,
+    ) -> Callable[[AsyncCallable], "Listener"]:
+        """
+        Decorator for creating an event listener.
+
+        Args:
+            event_name: The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.
+            delay_until_ready: Whether to delay the listener until the client is ready.
+            is_default_listener: Whether this listener is provided automatically by the library, and might be unwanted by users.
+            disable_default_listeners: Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.
+
+
+        Returns:
+            A listener object.
+
+        """
+
+        def wrapper(coro: AsyncCallable) -> "Listener":
+            if not asyncio.iscoroutinefunction(coro):
+                raise TypeError("Listener must be a coroutine")
+
+            name = event_name
+
+            if name is MISSING:
+                for typehint in coro.__annotations__.values():
+                    if (
+                        inspect.isclass(typehint)
+                        and issubclass(typehint, BaseEvent)
+                        and typehint.__name__ != "RawGatewayEvent"
+                    ):
+                        name = typehint.__name__
+                        break
+
+                if not name:
+                    name = coro.__name__
+
+            return cls(
+                coro,
+                get_event_name(name),
+                delay_until_ready=delay_until_ready,
+                is_default_listener=is_default_listener,
+                disable_default_listeners=disable_default_listeners,
+            )
+
+        return wrapper
+
+    def lazy_parse_params(self):
+        """Process the parameters of this listener."""
+        if self.pass_event_object is not MISSING:
+            return
+
+        if self.has_binding:
+            # discard the first parameter, which is the class instance
+            self._params = list(self._params.values())[1:]
+
+        self.pass_event_object = len(self._params) != 0
+
+
+def listen(
+    event_name: Absent[str | BaseEvent] = MISSING,
+    *,
+    delay_until_ready: bool = False,
+    is_default_listener: bool = False,
+    disable_default_listeners: bool = False,
+) -> Callable[[AsyncCallable], Listener]:
+    """
+    Decorator to make a function an event listener.
+
+    Args:
+        event_name: The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.
+        delay_until_ready: Whether to delay the listener until the client is ready.
+        is_default_listener: Whether this listener is provided automatically by the library, and might be unwanted by users.
+        disable_default_listeners: Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.
+
+
+    Returns:
+        A listener object.
+
+    """
+    return Listener.create(
+        event_name,
+        delay_until_ready=delay_until_ready,
+        is_default_listener=is_default_listener,
+        disable_default_listeners=disable_default_listeners,
+    )
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/localisation.py` & `discord-py-interactions-5.6.0/interactions/models/internal/localisation.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,129 +1,129 @@
-from functools import cached_property
-
-import attrs
-
-from interactions.client import const
-
-__all__ = ("LocalisedField", "LocalizedField")
-
-
-@attrs.define(eq=False, order=False, hash=False, slots=False)
-class LocalisedField:
-    """
-    An object that enables support for localising fields.
-
-    Supported locales: https://discord.com/developers/docs/reference#locales
-    """
-
-    default_locale: str = attrs.field(repr=False, default=const.default_locale)
-
-    bulgarian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "bg"})
-    chinese_china: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "zh-CN"})
-    chinese_taiwan: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "zh-TW"})
-    croatian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "hr"})
-    czech: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "cs"})
-    danish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "da"})
-    dutch: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "nl"})
-    english_uk: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "en-GB"})
-    english_us: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "en-US"})
-    finnish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "fi"})
-    french: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "fr"})
-    german: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "de"})
-    greek: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "el"})
-    hindi: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "hi"})
-    hungarian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "hu"})
-    italian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "it"})
-    japanese: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ja"})
-    korean: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ko"})
-    lithuanian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "lt"})
-    norwegian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "no"})
-    polish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "pl"})
-    portuguese_brazilian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "pt-BR"})
-    romanian_romania: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ro"})
-    russian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ru"})
-    spanish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "es-ES"})
-    swedish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "sv-SE"})
-    thai: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "th"})
-    turkish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "tr"})
-    ukrainian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "uk"})
-    vietnamese: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "vi"})
-
-    def __str__(self) -> str:
-        return str(self.default)
-
-    def __bool__(self) -> bool:
-        return self.default is not None
-
-    def __repr__(self) -> str:
-        return f"<{self.__class__.__name__}: default_locale={self.default_locale}, value='{self}'>"
-
-    @cached_property
-    def _code_mapping(self) -> dict:
-        """Generates a lookup table for this object on demand to allow for value retrieval with locale codes"""
-        data = []
-        for attr in self.__attrs_attrs__:
-            if attr.name != self.default_locale:
-                if code := attr.metadata.get("locale-code"):
-                    data.append((code, attr.name))
-        return dict(data)
-
-    @property
-    def default(self) -> str:
-        """The default value based on the CONST default_locale"""
-        return getattr(self, self.default_locale)
-
-    def get_locale(self, locale: str) -> str:
-        """
-        Get the value for the specified locale. Supports locale-codes and locale names.
-
-        Args:
-            locale: The locale to fetch
-
-        Returns:
-            The localised string, or the default value
-        """
-        if val := getattr(self, locale, None):
-            # Attempt to retrieve an attribute with the specified locale
-            return val
-        if attr := self._code_mapping.get(locale):
-            # assume the locale is a code, and attempt to find an attribute with that code
-            if val := getattr(self, attr, None):
-                # if the value isn't None, return
-                return val
-
-        # no value was found, return default
-        return self.default
-
-    @classmethod
-    def converter(cls, value: str | None) -> "LocalisedField":
-        if isinstance(value, LocalisedField):
-            return value
-        obj = cls()
-        if value:
-            obj.__setattr__(obj.default_locale, str(value))
-
-        return obj
-
-    @default_locale.validator
-    def _default_locale_validator(self, _, value: str) -> None:
-        try:
-            getattr(self, value)
-        except AttributeError:
-            raise ValueError(f"`{value}` is not a supported default localisation") from None
-
-    def as_dict(self) -> str:
-        return str(self)
-
-    def to_locale_dict(self) -> dict:
-        data = {}
-        for attr in self.__attrs_attrs__:
-            if attr.name != self.default_locale and "locale-code" in attr.metadata:
-                if val := getattr(self, attr.name):
-                    data[attr.metadata["locale-code"]] = val
-
-        if not data:
-            data = None  # handle discord being stupid
-        return data
-
-
-LocalizedField = LocalisedField
+from functools import cached_property
+
+import attrs
+
+from interactions.client import const
+
+__all__ = ("LocalisedField", "LocalizedField")
+
+
+@attrs.define(eq=False, order=False, hash=False, slots=False)
+class LocalisedField:
+    """
+    An object that enables support for localising fields.
+
+    Supported locales: https://discord.com/developers/docs/reference#locales
+    """
+
+    default_locale: str = attrs.field(repr=False, default=const.default_locale)
+
+    bulgarian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "bg"})
+    chinese_china: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "zh-CN"})
+    chinese_taiwan: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "zh-TW"})
+    croatian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "hr"})
+    czech: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "cs"})
+    danish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "da"})
+    dutch: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "nl"})
+    english_uk: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "en-GB"})
+    english_us: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "en-US"})
+    finnish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "fi"})
+    french: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "fr"})
+    german: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "de"})
+    greek: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "el"})
+    hindi: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "hi"})
+    hungarian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "hu"})
+    italian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "it"})
+    japanese: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ja"})
+    korean: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ko"})
+    lithuanian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "lt"})
+    norwegian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "no"})
+    polish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "pl"})
+    portuguese_brazilian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "pt-BR"})
+    romanian_romania: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ro"})
+    russian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "ru"})
+    spanish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "es-ES"})
+    swedish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "sv-SE"})
+    thai: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "th"})
+    turkish: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "tr"})
+    ukrainian: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "uk"})
+    vietnamese: str | None = attrs.field(repr=False, default=None, metadata={"locale-code": "vi"})
+
+    def __str__(self) -> str:
+        return str(self.default)
+
+    def __bool__(self) -> bool:
+        return self.default is not None
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__}: default_locale={self.default_locale}, value='{self}'>"
+
+    @cached_property
+    def _code_mapping(self) -> dict:
+        """Generates a lookup table for this object on demand to allow for value retrieval with locale codes"""
+        data = []
+        for attr in self.__attrs_attrs__:
+            if attr.name != self.default_locale:
+                if code := attr.metadata.get("locale-code"):
+                    data.append((code, attr.name))
+        return dict(data)
+
+    @property
+    def default(self) -> str:
+        """The default value based on the CONST default_locale"""
+        return getattr(self, self.default_locale)
+
+    def get_locale(self, locale: str) -> str:
+        """
+        Get the value for the specified locale. Supports locale-codes and locale names.
+
+        Args:
+            locale: The locale to fetch
+
+        Returns:
+            The localised string, or the default value
+        """
+        if val := getattr(self, locale, None):
+            # Attempt to retrieve an attribute with the specified locale
+            return val
+        if attr := self._code_mapping.get(locale):
+            # assume the locale is a code, and attempt to find an attribute with that code
+            if val := getattr(self, attr, None):
+                # if the value isn't None, return
+                return val
+
+        # no value was found, return default
+        return self.default
+
+    @classmethod
+    def converter(cls, value: str | None) -> "LocalisedField":
+        if isinstance(value, LocalisedField):
+            return value
+        obj = cls()
+        if value:
+            obj.__setattr__(obj.default_locale, str(value))
+
+        return obj
+
+    @default_locale.validator
+    def _default_locale_validator(self, _, value: str) -> None:
+        try:
+            getattr(self, value)
+        except AttributeError:
+            raise ValueError(f"`{value}` is not a supported default localisation") from None
+
+    def as_dict(self) -> str:
+        return str(self)
+
+    def to_locale_dict(self) -> dict:
+        data = {}
+        for attr in self.__attrs_attrs__:
+            if attr.name != self.default_locale and "locale-code" in attr.metadata:
+                if val := getattr(self, attr.name):
+                    data[attr.metadata["locale-code"]] = val
+
+        if not data:
+            data = None  # handle discord being stupid
+        return data
+
+
+LocalizedField = LocalisedField
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/protocols.py` & `discord-py-interactions-5.6.0/interactions/models/internal/protocols.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-import typing
-from typing import Protocol, Any, TYPE_CHECKING
-
-from interactions.api.http.route import Route
-from interactions.client.const import T_co
-from interactions.models.discord.file import UPLOADABLE_TYPE
-
-if TYPE_CHECKING:
-    from interactions.models.internal.context import BaseContext
-
-__all__ = ("Converter",)
-
-
-@typing.runtime_checkable
-class Converter(Protocol[T_co]):
-    """A protocol representing a class used to convert an argument."""
-
-    async def convert(self, ctx: "BaseContext", argument: Any) -> T_co:
-        """
-        The function that converts an argument to the appropriate type.
-
-        This should be overridden by subclasses for their conversion logic.
-
-        Args:
-            ctx: The context to use for the conversion.
-            argument: The argument to be converted.
-
-        Returns:
-            Any: The converted argument.
-        """
-        raise NotImplementedError("Derived classes need to implement this.")
-
-
-class CanRequest(Protocol[T_co]):
-    async def request(
-        self,
-        route: Route,
-        payload: list | dict | None = None,
-        files: list[UPLOADABLE_TYPE] | None = None,
-        reason: str | None = None,
-        params: dict | None = None,
-        **kwargs: dict,
-    ) -> str | dict[str, Any] | None:
-        raise NotImplementedError("Derived classes need to implement this.")
+import typing
+from typing import Protocol, Any, TYPE_CHECKING
+
+from interactions.api.http.route import Route
+from interactions.client.const import T_co
+from interactions.models.discord.file import UPLOADABLE_TYPE
+
+if TYPE_CHECKING:
+    from interactions.models.internal.context import BaseContext
+
+__all__ = ("Converter",)
+
+
+@typing.runtime_checkable
+class Converter(Protocol[T_co]):
+    """A protocol representing a class used to convert an argument."""
+
+    async def convert(self, ctx: "BaseContext", argument: Any) -> T_co:
+        """
+        The function that converts an argument to the appropriate type.
+
+        This should be overridden by subclasses for their conversion logic.
+
+        Args:
+            ctx: The context to use for the conversion.
+            argument: The argument to be converted.
+
+        Returns:
+            Any: The converted argument.
+        """
+        raise NotImplementedError("Derived classes need to implement this.")
+
+
+class CanRequest(Protocol[T_co]):
+    async def request(
+        self,
+        route: Route,
+        payload: list | dict | None = None,
+        files: list[UPLOADABLE_TYPE] | None = None,
+        reason: str | None = None,
+        params: dict | None = None,
+        **kwargs: dict,
+    ) -> str | dict[str, Any] | None:
+        raise NotImplementedError("Derived classes need to implement this.")
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/internal/tasks/task.py` & `discord-py-interactions-5.6.0/interactions/models/internal/tasks/task.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,168 +1,168 @@
-import asyncio
-import inspect
-from asyncio import Task as _Task
-from datetime import datetime, timedelta
-from typing import Callable
-
-import interactions
-from interactions.client.const import get_logger
-from .triggers import BaseTrigger
-
-__all__ = ("Task",)
-
-
-class Task:
-    """
-    Create an asynchronous background tasks. Tasks allow you to run code according to a trigger object.
-
-    A task's trigger must inherit from `BaseTrigger`.
-
-    Attributes:
-        callback (Callable): The function to be called when the trigger is triggered.
-        trigger (BaseTrigger): The trigger object that determines when the task should run.
-        task (Optional[_Task]): The task object that is running the trigger loop.
-        iteration (int): The number of times the task has run.
-
-    """
-
-    callback: Callable
-    trigger: BaseTrigger
-    task: _Task | None
-    _stop: asyncio.Event
-    iteration: int
-
-    def __init__(self, callback: Callable, trigger: BaseTrigger) -> None:
-        self.callback = callback
-        self.trigger = trigger
-        self._stop = asyncio.Event()
-        self.task = None
-        self.iteration = 0
-
-    @property
-    def started(self) -> bool:
-        """Whether the task is started"""
-        return self.task is not None
-
-    @property
-    def running(self) -> bool:
-        """Whether the task is running"""
-        return self.task is not None and not self.task.done()
-
-    @property
-    def done(self) -> bool:
-        """Whether the task is done/finished"""
-        return self.task is not None and self.task.done()
-
-    @property
-    def next_run(self) -> datetime | None:
-        """Get the next datetime this task will run."""
-        return self.trigger.next_fire() if self.running else None
-
-    @property
-    def delta_until_run(self) -> timedelta | None:
-        """Get the time until the next run of this task."""
-        if not self.running:
-            return None
-
-        next_run = self.next_run
-        return next_run - datetime.now() if next_run is not None else None
-
-    def on_error_sentry_hook(self, error: Exception) -> None:
-        """A dummy method for interactions.ext.sentry to hook"""
-
-    def on_error(self, error: Exception) -> None:
-        """Error handler for this task. Called when an exception is raised during execution of the task."""
-        self.on_error_sentry_hook(error)
-        interactions.Client.default_error_handler("Task", error)
-
-    async def __call__(self) -> None:
-        try:
-            if inspect.iscoroutinefunction(self.callback):
-                val = await self.callback()
-            else:
-                val = self.callback()
-
-            if isinstance(val, BaseTrigger):
-                self.reschedule(val)
-        except Exception as e:
-            self.on_error(e)
-
-    def _fire(self, fire_time: datetime) -> None:
-        """Called when the task is being fired."""
-        self.trigger.last_call_time = fire_time
-        _ = asyncio.create_task(self())
-        self.iteration += 1
-
-    async def _task_loop(self) -> None:
-        """The main task loop to fire the task at the specified time based on triggers configured."""
-        while not self._stop.is_set():
-            fire_time = self.trigger.next_fire()
-            if fire_time is None:
-                return self.stop()
-
-            future = asyncio.create_task(self._stop.wait())
-            timeout = (fire_time - datetime.now()).total_seconds()
-            done, _ = await asyncio.wait([future], timeout=timeout, return_when=asyncio.FIRST_COMPLETED)
-            if future in done:
-                return None
-
-            self._fire(fire_time)
-
-    def start(self) -> None:
-        """Start this task."""
-        try:
-            self.trigger.reschedule()
-            self._stop.clear()
-            self.task = asyncio.create_task(self._task_loop())
-        except RuntimeError:
-            get_logger().error(
-                "Unable to start task without a running event loop! We recommend starting tasks within an `on_startup` event."
-            )
-
-    def stop(self) -> None:
-        """End this task."""
-        self._stop.set()
-        if self.task:
-            self.task.cancel()
-
-    def restart(self) -> None:
-        """Restart this task."""
-        self.stop()
-        self.start()
-
-    def reschedule(self, trigger: BaseTrigger) -> None:
-        """
-        Change the trigger being used by this task.
-
-        Args:
-            trigger: The new Trigger to use
-
-        """
-        self.trigger = trigger
-        self.restart()
-
-    @classmethod
-    def create(cls, trigger: BaseTrigger) -> Callable[[Callable], "Task"]:
-        """
-        A decorator to create a task.
-
-        Example:
-            ```python
-            @Task.create(IntervalTrigger(minutes=5))
-            async def my_task():
-                print("It's been 5 minutes!")
-
-            @listen()
-            async def on_startup():
-                my_task.start()
-            ```
-
-        Args:
-            trigger: The trigger to use for this task
-
-        """
-
-        def wrapper(func: Callable) -> "Task":
-            return cls(func, trigger)
-
-        return wrapper
+import asyncio
+import inspect
+from asyncio import Task as _Task
+from datetime import datetime, timedelta
+from typing import Callable
+
+import interactions
+from interactions.client.const import get_logger
+from .triggers import BaseTrigger
+
+__all__ = ("Task",)
+
+
+class Task:
+    """
+    Create an asynchronous background tasks. Tasks allow you to run code according to a trigger object.
+
+    A task's trigger must inherit from `BaseTrigger`.
+
+    Attributes:
+        callback (Callable): The function to be called when the trigger is triggered.
+        trigger (BaseTrigger): The trigger object that determines when the task should run.
+        task (Optional[_Task]): The task object that is running the trigger loop.
+        iteration (int): The number of times the task has run.
+
+    """
+
+    callback: Callable
+    trigger: BaseTrigger
+    task: _Task | None
+    _stop: asyncio.Event
+    iteration: int
+
+    def __init__(self, callback: Callable, trigger: BaseTrigger) -> None:
+        self.callback = callback
+        self.trigger = trigger
+        self._stop = asyncio.Event()
+        self.task = None
+        self.iteration = 0
+
+    @property
+    def started(self) -> bool:
+        """Whether the task is started"""
+        return self.task is not None
+
+    @property
+    def running(self) -> bool:
+        """Whether the task is running"""
+        return self.task is not None and not self.task.done()
+
+    @property
+    def done(self) -> bool:
+        """Whether the task is done/finished"""
+        return self.task is not None and self.task.done()
+
+    @property
+    def next_run(self) -> datetime | None:
+        """Get the next datetime this task will run."""
+        return self.trigger.next_fire() if self.running else None
+
+    @property
+    def delta_until_run(self) -> timedelta | None:
+        """Get the time until the next run of this task."""
+        if not self.running:
+            return None
+
+        next_run = self.next_run
+        return next_run - datetime.now() if next_run is not None else None
+
+    def on_error_sentry_hook(self, error: Exception) -> None:
+        """A dummy method for interactions.ext.sentry to hook"""
+
+    def on_error(self, error: Exception) -> None:
+        """Error handler for this task. Called when an exception is raised during execution of the task."""
+        self.on_error_sentry_hook(error)
+        interactions.Client.default_error_handler("Task", error)
+
+    async def __call__(self) -> None:
+        try:
+            if inspect.iscoroutinefunction(self.callback):
+                val = await self.callback()
+            else:
+                val = self.callback()
+
+            if isinstance(val, BaseTrigger):
+                self.reschedule(val)
+        except Exception as e:
+            self.on_error(e)
+
+    def _fire(self, fire_time: datetime) -> None:
+        """Called when the task is being fired."""
+        self.trigger.last_call_time = fire_time
+        _ = asyncio.create_task(self())
+        self.iteration += 1
+
+    async def _task_loop(self) -> None:
+        """The main task loop to fire the task at the specified time based on triggers configured."""
+        while not self._stop.is_set():
+            fire_time = self.trigger.next_fire()
+            if fire_time is None:
+                return self.stop()
+
+            future = asyncio.create_task(self._stop.wait())
+            timeout = (fire_time - datetime.now()).total_seconds()
+            done, _ = await asyncio.wait([future], timeout=timeout, return_when=asyncio.FIRST_COMPLETED)
+            if future in done:
+                return None
+
+            self._fire(fire_time)
+
+    def start(self) -> None:
+        """Start this task."""
+        try:
+            self.trigger.reschedule()
+            self._stop.clear()
+            self.task = asyncio.create_task(self._task_loop())
+        except RuntimeError:
+            get_logger().error(
+                "Unable to start task without a running event loop! We recommend starting tasks within an `on_startup` event."
+            )
+
+    def stop(self) -> None:
+        """End this task."""
+        self._stop.set()
+        if self.task:
+            self.task.cancel()
+
+    def restart(self) -> None:
+        """Restart this task."""
+        self.stop()
+        self.start()
+
+    def reschedule(self, trigger: BaseTrigger) -> None:
+        """
+        Change the trigger being used by this task.
+
+        Args:
+            trigger: The new Trigger to use
+
+        """
+        self.trigger = trigger
+        self.restart()
+
+    @classmethod
+    def create(cls, trigger: BaseTrigger) -> Callable[[Callable], "Task"]:
+        """
+        A decorator to create a task.
+
+        Example:
+            ```python
+            @Task.create(IntervalTrigger(minutes=5))
+            async def my_task():
+                print("It's been 5 minutes!")
+
+            @listen()
+            async def on_startup():
+                my_task.start()
+            ```
+
+        Args:
+            trigger: The trigger to use for this task
+
+        """
+
+        def wrapper(func: Callable) -> "Task":
+            return cls(func, trigger)
+
+        return wrapper
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/misc/context_manager.py` & `discord-py-interactions-5.6.0/interactions/models/misc/context_manager.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from asyncio import sleep, Task, create_task
-from typing import TYPE_CHECKING
-
-from interactions.client.const import Absent, MISSING
-
-if TYPE_CHECKING:
-    from interactions import MessageableMixin
-
-__all__ = ("Typing",)
-
-
-class Typing:
-    """
-    A context manager to send a typing state to a given channel as long as long as the wrapped operation takes.
-
-    Args:
-        channel: The channel to send the typing state to
-    """
-
-    def __init__(self, channel: "MessageableMixin") -> None:
-        self._task: Absent[Task] = MISSING
-        self.channel: "MessageableMixin" = channel
-        self._stop: bool = False
-
-    async def _typing_task(self) -> None:
-        while not self._stop:
-            await self.channel.trigger_typing()
-            await sleep(5)
-
-    async def __aenter__(self) -> None:
-        self.task = create_task(self._typing_task())
-
-    async def __aexit__(self, *_) -> None:
-        self._stop = True
-        self.task.cancel()
+from asyncio import sleep, Task, create_task
+from typing import TYPE_CHECKING
+
+from interactions.client.const import Absent, MISSING
+
+if TYPE_CHECKING:
+    from interactions import MessageableMixin
+
+__all__ = ("Typing",)
+
+
+class Typing:
+    """
+    A context manager to send a typing state to a given channel as long as long as the wrapped operation takes.
+
+    Args:
+        channel: The channel to send the typing state to
+    """
+
+    def __init__(self, channel: "MessageableMixin") -> None:
+        self._task: Absent[Task] = MISSING
+        self.channel: "MessageableMixin" = channel
+        self._stop: bool = False
+
+    async def _typing_task(self) -> None:
+        while not self._stop:
+            await self.channel.trigger_typing()
+            await sleep(5)
+
+    async def __aenter__(self) -> None:
+        self.task = create_task(self._typing_task())
+
+    async def __aexit__(self, *_) -> None:
+        self._stop = True
+        self.task.cancel()
```

### Comparing `discord-py-interactions-5.5.1/interactions/models/misc/iterator.py` & `discord-py-interactions-5.6.0/interactions/models/misc/iterator.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,97 +1,97 @@
-import asyncio
-from abc import ABC, abstractmethod
-from asyncio import QueueEmpty
-from collections.abc import AsyncIterator as _AsyncIterator
-from typing import List, Any
-
-from interactions.client.const import MISSING, Absent
-from interactions.models.discord import snowflake
-
-__all__ = ("AsyncIterator",)
-
-
-class AsyncIterator(_AsyncIterator, ABC):
-    def __init__(self, limit: int = 50) -> None:
-        self._queue: asyncio.Queue = asyncio.Queue()
-        """The queue of items in the iterator"""
-
-        self._limit: int = limit or MISSING
-        """the limit of items to retrieve"""
-
-        self.last: Absent[Any] = MISSING
-        """The last item retrieved"""
-
-        self._retrieved_objects: List = []
-        """All items this iterator has retrieved"""
-
-    @property
-    def _continue(self) -> bool:
-        """Whether iteration should continue. Returns False if the limit has been reached."""
-        return len(self._retrieved_objects) < self._limit if self._limit else True
-
-    @property
-    def get_limit(self) -> int:
-        """Get how the maximum number of items that should be retrieved."""
-        return min(self._limit - len(self._retrieved_objects), 100) if self._limit else 100
-
-    @property
-    def total_retrieved(self) -> int:
-        """Get the total number of objects this iterator has retrieved."""
-        return len(self._retrieved_objects)
-
-    async def add_object(self, obj) -> None:
-        """Add an object to iterator's queue."""
-        return await self._queue.put(obj)
-
-    @abstractmethod
-    async def fetch(self) -> list:
-        """
-        Fetch additional objects.
-
-        Your implementation of this method *must* return a list of objects.
-        If no more objects are available, raise QueueEmpty
-
-        Returns:
-            List of objects
-
-        Raises:
-            QueueEmpty:  when no more objects are available.
-
-        """
-        ...
-
-    async def _get_items(self) -> None:
-        if self._continue:
-            data = await self.fetch()
-            [await self.add_object(obj) for obj in data]
-        else:
-            raise QueueEmpty
-
-    async def __anext__(self) -> Any:
-        try:
-            if self._queue.empty():
-                await self._get_items()
-            self.last = self._queue.get_nowait()
-
-            # add the message to the already retrieved objects, so that the search function works when calling it multiple times
-            self._retrieved_objects.append(self.last)
-
-            return self.last
-        except QueueEmpty as e:
-            raise StopAsyncIteration from e
-
-    async def flatten(self) -> List:
-        """Flatten this iterator into a list of objects."""
-        return [elem async for elem in self]
-
-    async def search(self, target_id: "snowflake.Snowflake_Type") -> bool:
-        """Search the iterator for an object with the given ID."""
-        target_id = snowflake.to_snowflake(target_id)
-
-        if target_id in [o.id for o in self._retrieved_objects]:
-            return True
-
-        async for o in self:
-            if o.id == target_id:
-                return True
-        return False
+import asyncio
+from abc import ABC, abstractmethod
+from asyncio import QueueEmpty
+from collections.abc import AsyncIterator as _AsyncIterator
+from typing import List, Any
+
+from interactions.client.const import MISSING, Absent
+from interactions.models.discord import snowflake
+
+__all__ = ("AsyncIterator",)
+
+
+class AsyncIterator(_AsyncIterator, ABC):
+    def __init__(self, limit: int = 50) -> None:
+        self._queue: asyncio.Queue = asyncio.Queue()
+        """The queue of items in the iterator"""
+
+        self._limit: int = limit or MISSING
+        """the limit of items to retrieve"""
+
+        self.last: Absent[Any] = MISSING
+        """The last item retrieved"""
+
+        self._retrieved_objects: List = []
+        """All items this iterator has retrieved"""
+
+    @property
+    def _continue(self) -> bool:
+        """Whether iteration should continue. Returns False if the limit has been reached."""
+        return len(self._retrieved_objects) < self._limit if self._limit else True
+
+    @property
+    def get_limit(self) -> int:
+        """Get how the maximum number of items that should be retrieved."""
+        return min(self._limit - len(self._retrieved_objects), 100) if self._limit else 100
+
+    @property
+    def total_retrieved(self) -> int:
+        """Get the total number of objects this iterator has retrieved."""
+        return len(self._retrieved_objects)
+
+    async def add_object(self, obj) -> None:
+        """Add an object to iterator's queue."""
+        return await self._queue.put(obj)
+
+    @abstractmethod
+    async def fetch(self) -> list:
+        """
+        Fetch additional objects.
+
+        Your implementation of this method *must* return a list of objects.
+        If no more objects are available, raise QueueEmpty
+
+        Returns:
+            List of objects
+
+        Raises:
+            QueueEmpty:  when no more objects are available.
+
+        """
+        ...
+
+    async def _get_items(self) -> None:
+        if self._continue:
+            data = await self.fetch()
+            [await self.add_object(obj) for obj in data]
+        else:
+            raise QueueEmpty
+
+    async def __anext__(self) -> Any:
+        try:
+            if self._queue.empty():
+                await self._get_items()
+            self.last = self._queue.get_nowait()
+
+            # add the message to the already retrieved objects, so that the search function works when calling it multiple times
+            self._retrieved_objects.append(self.last)
+
+            return self.last
+        except QueueEmpty as e:
+            raise StopAsyncIteration from e
+
+    async def flatten(self) -> List:
+        """Flatten this iterator into a list of objects."""
+        return [elem async for elem in self]
+
+    async def search(self, target_id: "snowflake.Snowflake_Type") -> bool:
+        """Search the iterator for an object with the given ID."""
+        target_id = snowflake.to_snowflake(target_id)
+
+        if target_id in [o.id for o in self._retrieved_objects]:
+            return True
+
+        async for o in self:
+            if o.id == target_id:
+                return True
+        return False
```

### Comparing `discord-py-interactions-5.5.1/pyproject.toml` & `discord-py-interactions-5.6.0/pyproject.toml`

 * *Files 21% similar despite different names*

```diff
@@ -1,201 +1,201 @@
-[tool.poetry]
-name = "interactions.py"
-version = "5.5.1"
-description = "Easy, simple, scalable and modular: a Python API wrapper for interactions."
-authors = [
-    "LordOfPolls <dev@lordofpolls.com>",
-]
-
-[tool.poetry.dependencies]
-python = ">=3.10,<4.0"
-aiohttp = "^3.8.3"
-attrs = ">=22.1.0"
-mypy = ">0.930"
-discord-typings = "^0.5.1"
-tomli = "^2.0.1"
-emoji = "^2.1.0"
-
-# Optional dependencies
-aiodns = { version = "*", optional = true }
-orjson = { version = "*", optional = true }
-Brotli = { version = "*", optional = true }
-faust-cchardet = { version = "*", optional = true }
-uvloop = { version = "*", optional = true, platform = "!win32" }
-mkdocs-autorefs = { version = "*", optional = true }
-mkdocs-awesome-pages-plugin = { version = "*", optional = true }
-mkdocs-material = { version = "*", optional = true }
-mkdocstrings-python = { version = "*", optional = true }
-mkdocs-minify-plugin = { version = "*", optional = true }
-mkdocs-git-committers-plugin-2 = { version = "*", optional = true }
-mkdocs-git-revision-date-localized-plugin = { version = "*", optional = true }
-pytest = { version = "*", optional = true }
-pytest-asyncio = { version = "*", optional = true }
-pytest-cov = { version = "*", optional = true }
-python-dotenv = { version = "*", optional = true }
-typeguard = { version = "*", optional = true }
-pre-commit = { version = "*", optional = true }
-
-[tool.poetry.group.voice.dependencies]
-PyNaCl = "^1.5.0,<1.6"
-
-[tool.poetry.group.speedup.dependencies]
-aiodns = "*"
-orjson = "*"
-Brotli = "*"
-faust-cchardet = "*"
-uvloop = { version = "*", platform = "!win32" }
-
-[tool.poetry.group.sentry.dependencies]
-sentry-sdk = "*"
-
-[tool.poetry.group.jurigged.dependencies]
-jurigged = "*"
-
-[tool.poetry.group.console.dependencies]
-aioconsole = "^0.6.0"
-
-[tool.poetry.group.docs.dependencies]
-mkdocs-autorefs = "*"
-mkdocs-awesome-pages-plugin = "*"
-mkdocs-material = "*"
-mkdocstrings-python = "*"
-mkdocs-minify-plugin = "*"
-mkdocs-git-committers-plugin-2 = "*"
-mkdocs-git-revision-date-localized-plugin = "*"
-
-[tool.poetry.group.tests.dependencies]
-pytest = "*"
-pytest-asyncio = "*"
-pytest-cov = "*"
-python-dotenv = "*"
-typeguard = "*"
-
-
-[tool.poetry.group.dev.dependencies]
-black = "^22.3.0"
-pre-commit = "^2.19.0"
-
-[tool.black]
-line-length = 120
-
-[tool.isort]
-profile = "black"
-skip = ["__init__.py"]
-
-[tool.mypy]
-ignore_missing_imports = true
-plugins = "naff.ext.mypy"
-
-[tool.pyright]
-useLibraryCodeForTypes = true
-reportMissingImports = false
-
-[tool.coverage.report]
-exclude_lines = [
-    "pragma: no cover",
-    "if TYPE_CHECKING:",
-]
-
-[tool.coverage.run]
-omit = [
-    "tests/*",
-]
-
-[build-system]
-requires = [
-    "setuptools",
-    "tomli",
-]
-build-backend = "setuptools.build_meta"
-
-[tools.coverage.run]
-source = [
-    "interactions",
-]
-
-[tool.pytest.ini_options]
-addopts = "-l -ra --durations=2 --junitxml=TestResults.xml"
-doctest_optionflags = "NORMALIZE_WHITESPACE"
-asyncio_mode="auto"
-log_cli = "1"
-# log_cli_level = "DEBUG"
-log_cli_format = "%(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)"
-log_cli_date_format="%Y-%m-%d %H:%M:%S"
-
-[tool.ruff]
-line-length = 120
-target-version = "py310"
-ignore-init-module-imports = true
-task-tags = ["TODO", "FIXME", "XXX", "HACK", "REVIEW", "NOTE"]
-show-source = false  # set to true if you want to see the source of the error/warning
-select = ["E", "F", "B", "Q", "RUF", "D", "ANN", "RET", "C"]
-ignore = [
-    "Q0", "E501",
-    # These default to arguing with Black.  We might configure some of them eventually
-    "ANN1",
-    # These insist that we have Type Annotations for self and cls.
-    "D105", "D107",
-    # Missing Docstrings in magic method and __init__
-    "D401",
-    # First line should be in imperative mood; try rephrasing
-    "D400", "D415",
-    # First line should end with a period
-    "D106",
-    # Missing docstring in public nested class.  This doesn't work well with Metadata classes.
-    "D417",
-    # Missing argument in the docstring
-    "D406",
-    # Section name should end with a newline
-    "D407",
-    # Missing dashed underline after section
-    "D212",
-    # Multi-line docstring summary should start at the first line
-    "D404",
-    # First word of the docstring should not be This
-    "D203",
-    # 1 blank line required before class docstring
-
-    # Everything below this line is something we care about, but don't currently meet
-    "ANN001",
-    # Missing type annotation for function argument 'token'
-    "ANN002",
-    # Missing type annotation for *args
-    "ANN003",
-    # Missing type annotation for **kwargs
-    "ANN401",
-    # Dynamically typed expressions (typing.Any) are disallowed
-#    "B009",
-    # Do not call getattr with a constant attribute value, it is not any safer than normal property access.
-    "B010",
-    # Do not call setattr with a constant attribute value, it is not any safer than normal property access.
-    "D100",
-    # Missing docstring in public module
-    "D101",
-    # ... class
-    "D102",
-    # ... method
-    "D103",
-    # ... function
-    "D104",
-    # ... package
-
-    # Plugins we don't currently include: flake8-return
-    "RET503",
-    # missing explicit return at the  end of function ableto return non-None value.
-    "RET504",
-    # unecessary variable assignement before return statement.
-]
-
-[tool.ruff.flake8-quotes]
-docstring-quotes = "double"
-
-[tool.ruff.flake8-annotations]
-mypy-init-return = true
-suppress-dummy-args = true
-suppress-none-returning = true
-
-[tool.ruff.flake8-errmsg]
-max-string-length = 20
-
-[tool.ruff.mccabe]
-max-complexity = 13
+[tool.poetry]
+name = "interactions.py"
+version = "5.6.0"
+description = "Easy, simple, scalable and modular: a Python API wrapper for interactions."
+authors = [
+    "LordOfPolls <dev@lordofpolls.com>",
+]
+
+[tool.poetry.dependencies]
+python = ">=3.10,<4.0"
+aiohttp = "^3.8.3"
+attrs = ">=22.1.0"
+mypy = ">0.930"
+discord-typings = "^0.5.1"
+tomli = "^2.0.1"
+emoji = "^2.1.0"
+
+# Optional dependencies
+aiodns = { version = "*", optional = true }
+orjson = { version = "*", optional = true }
+Brotli = { version = "*", optional = true }
+faust-cchardet = { version = "*", optional = true }
+uvloop = { version = "*", optional = true, platform = "!win32" }
+mkdocs-autorefs = { version = "*", optional = true }
+mkdocs-awesome-pages-plugin = { version = "*", optional = true }
+mkdocs-material = { version = "*", optional = true }
+mkdocstrings-python = { version = "*", optional = true }
+mkdocs-minify-plugin = { version = "*", optional = true }
+mkdocs-git-committers-plugin-2 = { version = "*", optional = true }
+mkdocs-git-revision-date-localized-plugin = { version = "*", optional = true }
+pytest = { version = "*", optional = true }
+pytest-asyncio = { version = "*", optional = true }
+pytest-cov = { version = "*", optional = true }
+python-dotenv = { version = "*", optional = true }
+typeguard = { version = "*", optional = true }
+pre-commit = { version = "*", optional = true }
+
+[tool.poetry.group.voice.dependencies]
+PyNaCl = "^1.5.0,<1.6"
+
+[tool.poetry.group.speedup.dependencies]
+aiodns = "*"
+orjson = "*"
+Brotli = "*"
+faust-cchardet = "*"
+uvloop = { version = "*", platform = "!win32" }
+
+[tool.poetry.group.sentry.dependencies]
+sentry-sdk = "*"
+
+[tool.poetry.group.jurigged.dependencies]
+jurigged = "*"
+
+[tool.poetry.group.console.dependencies]
+aioconsole = "^0.6.0"
+
+[tool.poetry.group.docs.dependencies]
+mkdocs-autorefs = "*"
+mkdocs-awesome-pages-plugin = "*"
+mkdocs-material = "*"
+mkdocstrings-python = "*"
+mkdocs-minify-plugin = "*"
+mkdocs-git-committers-plugin-2 = "*"
+mkdocs-git-revision-date-localized-plugin = "*"
+
+[tool.poetry.group.tests.dependencies]
+pytest = "*"
+pytest-asyncio = "*"
+pytest-cov = "*"
+python-dotenv = "*"
+typeguard = "*"
+
+
+[tool.poetry.group.dev.dependencies]
+black = "^22.3.0"
+pre-commit = "^2.19.0"
+
+[tool.black]
+line-length = 120
+
+[tool.isort]
+profile = "black"
+skip = ["__init__.py"]
+
+[tool.mypy]
+ignore_missing_imports = true
+plugins = "naff.ext.mypy"
+
+[tool.pyright]
+useLibraryCodeForTypes = true
+reportMissingImports = false
+
+[tool.coverage.report]
+exclude_lines = [
+    "pragma: no cover",
+    "if TYPE_CHECKING:",
+]
+
+[tool.coverage.run]
+omit = [
+    "tests/*",
+]
+
+[build-system]
+requires = [
+    "setuptools",
+    "tomli",
+]
+build-backend = "setuptools.build_meta"
+
+[tools.coverage.run]
+source = [
+    "interactions",
+]
+
+[tool.pytest.ini_options]
+addopts = "-l -ra --durations=2 --junitxml=TestResults.xml"
+doctest_optionflags = "NORMALIZE_WHITESPACE"
+asyncio_mode="auto"
+log_cli = "1"
+# log_cli_level = "DEBUG"
+log_cli_format = "%(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)"
+log_cli_date_format="%Y-%m-%d %H:%M:%S"
+
+[tool.ruff]
+line-length = 120
+target-version = "py310"
+ignore-init-module-imports = true
+task-tags = ["TODO", "FIXME", "XXX", "HACK", "REVIEW", "NOTE"]
+show-source = false  # set to true if you want to see the source of the error/warning
+select = ["E", "F", "B", "Q", "RUF", "D", "ANN", "RET", "C"]
+ignore = [
+    "Q0", "E501",
+    # These default to arguing with Black.  We might configure some of them eventually
+    "ANN1",
+    # These insist that we have Type Annotations for self and cls.
+    "D105", "D107",
+    # Missing Docstrings in magic method and __init__
+    "D401",
+    # First line should be in imperative mood; try rephrasing
+    "D400", "D415",
+    # First line should end with a period
+    "D106",
+    # Missing docstring in public nested class.  This doesn't work well with Metadata classes.
+    "D417",
+    # Missing argument in the docstring
+    "D406",
+    # Section name should end with a newline
+    "D407",
+    # Missing dashed underline after section
+    "D212",
+    # Multi-line docstring summary should start at the first line
+    "D404",
+    # First word of the docstring should not be This
+    "D203",
+    # 1 blank line required before class docstring
+
+    # Everything below this line is something we care about, but don't currently meet
+    "ANN001",
+    # Missing type annotation for function argument 'token'
+    "ANN002",
+    # Missing type annotation for *args
+    "ANN003",
+    # Missing type annotation for **kwargs
+    "ANN401",
+    # Dynamically typed expressions (typing.Any) are disallowed
+#    "B009",
+    # Do not call getattr with a constant attribute value, it is not any safer than normal property access.
+    "B010",
+    # Do not call setattr with a constant attribute value, it is not any safer than normal property access.
+    "D100",
+    # Missing docstring in public module
+    "D101",
+    # ... class
+    "D102",
+    # ... method
+    "D103",
+    # ... function
+    "D104",
+    # ... package
+
+    # Plugins we don't currently include: flake8-return
+    "RET503",
+    # missing explicit return at the  end of function ableto return non-None value.
+    "RET504",
+    # unecessary variable assignement before return statement.
+]
+
+[tool.ruff.flake8-quotes]
+docstring-quotes = "double"
+
+[tool.ruff.flake8-annotations]
+mypy-init-return = true
+suppress-dummy-args = true
+suppress-none-returning = true
+
+[tool.ruff.flake8-errmsg]
+max-string-length = 20
+
+[tool.ruff.mccabe]
+max-complexity = 13
```

### Comparing `discord-py-interactions-5.5.1/setup.py` & `discord-py-interactions-5.6.0/setup.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,69 +1,69 @@
-import itertools
-from pathlib import Path
-
-import tomli
-from setuptools import find_packages, setup
-
-with open("pyproject.toml", "rb") as f:
-    pyproject = tomli.load(f)
-
-extras_require = {
-    "voice": ["PyNaCl>=1.5.0,<1.6"],
-    "speedup": ["aiodns", "orjson", "Brotli", "faust-cchardet", "uvloop; sys_platform != 'win32'"],
-    "sentry": ["sentry-sdk"],
-    "jurigged": ["jurigged"],
-    "console": ["aioconsole>=0.6.0"],
-}
-extras_require["all"] = list(itertools.chain.from_iterable(extras_require.values()))
-extras_require["docs"] = extras_require["all"] + [
-    "mkdocs-autorefs",
-    "mkdocs-awesome-pages-plugin",
-    "mkdocs-material",
-    "mkdocstrings-python",
-    "mkdocs-minify-plugin",
-    "mkdocs-git-committers-plugin-2",
-    "mkdocs-git-revision-date-localized-plugin",
-]
-extras_require["tests"] = [
-    "pytest",
-    "pytest-asyncio",
-    "pytest-cov",
-    "python-dotenv",
-    "typeguard",
-]
-extras_require["dev"] = extras_require["tests"] + extras_require["docs"] + ["pre-commit"]
-
-setup(
-    name="discord-py-interactions",
-    description=pyproject["tool"]["poetry"]["description"],
-    long_description=(Path(__file__).parent / "README.md").read_text(),
-    long_description_content_type="text/markdown",
-    author="LordOfPolls",
-    author_email="dev@lordofpolls.com",
-    url="https://github.com/interactions-py/interactions.py",
-    version=pyproject["tool"]["poetry"]["version"],
-    packages=find_packages(),
-    include_package_data=True,
-    python_requires=">=3.10",
-    install_requires=(Path(__file__).parent / "requirements.txt").read_text().splitlines(),
-    classifiers=[
-        "Development Status :: 3 - Alpha",
-        "Framework :: AsyncIO",
-        "Framework :: aiohttp",
-        "Intended Audience :: Developers",
-        "License :: OSI Approved :: MIT License",
-        "Natural Language :: English",
-        "Operating System :: OS Independent",
-        "Programming Language :: Python :: 3",
-        "Programming Language :: Python :: 3.10",
-        "Topic :: Software Development :: Libraries",
-        "Topic :: Software Development :: Libraries :: Python Modules",
-        "Topic :: Documentation",
-        "Typing :: Typed",
-    ],
-    project_urls={
-        "Discord": "https://discord.gg/KkgMBVuEkx",
-        "Documentation": "https://naff-docs.readthedocs.io/en/latest/",  # TODO: replace
-    },
-    extras_require=extras_require,
-)
+import itertools
+from pathlib import Path
+
+import tomli
+from setuptools import find_packages, setup
+
+with open("pyproject.toml", "rb") as f:
+    pyproject = tomli.load(f)
+
+extras_require = {
+    "voice": ["PyNaCl>=1.5.0,<1.6"],
+    "speedup": ["aiodns", "orjson", "Brotli", "faust-cchardet", "uvloop; sys_platform != 'win32'"],
+    "sentry": ["sentry-sdk"],
+    "jurigged": ["jurigged"],
+    "console": ["aioconsole>=0.6.0"],
+}
+extras_require["all"] = list(itertools.chain.from_iterable(extras_require.values()))
+extras_require["docs"] = extras_require["all"] + [
+    "mkdocs-autorefs",
+    "mkdocs-awesome-pages-plugin",
+    "mkdocs-material",
+    "mkdocstrings-python",
+    "mkdocs-minify-plugin",
+    "mkdocs-git-committers-plugin-2",
+    "mkdocs-git-revision-date-localized-plugin",
+]
+extras_require["tests"] = [
+    "pytest",
+    "pytest-asyncio",
+    "pytest-cov",
+    "python-dotenv",
+    "typeguard",
+]
+extras_require["dev"] = extras_require["tests"] + extras_require["docs"] + ["pre-commit"]
+
+setup(
+    name="discord-py-interactions",
+    description=pyproject["tool"]["poetry"]["description"],
+    long_description=(Path(__file__).parent / "README.md").read_text(),
+    long_description_content_type="text/markdown",
+    author="LordOfPolls",
+    author_email="dev@lordofpolls.com",
+    url="https://github.com/interactions-py/interactions.py",
+    version=pyproject["tool"]["poetry"]["version"],
+    packages=find_packages(),
+    include_package_data=True,
+    python_requires=">=3.10",
+    install_requires=(Path(__file__).parent / "requirements.txt").read_text().splitlines(),
+    classifiers=[
+        "Development Status :: 3 - Alpha",
+        "Framework :: AsyncIO",
+        "Framework :: aiohttp",
+        "Intended Audience :: Developers",
+        "License :: OSI Approved :: MIT License",
+        "Natural Language :: English",
+        "Operating System :: OS Independent",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.10",
+        "Topic :: Software Development :: Libraries",
+        "Topic :: Software Development :: Libraries :: Python Modules",
+        "Topic :: Documentation",
+        "Typing :: Typed",
+    ],
+    project_urls={
+        "Discord": "https://discord.gg/KkgMBVuEkx",
+        "Documentation": "https://naff-docs.readthedocs.io/en/latest/",  # TODO: replace
+    },
+    extras_require=extras_require,
+)
```

### Comparing `discord-py-interactions-5.5.1/tests/consts.py` & `discord-py-interactions-5.6.0/tests/consts.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,156 +1,156 @@
-"""
-A bunch of fake API responses for testing.
-
-Because the library has a habit of mangling the data (_process_dict), these are functions that will always return clean responses.
-"""
-
-import random
-import typing
-import discord_typings
-from typing import Optional
-
-__all__ = ("SAMPLE_DM_DATA", "SAMPLE_GUILD_DATA", "SAMPLE_USER_DATA")
-
-
-def SAMPLE_USER_DATA(user_id: Optional[str] = None) -> discord_typings.UserData:
-    if user_id is None:
-        user_id = "123456789012345678"
-
-    return {
-        "id": user_id,
-        "username": "test_user",
-        "discriminator": "1234",
-        "avatar": "",
-    }
-
-
-def SAMPLE_DM_DATA() -> discord_typings.DMChannelData:
-    return {
-        "id": "123456789012345679",
-        "type": 1,
-        "last_message_id": None,
-        "recipients": [SAMPLE_USER_DATA()],
-    }
-
-
-def SAMPLE_CHANNEL_DATA(
-    channel_id: Optional[str] = None, guild_id: Optional[str] = None
-) -> discord_typings.ChannelData:
-    if channel_id is None:
-        channel_id = "123456789012345678"
-    return {
-        "id": channel_id,
-        "type": 0,
-        "guild_id": guild_id,
-        "name": "test_channel",
-        "topic": "",
-        "position": 0,
-        "permission_overwrites": [],
-        "bitrate": 0,
-        "user_limit": 0,
-        "rate_limit_per_user": 0,
-        "last_message_id": None,
-        "permissions": 0,
-        "nsfw": False,
-    }
-
-
-def SAMPLE_GUILD_DATA(guild_id: Optional[str] = None) -> discord_typings.GuildData:
-    if guild_id is None:
-        guild_id = "123456789012345670"
-    return {
-        "id": guild_id,
-        "name": "test_guild",
-        "icon": "",
-        "splash": "",
-        "discovery_splash": "",
-        "owner_id": "123456789012345678",
-        "afk_channel_id": None,
-        "afk_timeout": 0,
-        "verification_level": 0,
-        "default_message_notifications": 0,
-        "explicit_content_filter": 0,
-        "roles": [],
-        "emojis": [],
-        "features": [],
-        "mfa_level": 0,
-        "application_id": None,
-        "system_channel_id": None,
-        "system_channel_flags": 0,
-        "rules_channel_id": None,
-        "vanity_url_code": None,
-        "description": None,
-        "banner": None,
-        "premium_tier": 0,
-        "preferred_locale": "en-US",
-        "public_updates_channel_id": None,
-        "nsfw_level": 0,
-        "stickers": [],
-        "premium_progress_bar_enabled": False,
-    }
-
-
-def SAMPLE_MESSAGE_DATA(
-    channel_id: Optional[str] = None,
-    user_id: Optional[str] = None,
-    message_id: Optional[str] = None,
-    guild_id: Optional[str] = None,
-) -> discord_typings.MessageCreateData:
-    if channel_id is None:
-        channel_id = "123456789012345678"
-    if message_id is None:
-        message_id = "123456789012345677"
-    data = {
-        "id": message_id,
-        "channel_id": channel_id,
-        "author": SAMPLE_USER_DATA(user_id),
-        "content": "test_message",
-        "timestamp": "2022-07-16T20:56:55.999419+01:00",
-        "edited_timestamp": None,
-        "tts": False,
-        "mention_everyone": False,
-        "mentions": [SAMPLE_USER_DATA(user_id)],
-        "mention_roles": [],
-        "mention_channels": [],
-        "attachments": [],
-        "embeds": [],
-        "reactions": [],
-        "nonce": None,
-        "pinned": False,
-        "webhook_id": None,
-        "type": 0,
-        "activity": None,
-        "application": None,
-        "application_id": None,
-        "message_reference": None,
-        "flags": 0,
-        "refereces_message": None,
-        # "interaction": None,
-        "thread": None,
-        "components": [],
-        "sticker_items": [],
-    }
-    if guild_id is not None:
-        data["guild_id"] = guild_id
-    return data
-
-
-def SAMPLE_LOCALE() -> str:
-    options = typing.get_args(discord_typings.Locales)
-    return random.sample(options, 1)[0]  # type: ignore
-
-
-def SAMPLE_APPLICATION_DATA(owner: typing.Optional[discord_typings.UserData]) -> discord_typings.ApplicationData:
-    return {
-        "id": "10001000010001",
-        "name": "Sample Application",
-        "description": "Mock data, this is not a real bot.",
-        "rpc_origins": [],
-        "bot_public": False,
-        "bot_require_code_grant": False,
-        "owner": owner,
-        "verify_key": "",
-        "summary": "",
-        "icon": None,
-        "team": None,
-    }
+"""
+A bunch of fake API responses for testing.
+
+Because the library has a habit of mangling the data (_process_dict), these are functions that will always return clean responses.
+"""
+
+import random
+import typing
+import discord_typings
+from typing import Optional
+
+__all__ = ("SAMPLE_DM_DATA", "SAMPLE_GUILD_DATA", "SAMPLE_USER_DATA")
+
+
+def SAMPLE_USER_DATA(user_id: Optional[str] = None) -> discord_typings.UserData:
+    if user_id is None:
+        user_id = "123456789012345678"
+
+    return {
+        "id": user_id,
+        "username": "test_user",
+        "discriminator": "1234",
+        "avatar": "",
+    }
+
+
+def SAMPLE_DM_DATA() -> discord_typings.DMChannelData:
+    return {
+        "id": "123456789012345679",
+        "type": 1,
+        "last_message_id": None,
+        "recipients": [SAMPLE_USER_DATA()],
+    }
+
+
+def SAMPLE_CHANNEL_DATA(
+    channel_id: Optional[str] = None, guild_id: Optional[str] = None
+) -> discord_typings.ChannelData:
+    if channel_id is None:
+        channel_id = "123456789012345678"
+    return {
+        "id": channel_id,
+        "type": 0,
+        "guild_id": guild_id,
+        "name": "test_channel",
+        "topic": "",
+        "position": 0,
+        "permission_overwrites": [],
+        "bitrate": 0,
+        "user_limit": 0,
+        "rate_limit_per_user": 0,
+        "last_message_id": None,
+        "permissions": 0,
+        "nsfw": False,
+    }
+
+
+def SAMPLE_GUILD_DATA(guild_id: Optional[str] = None) -> discord_typings.GuildData:
+    if guild_id is None:
+        guild_id = "123456789012345670"
+    return {
+        "id": guild_id,
+        "name": "test_guild",
+        "icon": "",
+        "splash": "",
+        "discovery_splash": "",
+        "owner_id": "123456789012345678",
+        "afk_channel_id": None,
+        "afk_timeout": 0,
+        "verification_level": 0,
+        "default_message_notifications": 0,
+        "explicit_content_filter": 0,
+        "roles": [],
+        "emojis": [],
+        "features": [],
+        "mfa_level": 0,
+        "application_id": None,
+        "system_channel_id": None,
+        "system_channel_flags": 0,
+        "rules_channel_id": None,
+        "vanity_url_code": None,
+        "description": None,
+        "banner": None,
+        "premium_tier": 0,
+        "preferred_locale": "en-US",
+        "public_updates_channel_id": None,
+        "nsfw_level": 0,
+        "stickers": [],
+        "premium_progress_bar_enabled": False,
+    }
+
+
+def SAMPLE_MESSAGE_DATA(
+    channel_id: Optional[str] = None,
+    user_id: Optional[str] = None,
+    message_id: Optional[str] = None,
+    guild_id: Optional[str] = None,
+) -> discord_typings.MessageCreateData:
+    if channel_id is None:
+        channel_id = "123456789012345678"
+    if message_id is None:
+        message_id = "123456789012345677"
+    data = {
+        "id": message_id,
+        "channel_id": channel_id,
+        "author": SAMPLE_USER_DATA(user_id),
+        "content": "test_message",
+        "timestamp": "2022-07-16T20:56:55.999419+01:00",
+        "edited_timestamp": None,
+        "tts": False,
+        "mention_everyone": False,
+        "mentions": [SAMPLE_USER_DATA(user_id)],
+        "mention_roles": [],
+        "mention_channels": [],
+        "attachments": [],
+        "embeds": [],
+        "reactions": [],
+        "nonce": None,
+        "pinned": False,
+        "webhook_id": None,
+        "type": 0,
+        "activity": None,
+        "application": None,
+        "application_id": None,
+        "message_reference": None,
+        "flags": 0,
+        "refereces_message": None,
+        # "interaction": None,
+        "thread": None,
+        "components": [],
+        "sticker_items": [],
+    }
+    if guild_id is not None:
+        data["guild_id"] = guild_id
+    return data
+
+
+def SAMPLE_LOCALE() -> str:
+    options = typing.get_args(discord_typings.Locales)
+    return random.sample(options, 1)[0]  # type: ignore
+
+
+def SAMPLE_APPLICATION_DATA(owner: typing.Optional[discord_typings.UserData]) -> discord_typings.ApplicationData:
+    return {
+        "id": "10001000010001",
+        "name": "Sample Application",
+        "description": "Mock data, this is not a real bot.",
+        "rpc_origins": [],
+        "bot_public": False,
+        "bot_require_code_grant": False,
+        "owner": owner,
+        "verify_key": "",
+        "summary": "",
+        "icon": None,
+        "team": None,
+    }
```

### Comparing `discord-py-interactions-5.5.1/tests/test_contexts.py` & `discord-py-interactions-5.6.0/tests/test_contexts.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-import interactions
-from interactions.client.client import Client
-from interactions.models.discord.application import Application
-from interactions.models.discord.guild import Guild
-from tests.consts import SAMPLE_APPLICATION_DATA, SAMPLE_CHANNEL_DATA, SAMPLE_GUILD_DATA, SAMPLE_USER_DATA
-from tests.utils import generate_dummy_context
-
-from discord_typings import UserData
-import pytest
-
-
-__all__ = ()
-
-
-@pytest.fixture()
-def owner() -> UserData:
-    return SAMPLE_USER_DATA()
-
-
-@pytest.fixture()
-def bot(owner: UserData) -> Client:
-    bot = Client()
-    u = bot.cache.place_user_data(owner)
-    bot._app = Application.from_dict(SAMPLE_APPLICATION_DATA(owner), bot)
-    bot.owner_ids.add(u.id)
-    assert bot.owner is not None
-    assert bot.owner is u
-    return bot
-
-
-@pytest.fixture()
-def guild(bot: Client) -> Guild:
-    return bot.cache.place_guild_data(SAMPLE_GUILD_DATA(guild_id=1234123412341234))
-
-
-@pytest.mark.asyncio
-async def test_checks(bot: Client, guild: Guild) -> None:
-    user_id = 121216789012345678
-    assert bot.owner is not None
-    assert user_id != bot.owner.id
-
-    is_owner = interactions.is_owner()
-    assert await is_owner(generate_dummy_context(user_id=bot.owner.id, client=bot)) is True
-    assert await is_owner(generate_dummy_context(user_id=user_id, client=bot)) is False
-
-    has_id = interactions.has_id(user_id)
-    assert await has_id(generate_dummy_context(user_id=user_id, client=bot)) is True
-    assert await has_id(generate_dummy_context(user_id=bot.owner.id, client=bot)) is False
-
-    guild_only = interactions.guild_only()
-    bot.cache.place_channel_data(SAMPLE_CHANNEL_DATA(guild_id=guild.id))
-    assert await guild_only(generate_dummy_context(guild_id=guild.id, client=bot)) is True
-    assert await guild_only(generate_dummy_context(dm=True)) is False
-
-    dm_only = interactions.dm_only()
-    assert await dm_only(generate_dummy_context(guild_id=guild.id, client=bot)) is False
-    assert await dm_only(generate_dummy_context(dm=True)) is True
+import interactions
+from interactions.client.client import Client
+from interactions.models.discord.application import Application
+from interactions.models.discord.guild import Guild
+from tests.consts import SAMPLE_APPLICATION_DATA, SAMPLE_CHANNEL_DATA, SAMPLE_GUILD_DATA, SAMPLE_USER_DATA
+from tests.utils import generate_dummy_context
+
+from discord_typings import UserData
+import pytest
+
+
+__all__ = ()
+
+
+@pytest.fixture()
+def owner() -> UserData:
+    return SAMPLE_USER_DATA()
+
+
+@pytest.fixture()
+def bot(owner: UserData) -> Client:
+    bot = Client()
+    u = bot.cache.place_user_data(owner)
+    bot._app = Application.from_dict(SAMPLE_APPLICATION_DATA(owner), bot)
+    bot.owner_ids.add(u.id)
+    assert bot.owner is not None
+    assert bot.owner is u
+    return bot
+
+
+@pytest.fixture()
+def guild(bot: Client) -> Guild:
+    return bot.cache.place_guild_data(SAMPLE_GUILD_DATA(guild_id=1234123412341234))
+
+
+@pytest.mark.asyncio
+async def test_checks(bot: Client, guild: Guild) -> None:
+    user_id = 121216789012345678
+    assert bot.owner is not None
+    assert user_id != bot.owner.id
+
+    is_owner = interactions.is_owner()
+    assert await is_owner(generate_dummy_context(user_id=bot.owner.id, client=bot)) is True
+    assert await is_owner(generate_dummy_context(user_id=user_id, client=bot)) is False
+
+    has_id = interactions.has_id(user_id)
+    assert await has_id(generate_dummy_context(user_id=user_id, client=bot)) is True
+    assert await has_id(generate_dummy_context(user_id=bot.owner.id, client=bot)) is False
+
+    guild_only = interactions.guild_only()
+    bot.cache.place_channel_data(SAMPLE_CHANNEL_DATA(guild_id=guild.id))
+    assert await guild_only(generate_dummy_context(guild_id=guild.id, client=bot)) is True
+    assert await guild_only(generate_dummy_context(dm=True)) is False
+
+    dm_only = interactions.dm_only()
+    assert await dm_only(generate_dummy_context(guild_id=guild.id, client=bot)) is False
+    assert await dm_only(generate_dummy_context(dm=True)) is True
```

### Comparing `discord-py-interactions-5.5.1/tests/test_cooldowns.py` & `discord-py-interactions-5.6.0/tests/test_cooldowns.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,69 +1,69 @@
-import asyncio
-
-import pytest
-
-from interactions import MaxConcurrency, Buckets, CooldownSystem, Cooldown
-from tests.utils import generate_dummy_context
-
-__all__ = ()
-
-
-@pytest.mark.asyncio
-async def test_cooldowns() -> None:
-    user_id = 903968203779215401
-    context = generate_dummy_context(user_id=user_id)
-    rate = 2
-
-    cooldown = Cooldown(Buckets.USER, 1, rate)
-
-    # test cooldown locks
-    assert await cooldown.get_cooldown(context) is not None
-    assert await cooldown.on_cooldown(context) is False
-    assert await cooldown.acquire_token(context) is True
-    assert await cooldown.acquire_token(context) is False
-    assert await cooldown.on_cooldown(context) is True
-
-    # test cooldown unlock
-    await asyncio.sleep(rate)
-    assert await cooldown.get_cooldown_time(context) == 0
-    assert await cooldown.on_cooldown(context) is False
-    assert await cooldown.acquire_token(context) is True
-
-    assert isinstance(await cooldown.get_cooldown(context), CooldownSystem)
-
-    # test cooldown time
-    await cooldown.acquire_token(context)
-    assert await cooldown.get_cooldown_time(context) >= 0
-
-    # test reset
-    await cooldown.acquire_token(context)
-    assert await cooldown.on_cooldown(context) is True
-    await cooldown.reset(context)
-    assert await cooldown.on_cooldown(context) is False
-    await cooldown.acquire_token(context)
-    assert await cooldown.on_cooldown(context) is True
-    await cooldown.reset_all()
-    assert await cooldown.on_cooldown(context) is False
-
-
-@pytest.mark.asyncio
-async def test_max_concurrency() -> None:
-    user_id = 903968203779215401
-    context = generate_dummy_context(user_id=user_id)
-    concurrent = 1
-
-    max_conc = MaxConcurrency(concurrent, Buckets.USER, False)
-
-    assert isinstance(await max_conc.get_semaphore(context), asyncio.Semaphore)
-
-    assert await max_conc.acquire(context) is True
-    assert await max_conc.acquire(context) is False
-    await max_conc.release(context)
-    assert await max_conc.acquire(context) is True
-    await max_conc.release(context)
-
-
-@pytest.mark.asyncio
-async def test_buckets() -> None:
-    context = generate_dummy_context()
-    _ = (await bucket.get_key(context) for bucket in Buckets)
+import asyncio
+
+import pytest
+
+from interactions import MaxConcurrency, Buckets, CooldownSystem, Cooldown
+from tests.utils import generate_dummy_context
+
+__all__ = ()
+
+
+@pytest.mark.asyncio
+async def test_cooldowns() -> None:
+    user_id = 903968203779215401
+    context = generate_dummy_context(user_id=user_id)
+    rate = 2
+
+    cooldown = Cooldown(Buckets.USER, 1, rate)
+
+    # test cooldown locks
+    assert await cooldown.get_cooldown(context) is not None
+    assert await cooldown.on_cooldown(context) is False
+    assert await cooldown.acquire_token(context) is True
+    assert await cooldown.acquire_token(context) is False
+    assert await cooldown.on_cooldown(context) is True
+
+    # test cooldown unlock
+    await asyncio.sleep(rate)
+    assert await cooldown.get_cooldown_time(context) == 0
+    assert await cooldown.on_cooldown(context) is False
+    assert await cooldown.acquire_token(context) is True
+
+    assert isinstance(await cooldown.get_cooldown(context), CooldownSystem)
+
+    # test cooldown time
+    await cooldown.acquire_token(context)
+    assert await cooldown.get_cooldown_time(context) >= 0
+
+    # test reset
+    await cooldown.acquire_token(context)
+    assert await cooldown.on_cooldown(context) is True
+    await cooldown.reset(context)
+    assert await cooldown.on_cooldown(context) is False
+    await cooldown.acquire_token(context)
+    assert await cooldown.on_cooldown(context) is True
+    await cooldown.reset_all()
+    assert await cooldown.on_cooldown(context) is False
+
+
+@pytest.mark.asyncio
+async def test_max_concurrency() -> None:
+    user_id = 903968203779215401
+    context = generate_dummy_context(user_id=user_id)
+    concurrent = 1
+
+    max_conc = MaxConcurrency(concurrent, Buckets.USER, False)
+
+    assert isinstance(await max_conc.get_semaphore(context), asyncio.Semaphore)
+
+    assert await max_conc.acquire(context) is True
+    assert await max_conc.acquire(context) is False
+    await max_conc.release(context)
+    assert await max_conc.acquire(context) is True
+    await max_conc.release(context)
+
+
+@pytest.mark.asyncio
+async def test_buckets() -> None:
+    context = generate_dummy_context()
+    _ = (await bucket.get_key(context) for bucket in Buckets)
```

### Comparing `discord-py-interactions-5.5.1/tests/test_emoji.py` & `discord-py-interactions-5.6.0/tests/test_emoji.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,140 +1,140 @@
-import string
-
-import emoji
-
-from interactions.models.discord.emoji import PartialEmoji, process_emoji, process_emoji_req_format
-
-__all__ = ()
-
-
-def test_emoji_comparisons() -> None:
-    thumbs_emoji = "👍"
-    custom_emoji = "<:sparklesnek:910496037708374016>"
-
-    e = PartialEmoji.from_str(thumbs_emoji)
-    assert e != thumbs_emoji
-    assert e.name == thumbs_emoji
-
-    e = PartialEmoji.from_str(custom_emoji)
-    assert e != custom_emoji
-    assert e.name == "sparklesnek"
-    assert e.id == 910496037708374016
-
-
-def test_emoji_formatting() -> None:
-    sample = "<:sparklesnek:910496037708374016>"
-    target = "sparklesnek:910496037708374016"
-
-    emoji = PartialEmoji.from_str(sample)
-
-    assert emoji.req_format == target
-    assert process_emoji_req_format(sample) == target
-    assert process_emoji_req_format({"id": 910496037708374016, "name": "sparklesnek", "animated": True}) == target
-
-
-def test_emoji_processing() -> None:
-    raw_sample = "<:sparklesnek:910496037708374016>"
-    dict_sample = {"id": 910496037708374016, "name": "sparklesnek", "animated": False}
-    unicode_sample = "👍"
-    target = "sparklesnek:910496037708374016"
-
-    assert process_emoji_req_format(raw_sample) == target
-    assert process_emoji_req_format(dict_sample) == target
-    assert process_emoji_req_format(unicode_sample) == unicode_sample
-
-    raw_emoji = process_emoji(raw_sample)
-    dict_emoji = process_emoji(dict_sample)
-    unicode_emoji = process_emoji(unicode_sample)
-
-    assert isinstance(raw_emoji, dict) and raw_emoji == dict_sample
-    assert isinstance(dict_emoji, dict) and dict_emoji == dict_sample
-    assert isinstance(unicode_emoji, dict) and unicode_emoji == {"name": "👍", "animated": False}
-
-    from_str = PartialEmoji.from_str(raw_sample)
-    assert from_str.req_format == target
-    assert from_str.id == 910496037708374016
-    assert from_str.name == "sparklesnek"
-    assert from_str.animated is False
-    assert str(from_str) == raw_sample
-
-    assert PartialEmoji.from_str("<a:sparklesnek:910496037708374016>").animated is True
-
-
-def test_unicode_recognition() -> None:
-    for _e in emoji.EMOJI_DATA:
-        assert PartialEmoji.from_str(_e) is not None
-
-
-def test_regional_indicators() -> None:
-    regional_indicators = [
-        "🇦",
-        "🇧",
-        "🇨",
-        "🇩",
-        "🇪",
-        "🇫",
-        "🇬",
-        "🇭",
-        "🇮",
-        "🇯",
-        "🇰",
-        "🇱",
-        "🇲",
-        "🇳",
-        "🇴",
-        "🇵",
-        "🇶",
-        "🇷",
-        "🇸",
-        "🇹",
-        "🇺",
-        "🇻",
-        "🇼",
-        "🇽",
-        "🇾",
-        "🇿",
-    ]
-    for _e in regional_indicators:
-        assert PartialEmoji.from_str(_e) is not None
-
-
-def test_numerical_emoji() -> None:
-    numerical_emoji = ["0️⃣", "1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣"]
-    for _e in numerical_emoji:
-        assert PartialEmoji.from_str(_e) is not None
-
-
-def test_false_positives() -> None:
-    for _e in string.printable:
-        assert PartialEmoji.from_str(_e) is None
-
-    unicode_general_punctuation = [
-        "’",  # noqa: RUF001
-        "‘",  # noqa: RUF001
-        "“",
-        "”",
-        "…",
-        "–",  # noqa: RUF001
-        "—",
-        "•",
-        "◦",
-        "‣",
-        "⁃",  # noqa: RUF001
-        "⁎",  # noqa: RUF001
-        "⁏",
-        "⁒",
-        "⁓",  # noqa: RUF001
-        "⁺",
-        "⁻",
-        "⁼",
-        "⁽",
-        "⁾",
-        "ⁿ",
-        "₊",
-        "₋",
-        "₌",
-        "₍",
-        "₎",
-    ]
-    for _e in unicode_general_punctuation:
-        assert PartialEmoji.from_str(_e) is None
+import string
+
+import emoji
+
+from interactions.models.discord.emoji import PartialEmoji, process_emoji, process_emoji_req_format
+
+__all__ = ()
+
+
+def test_emoji_comparisons() -> None:
+    thumbs_emoji = "👍"
+    custom_emoji = "<:sparklesnek:910496037708374016>"
+
+    e = PartialEmoji.from_str(thumbs_emoji)
+    assert e != thumbs_emoji
+    assert e.name == thumbs_emoji
+
+    e = PartialEmoji.from_str(custom_emoji)
+    assert e != custom_emoji
+    assert e.name == "sparklesnek"
+    assert e.id == 910496037708374016
+
+
+def test_emoji_formatting() -> None:
+    sample = "<:sparklesnek:910496037708374016>"
+    target = "sparklesnek:910496037708374016"
+
+    emoji = PartialEmoji.from_str(sample)
+
+    assert emoji.req_format == target
+    assert process_emoji_req_format(sample) == target
+    assert process_emoji_req_format({"id": 910496037708374016, "name": "sparklesnek", "animated": True}) == target
+
+
+def test_emoji_processing() -> None:
+    raw_sample = "<:sparklesnek:910496037708374016>"
+    dict_sample = {"id": 910496037708374016, "name": "sparklesnek", "animated": False}
+    unicode_sample = "👍"
+    target = "sparklesnek:910496037708374016"
+
+    assert process_emoji_req_format(raw_sample) == target
+    assert process_emoji_req_format(dict_sample) == target
+    assert process_emoji_req_format(unicode_sample) == unicode_sample
+
+    raw_emoji = process_emoji(raw_sample)
+    dict_emoji = process_emoji(dict_sample)
+    unicode_emoji = process_emoji(unicode_sample)
+
+    assert isinstance(raw_emoji, dict) and raw_emoji == dict_sample
+    assert isinstance(dict_emoji, dict) and dict_emoji == dict_sample
+    assert isinstance(unicode_emoji, dict) and unicode_emoji == {"name": "👍", "animated": False}
+
+    from_str = PartialEmoji.from_str(raw_sample)
+    assert from_str.req_format == target
+    assert from_str.id == 910496037708374016
+    assert from_str.name == "sparklesnek"
+    assert from_str.animated is False
+    assert str(from_str) == raw_sample
+
+    assert PartialEmoji.from_str("<a:sparklesnek:910496037708374016>").animated is True
+
+
+def test_unicode_recognition() -> None:
+    for _e in emoji.EMOJI_DATA:
+        assert PartialEmoji.from_str(_e) is not None
+
+
+def test_regional_indicators() -> None:
+    regional_indicators = [
+        "🇦",
+        "🇧",
+        "🇨",
+        "🇩",
+        "🇪",
+        "🇫",
+        "🇬",
+        "🇭",
+        "🇮",
+        "🇯",
+        "🇰",
+        "🇱",
+        "🇲",
+        "🇳",
+        "🇴",
+        "🇵",
+        "🇶",
+        "🇷",
+        "🇸",
+        "🇹",
+        "🇺",
+        "🇻",
+        "🇼",
+        "🇽",
+        "🇾",
+        "🇿",
+    ]
+    for _e in regional_indicators:
+        assert PartialEmoji.from_str(_e) is not None
+
+
+def test_numerical_emoji() -> None:
+    numerical_emoji = ["0️⃣", "1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣"]
+    for _e in numerical_emoji:
+        assert PartialEmoji.from_str(_e) is not None
+
+
+def test_false_positives() -> None:
+    for _e in string.printable:
+        assert PartialEmoji.from_str(_e) is None
+
+    unicode_general_punctuation = [
+        "’",  # noqa: RUF001
+        "‘",  # noqa: RUF001
+        "“",
+        "”",
+        "…",
+        "–",  # noqa: RUF001
+        "—",
+        "•",
+        "◦",
+        "‣",
+        "⁃",  # noqa: RUF001
+        "⁎",  # noqa: RUF001
+        "⁏",
+        "⁒",
+        "⁓",  # noqa: RUF001
+        "⁺",
+        "⁻",
+        "⁼",
+        "⁽",
+        "⁾",
+        "ⁿ",
+        "₊",
+        "₋",
+        "₌",
+        "₍",
+        "₎",
+    ]
+    for _e in unicode_general_punctuation:
+        assert PartialEmoji.from_str(_e) is None
```

### Comparing `discord-py-interactions-5.5.1/tests/utils.py` & `discord-py-interactions-5.6.0/tests/utils.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from interactions import Snowflake_Type, Client, Message
-from interactions.models.internal.context import InteractionContext
-from tests.consts import SAMPLE_MESSAGE_DATA
-from interactions.ext.prefixed_commands import PrefixedContext
-
-__all__ = ("generate_dummy_context",)
-
-
-def generate_dummy_context(
-    user_id: Snowflake_Type | None = None,
-    channel_id: Snowflake_Type | None = None,
-    guild_id: Snowflake_Type | None = None,
-    message_id: Snowflake_Type | None = None,
-    dm: bool = False,
-    client: Client | None = None,
-) -> InteractionContext:
-    """Generates a dummy context for testing."""
-    client = Client() if client is None else client
-
-    if not dm and not guild_id:
-        guild_id = "123456789012345670"
-    elif dm:
-        guild_id = None
-
-    # channel = SAMPLE_CHANNEL_DATA(channel_id=channel_id, guild_id=guild_id)
-    message = SAMPLE_MESSAGE_DATA(user_id=user_id, channel_id=channel_id, message_id=message_id, guild_id=guild_id)
-
-    return PrefixedContext.from_message(client, Message.from_dict(message, client))
+from interactions import Snowflake_Type, Client, Message
+from interactions.models.internal.context import InteractionContext
+from tests.consts import SAMPLE_MESSAGE_DATA
+from interactions.ext.prefixed_commands import PrefixedContext
+
+__all__ = ("generate_dummy_context",)
+
+
+def generate_dummy_context(
+    user_id: Snowflake_Type | None = None,
+    channel_id: Snowflake_Type | None = None,
+    guild_id: Snowflake_Type | None = None,
+    message_id: Snowflake_Type | None = None,
+    dm: bool = False,
+    client: Client | None = None,
+) -> InteractionContext:
+    """Generates a dummy context for testing."""
+    client = Client() if client is None else client
+
+    if not dm and not guild_id:
+        guild_id = "123456789012345670"
+    elif dm:
+        guild_id = None
+
+    # channel = SAMPLE_CHANNEL_DATA(channel_id=channel_id, guild_id=guild_id)
+    message = SAMPLE_MESSAGE_DATA(user_id=user_id, channel_id=channel_id, message_id=message_id, guild_id=guild_id)
+
+    return PrefixedContext.from_message(client, Message.from_dict(message, client))
```

