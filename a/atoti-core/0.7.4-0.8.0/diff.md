# Comparing `tmp/atoti_core-0.7.4-0_cb607ee-py3-none-any.whl.zip` & `tmp/atoti_core-0.8.0-0_04c5fd8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,69 +1,79 @@
-Zip file size: 60432 bytes, number of entries: 67
--rw-r--r--  2.0 unx    23139 b- defN 23-Mar-15 20:20 atoti_core/LICENSE
--rw-r--r--  2.0 unx     1823 b- defN 23-Mar-15 20:11 atoti_core/__init__.py
--rw-r--r--  2.0 unx      335 b- defN 23-Mar-15 20:11 atoti_core/_deprecated_comparison_with_none.py
--rw-r--r--  2.0 unx     1652 b- defN 23-Mar-15 20:11 atoti_core/_get_endpoint_path.py
--rw-r--r--  2.0 unx      150 b- defN 23-Mar-15 20:11 atoti_core/_other_coordinates.py
--rw-r--r--  2.0 unx      346 b- defN 23-Mar-15 20:11 atoti_core/_server_versions.py
--rw-r--r--  2.0 unx     8665 b- defN 23-Mar-15 20:11 atoti_core/activeviam_client.py
--rw-r--r--  2.0 unx      128 b- defN 23-Mar-15 20:11 atoti_core/arithmetic_operator.py
--rw-r--r--  2.0 unx     2376 b- defN 23-Mar-15 20:11 atoti_core/base_cube.py
--rw-r--r--  2.0 unx      534 b- defN 23-Mar-15 20:11 atoti_core/base_cubes.py
--rw-r--r--  2.0 unx     2269 b- defN 23-Mar-15 20:11 atoti_core/base_hierarchies.py
--rw-r--r--  2.0 unx     5670 b- defN 23-Mar-15 20:11 atoti_core/base_hierarchy.py
--rw-r--r--  2.0 unx     4945 b- defN 23-Mar-15 20:11 atoti_core/base_level.py
--rw-r--r--  2.0 unx     3672 b- defN 23-Mar-15 20:11 atoti_core/base_levels.py
--rw-r--r--  2.0 unx     2523 b- defN 23-Mar-15 20:11 atoti_core/base_measure.py
--rw-r--r--  2.0 unx     1344 b- defN 23-Mar-15 20:11 atoti_core/base_measures.py
--rw-r--r--  2.0 unx     8711 b- defN 23-Mar-15 20:11 atoti_core/base_session.py
--rw-r--r--  2.0 unx      228 b- defN 23-Mar-15 20:11 atoti_core/boolean_operator.py
--rw-r--r--  2.0 unx     3517 b- defN 23-Mar-15 20:11 atoti_core/combine_conditions.py
--rw-r--r--  2.0 unx      712 b- defN 23-Mar-15 20:11 atoti_core/comparison_operator.py
--rw-r--r--  2.0 unx      779 b- defN 23-Mar-15 20:11 atoti_core/condition_to_dict.py
--rw-r--r--  2.0 unx      926 b- defN 23-Mar-15 20:11 atoti_core/condition_to_pairs.py
--rw-r--r--  2.0 unx     3671 b- defN 23-Mar-15 20:11 atoti_core/constant.py
--rw-r--r--  2.0 unx       61 b- defN 23-Mar-15 20:11 atoti_core/context.py
--rw-r--r--  2.0 unx     1170 b- defN 23-Mar-15 20:11 atoti_core/convert_to_pandas.py
--rw-r--r--  2.0 unx      374 b- defN 23-Mar-15 20:11 atoti_core/coordinates.py
--rw-r--r--  2.0 unx     3763 b- defN 23-Mar-15 20:11 atoti_core/data_type.py
--rw-r--r--  2.0 unx     9608 b- defN 23-Mar-15 20:11 atoti_core/decombine_condition.py
--rw-r--r--  2.0 unx      551 b- defN 23-Mar-15 20:11 atoti_core/deprecated.py
--rw-r--r--  2.0 unx     1786 b- defN 23-Mar-15 20:11 atoti_core/doc.py
--rw-r--r--  2.0 unx      138 b- defN 23-Mar-15 20:11 atoti_core/empty_mapping.py
--rw-r--r--  2.0 unx     3465 b- defN 23-Mar-15 20:11 atoti_core/fetch_json.py
--rw-r--r--  2.0 unx      673 b- defN 23-Mar-15 20:11 atoti_core/find_corresponding_top_level_variable_name.py
--rw-r--r--  2.0 unx      326 b- defN 23-Mar-15 20:11 atoti_core/get_env_flag.py
--rw-r--r--  2.0 unx     2181 b- defN 23-Mar-15 20:11 atoti_core/get_literal_args.py
--rw-r--r--  2.0 unx      358 b- defN 23-Mar-15 20:11 atoti_core/get_package_version.py
--rw-r--r--  2.0 unx      265 b- defN 23-Mar-15 20:11 atoti_core/get_top_level_package_name.py
--rw-r--r--  2.0 unx      379 b- defN 23-Mar-15 20:11 atoti_core/has_coordinates.py
--rw-r--r--  2.0 unx      427 b- defN 23-Mar-15 20:11 atoti_core/hierarchy_coordinates.py
--rw-r--r--  2.0 unx     2910 b- defN 23-Mar-15 20:11 atoti_core/hierarchy_isin_condition.py
--rw-r--r--  2.0 unx       76 b- defN 23-Mar-15 20:11 atoti_core/hierarchy_key.py
--rw-r--r--  2.0 unx      109 b- defN 23-Mar-15 20:11 atoti_core/http_method.py
--rw-r--r--  2.0 unx      806 b- defN 23-Mar-15 20:11 atoti_core/immutable_mapping.py
--rw-r--r--  2.0 unx      390 b- defN 23-Mar-15 20:11 atoti_core/ipython_key_completions.py
--rw-r--r--  2.0 unx     2319 b- defN 23-Mar-15 20:11 atoti_core/isin_condition.py
--rw-r--r--  2.0 unx      900 b- defN 23-Mar-15 20:11 atoti_core/keyword_only_dataclass.py
--rw-r--r--  2.0 unx      720 b- defN 23-Mar-15 20:11 atoti_core/level_coordinates.py
--rw-r--r--  2.0 unx      109 b- defN 23-Mar-15 20:11 atoti_core/level_key.py
--rw-r--r--  2.0 unx      389 b- defN 23-Mar-15 20:11 atoti_core/measure_coordinates.py
--rw-r--r--  2.0 unx      280 b- defN 23-Mar-15 20:11 atoti_core/missing_plugin_error.py
--rw-r--r--  2.0 unx     9779 b- defN 23-Mar-15 20:11 atoti_core/operand_convertible_with_coordinates.py
--rw-r--r--  2.0 unx    25759 b- defN 23-Mar-15 20:11 atoti_core/operation.py
--rw-r--r--  2.0 unx      180 b- defN 23-Mar-15 20:11 atoti_core/path.py
--rw-r--r--  2.0 unx      945 b- defN 23-Mar-15 20:11 atoti_core/plugin.py
--rw-r--r--  2.0 unx     4198 b- defN 23-Mar-15 20:11 atoti_core/plugins.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-15 20:11 atoti_core/py.typed
--rw-r--r--  2.0 unx     9042 b- defN 23-Mar-15 20:11 atoti_core/query_doc.py
--rw-r--r--  2.0 unx      399 b- defN 23-Mar-15 20:11 atoti_core/query_filter.py
--rw-r--r--  2.0 unx      762 b- defN 23-Mar-15 20:11 atoti_core/raise_multiple_levels_with_same_name_error.py
--rw-r--r--  2.0 unx     2188 b- defN 23-Mar-15 20:11 atoti_core/repr_json.py
--rw-r--r--  2.0 unx      180 b- defN 23-Mar-15 20:11 atoti_core/running_in_ipython.py
--rw-r--r--  2.0 unx       28 b- defN 23-Mar-15 20:11 atoti_core/scenario.py
--rw-r--r--  2.0 unx      562 b- defN 23-Mar-15 20:11 atoti_core/str_to_bool.py
--rw-r--r--  2.0 unx      797 b- defN 23-Mar-15 20:20 atoti_core-0.7.4.dist-info/METADATA
--rw-r--r--  2.0 unx      109 b- defN 23-Mar-15 20:20 atoti_core-0.7.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 23-Mar-15 20:20 atoti_core-0.7.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     5694 b- defN 23-Mar-15 20:20 atoti_core-0.7.4.dist-info/RECORD
-67 files, 173281 bytes uncompressed, 51374 bytes compressed:  70.4%
+Zip file size: 68171 bytes, number of entries: 77
+-rw-r--r--  2.0 unx    23472 b- defN 23-Jun-02 01:02 atoti_core/LICENSE
+-rw-r--r--  2.0 unx     2420 b- defN 23-Jun-02 00:55 atoti_core/__init__.py
+-rw-r--r--  2.0 unx     1679 b- defN 23-Jun-02 00:55 atoti_core/_get_endpoint_path.py
+-rw-r--r--  2.0 unx      150 b- defN 23-Jun-02 00:55 atoti_core/_other_coordinates.py
+-rw-r--r--  2.0 unx      398 b- defN 23-Jun-02 00:55 atoti_core/_server_versions.py
+-rw-r--r--  2.0 unx     8811 b- defN 23-Jun-02 00:55 atoti_core/activeviam_client.py
+-rw-r--r--  2.0 unx      128 b- defN 23-Jun-02 00:55 atoti_core/arithmetic_operator.py
+-rw-r--r--  2.0 unx     2437 b- defN 23-Jun-02 00:55 atoti_core/base_cube.py
+-rw-r--r--  2.0 unx      561 b- defN 23-Jun-02 00:55 atoti_core/base_cubes.py
+-rw-r--r--  2.0 unx     2277 b- defN 23-Jun-02 00:55 atoti_core/base_hierarchies.py
+-rw-r--r--  2.0 unx     5690 b- defN 23-Jun-02 00:55 atoti_core/base_hierarchy.py
+-rw-r--r--  2.0 unx     4900 b- defN 23-Jun-02 00:55 atoti_core/base_level.py
+-rw-r--r--  2.0 unx     3961 b- defN 23-Jun-02 00:55 atoti_core/base_levels.py
+-rw-r--r--  2.0 unx     2522 b- defN 23-Jun-02 00:55 atoti_core/base_measure.py
+-rw-r--r--  2.0 unx     1365 b- defN 23-Jun-02 00:55 atoti_core/base_measures.py
+-rw-r--r--  2.0 unx    10896 b- defN 23-Jun-02 00:55 atoti_core/base_session.py
+-rw-r--r--  2.0 unx      221 b- defN 23-Jun-02 00:55 atoti_core/boolean_operator.py
+-rw-r--r--  2.0 unx      420 b- defN 23-Jun-02 00:55 atoti_core/column_coordinates.py
+-rw-r--r--  2.0 unx     3537 b- defN 23-Jun-02 00:55 atoti_core/combine_conditions.py
+-rw-r--r--  2.0 unx      732 b- defN 23-Jun-02 00:55 atoti_core/comparison_operator.py
+-rw-r--r--  2.0 unx      773 b- defN 23-Jun-02 00:55 atoti_core/condition_to_dict.py
+-rw-r--r--  2.0 unx      913 b- defN 23-Jun-02 00:55 atoti_core/condition_to_pairs.py
+-rw-r--r--  2.0 unx     5240 b- defN 23-Jun-02 00:55 atoti_core/constant.py
+-rw-r--r--  2.0 unx       88 b- defN 23-Jun-02 00:55 atoti_core/context.py
+-rw-r--r--  2.0 unx     3313 b- defN 23-Jun-02 00:55 atoti_core/convert_series.py
+-rw-r--r--  2.0 unx      349 b- defN 23-Jun-02 00:55 atoti_core/coordinates.py
+-rw-r--r--  2.0 unx      153 b- defN 23-Jun-02 00:55 atoti_core/coordinates_like.py
+-rw-r--r--  2.0 unx     1720 b- defN 23-Jun-02 00:55 atoti_core/create_dataframe.py
+-rw-r--r--  2.0 unx     3946 b- defN 23-Jun-02 00:55 atoti_core/data_type.py
+-rw-r--r--  2.0 unx     9600 b- defN 23-Jun-02 00:55 atoti_core/decombine_condition.py
+-rw-r--r--  2.0 unx       78 b- defN 23-Jun-02 00:55 atoti_core/default_query_timeout.py
+-rw-r--r--  2.0 unx     3191 b- defN 23-Jun-02 00:55 atoti_core/delegate_mutable_mapping.py
+-rw-r--r--  2.0 unx     1325 b- defN 23-Jun-02 00:55 atoti_core/delegate_mutable_set.py
+-rw-r--r--  2.0 unx      553 b- defN 23-Jun-02 00:55 atoti_core/deprecated.py
+-rw-r--r--  2.0 unx     1903 b- defN 23-Jun-02 00:55 atoti_core/doc.py
+-rw-r--r--  2.0 unx      165 b- defN 23-Jun-02 00:55 atoti_core/empty_mapping.py
+-rw-r--r--  2.0 unx     3431 b- defN 23-Jun-02 00:55 atoti_core/fetch_json.py
+-rw-r--r--  2.0 unx      590 b- defN 23-Jun-02 00:55 atoti_core/find_corresponding_top_level_variable_name.py
+-rw-r--r--  2.0 unx      326 b- defN 23-Jun-02 00:55 atoti_core/get_env_flag.py
+-rw-r--r--  2.0 unx     1613 b- defN 23-Jun-02 00:55 atoti_core/get_installed_plugins.py
+-rw-r--r--  2.0 unx     1008 b- defN 23-Jun-02 00:55 atoti_core/get_ipython.py
+-rw-r--r--  2.0 unx     2145 b- defN 23-Jun-02 00:55 atoti_core/get_literal_args.py
+-rw-r--r--  2.0 unx      358 b- defN 23-Jun-02 00:55 atoti_core/get_package_version.py
+-rw-r--r--  2.0 unx      265 b- defN 23-Jun-02 00:55 atoti_core/get_top_level_package_name.py
+-rw-r--r--  2.0 unx      379 b- defN 23-Jun-02 00:55 atoti_core/has_coordinates.py
+-rw-r--r--  2.0 unx      402 b- defN 23-Jun-02 00:55 atoti_core/hierarchy_coordinates.py
+-rw-r--r--  2.0 unx     4282 b- defN 23-Jun-02 00:55 atoti_core/hierarchy_isin_condition.py
+-rw-r--r--  2.0 unx       69 b- defN 23-Jun-02 00:55 atoti_core/hierarchy_key.py
+-rw-r--r--  2.0 unx      109 b- defN 23-Jun-02 00:55 atoti_core/http_method.py
+-rw-r--r--  2.0 unx      886 b- defN 23-Jun-02 00:55 atoti_core/immutable_mapping.py
+-rw-r--r--  2.0 unx      404 b- defN 23-Jun-02 00:55 atoti_core/ipython_key_completions.py
+-rw-r--r--  2.0 unx     3420 b- defN 23-Jun-02 00:55 atoti_core/isin_condition.py
+-rw-r--r--  2.0 unx      109 b- defN 23-Jun-02 00:55 atoti_core/java_max_int.py
+-rw-r--r--  2.0 unx     1011 b- defN 23-Jun-02 00:55 atoti_core/keyword_only_dataclass.py
+-rw-r--r--  2.0 unx      695 b- defN 23-Jun-02 00:55 atoti_core/level_coordinates.py
+-rw-r--r--  2.0 unx      102 b- defN 23-Jun-02 00:55 atoti_core/level_key.py
+-rw-r--r--  2.0 unx      637 b- defN 23-Jun-02 00:55 atoti_core/license_key.py
+-rw-r--r--  2.0 unx      364 b- defN 23-Jun-02 00:55 atoti_core/measure_coordinates.py
+-rw-r--r--  2.0 unx      280 b- defN 23-Jun-02 00:55 atoti_core/missing_plugin_error.py
+-rw-r--r--  2.0 unx     9157 b- defN 23-Jun-02 00:55 atoti_core/operand_convertible_with_coordinates.py
+-rw-r--r--  2.0 unx    25609 b- defN 23-Jun-02 00:55 atoti_core/operation.py
+-rw-r--r--  2.0 unx      315 b- defN 23-Jun-02 00:55 atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py
+-rw-r--r--  2.0 unx      180 b- defN 23-Jun-02 00:55 atoti_core/path.py
+-rw-r--r--  2.0 unx      738 b- defN 23-Jun-02 00:55 atoti_core/plugin.py
+-rw-r--r--  2.0 unx      866 b- defN 23-Jun-02 00:55 atoti_core/plugins.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-02 00:55 atoti_core/py.typed
+-rw-r--r--  2.0 unx     9949 b- defN 23-Jun-02 00:55 atoti_core/query_doc.py
+-rw-r--r--  2.0 unx      405 b- defN 23-Jun-02 00:55 atoti_core/query_filter.py
+-rw-r--r--  2.0 unx      789 b- defN 23-Jun-02 00:55 atoti_core/raise_multiple_levels_with_same_name_error.py
+-rw-r--r--  2.0 unx     2270 b- defN 23-Jun-02 00:55 atoti_core/reactive_mutable_set.py
+-rw-r--r--  2.0 unx     2202 b- defN 23-Jun-02 00:55 atoti_core/repr_json.py
+-rw-r--r--  2.0 unx       28 b- defN 23-Jun-02 00:55 atoti_core/scenario.py
+-rw-r--r--  2.0 unx      563 b- defN 23-Jun-02 00:55 atoti_core/str_to_bool.py
+-rw-r--r--  2.0 unx      855 b- defN 23-Jun-02 01:02 atoti_core-0.8.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      109 b- defN 23-Jun-02 01:02 atoti_core-0.8.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Jun-02 01:02 atoti_core-0.8.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6580 b- defN 23-Jun-02 01:02 atoti_core-0.8.0.dist-info/RECORD
+77 files, 193398 bytes uncompressed, 57713 bytes compressed:  70.2%
```

## zipnote {}

```diff
@@ -1,16 +1,13 @@
 Filename: atoti_core/LICENSE
 Comment: 
 
 Filename: atoti_core/__init__.py
 Comment: 
 
-Filename: atoti_core/_deprecated_comparison_with_none.py
-Comment: 
-
 Filename: atoti_core/_get_endpoint_path.py
 Comment: 
 
 Filename: atoti_core/_other_coordinates.py
 Comment: 
 
 Filename: atoti_core/_server_versions.py
@@ -48,14 +45,17 @@
 
 Filename: atoti_core/base_session.py
 Comment: 
 
 Filename: atoti_core/boolean_operator.py
 Comment: 
 
+Filename: atoti_core/column_coordinates.py
+Comment: 
+
 Filename: atoti_core/combine_conditions.py
 Comment: 
 
 Filename: atoti_core/comparison_operator.py
 Comment: 
 
 Filename: atoti_core/condition_to_dict.py
@@ -66,26 +66,41 @@
 
 Filename: atoti_core/constant.py
 Comment: 
 
 Filename: atoti_core/context.py
 Comment: 
 
-Filename: atoti_core/convert_to_pandas.py
+Filename: atoti_core/convert_series.py
 Comment: 
 
 Filename: atoti_core/coordinates.py
 Comment: 
 
+Filename: atoti_core/coordinates_like.py
+Comment: 
+
+Filename: atoti_core/create_dataframe.py
+Comment: 
+
 Filename: atoti_core/data_type.py
 Comment: 
 
 Filename: atoti_core/decombine_condition.py
 Comment: 
 
+Filename: atoti_core/default_query_timeout.py
+Comment: 
+
+Filename: atoti_core/delegate_mutable_mapping.py
+Comment: 
+
+Filename: atoti_core/delegate_mutable_set.py
+Comment: 
+
 Filename: atoti_core/deprecated.py
 Comment: 
 
 Filename: atoti_core/doc.py
 Comment: 
 
 Filename: atoti_core/empty_mapping.py
@@ -96,14 +111,20 @@
 
 Filename: atoti_core/find_corresponding_top_level_variable_name.py
 Comment: 
 
 Filename: atoti_core/get_env_flag.py
 Comment: 
 
+Filename: atoti_core/get_installed_plugins.py
+Comment: 
+
+Filename: atoti_core/get_ipython.py
+Comment: 
+
 Filename: atoti_core/get_literal_args.py
 Comment: 
 
 Filename: atoti_core/get_package_version.py
 Comment: 
 
 Filename: atoti_core/get_top_level_package_name.py
@@ -129,35 +150,44 @@
 
 Filename: atoti_core/ipython_key_completions.py
 Comment: 
 
 Filename: atoti_core/isin_condition.py
 Comment: 
 
+Filename: atoti_core/java_max_int.py
+Comment: 
+
 Filename: atoti_core/keyword_only_dataclass.py
 Comment: 
 
 Filename: atoti_core/level_coordinates.py
 Comment: 
 
 Filename: atoti_core/level_key.py
 Comment: 
 
+Filename: atoti_core/license_key.py
+Comment: 
+
 Filename: atoti_core/measure_coordinates.py
 Comment: 
 
 Filename: atoti_core/missing_plugin_error.py
 Comment: 
 
 Filename: atoti_core/operand_convertible_with_coordinates.py
 Comment: 
 
 Filename: atoti_core/operation.py
 Comment: 
 
+Filename: atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py
+Comment: 
+
 Filename: atoti_core/path.py
 Comment: 
 
 Filename: atoti_core/plugin.py
 Comment: 
 
 Filename: atoti_core/plugins.py
@@ -171,32 +201,32 @@
 
 Filename: atoti_core/query_filter.py
 Comment: 
 
 Filename: atoti_core/raise_multiple_levels_with_same_name_error.py
 Comment: 
 
-Filename: atoti_core/repr_json.py
+Filename: atoti_core/reactive_mutable_set.py
 Comment: 
 
-Filename: atoti_core/running_in_ipython.py
+Filename: atoti_core/repr_json.py
 Comment: 
 
 Filename: atoti_core/scenario.py
 Comment: 
 
 Filename: atoti_core/str_to_bool.py
 Comment: 
 
-Filename: atoti_core-0.7.4.dist-info/METADATA
+Filename: atoti_core-0.8.0.dist-info/METADATA
 Comment: 
 
-Filename: atoti_core-0.7.4.dist-info/WHEEL
+Filename: atoti_core-0.8.0.dist-info/WHEEL
 Comment: 
 
-Filename: atoti_core-0.7.4.dist-info/top_level.txt
+Filename: atoti_core-0.8.0.dist-info/top_level.txt
 Comment: 
 
-Filename: atoti_core-0.7.4.dist-info/RECORD
+Filename: atoti_core-0.8.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## atoti_core/LICENSE

```diff
@@ -1,30 +1,27 @@
-ATOTI
-Free community edition LICENSE AGREEMENT
-Version 0.7.4
-
-This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of ATOTI version 0.7.4, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
+This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.0, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
 
 By requesting to have access to the Software, downloading or using the Software, End User acknowledges that he/she and End Customer has understood and agreed with the terms of this EULA.
 If End Customer does not accept these terms, End User must not use the Software.
 
 End Customer and ActiveViam are hereinafter individually or collectively referred to as the "PARTY (IES)".
 
 1. Purpose & description of the Software
 
    1. The EULA sets out the terms and conditions under which End User may install the Software from a library package and/or use the Software on a royalty-free basis.
       In order to run the Software, End User must install a java virtual machine (JVM).
       For convenience purposes, the Software includes the JVM provided by OpenJDK in the downloadable package.
       OpenJDK is licensed under the GPLv2 with classpath exception license https://openjdk.java.net/legal/gplv2+ce.html.
 
-   2. The Software can be downloaded via third party platforms such as, but not limited to, https://pypi.org/ or via ActiveViam's servers. The features and functionalities of the Software are listed on the Software's website at https://atoti.io/ (the "Site").
+   2. The Software can be downloaded via third party platforms such as, but not limited to, https://pypi.org or via ActiveViam's servers.
+      The features and functionalities of the Software are listed on the Software's website at https://www.atoti.io (the "Site").
 
 2. Limited community edition
 
-   1. The Software is provided for the restricted usage authorized herein.
+   1. The Software is provided under this EULA for the restricted usage authorized herein.
       It may not include all features and functionalities found in any future version of the Software.
       It is also possible that some of the features and functionalities included in the current version of the Software may be removed from future versions of the Software or that some use cases authorized for this version may not apply to future versions.
 
    2. The Software is made available exclusively for the purpose of demonstrating the possibilities offered by the Software so End Customer can evaluate the possibilities and potential of the Software.
 
 3. License Grant
 
@@ -40,34 +37,41 @@
       ActiveViam will acknowledge and confirm that End User may use the Software in Production Environment by email and may add certain restrictions / conditions to this authorization.
       If ActiveViam does not respond within ten (10) business days from End User's request, ActiveViam is deemed to have denied use of the Software in the Production Environment.
 
    4. Regarding any other elements generated as part of the use of the Software such as the models or dashboards created (the "Results"), they cannot in any event be used for more than the number of Viewers indicated herein without subscribing to an Enterprise Edition License Agreement.
 
    5. This EULA includes the right to display and copy the Software and the Results solely for the purposes authorized herein above.
 
-   6. When End User downloads the Software, End User is provided with the executable code of the Software. End User understands that no source code is provided.
+   6. When End User downloads the Software, End User is provided with the executable code of the Software.
+      End User understands that no source code is provided.
 
    7. The Software does not include any authentication or user access control system.
       End User / End Customer is not authorized to use or add any external software, hardware or programming method to implement an authentication or user access control layer to the Software.
-      This feature is available in ATOTI+, the enterprise edition of the Software (see section 7 below).
+      This feature is available in Atoti, the enterprise edition of the Software (see section 7 below).
 
    8. End User may make one copy of the Software in machine readable form for backup / security purposes only, provided that the backup copy must include all proprietary notices contained in the original Software package.
 
 4. Ownership - Restrictions
 
-   1. The EULA does not convey any assignment of rights to End User or End Customer on the Software. ActiveViam owns or has all the title, copyright and other intellectual property rights in the Software.
+   1. The EULA does not convey any assignment of rights to End User or End Customer on the Software.
+      ActiveViam owns or has all the title, copyright and other intellectual property rights in the Software.
 
-   2. Regarding Results, End User is also granted a right to use such Results as provided under this EULA. However, such Results are not assigned to the End Customer.
+   2. Regarding Results, End User is also granted a right to use such Results as provided under this EULA.
+      However, such Results are not assigned to the End Customer.
 
    3. End User may not and will not allow a third party to:
 
       1. reverse engineer, decompile, disassemble, or otherwise attempt to discover / have access to the source code or algorithms of the Software,
+
       2. adapt, modify, translate, disable any features and functionality of, the Software / the Results, or create derivative works based on the Software/ the Results,
+
       3. distribute, share, timeshare, transfer, sell, rent, lease, lend, grant a security interest in, use for service bureau purposes, sublicense or send the Software / Results or make available the Software or its functionalities to any other End User aside from Viewers,
+
       4. remove, modify, or conceal any product identification, copyright, proprietary, intellectual property notices or other marks on or within the Software,
+
       5. use the Software in any manner not expressly authorized by this EULA, such as develop a product which is competitive with any ActiveViam product or services offerings.
 
 5. Software Support
 
    1. ActiveViam will not provide any support or maintenance services under this EULA or any other professional services except as offered on a discretionary basis.
       End Customer acknowledges that ActiveViam has no express or implied obligation to announce or make available any updates, enhancements, modifications, revisions, or additions to the Software and that this EULA does not give End Customer any rights in or to any of the foregoing.
       Support and maintenance are available under an enterprise edition license of the Software (see section 7 below).
@@ -80,120 +84,134 @@
       In addition, such release or new Community edition may require an access to the internet, an updated version of the browser or to upgrade other Software dependencies (such as Java, Python, anaconda, node, etc.) and additional storage space on the device used to download the Software.
       Failing to meet these criteria may result in the failing to download or install the release or new community edition version.
 
    4. If necessary and requested in writing by End User, ActiveViam will provide available interface information needed to achieve interoperability between the Software and another software or application.
 
 6. Software's improvements
 
-   1. For the purpose of improving the Software and for statistical and analytical purposes, ActiveViam has integrated a telemetry feature in the Software that automatically collects the following information:
+   1. For the purpose of improving the Software and for statistical and analytical purposes as Atoti CE is provided in a freemium community version, ActiveViam has integrated a telemetry feature in the Software that automatically collects the following information:
 
       1. when a session is created, from where (geo location based on the IP address)
+
       2. method call/API usage
+
       3. data size/data structure
+
       4. error types
+
       5. up time
-      6. Python, atoti, and OS version
 
-   2. ActiveViam also associates a random unique ID for each installation of the Software and session to track the number of installations and how many sessions are run by installation without direct or indirect identification of the End-User concerned.
+      6. Python, Atoti CE, O/S versions
+
+   2. ActiveViam also associates a random unique ID for each installation of the Software and session to track the number of installations and how many sessions are run by installation without direct or indirect identification of the End User concerned.
 
-   3. ActiveViam will not access at any time the data processed by the Software nor information to identify the End-User.
+   3. ActiveViam will not access at any time the data processed by the Software nor information to identify the End User and/or End Customer except to verify compliance with this Agreement and as provided under the privacy policy.
 
-   4. If End-User does not want this information to be uploaded to ActiveViam, or if End User's system does not allow information to be sent to ActiveViam, End-User must register and obtain an evaluation license as provided in section 7.2 below in which case the telemetry can be disabled.
+   4. If End User does not want this information to be uploaded to ActiveViam, or if End User's system does not allow information to be uploaded to ActiveViam, End User must register and obtain an evaluation license as provided in section 7.2 below in which case the telemetry can be disabled.
+      This evaluation license is available through https://www.atoti.io/evaluation-license-request.
 
-7. Upgrade to the ATOTI+ version of the Software
+7. Upgrade to the Atoti version of the Software
 
-   1. End User may upgrade the Software to an enterprise edition of the Software ("ATOTI+") allowing them to download the ATOTI+ extensions.
-      The telemetry is automatically disabled when the ATOTI+ plugin is installed and enabled.
+   1. End User may upgrade the Software to an enterprise edition of the Software ("Atoti") allowing them to use the full Atoti extensions and disable telemetry.
 
-   2. Except for evaluation licenses that can be granted through registration, use of ATOTI+ is subject to the execution by End Customer of a separate paid license agreement with ActiveViam instead of this EULA.
+   2. Except for evaluation licenses that can be granted through registration and accepting the evaluation license terms, use of Atoti is subject to the execution by End Customer of a separate paid license agreement with ActiveViam instead of this EULA.
 
 8. Term and Termination
 
    1. The Software can be used for a period of 100 (hundred) days from the date of the Software's release (the "Term").
-      At the end of the Term, End-User must upgrade to a more recent version of the Software.
+      At the end of the Term, End User must upgrade to a more recent version of the Software.
       In the absence of a Software's release before the end of the Term, the Term will be extended until a new version is released.
 
    2. ActiveViam may terminate this EULA at any time by informing End User (if End User has provided his/her contact information) or deciding so when making available a Software release or new community edition.
 
    3. The rights under this EULA will terminate automatically without notice and without compensation from ActiveViam if End User / End Customer fails to comply with any of the terms and conditions of this EULA, notwithstanding ActiveViam's right to claim damages.
 
    4. The EULA will also terminate if and when End User deletes / erases the Software and any copy made of it.
 
    5. At the end of the Term, End User must cease all use of the Software and erase all copies of the Software, the Results and releases.
 
 9. Data Protection
 
-   1. ActiveViam and the End Customer undertake to comply with the applicable regulation on data privacy depending on the location of End-Users (the "Data Privacy Regulation").
+   1. ActiveViam and the End Customer undertake to comply with the applicable regulation on data privacy depending on the location of End User (the "Data Privacy Regulation").
 
    2. The End User exercises total control over the uses he/she makes of the Software, therefore End Customer fully and exclusively bears the responsibility of all processing activities of any personal data that may be carried out using the Software.
 
    3. If contact information is provided by End User, ActiveViam shall process this data in compliance with its privacy policy.
-      Access and use of the Site is subject to a privacy policy and terms of use available at the following addresses https://atoti.io/privacy-policy and https://atoti.io/terms.
+      Access and use of the Site is subject to a privacy policy and terms of use available at the following addresses https://www.atoti.io/privacy-policy and https://www.atoti.io/terms.
 
 10. Warranty
 
-   1. THE SOFTWARE IS PROVIDED "AS IS" AND ON AN "AS AVAILABLE" BASIS.
-      ACTIVEVIAM HEREBY EXPRESSLY EXCLUDES, TO THE FULLEST EXTENT PERMISSIBLE BY LAW, ALL WARRANTIES, REPRESENTATIONS, GUARANTEES, CONDITIONS AND TERMS, OTHER THAN THOSE EXPRESSLY SET OUT IN THIS EULA, SUCH AS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR FREE, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, WHETHER EXPRESS OR IMPLIED BY STATUTE, COMMON LAW, COURSE OF DEALING, TRADE USAGE OR OTHERWISE AND WHETHER WRITTEN OR ORAL, INCLUDING BUT NOT LIMITED TO ANY WARRANTY AS TO THE ACCURACY AND ADEQUACY OF ANY RESULTS GENERATED THROUGH USE OF THE SOFTWARE.
-      END-CUSTOMER BEARS AND ASSUMES THE ENTIRE RISK AS TO THE RESULTS AND PERFORMANCE OF THE SOFTWARE AND/OR THE USE IT MAKES OR ANY RELIANCE ON THE RESULTS.
+    1. THE SOFTWARE IS PROVIDED "AS IS" AND ON AN "AS AVAILABLE" BASIS.
+       ACTIVEVIAM HEREBY EXPRESSLY EXCLUDES, TO THE FULLEST EXTENT PERMISSIBLE BY LAW, ALL WARRANTIES, REPRESENTATIONS, GUARANTEES, CONDITIONS AND TERMS, OTHER THAN THOSE EXPRESSLY SET OUT IN THIS EULA, SUCH AS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR FREE, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, WHETHER EXPRESS OR IMPLIED BY STATUTE, COMMON LAW, COURSE OF DEALING, TRADE USAGE OR OTHERWISE AND WHETHER WRITTEN OR ORAL, INCLUDING BUT NOT LIMITED TO ANY WARRANTY AS TO THE ACCURACY AND ADEQUACY OF ANY RESULTS GENERATED THROUGH USE OF THE SOFTWARE.
+       END CUSTOMER BEARS AND ASSUMES THE ENTIRE RISK AS TO THE RESULTS AND PERFORMANCE OF THE SOFTWARE AND/OR THE USE IT MAKES OR ANY RELIANCE ON THE RESULTS.
 
-   2. END-CUSTOMER HEREBY REPRESENTS THAT IT SHALL (I) COMPLY WITH ALL APPLICABLE LOCAL AND FOREIGN LAWS AND REGULATIONS WHICH MAY GOVERN THE USE OF THE SOFTWARE AND DOCUMENTATION, AND (II) USE THE SOFTWARE AND DOCUMENTATION ONLY FOR LAWFUL PURPOSES AND IN ACCORDANCE WITH THE TERMS OF THIS EULA.
-      END-CUSTOMER SHALL INDEMNIFY AND HOLD ACTIVEVIAM ITS AFFILIATES, MANAGERS AND ADVISORS, AND EACH OF THEIR OFFICERS, DIRECTORS, SHAREHOLDERS, PARTNERS, EMPLOYEES, REPRESENTATIVES, AGENTS AND ATTORNEYS (INDEMNIFIED PARTIES) HARMLESS AGAINST ANY TROUBLE, CLAIM, EVICTION, DAMAGES OR PROTEST IN CASE OF BREACH OF ANY OBLIGATION OF THE EULA HARMLESS FROM ANY AND ALL LOSSES, LIABILITIES, OBLIGATIONS, CLAIMS, CONTINGENCIES, DAMAGES, REASONABLE COSTS AND EXPENSES, INCLUDING ALL JUDGMENTS, AMOUNTS PAID IN SETTLEMENTS, COURT COSTS AND REASONABLE ATTORNEYS' FEES AND COSTS OF INVESTIGATION THAT ANY INDEMNIFIED PARTY MAY SUFFER OR INCUR AS A RESULT OF OR RELATING TO ANY BREACH BY END-CUSTOMER OF THE REPRESENTATIONS HEREIN.
+    2. END CUSTOMER HEREBY REPRESENTS THAT IT SHALL (I) COMPLY WITH ALL APPLICABLE LOCAL AND FOREIGN LAWS AND REGULATIONS WHICH MAY GOVERN THE USE OF THE SOFTWARE AND DOCUMENTATION, AND (II) USE THE SOFTWARE AND DOCUMENTATION ONLY FOR LAWFUL PURPOSES AND IN ACCORDANCE WITH THE TERMS OF THIS EULA.
+       END CUSTOMER SHALL INDEMNIFY AND HOLD ACTIVEVIAM ITS AFFILIATES, MANAGERS AND ADVISORS, AND EACH OF THEIR OFFICERS, DIRECTORS, SHAREHOLDERS, PARTNERS, EMPLOYEES, REPRESENTATIVES, AGENTS AND ATTORNEYS (INDEMNIFIED PARTIES) HARMLESS AGAINST ANY TROUBLE, CLAIM, EVICTION, DAMAGES OR PROTEST IN CASE OF BREACH OF ANY OBLIGATION OF THE EULA HARMLESS FROM ANY AND ALL LOSSES, LIABILITIES, OBLIGATIONS, CLAIMS, CONTINGENCIES, DAMAGES, REASONABLE COSTS AND EXPENSES, INCLUDING ALL JUDGMENTS, AMOUNTS PAID IN SETTLEMENTS, COURT COSTS AND REASONABLE ATTORNEYS' FEES AND COSTS OF INVESTIGATION THAT ANY INDEMNIFIED PARTY MAY SUFFER OR INCUR AS A RESULT OF OR RELATING TO ANY BREACH BY END CUSTOMER OF THE REPRESENTATIONS HEREIN.
 
 11. Limited Liability
 
-   1. NOTHING IN THIS EULA SHALL BE DEEMED TO EXCLUDE, RESTRICT OR LIMIT LIABILITY OF EITHER PARTY (OR THEIR RESPECTIVE AGENTS OR SUB-CONTRACTORS) FOR DEATH OR PERSONAL INJURY RESULTING FROM THEIR NEGLIGENCE OR ANY LIABILITY FOR FRAUDULENT MISREPRESENTATION.
+    1. NOTHING IN THIS EULA SHALL BE DEEMED TO EXCLUDE, RESTRICT OR LIMIT LIABILITY OF EITHER PARTY (OR THEIR RESPECTIVE AGENTS OR SUB-CONTRACTORS) FOR DEATH OR PERSONAL INJURY RESULTING FROM THEIR NEGLIGENCE OR ANY LIABILITY FOR FRAUDULENT MISREPRESENTATION.
+
+    2. SUBJECT TO SECTION 11.1, ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) SHALL NOT BE LIABLE FOR ANY DAMAGES OF ANY KIND ARISING OUT OF OR RELATING TO THE USE OR THE INABILITY TO USE THE SOFTWARE, RESULTS OR ANY THIRD PARTY APPLICATION, ITS CONTENT OR FUNCTIONALITY, INCLUDING BUT NOT LIMITED TO DAMAGED CAUSES BY OR RELATED TO ERRORS, OMISSIONS, INTERRUPTIONS, DEFECTS, DELAY IN OPERATION OR TRANSMISSION, COMPUTER VIRUS, FAILURE TO CONNECT, NETWORK CHARGES, IN-APP PURCHASES, AND ALL OTHER DIRECT, INDIRECT, MORAL, INCIDENTAL, SPECIAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES OR ANY OTHER DAMAGES WHATSOEVER, INCLUDING BUT NOT LIMITED TO LOSS ARISING OUT OF OR IN CONNECTION WITH THE SOFTWARE OR RESULTS WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF ACTIVEVIAM IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
+       ACTIVEVIAM WILL NOT BE RESPONSIBLE FOR ANY DAMAGE CAUSED BY END CUSTOMER, END USER, ITS EMPLOYEES, SUBCONTRACTORS OR ANY THIRD PARTIES.
+
+    3. SUBJECT TO SECTION 11.1, ACTIVEVIAM SHALL ONLY BE LIABLE FOR DIRECT DAMAGES AND IN NO EVENT SHALL ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) BE LIABLE FOR:
 
-   2. SUBJECT TO SECTION 11.1, ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) SHALL NOT BE LIABLE FOR ANY DAMAGES OF ANY KIND ARISING OUT OF OR RELATING TO THE USE OR THE INABILITY TO USE THE SOFTWARE, RESULTS OR ANY THIRD PARTY APPLICATION, ITS CONTENT OR FUNCTIONALITY, INCLUDING BUT NOT LIMITED TO DAMAGED CAUSES BY OR RELATED TO ERRORS, OMISSIONS, INTERRUPTIONS, DEFECTS, DELAY IN OPERATION OR TRANSMISSION, COMPUTER VIRUS, FAILURE TO CONNECT, NETWORK CHARGES, IN-APP PURCHASES, AND ALL OTHER DIRECT, INDIRECT, MORAL, INCIDENTAL, SPECIAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES OR ANY OTHER DAMAGES WHATSOEVER, INCLUDING BUT NOT LIMITED TO LOSS ARISING OUT OF OR IN CONNECTION WITH THE SOFTWARE OR RESULTS WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF ACTIVEVIAM IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
-      ACTIVEVIAM WILL NOT BE RESPONSIBLE FOR ANY DAMAGE CAUSED BY END-CUSTOMER, END-USER, ITS EMPLOYEES, SUBCONTRACTORS OR ANY THIRD PARTIES.
+       1. ANY LOSS OF REVENUES OR PROFITS, LOSS, CORRUPTION OR DAMAGED OF DATA, COST OF COVER, BUSINESS INTERRUPTION, LOSS OF USE, LOSS OF CONTRACTS, LOSS OF GOODWILL (WHETHER DIRECT OR INDIRECT); OR
 
-   3. SUBJECT TO SECTION 11.1, ACTIVEVIAM SHALL ONLY BE LIABLE FOR DIRECT DAMAGES AND IN NO EVENT SHALL ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) BE LIABLE FOR:
+       2. ANY INDIRECT OR CONSEQUENTIAL LOSSES OF ANY NATURE WHATSOEVER; OR
 
-      1. ANY LOSS OF REVENUES OR PROFITS, LOSS, CORRUPTION OR DAMAGED OF DATA, COST OF COVER, BUSINESS INTERRUPTION, LOSS OF USE, LOSS OF CONTRACTS, LOSS OF GOODWILL (WHETHER DIRECT OR INDIRECT); OR
-      2. ANY INDIRECT OR CONSEQUENTIAL LOSSES OF ANY NATURE WHATSOEVER; OR
-      3. ANY FAILURE OF THE SOFTWARE DUE TO ANY INTEGRATION OR INTEROPERABILITY ISSUES ARISING WITH ANY THIRD PARTY OR END CUSTOMER SYSTEMS OR LEGACY SYSTEMS UNLESS EXPRESSLY SET OUT TO THE CONTRARY;
-      4. WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF IT IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
-      5. ANY DAMAGES OR LOSS MUST BE NOTIFIED IN WRITING TO ACTIVEVIAM WITHIN FIFTEEN (15) DAYS OF ITS OCCURRENCE, FAILURE TO DO SO EXTINGUISHES SUCH CLAIM.
+       3. ANY FAILURE OF THE SOFTWARE DUE TO ANY INTEGRATION OR INTEROPERABILITY ISSUES ARISING WITH ANY THIRD PARTY OR END CUSTOMER SYSTEMS OR LEGACY SYSTEMS UNLESS EXPRESSLY SET OUT TO THE CONTRARY;
 
-   4. SOME STATES/COUNTRIES MAY NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, IN WHOLE OR IN PART, SO THE ABOVE LIMITATION MAY NOT APPLY IN ITS ENTIRETY TO USERS IN THOSE JURISDICTIONS SHALL BE APPLICABLE TO THE MAXIMUM EXTENT PERMISSIBLE.
-      IF ANY COURT OF COMPETENT JURISDICTIONS DETERMINES THAT ACTIVEVIAM IS OBLIGATED TO WARRANT THE PERFORMANCE OF THE SOFTWARE NOTWITHSTANDING THAT IS HAS BEEN PROVIDED TO END-CUSTOMER HEREUNDER FREE OF CHARGE, END-CUSTOMER'S EXCLUSIVE REMEDY SHALL BE THAT ACTIVEVIAM WILL REPAIR OR REPLACE THE SOFTWARE WITH ALTERNATIVE SOFTWARE REASONABLY SIMILAR TO THE SOFTWARE.
+       4. WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF IT IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
 
-   5. END-CUSTOMER ACKNOWLEDGES AND AGREES THAT ACTIVEVIAM WOULD NOT BE ABLE TO PROVIDE THE SOFTWARE ON A NO-FEE BASIS WITHOUT SUCH LIMITATIONS.
+       5. ANY DAMAGES OR LOSS MUST BE NOTIFIED IN WRITING TO ACTIVEVIAM WITHIN FIFTEEN (15) DAYS OF ITS OCCURRENCE, FAILURE TO DO SO EXTINGUISHES SUCH CLAIM.
+
+    4. SOME STATES/COUNTRIES MAY NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, IN WHOLE OR IN PART, SO THE ABOVE LIMITATION MAY NOT APPLY IN ITS ENTIRETY IN WHICH CASE SUCH EXCLUSION OR LIMITATION OF LIABILITY SHALL BE APPLICABLE TO THE MAXIMUM EXTENT PERMISSIBLE UNDER APPLICABLE LAW.
+       IF ANY COURT OF COMPETENT JURISDICTIONS DETERMINES THAT ACTIVEVIAM IS OBLIGATED TO WARRANT THE PERFORMANCE OF THE SOFTWARE NOTWITHSTANDING THAT IT HAS BEEN PROVIDED TO END CUSTOMER HEREUNDER FREE OF CHARGE, END CUSTOMER'S EXCLUSIVE REMEDY SHALL BE THAT ACTIVEVIAM WILL REPAIR OR REPLACE THE SOFTWARE WITH ALTERNATIVE SOFTWARE REASONABLY SIMILAR TO THE SOFTWARE.
+
+    5. END CUSTOMER ACKNOWLEDGES AND AGREES THAT ACTIVEVIAM WOULD NOT BE ABLE TO PROVIDE THE SOFTWARE ON A NO-FEE BASIS WITHOUT SUCH LIMITATIONS.
 
 12. Third Party Application including Open Source
 
-   1. End User agrees that third party applications, software or programs, including solutions offered on an open source mode (the "Third-Party Software") may be required, included with, or downloaded with this Software.
-      ActiveViam makes no representations whatsoever about any of these Third-Party Software, as such Third-Party Software may be subject to open source license provisions.
-      ActiveViam may provide the applicable open source licenses upon request.
-
-   2. Since ActiveViam has no control over such Third-Party Software, End Customer acknowledges and agrees that ActiveViam is not responsible for such Third-Party Software.
-      End Customer expressly acknowledges and agrees that the use of Third-Party Software is at its sole risk and that the entire risk of unsatisfactory quality, performance, accuracy and effort is borne by End Customer.
-      ActiveViam shall not be responsible or liable, directly or indirectly, for any damage or loss, including but not limited to any damage to or loss of data, caused or alleged to be caused by, or in connection with, use of or reliance on any such Third-Party Software available on or through any such Third-Party Software.
-
-   3. End Customer acknowledges and agrees that the use of any Third-Party Software is governed by such Third-Party Software's terms, EULA and privacy Policy, or other such agreement and that any information or personal data provided by the End User, whether knowingly or unknowingly, to such Third-Party Software, will be subject to such Third-Party Software' privacy policy.
-      ActiveViam expressly disclaims any responsibility for any disclosure of information or any other practices of any Third-Party Software.
-      ActiveViam expressly disclaims any warranty regarding whether personal information is captured by any Third-Party Software provider or the use to which such personal information may be put by such Third-Party Software provider.
+    1. End User agrees that third party applications, software or programs, including solutions offered on an open source mode (the "Third-Party Software") may be required, included with, or downloaded with this Software.
+       ActiveViam makes no representations whatsoever about any of these Third-Party Software, as such Third-Party Software may be subject to open source license provisions.
+       ActiveViam may provide the applicable open source licenses upon request.
+
+    2. Since ActiveViam has no control over such Third-Party Software, End Customer acknowledges and agrees that ActiveViam is not responsible for such Third-Party Software.
+       End Customer expressly acknowledges and agrees that the use of Third-Party Software is at its sole risk and that the entire risk of unsatisfactory quality, performance, accuracy and effort is borne by End Customer.
+       ActiveViam shall not be responsible or liable, directly or indirectly, for any damage or loss, including but not limited to any damage to or loss of data, caused or alleged to be caused by, or in connection with, use of or reliance on any such Third-Party Software available on or through any such Third-Party Software.
+
+    3. End Customer acknowledges and agrees that the use of any Third-Party Software is governed by such Third-Party Software's terms, EULA and privacy Policy, or other such agreement and that any information or personal data provided by the End User, whether knowingly or unknowingly, to such Third-Party Software, will be subject to such Third-Party Software' privacy policy.
+       ActiveViam expressly disclaims any responsibility for any disclosure of information or any other practices of any Third-Party Software.
+       ActiveViam expressly disclaims any warranty regarding whether personal information is captured by any Third-Party Software provider or the use to which such personal information may be put by such Third-Party Software provider.
 
 13. Assignment and Transfer
 
-   1. End Customer may not assign, delegate, hypothecate, encumbered or otherwise transfer this EULA in whole or in part, or any rights or obligations hereunder (by operation of law, agreement of otherwise), without the prior written consent of ActiveViam to any third party.
-      Any attempt to assign, delegate or otherwise transfer any of End-Customer's rights or obligations without ActiveViam's consent shall be void.
+    1. End Customer may not assign, delegate, hypothecate, encumbered or otherwise transfer this EULA in whole or in part, or any rights or obligations hereunder (by operation of law, agreement of otherwise), without the prior written consent of ActiveViam to any third party.
+       Any attempt to assign, delegate or otherwise transfer any of End Customer's rights or obligations without ActiveViam's consent shall be void.
 
-   2. In addition, End Customer expressly authorizes ActiveViam to assign the EULA to a subsidiary, or to any company or legal entity, in particular in the context of a merger, divestiture, transfer, partial asset contribution or direct or indirect change of control.
+    2. In addition, End Customer expressly authorizes ActiveViam to assign the EULA to a subsidiary, or to any company or legal entity, in particular in the context of a merger, divestiture, transfer, partial asset contribution or direct or indirect change of control.
 
 14. General provisions
 
-   1. Export rules.
-      End Customer acknowledges that the Software may be subject to the U.S. Export Administration Regulations and other export laws and regulations, and End Customer will comply with such regulations.
-   2. Non - waiver.
-      Unless otherwise agreed, failure by either Party to exercise any of its rights hereunder or to enforce at any time any provision, term or condition of this EULA will not be deemed or considered a waiver or forfeiture of that Party's right or ability to enforce such provision, term or condition.
-   3. Severance.
-      If any provision of this EULA (or part of any provision) is held to be void, illegal or otherwise unenforceable by any court of competent jurisdiction, such provision (or part) shall, to the extent necessary to ensure that the remaining provisions of this EULA are not void, illegal or unenforceable, be deemed to be deleted and the validity, legality and/or enforceability of the remaining provisions of this EULA shall not be affected.
-      In such a case, the Parties will do their best efforts to interpret or renegotiate the concerned provision to achieve as nearly as possible the same economic effect of the original provision and remain in line with the Parties' intentions.
-   4. Compliance.
-      Upon ActiveViam's written request, the End User will certify in writing that the use of the Software is fully compliant with the terms of this EULA.
-   5. Modifications.
-      The EULA may be modified at any time and without any prior notice.
-      The applicable version of the EULA that governs the use of the Software is the EULA in force when End User downloads the Software and that is enclosed with it.
-      Any modification of the EULA applies to all the elements previously installed and/or generated by End User and overrides any previous version as soon as End User downloads any release.
-   6. This EULA is exclusively governed and construed in accordance with the laws of the State of New-York, United-States of America, without regard to any conflict of law rules, and excluding the application of the United Nations Convention on Contracts for the International Sale of Goods.
-      In order to resolve amicably any dispute that may arise with respect to the interpretation, the performance and/or the termination of this EULA, the Parties agree to meet after the receipt of a notice sent by registered mail by one of the Parties, with the intent to solve any dispute in an amicable way.
-      Failing for the Parties to reach an amicable settlement by executing a settlement agreement within thirty (30) days following the notification by a Party of the existence of the dispute and making an express reference to this provision, the Parties shall submit their dispute to the state and federal courts sitting in New York, New York that will have exclusive jurisdiction to settle the dispute.
+    1. Export rules.
+       End Customer acknowledges that the Software may be subject to the U.S. Export Administration Regulations and other export laws and regulations, and End Customer will comply with such regulations.
+
+    2. Non - waiver.
+       Unless otherwise agreed, failure by either Party to exercise any of its rights hereunder or to enforce at any time any provision, term or condition of this EULA will not be deemed or considered a waiver or forfeiture of that Party's right or ability to enforce such provision, term or condition.
+
+    3. Severance.
+       If any provision of this EULA (or part of any provision) is held to be void, illegal or otherwise unenforceable by any court of competent jurisdiction, such provision (or part) shall, to the extent necessary to ensure that the remaining provisions of this EULA are not void, illegal or unenforceable, be deemed to be deleted and the validity, legality and/or enforceability of the remaining provisions of this EULA shall not be affected.
+       In such a case, the Parties will do their best efforts to interpret or renegotiate the concerned provision to achieve as nearly as possible the same economic effect of the original provision and remain in line with the Parties' intentions.
+
+    4. Compliance.
+       Upon ActiveViam's written request, the End User will certify in writing that the use of the Software is fully compliant with the terms of this EULA.
+
+    5. Modifications.
+       The EULA may be modified at any time and without any prior notice.
+       The applicable version of the EULA that governs the use of the Software is the EULA in force when End User downloads the Software and that is enclosed with it.
+       Any modification of the EULA applies to all the elements previously installed and/or generated by End User and overrides any previous version as soon as End User downloads any release.
+
+    6. This EULA is exclusively governed and construed in accordance with the laws of the State of New-York, United-States of America, without regard to any conflict of law rules, and excluding the application of the United Nations Convention on Contracts for the International Sale of Goods.
+       In order to resolve amicably any dispute that may arise with respect to the interpretation, the performance and/or the termination of this EULA, the Parties agree to meet after the receipt of a notice sent by registered mail by one of the Parties, with the intent to solve any dispute in an amicable way.
+       Failing for the Parties to reach an amicable settlement by executing a settlement agreement within thirty (30) days following the notification by a Party of the existence of the dispute and making an express reference to this provision, the Parties shall submit their dispute to the state and federal courts sitting in New York, New York that will have exclusive jurisdiction to settle the dispute.
```

## atoti_core/__init__.py

```diff
@@ -1,58 +1,72 @@
-"""Package containing private symbols shared by the other atoti packages."""
+"""Package containing private symbols shared by the other Atoti packages."""
 
 from .activeviam_client import *
 from .arithmetic_operator import *
 from .base_cube import *
 from .base_cubes import *
 from .base_hierarchies import *
 from .base_hierarchy import *
 from .base_level import *
 from .base_levels import *
 from .base_measure import *
 from .base_measures import *
 from .base_session import *
 from .boolean_operator import *
+from .column_coordinates import *
 from .combine_conditions import *
 from .comparison_operator import *
 from .condition_to_dict import *
 from .condition_to_pairs import *
 from .constant import *
 from .context import *
-from .convert_to_pandas import *
+from .convert_series import *
 from .coordinates import *
+from .coordinates_like import *
+from .create_dataframe import *
 from .data_type import *
 from .decombine_condition import *
+from .default_query_timeout import *
+from .delegate_mutable_mapping import *
+from .delegate_mutable_set import *
 from .deprecated import *
 from .doc import *
 from .empty_mapping import *
 from .fetch_json import *
 from .find_corresponding_top_level_variable_name import *
 from .get_env_flag import *
+from .get_installed_plugins import *
+from .get_ipython import *
 from .get_literal_args import *
 from .get_package_version import *
 from .get_top_level_package_name import *
 from .has_coordinates import *
 from .hierarchy_coordinates import *
 from .hierarchy_isin_condition import *
 from .hierarchy_key import *
 from .http_method import *
 from .immutable_mapping import *
 from .ipython_key_completions import *
 from .isin_condition import *
+from .java_max_int import *
 from .keyword_only_dataclass import *
 from .level_coordinates import *
 from .level_key import *
+from .license_key import *
 from .measure_coordinates import *
 from .missing_plugin_error import *
 from .operand_convertible_with_coordinates import *
 from .operation import *
+from .pandas_nullable_dtype_to_non_nullable_dtype import *
 from .path import *
 from .plugin import *
-from .plugins import *
+
+# To avoid `"get_installed_plugins" is not exported from module "atoti_core.plugins", import from "atoti_core.get_installed_plugins" instead` Pyright error.
+# Revisit when upgrading Pyright.
+from .plugins import PLUGINS as PLUGINS
 from .query_doc import *
 from .query_filter import *
 from .raise_multiple_levels_with_same_name_error import *
+from .reactive_mutable_set import *
 from .repr_json import *
-from .running_in_ipython import *
 from .scenario import *
 from .str_to_bool import *
```

## atoti_core/_get_endpoint_path.py

```diff
@@ -1,8 +1,9 @@
-from typing import Collection, Literal
+from collections.abc import Collection
+from typing import Literal
 
 from ._server_versions import ServerVersions
 
 _SUPPORTED_PIVOT_VERSIONS = ("4", "5", "6", "7zz1", "8zz1", "8zz2", "8")
 
 
 def _get_supported_version_index(
```

## atoti_core/_server_versions.py

```diff
@@ -1,16 +1,17 @@
-from typing import Mapping, Sequence, TypedDict
+from collections.abc import Mapping, Sequence
+from typing import TypedDict
 
 
 class _ApiVersion(TypedDict):
-    id: str
+    id: str  # noqa: A003
     restPath: str
 
 
-class ApiVersion(_ApiVersion, total=False):
+class ApiVersion(_ApiVersion, TypedDict, total=False):
     wsPath: str
 
 
 class ServerApi(TypedDict):
     versions: Sequence[ApiVersion]
```

## atoti_core/activeviam_client.py

```diff
@@ -1,26 +1,23 @@
 from __future__ import annotations
 
 import json
+from collections.abc import Callable, Mapping, Sequence
 from dataclasses import replace
 from email.message import Message
 from functools import cached_property
 from http.client import HTTPResponse
 from pathlib import Path
 from ssl import create_default_context
 from typing import (
     IO,
     Any,
-    Callable,
-    List,
     Literal,
-    Mapping,
     NoReturn,
     Optional,
-    Sequence,
     TypedDict,
     Union,
     cast,
     overload,
 )
 from urllib.error import HTTPError
 from urllib.parse import urljoin
@@ -40,23 +37,23 @@
 from .fetch_json import JSON_CONTENT_TYPE, JsonResponse, fetch_json
 from .http_method import HttpMethod
 from .path import local_to_absolute_path
 
 
 class _ErrorChainItem(TypedDict):
     message: str
-    type: str
+    type: str  # noqa: A003
 
 
 class _CurrentActiveViamJsonHttpErrorBody(TypedDict):
     errorChain: Sequence[_ErrorChainItem]
     stackTrace: str
 
 
-class _LegacyActiveViamJsonHttpErrorBody(TypedDict):  # ActivePivot < 6.0.0-M1.
+class _LegacyActiveViamJsonHttpErrorBody(TypedDict):  # Atoti Server < 6.0.0-M1.
     error: _CurrentActiveViamJsonHttpErrorBody
     status: Literal["error"]
 
 
 def _is_current_activeviam_json_http_error_body(
     body: Any,
 ) -> TypeGuard[_CurrentActiveViamJsonHttpErrorBody]:
@@ -158,15 +155,15 @@
         return request
 
     http_request = _handle_request
     https_request = _handle_request
 
 
 class ActiveViamClient:
-    """Used to communicate with ActiveViam servers such as ActivePivot or the Content Server.
+    """Used to communicate with ActiveViam servers such as Atoti Server or the Content Server.
 
     This class uses a custom HTTP error handler to enrich the raised errors with the server stack trace.
     """
 
     def __init__(
         self,
         url: str,
@@ -176,15 +173,15 @@
         certificate_authority: Optional[Path] = None,
         client_certificate: Optional[Path] = None,
         client_certificate_keyfile: Optional[Path] = None,
         client_certificate_password: Optional[str] = None,
     ) -> None:
         self._url = url.strip("/")
 
-        handlers: List[BaseHandler] = [_ActiveViamJsonHttpErrorHandler()]
+        handlers: list[BaseHandler] = [_ActiveViamJsonHttpErrorHandler()]
 
         if auth:
             handlers.append(_AuthHandler(auth))
 
         if certificate_authority or client_certificate:
             context = create_default_context()
             if certificate_authority:
@@ -262,15 +259,15 @@
         assert isinstance(response, JsonResponse)
 
         if (
             isinstance(response.body, dict)
             and "data" in response.body
             and response.body.get("status") == "success"
         ):
-            # ActivePivot < 6.0.0-M1.
+            # Atoti Server < 6.0.0-M1.
             return replace(response, body=response.body["data"])
 
         return response
 
     def ping(self) -> str:
         url = self._get_endpoint_url(namespace="activeviam/pivot", route="ping")
         response = self._opener_director.open(url)
@@ -312,7 +309,11 @@
         return self._get_url(path)
 
     @cached_property
     def server_versions(self) -> ServerVersions:
         url = self._get_url("versions/rest")
         body = fetch_json(url, opener_director=self._opener_director).body
         return cast(ServerVersions, body)
+
+    @property
+    def has_atoti_python_api_endpoints(self) -> bool:
+        return "atoti" in self.server_versions["apis"]
```

## atoti_core/base_cube.py

```diff
@@ -1,21 +1,23 @@
 from __future__ import annotations
 
 from abc import abstractmethod
+from collections.abc import Iterable
 from datetime import timedelta
-from typing import Any, Generic, Iterable, Literal, Optional, TypeVar
+from typing import Any, Generic, Literal, Optional, TypeVar
 
 import pandas as pd
 
 from .base_hierarchies import BaseHierarchiesBound
 from .base_level import BaseLevel
 from .base_levels import BaseLevelsBound, HierarchiesT
 from .base_measure import BaseMeasure
 from .base_measures import BaseMeasuresBound
 from .context import Context
+from .default_query_timeout import DEFAULT_QUERY_TIMEOUT
 from .empty_mapping import EMPTY_MAPPING
 from .query_filter import QueryFilter
 from .repr_json import ReprJson, ReprJsonable
 from .scenario import BASE_SCENARIO_NAME
 
 LevelsT = TypeVar("LevelsT", bound=BaseLevelsBound, covariant=True)
 MeasuresT = TypeVar("MeasuresT", bound=BaseMeasuresBound, covariant=True)
@@ -55,20 +57,20 @@
         return self._hierarchies
 
     @abstractmethod
     def query(
         self,
         *measures: BaseMeasure,
         context: Context = EMPTY_MAPPING,
-        filter: Optional[QueryFilter] = None,  # pylint: disable=redefined-builtin
+        filter: Optional[QueryFilter] = None,  # noqa: A002
         include_totals: bool = False,
         levels: Iterable[BaseLevel] = (),
         mode: Literal["pretty", "raw"] = "pretty",
         scenario: str = BASE_SCENARIO_NAME,
-        timeout: timedelta = timedelta(seconds=30),
+        timeout: timedelta = DEFAULT_QUERY_TIMEOUT,
         **kwargs: Any,
     ) -> pd.DataFrame:
         ...
 
     def _repr_json_(self) -> ReprJson:
         return (
             {
```

## atoti_core/base_cubes.py

```diff
@@ -1,8 +1,9 @@
-from typing import Mapping, TypeVar
+from collections.abc import Mapping
+from typing import TypeVar
 
 from .base_cube import BaseCubeBound
 from .repr_json import ReprJson, ReprJsonable
 
 CubeT = TypeVar("CubeT", bound=BaseCubeBound, covariant=True)
```

## atoti_core/base_hierarchies.py

```diff
@@ -1,30 +1,31 @@
 from __future__ import annotations
 
 from abc import abstractmethod
-from typing import Dict, Iterable, List, Mapping, Optional, Tuple, TypeVar, Union
+from collections.abc import Iterable, Mapping
+from typing import Optional, TypeVar, Union
 
 from .base_hierarchy import BaseHierarchyBound
 from .hierarchy_coordinates import HierarchyCoordinates
 from .hierarchy_key import HierarchyKey
 from .repr_json import ReprJson, ReprJsonable
 
 HierarchyT = TypeVar("HierarchyT", bound=BaseHierarchyBound, covariant=True)
 
 
-class BaseHierarchies(Mapping[Tuple[str, str], HierarchyT], ReprJsonable):
+class BaseHierarchies(Mapping[tuple[str, str], HierarchyT], ReprJsonable):
     """Manage the base hierarchies."""
 
     @abstractmethod
     def __getitem__(self, key: HierarchyKey, /) -> HierarchyT:
         """Return the hierarchy with the given name."""
 
     def _repr_json_(self) -> ReprJson:
         """Return the JSON representation of hierarchies."""
-        dimensions: Dict[str, List[HierarchyT]] = {}
+        dimensions: dict[str, list[HierarchyT]] = {}
         for hierarchy in self.values():
             dimensions.setdefault(hierarchy.dimension, []).append(hierarchy)
         json = {
             dimension: dict(
                 sorted(
                     {
                         hierarchy._repr_json_()[1]["root"]: hierarchy._repr_json_()[0]
@@ -33,15 +34,15 @@
                 )
             )
             for dimension, dimension_hierarchies in sorted(dimensions.items())
         }
         return json, {"expanded": True, "root": "Dimensions"}
 
     @staticmethod
-    def _convert_key(key: HierarchyKey, /) -> Tuple[Optional[str], str]:
+    def _convert_key(key: HierarchyKey, /) -> tuple[Optional[str], str]:
         """Get the dimension and hierarchy from the key."""
         if isinstance(key, str):
             return (None, key)
 
         return key
 
     @staticmethod
```

## atoti_core/base_hierarchy.py

```diff
@@ -1,11 +1,12 @@
 from __future__ import annotations
 
 from abc import abstractmethod
-from typing import Generic, Literal, Mapping, Tuple, TypeVar
+from collections.abc import Mapping
+from typing import Generic, Literal, TypeVar
 
 from .base_level import BaseLevel
 from .constant import Constant, ConstantValue
 from .has_coordinates import HasCoordinates
 from .hierarchy_coordinates import HierarchyCoordinates
 from .hierarchy_isin_condition import HierarchyIsinCondition
 from .operation import Condition
@@ -53,15 +54,15 @@
 
         * A slicing hierarchy is not aggregable at the top level, meaning that it does not make sense to aggregate data across all members of the hierarchy.
 
           For instance, for an :guilabel:`As of date` hierarchy giving the current bank account :guilabel:`Balance` for a given date, it does not provide any meaningful information to aggregate the :guilabel:`Balance` across all the dates.
         """
 
     def isin(
-        self, *member_paths: Tuple[ConstantValue, ...]
+        self, *member_paths: tuple[ConstantValue, ...]
     ) -> Condition[HierarchyCoordinates, Literal["isin"], Constant, None]:
         """Return a condition to check that the hierarchy is on one of the given members.
 
         Considering ``hierarchy_1`` containing ``level_1`` and ``level_2``, ``hierarchy_1.isin((a,), (b, c))`` is equivalent to ``(level_1 == a) | ((level_1 == b) & (level_2 == c))``.
 
         Args:
             member_paths: One or more member paths expressed as tuples on which the hierarchy should be.
```

## atoti_core/base_level.py

```diff
@@ -93,23 +93,22 @@
 
         """
         return IsinCondition(
             subject=self._operation_operand,
             elements=tuple(Constant(member) for member in members),
         )
 
-    def isnull(  # pylint: disable=useless-super-delegation
+    def isnull(
         self,
     ) -> Condition[LevelCoordinates, Literal["eq"], None, None]:
         """Return a condition evaluating to ``True`` when a level is not expressed in a query and ``False`` otherwise.
 
         Use `~level.isnull()` for the opposite behavior.
 
         Example:
-
             >>> df = pd.DataFrame(
             ...     columns=["Country", "City", "Price"],
             ...     data=[
             ...         ("France", "Paris", 200.0),
             ...         ("Germany", "Berlin", 120),
             ...     ],
             ... )
```

## atoti_core/base_levels.py

```diff
@@ -1,13 +1,14 @@
 from __future__ import annotations
 
 import operator
 from abc import abstractmethod
+from collections.abc import Iterator, Mapping
 from itertools import chain
-from typing import Dict, Generic, Iterator, Mapping, Optional, Tuple, TypeVar, cast
+from typing import Generic, Optional, TypeVar, cast
 
 from .base_hierarchies import BaseHierarchiesBound
 from .base_hierarchy import LevelT
 from .base_level import BaseLevel
 from .ipython_key_completions import (
     IPythonKeyCompletions,
     get_ipython_key_completions_for_mapping,
@@ -24,36 +25,38 @@
     """Base class to manipulate flattened levels."""
 
     def __init__(self, *, hierarchies: HierarchiesT) -> None:
         super().__init__()
 
         self._hierarchies = hierarchies
 
-    def _flatten(self) -> Dict[str, Optional[LevelT]]:
-        flat_levels: Dict[str, Optional[LevelT]] = {}
+    def _flatten(self) -> dict[str, Optional[LevelT]]:
+        flat_levels: dict[str, Optional[LevelT]] = {}
         for hierarchy in self._hierarchies.values():
             for level in hierarchy.levels.values():
                 if level.name in flat_levels:
                     # None is used as a flag to mark levels appearing in multiple hierarchies.
                     # When it happens, the user must use a tuple to retrieve the level.
                     # Like that: (hierarchy name, level name).
                     flat_levels[level.name] = None
                 else:
-                    flat_levels[level.name] = level  # type: ignore
+                    flat_levels[level.name] = level  # type: ignore[assignment] # pyright: ignore[reportGeneralTypeIssues]
         return flat_levels
 
     def __getitem__(self, key: LevelKey, /) -> LevelT:
         """Return the level with the given key."""
         if isinstance(key, str):
             return self._find_level(key)
 
-        if len(key) == 2:
+        if len(key) == 2:  # noqa: PLR2004
             return self._find_level(key[1], hierarchy_name=key[0])
 
-        key = cast(Tuple[str, str, str], key)
+        # Pyright narrows the type after the previous checks but mypy does not so casting is required.
+        # See https://github.com/python/mypy/issues/1178.
+        key = cast(tuple[str, str, str], key)  # pyright: ignore[reportUnnecessaryCast]
         return self._find_level(key[2], dimension_name=key[0], hierarchy_name=key[1])
 
     @abstractmethod
     def _find_level(
         self,
         level_name: str,
         *,
```

## atoti_core/base_measure.py

```diff
@@ -39,15 +39,14 @@
 
     def isnull(self) -> Condition[MeasureCoordinates, Literal["eq"], None, None]:
         """Return a condition evaluating to ``True`` if the measure evalutes to ``None`` and ``False`` otherwise.
 
         Use ``~measure.isnull()`` for the opposite behavior.
 
         Example:
-
             >>> df = pd.DataFrame(
             ...     columns=["Country", "City", "Price"],
             ...     data=[
             ...         ("France", "Paris", 200.0),
             ...         ("Germany", "Berlin", None),
             ...     ],
             ... )
```

## atoti_core/base_measures.py

```diff
@@ -1,19 +1,20 @@
-from typing import Any, Dict, Mapping, TypeVar
+from collections.abc import Mapping
+from typing import Any, TypeVar
 
 from .base_measure import BaseMeasure
 from .repr_json import ReprJson, ReprJsonable
 
 MeasureT = TypeVar("MeasureT", bound=BaseMeasure, covariant=True)
 
 
 class BaseMeasures(Mapping[str, MeasureT], ReprJsonable):
     def _repr_json_(self) -> ReprJson:
         """Return the JSON representation of measures."""
-        measures_json: Dict[str, Dict[str, Any]] = {}
+        measures_json: dict[str, dict[str, Any]] = {}
         no_folder = {}
         for measure in self.values():
             if measure.visible:
                 json = {"formatter": measure.formatter}
                 if measure.description is not None:
                     json["description"] = measure.description
                 if measure.folder is None:
```

## atoti_core/base_session.py

```diff
@@ -1,70 +1,142 @@
+from __future__ import annotations
+
 import random
 import string
 from abc import abstractmethod
+from collections.abc import Mapping
 from datetime import timedelta
 from time import time
-from typing import Any, Dict, Generic, Literal, Mapping, Optional, TypeVar, cast
+from typing import Any, Generic, Literal, Optional, TypeVar, cast
 
 import pandas as pd
 
 from .activeviam_client import ActiveViamClient
 from .base_cubes import BaseCubesBound
 from .context import Context
+from .default_query_timeout import DEFAULT_QUERY_TIMEOUT
 from .doc import doc
 from .empty_mapping import EMPTY_MAPPING
 from .find_corresponding_top_level_variable_name import (
     find_corresponding_top_level_variable_name,
 )
 from .missing_plugin_error import MissingPluginError
 from .query_doc import QUERY_ARGS_DOC
 from .repr_json import ReprJson, ReprJsonable
 
 CubesT = TypeVar("CubesT", bound=BaseCubesBound, covariant=True)
+_SecurityT = TypeVar("_SecurityT", covariant=True)
 
 
 def _generate_session_id() -> str:
     random_string = "".join(
-        # No need for cryptographic security.
-        random.choices(string.ascii_uppercase + string.digits, k=6)  # nosec B311
+        # No cryptographic security required.
+        random.choices(string.ascii_uppercase + string.digits, k=6)  # noqa: S311
     )
-    return f"{str(int(time()))}_{random_string}"
+    return f"{int(time())}_{random_string}"
 
 
-class BaseSession(Generic[CubesT], ReprJsonable):
+class BaseSession(Generic[CubesT, _SecurityT], ReprJsonable):
     """Base class for session."""
 
     def __init__(self) -> None:
         self.__id = _generate_session_id()
 
+        def link(
+            session: BaseSessionBound,  # noqa: ARG001
+            /,
+            *,
+            path: str,  # noqa: ARG001
+        ) -> object:
+            raise MissingPluginError("jupyterlab3")
+
+        def visualize(
+            session: BaseSessionBound,  # noqa: ARG001
+            /,
+            *,
+            name: Optional[str] = None,  # noqa: ARG001
+        ) -> None:
+            raise MissingPluginError("jupyterlab3")
+
+        self._link = link
+        self._visualize = visualize
+
     @property
     @abstractmethod
     def _client(self) -> ActiveViamClient:
         ...
 
     @property
     @abstractmethod
     def _location(self) -> Mapping[str, Any]:
         """Location data used to create a link to this session."""
 
-    def link(self, *, path: str = "") -> Any:
-        raise MissingPluginError("jupyterlab")
+    def link(
+        self,
+        *,
+        path: str = "",
+    ) -> object:
+        """Display a link to this session.
+
+        Clicking on the link will open it in a new browser tab.
+
+        Note:
+            This method requires the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin.
+
+        The extension will try to access the session through (in that order):
+
+        #. `Jupyter Server Proxy <https://jupyter-server-proxy.readthedocs.io/>`__ if it is enabled.
+        #. ``f"{session_protocol}//{jupyter_server_hostname}:{session.port}"`` for :class:`atoti.Session` and ``session.url`` for :class:`atoti_query.QuerySession`.
+
+        Args:
+            path: The path to append to the session base URL.
+                Defaults to the session home page.
+
+        Example:
+            Pointing directly to an existing dashboard:
+
+            .. testcode::
+
+                dashboard_id = "92i"
+                session.link(path=f"#/dashboard/{dashboard_id}")
+
+        """
+        return self._link(self, path=path)
 
     @property
     @abstractmethod
     def cubes(self) -> CubesT:
         """Cubes of the session."""
 
     @property
     @abstractmethod
+    def _security(self) -> _SecurityT:
+        ...
+
+    @property
+    @abstractmethod
     def _local_url(self) -> str:
         """URL that can be used to access the session on the host machine's network."""
 
-    def visualize(self, name: Optional[str] = None) -> Any:
-        raise MissingPluginError("jupyterlab")
+    def visualize(
+        self,
+        name: Optional[str] = None,
+    ) -> None:
+        """Display an Atoti widget to explore the session interactively.
+
+        Note:
+            This method requires the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin.
+
+        The widget state will be stored in the cell metadata.
+        This state should not have to be edited but, if desired, it can be found in JupyterLab by opening the "Notebook tools" sidebar and expanding the "Advanced Tools" section.
+
+        Args:
+            name: The name to give to the widget.
+        """
+        return self._visualize(self, name=name)
 
     @property
     def _id(self) -> str:
         return self.__id
 
     @doc(
         f"""Execute an MDX query and return its result as a pandas DataFrame.
@@ -187,32 +259,30 @@
     )
     @abstractmethod
     def query_mdx(
         self,
         mdx: str,
         *,
         keep_totals: bool = False,
-        timeout: timedelta = timedelta(seconds=30),
+        timeout: timedelta = DEFAULT_QUERY_TIMEOUT,
         mode: Literal["pretty", "raw"] = "pretty",
         context: Context = EMPTY_MAPPING,
     ) -> pd.DataFrame:
         ...
 
     @abstractmethod
-    def _generate_auth_headers(self) -> Dict[str, str]:
+    def _generate_auth_headers(self) -> dict[str, str]:
         """Generate authentication headers that can be used to authenticate against this session."""
 
     def _get_widget_creation_code(self) -> Optional[str]:
         session_variable_name = find_corresponding_top_level_variable_name(self)
 
         return f"{session_variable_name}.visualize()" if session_variable_name else None
 
-    def _block_until_widget_loaded(  # pylint: disable=unused-argument
-        self, widget_id: str
-    ) -> None:
+    def _block_until_widget_loaded(self, widget_id: str) -> None:
         # Nothing to do by default.
         ...
 
     def _repr_json_(self) -> ReprJson:
         cubes = self.cubes._repr_json_()[0]
         data = (
             {"Tables": cast(Any, self).tables._repr_json_()[0], "Cubes": cubes}
@@ -221,8 +291,8 @@
         )
         return (
             data,
             {"expanded": False, "root": type(self).__name__},
         )
 
 
-BaseSessionBound = BaseSession[BaseCubesBound]
+BaseSessionBound = BaseSession[BaseCubesBound, Any]
```

## atoti_core/boolean_operator.py

```diff
@@ -1,9 +1,9 @@
-from typing import Literal, Tuple, cast
+from typing import Literal, cast
 
 from .get_literal_args import get_literal_args
 
 BooleanOperator = Literal["and", "or"]
 
 ALL_BOOLEAN_OPERATORS = cast(
-    Tuple[BooleanOperator, ...], get_literal_args(BooleanOperator)
+    tuple[BooleanOperator, ...], get_literal_args(BooleanOperator)
 )
```

## atoti_core/combine_conditions.py

```diff
@@ -1,8 +1,9 @@
-from typing import Collection, Literal, Tuple, TypeVar, Union, overload
+from collections.abc import Collection
+from typing import Literal, TypeVar, Union, overload
 
 from .boolean_operator import BooleanOperator
 from .operation import (
     CombinedCondition,
     Condition,
     ConditionCombinationOperatorBound,
     ConditionCombinationOperatorT,
@@ -45,15 +46,15 @@
         operator=operator,
     )
 
 
 @overload
 # If the top level collection has a single element, the operator `or` will not be used, only `and`.
 def combine_conditions(
-    conditions: Tuple[
+    conditions: tuple[
         Collection[
             Condition[
                 ConditionSubjectT,
                 ConditionComparisonOperatorT,
                 ConditionTargetT,
                 ConditionCombinationOperatorT,
             ]
@@ -69,15 +70,15 @@
     ...
 
 
 @overload
 # If all the bottom level collections have a single element, the operator `and` will not be used, only `or`.
 def combine_conditions(
     conditions: Collection[
-        Tuple[
+        tuple[
             Condition[
                 ConditionSubjectT,
                 ConditionComparisonOperatorT,
                 ConditionTargetT,
                 ConditionCombinationOperatorT,
             ]
         ]
```

## atoti_core/comparison_operator.py

```diff
@@ -1,15 +1,16 @@
-from typing import Literal, Mapping, Tuple, cast
+from collections.abc import Mapping
+from typing import Literal, cast
 
 from .get_literal_args import get_literal_args
 
 ComparisonOperator = Literal["eq", "ge", "gt", "le", "lt", "ne"]
 
 ALL_COMPARISON_OPERATORS = cast(
-    Tuple[ComparisonOperator, ...], get_literal_args(ComparisonOperator)
+    tuple[ComparisonOperator, ...], get_literal_args(ComparisonOperator)
 )
 
 _OPERATOR_TO_INVERSE_OPERATOR_ONE_WAY: Mapping[
     ComparisonOperator, ComparisonOperator
 ] = {
     "eq": "ne",
     "lt": "ge",
```

## atoti_core/condition_to_dict.py

```diff
@@ -1,25 +1,25 @@
-from typing import Dict, Literal, Optional
+from typing import Literal, Optional
 
 from .condition_to_pairs import condition_to_pairs
 from .has_coordinates import CoordinatesT
 from .operation import Condition, ConditionTargetT
 
 
 def condition_to_dict(
     condition: Condition[
         CoordinatesT,
         Literal["eq"],
         ConditionTargetT,
         Optional[Literal["and"]],
     ],
     /,
-) -> Dict[CoordinatesT, ConditionTargetT]:
+) -> dict[CoordinatesT, ConditionTargetT]:
     pairs = condition_to_pairs(condition)
-    result: Dict[CoordinatesT, ConditionTargetT] = {}
+    result: dict[CoordinatesT, ConditionTargetT] = {}
 
     for coordinates, target in pairs:
         if coordinates in result:
             raise ValueError(
                 f"Expected the combined condition to have distinct subjects but got `{coordinates}` twice."
             )
```

## atoti_core/condition_to_pairs.py

```diff
@@ -1,8 +1,8 @@
-from typing import List, Literal, Optional, Tuple, cast
+from typing import Literal, Optional, cast
 
 from .decombine_condition import decombine_condition
 from .operation import (
     ComparisonCondition,
     Condition,
     ConditionSubjectT,
     ConditionTargetT,
@@ -13,17 +13,17 @@
     condition: Condition[
         ConditionSubjectT,
         Literal["eq"],
         ConditionTargetT,
         Optional[Literal["and"]],
     ],
     /,
-) -> List[Tuple[ConditionSubjectT, ConditionTargetT]]:
+) -> list[tuple[ConditionSubjectT, ConditionTargetT]]:
     comparison_conditions = cast(
-        Tuple[
+        tuple[
             ComparisonCondition[ConditionSubjectT, Literal["eq"], ConditionTargetT], ...
         ],
         decombine_condition(
             condition,
             allowed_comparison_operators=("eq",),
             allowed_combination_operators=("and",),
             allowed_isin_element_types=(),
```

## atoti_core/constant.py

```diff
@@ -1,18 +1,18 @@
 from __future__ import annotations
 
 import math
+from collections.abc import Iterable
 from dataclasses import dataclass, field
 from datetime import date, datetime, time
 
 # Here `get_args()` is used on `Union`, not on `Literal`.
 from typing import (  # pylint: disable=preferred-function
     Any,
-    Iterable,
-    Tuple,
+    NoReturn,
     Union,
     get_args,
 )
 
 from typing_extensions import TypeGuard
 
 from .data_type import DataType
@@ -29,17 +29,17 @@
     str,
     time,
 ]
 
 _CONSTANT_ARRAY_ELEMENT_TYPES = get_args(_ConstantArrayElement)
 
 
-def _get_checked_value_and_data_type(  # pylint: disable=too-many-branches,too-many-return-statements
+def _get_checked_value_and_data_type(  # noqa: C901, PLR0911, PLR0912
     value: ConstantValue, /
-) -> Tuple[ConstantValue, DataType]:
+) -> tuple[ConstantValue, DataType]:
     # Use the widest types to avoid compilation problems.
     # For better performance, types are checked from the most probable to the least.
 
     if isinstance(value, bool):
         return value, "boolean"
     if isinstance(value, float):
         if math.isnan(value):
@@ -92,21 +92,65 @@
 
     raise TypeError(f"Unexpected constant value type: `{type(value).__name__}`.")
 
 
 def is_constant_value(value: Any, /) -> TypeGuard[ConstantValue]:
     try:
         Constant(value)
-        return True
     except (TypeError, ValueError):
         return False
+    else:
+        return True
 
 
 @dataclass(frozen=True)
 class Constant:  # pylint: disable=keyword-only-dataclass
     data_type: DataType = field(init=False, compare=False, repr=False)
     value: ConstantValue
 
     def __post_init__(self) -> None:
         value, data_type = _get_checked_value_and_data_type(self.value)
         self.__dict__["data_type"] = data_type
         self.__dict__["value"] = value
+
+    def __lt__(self, other: Any) -> bool:  # noqa: C901
+        if not isinstance(other, Constant):
+            raise TypeError(
+                f"Cannot compare `{Constant.__name__}` to `{type(other).__name__}`."
+            )
+
+        def raise_type_error() -> NoReturn:
+            raise TypeError(
+                f"Cannot compare `{self.data_type}` `{Constant.__name__}` to `{other.data_type}` `{Constant.__name__}`."
+            )
+
+        if isinstance(self.value, (bool, int, float)):
+            if not isinstance(other.value, (bool, int, float)):
+                raise_type_error()
+            return self.value < other.value
+
+        if isinstance(self.value, str):
+            if not isinstance(other.value, str):
+                raise_type_error()
+            return self.value < other.value
+
+        if isinstance(self.value, Iterable):
+            if not isinstance(other.value, Iterable):
+                raise_type_error()
+            return tuple(self.value) < tuple(other.value)
+
+        if isinstance(self.value, date):
+            if not isinstance(other.value, date):
+                raise_type_error()
+            return self.value < other.value
+
+        if isinstance(self.value, datetime):
+            if not isinstance(other.value, date):
+                raise_type_error()
+            return self.value < other.value
+
+        # All the other types have already been handled.
+        assert isinstance(self.value, time)
+
+        if not isinstance(other.value, time):
+            raise_type_error()
+        return self.value < other.value
```

## atoti_core/context.py

```diff
@@ -1,3 +1,4 @@
-from typing import Any, Mapping
+from collections.abc import Mapping
+from typing import Any
 
 Context = Mapping[str, Any]
```

## atoti_core/coordinates.py

```diff
@@ -1,16 +1,15 @@
 from abc import ABC, abstractmethod
 from functools import cached_property
-from typing import Tuple
 
 
 class Coordinates(ABC):
     @property
     @abstractmethod
-    def key(self) -> Tuple[str, ...]:
+    def key(self) -> tuple[str, ...]:
         ...
 
     @cached_property
     def java_description(self) -> str:
         return "@".join(reversed(self.key))
 
     def __str__(self) -> str:
```

## atoti_core/data_type.py

```diff
@@ -121,13 +121,19 @@
     return data_type in get_literal_args(NumericDataType)
 
 
 def is_numeric_array_type(data_type: DataType, /) -> TypeGuard[NumericArrayDataType]:
     return data_type in get_literal_args(NumericArrayDataType)
 
 
+def get_numeric_array_element_type(
+    data_type: NumericArrayDataType, /
+) -> NumericDataType:
+    return cast(NumericDataType, parse_data_type(data_type[: -len(_ARRAY_SUFFIX)]))
+
+
 def is_boolean_type(data_type: DataType, /) -> TypeGuard[BooleanDataType]:
     return data_type in get_literal_args(BooleanDataType)
 
 
 def is_primitive_type(data_type: DataType, /) -> TypeGuard[PrimitiveDataType]:
     return data_type in get_literal_args(PrimitiveDataType)
```

## atoti_core/decombine_condition.py

```diff
@@ -1,9 +1,9 @@
 from itertools import chain, product
-from typing import Dict, List, Tuple, Type, TypeVar, cast
+from typing import TypeVar, cast
 
 from .boolean_operator import ALL_BOOLEAN_OPERATORS, BooleanOperator
 from .comparison_operator import ALL_COMPARISON_OPERATORS, ComparisonOperator
 from .constant import Constant
 from .coordinates import Coordinates
 from .hierarchy_isin_condition import HierarchyIsinCondition
 from .isin_condition import IsinCondition, IsinConditionElementT
@@ -25,84 +25,88 @@
 )
 
 
 def _check_subject(
     subject: ConditionSubjectBound,
     /,
     *,
-    allowed_types: Tuple[Type[ConditionSubjectT], ...],
+    allowed_types: tuple[type[ConditionSubjectT], ...],
 ) -> ConditionSubjectT:
     if not isinstance(subject, allowed_types):
         raise TypeError(
             f"Expected the type of the condition's subject to be one of `{tuple(allowed_type.__name__ for allowed_type in allowed_types)}` but got `{type(subject).__name__}`."
         )
     # If the `isinstance()` above returned `True`, thanks to the type of `allowed_types`, `subject` is guaranteed to be a `ConditionSubjectT`.
     return subject  # type: ignore[return-value]
 
 
-def decombine_condition(  # pylint: disable=too-many-branches
+_NONE_TYPE = type(None)
+
+
+def decombine_condition(  # noqa: C901, PLR0912
     condition: ConditionBound,
     /,
     *,
-    allowed_subject_types: Tuple[
-        Type[ConditionSubjectT],
+    allowed_subject_types: tuple[
+        type[ConditionSubjectT],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
         Coordinates,
         Operation,
     ),
-    allowed_comparison_operators: Tuple[
+    allowed_comparison_operators: tuple[
         _ComparisonOperatorT,
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = ALL_COMPARISON_OPERATORS,  # type: ignore[assignment]
-    allowed_target_types: Tuple[
-        Type[ConditionTargetT],
+    allowed_target_types: tuple[
+        type[ConditionTargetT],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
-        type(None),
+        _NONE_TYPE,
         Constant,
         Coordinates,
         Operation,
     ),
-    allowed_combination_operators: Tuple[
+    allowed_combination_operators: tuple[
         _CombinationOperatorT,
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = ALL_BOOLEAN_OPERATORS,  # type: ignore[assignment]
-    allowed_isin_element_types: Tuple[
-        Type[IsinConditionElementT],
+    allowed_isin_element_types: tuple[
+        type[IsinConditionElementT],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
-        type(None),
+        _NONE_TYPE,
         Constant,
     ),
-) -> Tuple[
-    Tuple[
-        Tuple[
+) -> tuple[
+    tuple[
+        tuple[
             ComparisonCondition[
                 ConditionSubjectT, _ComparisonOperatorT, ConditionTargetT
             ],
             ...,
         ],
-        Tuple[IsinCondition[ConditionSubjectT, IsinConditionElementT], ...],
-        Tuple[HierarchyIsinCondition, ...],
+        tuple[IsinCondition[ConditionSubjectT, IsinConditionElementT], ...],
+        tuple[HierarchyIsinCondition, ...],
     ],
     ...,
 ]:
     """Return the conditions in disjunctive normal form.
 
     For example: ``c1 & (c2 | c3)`` will return ``((c_1, c_2), (c_1, c_3))``.
 
     If ``allowed_combination_operators=("and",)`` is passed, the top level tuple will have a single element.
 
-    If ``allowed_isin_element_types=()`` is passed, the tuples containing isin and hierarchy isin conditions will be empty."""
+    If ``allowed_isin_element_types=()`` is passed, the tuples containing isin and hierarchy isin conditions will be empty.
+    """
     if isinstance(condition, ComparisonCondition):
         subject = _check_subject(condition.subject, allowed_types=allowed_subject_types)
 
         operator = condition.operator
         if operator not in allowed_comparison_operators:
             raise ValueError(
                 f"Expected `{ComparisonCondition.__name__}`'s operator to be one of `{allowed_comparison_operators}` but got `{operator}`."
@@ -137,15 +141,15 @@
 
         elements = condition.elements
         for element in elements:
             if not isinstance(element, allowed_isin_element_types):
                 raise TypeError(
                     f"Expected the type of the `{IsinCondition.__name__}`'s elements to be one of `{tuple(allowed_type.__name__ for allowed_type in allowed_isin_element_types)}` but got `{type(element).__name__}`."
                 )
-        elements = cast(Tuple[IsinConditionElementT, ...], elements)
+        elements = cast(tuple[IsinConditionElementT, ...], elements)
 
         return (((), (IsinCondition(subject=subject, elements=elements),), ()),)
 
     if isinstance(condition, HierarchyIsinCondition):
         if not allowed_isin_element_types:
             raise TypeError(
                 f"Expected no `isin` condition but got a `{type(condition).__name__}`."
@@ -177,76 +181,76 @@
             )
             for sub_condition in condition.sub_conditions
         )
 
         if operator == "or":
             return first_decombined_conditions + second_decombined_conditions
 
-        mixed_first_decombined_conditions, mixed_second_decombined_conditions = [
+        mixed_first_decombined_conditions, mixed_second_decombined_conditions = (
             [
                 comparison_conditions + isin_conditions + hierarchy_isin_conditions
                 for comparison_conditions, isin_conditions, hierarchy_isin_conditions in decombined_conditions
             ]
             for decombined_conditions in [
                 first_decombined_conditions,
                 second_decombined_conditions,
             ]
-        ]
+        )
 
-        decombined_conditions: List[
-            Tuple[
-                Tuple[
+        decombined_conditions: list[
+            tuple[
+                tuple[
                     ComparisonCondition[
                         ConditionSubjectT, _ComparisonOperatorT, ConditionTargetT
                     ],
                     ...,
                 ],
-                Tuple[IsinCondition[ConditionSubjectT, IsinConditionElementT], ...],
-                Tuple[HierarchyIsinCondition, ...],
+                tuple[IsinCondition[ConditionSubjectT, IsinConditionElementT], ...],
+                tuple[HierarchyIsinCondition, ...],
             ],
         ] = []
 
         for normalized_conditions in (
             chain(*mixed_decombined_conditions)
             for mixed_decombined_conditions in product(
                 mixed_first_decombined_conditions, mixed_second_decombined_conditions
             )
         ):
-            type_to_conditions: Dict[Type[ConditionBound], List[ConditionBound]] = {}
+            type_to_conditions: dict[type[ConditionBound], list[ConditionBound]] = {}
 
             for normalized_condition in normalized_conditions:
                 type_to_conditions.setdefault(type(normalized_condition), []).append(
                     normalized_condition
                 )
 
             decombined_conditions.append(
                 (
                     tuple(
                         cast(
-                            List[
+                            list[
                                 ComparisonCondition[
                                     ConditionSubjectT,
                                     _ComparisonOperatorT,
                                     ConditionTargetT,
                                 ],
                             ],
                             type_to_conditions.get(ComparisonCondition, []),
                         )
                     ),
                     tuple(
                         cast(
-                            List[
+                            list[
                                 IsinCondition[ConditionSubjectT, IsinConditionElementT]
                             ],
                             type_to_conditions.get(IsinCondition, []),
                         )
                     ),
                     tuple(
                         cast(
-                            List[HierarchyIsinCondition],
+                            list[HierarchyIsinCondition],
                             type_to_conditions.get(HierarchyIsinCondition, []),
                         )
                     ),
                 )
             )
 
         return tuple(decombined_conditions)
```

## atoti_core/deprecated.py

```diff
@@ -1,17 +1,16 @@
 from warnings import warn
 
 
-def deprecated(message: str) -> None:
+def deprecated(message: str, /) -> None:
     """Raise a warning to indicate that something is deprecated.
 
     Args:
         message: Explanation of the deprecation.
     """
-
     # Using FutureWarning instead of DeprecationWarning because
     # DeprecationWarnings are hidden by default in IPython.
     # pandas does the same.
     # See:
     #  - https://docs.python.org/3/library/warnings.html#warning-categories
     #  - https://github.com/ipython/ipython/issues/8478
     warn(message, category=FutureWarning, stacklevel=2)
```

## atoti_core/doc.py

```diff
@@ -1,10 +1,13 @@
+from __future__ import annotations
+
+from collections.abc import Callable
 from functools import wraps
 from textwrap import dedent
-from typing import Any, Callable, List, TypeVar, Union, cast
+from typing import Any, TypeVar, Union, cast
 
 from typing_extensions import ParamSpec
 
 _P = ParamSpec("_P")
 _R = TypeVar("_R")
 
 
@@ -17,15 +20,15 @@
 
     def decorator(function: Callable[_P, _R]) -> Callable[_P, _R]:
         @wraps(function)
         def wrapper(*args: _P.args, **kwargs: _P.kwargs) -> Any:
             return function(*args, **kwargs)
 
         # Collecting docstring and docstring templates
-        docstring_components: List[Union[str, Callable[..., Any]]] = []
+        docstring_components: list[Union[str, Callable[..., Any]]] = []
 
         if function.__doc__:
             docstring_components.append(dedent(function.__doc__))
 
         for arg in cast(Any, args):
             if hasattr(arg, "_docstring_components"):
                 docstring_components.extend(
@@ -43,12 +46,12 @@
                 arg.format(**kwargs)
                 if isinstance(arg, str)
                 else dedent(arg.__doc__ or "")
                 for arg in docstring_components
             ]
         )
 
-        wrapper._docstring_components = docstring_components  # type: ignore
+        wrapper._docstring_components = docstring_components  # type: ignore[attr-defined] # pyright: ignore[reportFunctionMemberAccess]
 
         return wrapper
 
     return decorator
```

## atoti_core/empty_mapping.py

```diff
@@ -1,5 +1,6 @@
-from typing import Any, Mapping
+from collections.abc import Mapping
+from typing import Any
 
 from .immutable_mapping import ImmutableMapping
 
 EMPTY_MAPPING: Mapping[Any, Any] = ImmutableMapping({})
```

## atoti_core/fetch_json.py

```diff
@@ -1,13 +1,14 @@
 import json
+from collections.abc import Callable, Mapping
 from dataclasses import dataclass
 from datetime import timedelta
 from http.client import HTTPResponse
 from mimetypes import types_map
-from typing import Callable, Literal, Mapping, Optional, Union, overload
+from typing import Literal, Optional, Union, overload
 from urllib.request import OpenerDirector, Request, urlopen
 
 from .empty_mapping import EMPTY_MAPPING
 from .http_method import HttpMethod
 from .keyword_only_dataclass import keyword_only_dataclass
 
 _CONTENT_TYPE_HEADER_NAME = "content-type"
@@ -97,17 +98,15 @@
     headers = {_CONTENT_TYPE_HEADER_NAME: JSON_CONTENT_TYPE, **headers}
     request = Request(url, data=data, headers=headers, method=method)
     timeout_in_seconds = timeout.total_seconds() if timeout else None
 
     response: HTTPResponse = (
         opener_director.open(request, timeout=timeout_in_seconds)
         if opener_director
-        else urlopen(  # nosec: B310 # pylint: disable=consider-using-with
-            request, timeout=timeout_in_seconds
-        )
+        else urlopen(request, timeout=timeout_in_seconds)  # noqa: S310
     )
 
     if raw:
         return response
 
     with response:
         response_content_type = response.headers.get_content_type()
```

## atoti_core/find_corresponding_top_level_variable_name.py

```diff
@@ -1,23 +1,22 @@
-from typing import Any, Mapping, Optional, cast
+from collections.abc import Mapping
+from typing import Any, Optional, cast
 
-from .running_in_ipython import running_in_ipython
+from .get_ipython import get_ipython
 
 
 def find_corresponding_top_level_variable_name(
     value: Any,
 ) -> Optional[str]:
-    if not running_in_ipython():
-        return None
+    ipython = get_ipython()
 
-    from IPython import (  # pylint: disable=undeclared-dependency, nested-import
-        get_ipython,
-    )
+    if ipython is None:
+        return None
 
-    top_level_variables: Mapping[str, Any] = cast(Any, get_ipython()).user_ns
+    top_level_variables: Mapping[str, Any] = cast(Any, ipython).user_ns
 
     for variable_name, variable_value in top_level_variables.items():
         is_regular_variable = not variable_name.startswith("_")
         if is_regular_variable and variable_value is value:
             return variable_name
 
     return None
```

## atoti_core/get_literal_args.py

```diff
@@ -1,54 +1,51 @@
 from enum import Enum
 
 # `typing.get_args()` is used to implement the preferred alternative.
 from typing import (  # pylint: disable=preferred-function
     Any,
-    List,
     Literal,
     Optional,
-    Tuple,
-    Type,
     Union,
     get_args,
 )
 
 # From https://www.python.org/dev/peps/pep-0586/#legal-parameters-for-literal-at-type-check-time
 _LiteralArg = Optional[Union[bool, bytes, Enum, int, str]]
 """Type of a value that can be used as :class:`typing.Literal` args."""
 
-LITERAL_ARG_TYPES: Tuple[Type[_LiteralArg], ...] = (
+LITERAL_ARG_TYPES: tuple[type[_LiteralArg], ...] = (
     bool,
     bytes,
     Enum,
     int,
     type(None),
     str,
 )
 """Instances of these types can be used as :class:`typing.Literal` args."""
 
 
 # Inspired from https://github.com/agronholm/typeguard/blob/de6ab051309ba74a0a27840f8172697c8778ae4f/src/typeguard/__init__.py#L625-L642.
-def get_literal_args(any_type: Any, /) -> Tuple[_LiteralArg, ...]:
+def get_literal_args(any_type: Any, /) -> tuple[_LiteralArg, ...]:
     """Extract all the top-level :class:`typing.Literal` args from the passed type.
 
     This function exists because :func:`typing.get_args` does not support nested :class:`typing.Literal`s.
 
     *any_type* cannot be an unresolved type, use :func:`typing.get_type_hints` to handle `postponed evaluation of annotations <https://www.python.org/dev/peps/pep-0563/>`__.
 
     The returned tuple is guaranteed to contain unique values.
     """
     if getattr(any_type, "__origin__", None) not in {
         Literal,
         Union,
     }:
         # Ignore nested types.
-        return tuple()
+        return ()
 
-    literal_args: List[_LiteralArg] = []
+    literal_args: list[_LiteralArg] = []
 
     def add_arg(new_arg: Any, /) -> None:
         # Using `any` with `is` rather than just `new_arg in literal_args` to distinguish different booleans with other truthy/falsy values.
         # See https://docs.python.org/3.9/reference/expressions.html#membership-test-operations.
         if any(new_arg is arg for arg in literal_args):
             return
         literal_args.append(new_arg)
```

## atoti_core/hierarchy_coordinates.py

```diff
@@ -1,17 +1,16 @@
 from dataclasses import dataclass
-from typing import Tuple
 
 from .coordinates import Coordinates
 
 
 @dataclass(frozen=True)
 class HierarchyCoordinates(Coordinates):  # pylint: disable=keyword-only-dataclass
     dimension_name: str
     hierarchy_name: str
 
     @property
-    def key(self) -> Tuple[str, str]:
+    def key(self) -> tuple[str, str]:
         return self.dimension_name, self.hierarchy_name
 
     def __repr__(self) -> str:
         return f"h[{self.key}]"
```

## atoti_core/hierarchy_isin_condition.py

```diff
@@ -1,45 +1,91 @@
+from collections.abc import Iterable
 from dataclasses import dataclass
-from typing import FrozenSet, Literal, NoReturn, Tuple, Type
+from functools import cached_property
+from typing import Literal, NoReturn, Optional, Union
 
 from .combine_conditions import combine_conditions
 from .constant import Constant
 from .coordinates import Coordinates
 from .hierarchy_coordinates import HierarchyCoordinates
-from .keyword_only_dataclass import keyword_only_dataclass
 from .level_coordinates import LevelCoordinates
 from .operation import ComparisonCondition, Condition, ConditionCombinationOperatorBound
 
 
-@keyword_only_dataclass
 @dataclass(frozen=True)
 class HierarchyIsinCondition(
     Condition[HierarchyCoordinates, Literal["isin"], Constant, None]
 ):
     subject: HierarchyCoordinates
-    level_names: Tuple[str, ...]
-    member_paths: Tuple[Tuple[Constant, ...], ...]
+    level_names: tuple[str, ...]
+    _member_paths: frozenset[tuple[Constant, ...]]
 
-    def __post_init__(self) -> None:
-        if not self.member_paths:
+    def __init__(
+        self,
+        *,
+        subject: HierarchyCoordinates,
+        level_names: tuple[str, ...],
+        member_paths: Iterable[tuple[Constant, ...]],
+    ) -> None:
+        if not member_paths:
             raise ValueError(
                 "No passed member paths, the condition will always evaluate to `False`."
             )
 
-        for member_path in self.member_paths:
+        for member_path in member_paths:
             if not member_path:
                 raise ValueError(
                     "Passed one empty member path: it is unnecessary since it will always evaluate to `False`."
                 )
 
-            if len(member_path) > len(self.level_names):
+            if len(member_path) > len(level_names):
                 raise ValueError(
-                    f"Member path `{tuple(member.value for member in member_path)}` contains more than {len(self.level_names)} elements which is the number of levels of `{repr(self.subject)}`."
+                    f"Member path `{tuple(member.value for member in member_path)}` contains more than {len(level_names)} elements which is the number of levels of `{subject!r}`."
                 )
 
+        self.__dict__["subject"] = subject
+        self.__dict__["level_names"] = level_names
+        self.__dict__["_member_paths"] = frozenset(member_paths)
+
+    @cached_property
+    def member_paths(self) -> tuple[tuple[Constant, ...], ...]:
+        # The member paths are sorted to ensure predictability.
+        return tuple(sorted(self._member_paths))
+
+    @cached_property
+    def normalized(
+        self,
+    ) -> Condition[
+        Union[HierarchyCoordinates, LevelCoordinates],
+        Literal["eq", "isin"],
+        Constant,
+        Optional[Literal["and"]],
+    ]:
+        if len(self.member_paths) != 1:
+            return self
+
+        return combine_conditions(
+            (
+                [
+                    ComparisonCondition(
+                        subject=LevelCoordinates(
+                            self.subject.dimension_name,
+                            self.subject.hierarchy_name,
+                            level_name,
+                        ),
+                        operator="eq",
+                        target=member,
+                    )
+                    for level_name, member in zip(
+                        self.level_names, next(iter(self.member_paths))
+                    )
+                ],
+            )
+        )
+
     @property
     def combined_comparison_condition(
         self,
     ) -> Condition[
         LevelCoordinates, Literal["eq"], Constant, ConditionCombinationOperatorBound
     ]:
         return combine_conditions(
@@ -57,18 +103,18 @@
                     for level_name, member in zip(self.level_names, member_path)
                 ]
                 for member_path in self.member_paths
             ]
         )
 
     @property
-    def _coordinates_classes(self) -> FrozenSet[Type[Coordinates]]:
+    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
         return frozenset([type(self.subject)])
 
     def __invert__(
         self,
     ) -> NoReturn:
         raise RuntimeError(f"A `{type(self).__name__}` cannot be inverted.")
         # It can actually be done using `~hierarchy_isin_condition.combined_comparison_condition` but this changes the type of `subject` which breaks the contract of `Condition.__invert__()`.
 
     def __repr__(self) -> str:
-        return f"{repr(self.subject)}.isin{repr(tuple(tuple(member.value for member in member_path) for member_path in self.member_paths))}"
+        return f"{self.subject!r}.isin{tuple(tuple(member.value for member in member_path) for member_path in self.member_paths)!r}"
```

## atoti_core/hierarchy_key.py

```diff
@@ -1,3 +1,3 @@
-from typing import Tuple, Union
+from typing import Union
 
-HierarchyKey = Union[str, Tuple[str, str]]
+HierarchyKey = Union[str, tuple[str, str]]
```

## atoti_core/immutable_mapping.py

```diff
@@ -1,8 +1,9 @@
-from typing import Iterator, Mapping, TypeVar
+from collections.abc import Iterator, Mapping
+from typing import TypeVar
 
 from .ipython_key_completions import (
     IPythonKeyCompletions,
     get_ipython_key_completions_for_mapping,
 )
 
 _Key = TypeVar("_Key")
@@ -24,8 +25,8 @@
     def __len__(self) -> int:
         return len(self._data)
 
     def __repr__(self) -> str:
         return repr(self._data)
 
     def _ipython_key_completions_(self) -> IPythonKeyCompletions:
-        return get_ipython_key_completions_for_mapping(self)  # type: ignore
+        return get_ipython_key_completions_for_mapping(self)  # type: ignore[arg-type] # pyright: ignore[reportGeneralTypeIssues]
```

## atoti_core/ipython_key_completions.py

```diff
@@ -1,10 +1,11 @@
-from typing import Any, List, Mapping, Tuple, Union
+from collections.abc import Mapping
+from typing import Any, Union
 
-IPythonKeyCompletions = List[Union[str, Tuple[str, str]]]
+IPythonKeyCompletions = list[Union[str, tuple[str, str]]]
 
 
 def get_ipython_key_completions_for_mapping(
-    mapping: Union[Mapping[str, Any], Mapping[Tuple[str, ...], Any]]
+    mapping: Union[Mapping[str, Any], Mapping[tuple[str, ...], Any]]
 ) -> IPythonKeyCompletions:
     """Return IPython key completions for mapping."""
     return sorted({key if isinstance(key, str) else key[-1] for key in mapping})
```

## atoti_core/isin_condition.py

```diff
@@ -1,46 +1,75 @@
+from collections.abc import Iterable
 from dataclasses import dataclass
-from typing import FrozenSet, Literal, Optional, Tuple, Type, TypeVar
+from functools import cached_property
+from typing import Literal, Optional, TypeVar
 
 from .combine_conditions import combine_conditions
 from .constant import Constant
 from .coordinates import Coordinates
 from .hierarchy_coordinates import HierarchyCoordinates
-from .keyword_only_dataclass import keyword_only_dataclass
 from .operation import (
     ComparisonCondition,
     Condition,
     ConditionCombinationOperatorBound,
     ConditionComparisonOperatorBound,
     ConditionSubjectT,
 )
 
 IsinConditionElementT = TypeVar(
     "IsinConditionElementT", bound=Optional[Constant], covariant=True
 )
 
 
-@keyword_only_dataclass
 @dataclass(frozen=True)
 class IsinCondition(
     Condition[ConditionSubjectT, Literal["isin"], IsinConditionElementT, None]
 ):
     subject: ConditionSubjectT
-    elements: Tuple[IsinConditionElementT, ...]
+    _elements: frozenset[IsinConditionElementT]
 
-    def __post_init__(self) -> None:
+    def __init__(
+        self, *, subject: ConditionSubjectT, elements: Iterable[IsinConditionElementT]
+    ) -> None:
         assert not isinstance(
-            self.subject, HierarchyCoordinates
+            subject, HierarchyCoordinates
         ), "Conditions on hierarchies must use `HierarchyIsinCondition`."
 
-        if not self.elements:
+        if not elements:
             raise ValueError(
                 "No passed elements, the condition will always evaluate to `False`."
             )
 
+        self.__dict__["subject"] = subject
+        self.__dict__["_elements"] = frozenset(elements)
+
+    @cached_property
+    def elements(self) -> tuple[IsinConditionElementT, ...]:
+        # The elements are sorted to ensure predictability.
+        return (
+            # Collections containing `None` cannot be sorted.
+            # If `None` is in the elements it's added at the head of the tuple.
+            # The remaining non-`None` elements are sorted and inserted after.
+            *([None] if None in self._elements else []),  # type: ignore[arg-type] # pyright: ignore[reportGeneralTypeIssues]
+            *sorted(element for element in self._elements if element is not None),  # type: ignore[type-var]
+        )
+
+    @cached_property
+    def normalized(
+        self,
+    ) -> Condition[
+        ConditionSubjectT, Literal["eq", "isin"], IsinConditionElementT, None
+    ]:
+        if len(self.elements) != 1:
+            return self
+
+        return ComparisonCondition(
+            subject=self.subject, operator="eq", target=self.elements[0]
+        )
+
     @property
     def combined_comparison_condition(
         self,
     ) -> Condition[
         ConditionSubjectT, Literal["eq"], IsinConditionElementT, Optional[Literal["or"]]
     ]:
         return combine_conditions(
@@ -51,25 +80,25 @@
                     ),
                 )
                 for element in self.elements
             ]
         )
 
     @property
-    def _coordinates_classes(self) -> FrozenSet[Type[Coordinates]]:
+    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
         return self._get_coordinates_classes(self.subject)
 
     def __invert__(
         self,
     ) -> Condition[
         ConditionSubjectT,
         ConditionComparisonOperatorBound,
         IsinConditionElementT,
         ConditionCombinationOperatorBound,
     ]:
         return ~self.combined_comparison_condition
 
     def __repr__(self) -> str:
-        return f"{repr(self.subject)}.isin{repr(tuple(element.value if isinstance(element, Constant) else element for element in self.elements))}"
+        return f"{self.subject!r}.isin{tuple(element.value if isinstance(element, Constant) else element for element in self.elements)!r}"
 
 
 IsinConditionBound = IsinCondition[Coordinates, Optional[Constant]]
```

## atoti_core/keyword_only_dataclass.py

```diff
@@ -1,15 +1,15 @@
 from dataclasses import is_dataclass
 from functools import wraps
-from typing import Any, Type, TypeVar
+from typing import Any, TypeVar
 
 _T = TypeVar("_T")
 
 
-def keyword_only_dataclass(cls: Type[_T]) -> Type[_T]:
+def keyword_only_dataclass(cls: type[_T]) -> type[_T]:
     """Decorate a dataclass to force its construction to be done with keyword-only parameters.
 
     Replace with func:`dataclasses.dataclass`'s *kw_only* when bumping minimum supported version of Python to 3.10.
     """
     assert is_dataclass(cls), f"Expected a dataclass but received {cls}."
     init = cls.__init__
 
@@ -18,10 +18,11 @@
         self: _T, *args: Any, **kwargs: Any
     ) -> None:
         assert (
             len(args) == 0
         ), f"{cls.__name__} expects keyword-only arguments but the following positional arguments were passed: {args}."
         init(self, **kwargs)
 
-    setattr(cls, "__init__", init_enforcing_keyword_only_arguments)
+    setattr(cls, "__init__", init_enforcing_keyword_only_arguments)  # noqa: B010
 
-    return cls
+    # Mypy reports `got "Type[DataclassInstance]", expected "Type[_T]"`.
+    return cls  # type: ignore[return-value]
```

## atoti_core/level_coordinates.py

```diff
@@ -1,23 +1,22 @@
 from dataclasses import dataclass
 from functools import cached_property
-from typing import Tuple
 
 from .coordinates import Coordinates
 from .hierarchy_coordinates import HierarchyCoordinates
 
 
 @dataclass(frozen=True)
 class LevelCoordinates(Coordinates):  # pylint: disable=keyword-only-dataclass
     dimension_name: str
     hierarchy_name: str
     level_name: str
 
     @property
-    def key(self) -> Tuple[str, str, str]:
+    def key(self) -> tuple[str, str, str]:
         return self.dimension_name, self.hierarchy_name, self.level_name
 
     @cached_property
     def hierarchy_coordinates(self) -> HierarchyCoordinates:
         return HierarchyCoordinates(self.dimension_name, self.hierarchy_name)
 
     def __repr__(self) -> str:
```

## atoti_core/level_key.py

```diff
@@ -1,7 +1,7 @@
-from typing import Tuple, Union
+from typing import Union
 
 LevelKey = Union[
     str,
-    Tuple[str, str],
-    Tuple[str, str, str],
+    tuple[str, str],
+    tuple[str, str, str],
 ]
```

## atoti_core/measure_coordinates.py

```diff
@@ -1,16 +1,15 @@
 from dataclasses import dataclass
-from typing import Tuple
 
 from .coordinates import Coordinates
 
 
 @dataclass(frozen=True)
 class MeasureCoordinates(Coordinates):  # pylint: disable=keyword-only-dataclass
     measure_name: str
 
     @property
-    def key(self) -> Tuple[str]:
+    def key(self) -> tuple[str]:
         return (self.measure_name,)
 
     def __repr__(self) -> str:
         return f"""m["{self.measure_name}"]"""
```

## atoti_core/operand_convertible_with_coordinates.py

```diff
@@ -1,12 +1,11 @@
 from __future__ import annotations
 
-from typing import Literal, Optional, Union, overload
+from typing import Literal, Union, overload
 
-from ._deprecated_comparison_with_none import deprecated_comparison_with_none
 from ._other_coordinates import OtherCoordinatesT
 from .constant import Constant, ConstantValue
 from .has_coordinates import CoordinatesT, HasCoordinates
 from .operation import (
     ComparisonCondition,
     Condition,
     OperandConvertible,
@@ -21,15 +20,15 @@
 ):
     """This class overrides `OperandConvertible`'s `Condition`-creating methods so that the type of the returned `Condition`'s `subject` is narrowed down to an instance of `Coordinates` instead of a `Union[Coordinates, Operation]`.
 
     The returned `Condition`'s `target` is also kept as narrow as possible thanks to `@overload`s.
     """
 
     # Without this, the classes inheriting from this class are considered unhashable.
-    def __hash__(self) -> int:  # pylint: disable=useless-super-delegation
+    def __hash__(self) -> int:
         return super().__hash__()
 
     def isnull(
         self,
     ) -> Condition[CoordinatesT, Literal["eq"], None, None]:
         return ComparisonCondition(
             subject=self._operation_operand,
@@ -40,67 +39,57 @@
     @property
     def _operation_operand(self) -> CoordinatesT:
         return self._coordinates
 
     # The signature is not compatible with `object.__eq__()` on purpose.
     @overload  # type: ignore[override]
     def __eq__(
-        self, other: None, /
-    ) -> Condition[CoordinatesT, Literal["eq"], None, None]:
-        ...
-
-    @overload
-    def __eq__(
         self, other: ConstantValue, /
     ) -> Condition[CoordinatesT, Literal["eq"], Constant, None]:
         ...
 
     @overload
     def __eq__(
         self, other: HasCoordinates[OtherCoordinatesT], /
-    ) -> Condition[CoordinatesT, Literal["eq"], OtherCoordinatesT, None,]:
+    ) -> Condition[CoordinatesT, Literal["eq"], OtherCoordinatesT, None]:
         ...
 
     @overload
     def __eq__(
         self,
-        other: Optional[
-            Union[
-                ConstantValue,
-                HasCoordinates[OtherCoordinatesT],
-                Operation[OtherCoordinatesT],
-            ]
+        other: Union[
+            ConstantValue,
+            HasCoordinates[OtherCoordinatesT],
+            Operation[OtherCoordinatesT],
         ],
         /,
     ) -> Condition[
         CoordinatesT,
         Literal["eq"],
-        Optional[Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]]],
+        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
         None,
     ]:
         ...
 
     # The signature is not compatible with `object.__eq__()` on purpose.
     def __eq__(  # pyright: ignore[reportIncompatibleMethodOverride]
         self,
-        other: Optional[
-            Union[
-                ConstantValue,
-                HasCoordinates[OtherCoordinatesT],
-                Operation[OtherCoordinatesT],
-            ]
+        other: Union[
+            ConstantValue,
+            HasCoordinates[OtherCoordinatesT],
+            Operation[OtherCoordinatesT],
         ],
         /,
     ) -> Condition[
         CoordinatesT,
         Literal["eq"],
-        Optional[Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]]],
+        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
         None,
     ]:
-        deprecated_comparison_with_none(other)
+        assert other is not None, "Use `isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             target=convert_to_operand(other),
             operator="eq",
         )
 
     @overload
@@ -108,15 +97,15 @@
         self, other: ConstantValue, /
     ) -> Condition[CoordinatesT, Literal["ge"], Constant, None]:
         ...
 
     @overload
     def __ge__(
         self, other: HasCoordinates[OtherCoordinatesT], /
-    ) -> Condition[CoordinatesT, Literal["ge"], OtherCoordinatesT, None,]:
+    ) -> Condition[CoordinatesT, Literal["ge"], OtherCoordinatesT, None]:
         ...
 
     @overload
     def __ge__(
         self,
         other: Union[
             ConstantValue,
@@ -157,15 +146,15 @@
         self, other: ConstantValue, /
     ) -> Condition[CoordinatesT, Literal["gt"], Constant, None]:
         ...
 
     @overload
     def __gt__(
         self, other: HasCoordinates[OtherCoordinatesT], /
-    ) -> Condition[CoordinatesT, Literal["gt"], OtherCoordinatesT, None,]:
+    ) -> Condition[CoordinatesT, Literal["gt"], OtherCoordinatesT, None]:
         ...
 
     @overload
     def __gt__(
         self,
         other: Union[
             ConstantValue,
@@ -206,15 +195,15 @@
         self, other: ConstantValue, /
     ) -> Condition[CoordinatesT, Literal["le"], Constant, None]:
         ...
 
     @overload
     def __le__(
         self, other: HasCoordinates[OtherCoordinatesT], /
-    ) -> Condition[CoordinatesT, Literal["le"], OtherCoordinatesT, None,]:
+    ) -> Condition[CoordinatesT, Literal["le"], OtherCoordinatesT, None]:
         ...
 
     @overload
     def __le__(
         self,
         other: Union[
             ConstantValue,
@@ -255,15 +244,15 @@
         self, other: ConstantValue, /
     ) -> Condition[CoordinatesT, Literal["lt"], Constant, None]:
         ...
 
     @overload
     def __lt__(
         self, other: HasCoordinates[OtherCoordinatesT], /
-    ) -> Condition[CoordinatesT, Literal["lt"], OtherCoordinatesT, None,]:
+    ) -> Condition[CoordinatesT, Literal["lt"], OtherCoordinatesT, None]:
         ...
 
     @overload
     def __lt__(
         self,
         other: Union[
             ConstantValue,
@@ -298,65 +287,55 @@
             operator="lt",
             target=convert_to_operand(other),
         )
 
     # The signature is not compatible with `object.__ne__()` on purpose.
     @overload  # type: ignore[override]
     def __ne__(
-        self, other: None, /
-    ) -> Condition[CoordinatesT, Literal["ne"], None, None]:
-        ...
-
-    @overload
-    def __ne__(
         self, other: ConstantValue, /
     ) -> Condition[CoordinatesT, Literal["ne"], Constant, None]:
         ...
 
     @overload
     def __ne__(
         self, other: HasCoordinates[OtherCoordinatesT], /
-    ) -> Condition[CoordinatesT, Literal["ne"], OtherCoordinatesT, None,]:
+    ) -> Condition[CoordinatesT, Literal["ne"], OtherCoordinatesT, None]:
         ...
 
     @overload
     def __ne__(
         self,
-        other: Optional[
-            Union[
-                ConstantValue,
-                HasCoordinates[OtherCoordinatesT],
-                Operation[OtherCoordinatesT],
-            ]
+        other: Union[
+            ConstantValue,
+            HasCoordinates[OtherCoordinatesT],
+            Operation[OtherCoordinatesT],
         ],
         /,
     ) -> Condition[
         CoordinatesT,
         Literal["ne"],
-        Optional[Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]]],
+        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
         None,
     ]:
         ...
 
     # The signature is not compatible with `object.__ne__()` on purpose.
     def __ne__(  # pyright: ignore[reportIncompatibleMethodOverride]
         self,
-        other: Optional[
-            Union[
-                ConstantValue,
-                HasCoordinates[OtherCoordinatesT],
-                Operation[OtherCoordinatesT],
-            ]
+        other: Union[
+            ConstantValue,
+            HasCoordinates[OtherCoordinatesT],
+            Operation[OtherCoordinatesT],
         ],
         /,
     ) -> Condition[
         CoordinatesT,
         Literal["ne"],
-        Optional[Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]]],
+        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
         None,
     ]:
-        deprecated_comparison_with_none(other, invert=True)
+        assert other is not None, "Use `~isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ne",
             target=convert_to_operand(other),
         )
```

## atoti_core/operation.py

```diff
@@ -1,28 +1,24 @@
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
+from collections.abc import Mapping
 from dataclasses import dataclass
 from functools import cached_property
 from itertools import chain
 from typing import (
-    FrozenSet,
     Generic,
     Literal,
-    Mapping,
     NoReturn,
     Optional,
-    Tuple,
-    Type,
     TypeVar,
     Union,
     overload,
 )
 
-from ._deprecated_comparison_with_none import deprecated_comparison_with_none
 from ._other_coordinates import OtherCoordinatesT
 from .arithmetic_operator import ArithmeticOperator
 from .boolean_operator import BooleanOperator
 from .comparison_operator import OPERATOR_TO_INVERSE_OPERATOR, ComparisonOperator
 from .constant import Constant, ConstantValue
 from .coordinates import Coordinates
 from .data_type import DataType
@@ -110,15 +106,15 @@
         return id(self)
 
     def __getitem__(
         self,
         index: Union[
             slice,
             int,
-            Tuple[int, ...],
+            tuple[int, ...],
             HasCoordinates[OtherCoordinatesT],
             Operation[OtherCoordinatesT],
         ],
         /,
     ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
         return IndexingOperation(
             operand=self._operation_operand,
@@ -128,31 +124,29 @@
                 index
                 if isinstance(index, (slice, Operation))
                 else Constant(list(index) if isinstance(index, tuple) else index)
             ),
         )
 
     # The signature is not compatible with `object.__eq__()` on purpose.
-    def __eq__(  # type: ignore[override]
+    def __eq__(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
         self,
-        other: Optional[
-            Union[
-                ConstantValue,
-                HasCoordinates[OtherCoordinatesT],
-                Operation[OtherCoordinatesT],
-            ]
+        other: Union[
+            ConstantValue,
+            HasCoordinates[OtherCoordinatesT],
+            Operation[OtherCoordinatesT],
         ],
         /,
     ) -> Condition[
         NonConstantNonConditionOperand[CoordinatesT],
         Literal["eq"],
-        Optional[Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]]],
+        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
         None,
     ]:
-        deprecated_comparison_with_none(other)
+        assert other is not None, "Use `isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             target=convert_to_operand(other),
             operator="eq",
         )
 
     def __ge__(
@@ -232,31 +226,29 @@
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="lt",
             target=convert_to_operand(other),
         )
 
     # The signature is not compatible with `object.__ne__()` on purpose.
-    def __ne__(  # type: ignore[override]
+    def __ne__(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
         self,
-        other: Optional[
-            Union[
-                ConstantValue,
-                HasCoordinates[OtherCoordinatesT],
-                Operation[OtherCoordinatesT],
-            ]
+        other: Union[
+            ConstantValue,
+            HasCoordinates[OtherCoordinatesT],
+            Operation[OtherCoordinatesT],
         ],
         /,
     ) -> Condition[
         NonConstantNonConditionOperand[CoordinatesT],
         Literal["ne"],
-        Optional[Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]]],
+        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
         None,
     ]:
-        deprecated_comparison_with_none(other, invert=True)
+        assert other is not None, "Use `~isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ne",
             target=convert_to_operand(other),
         )
 
     def __add__(
@@ -461,37 +453,36 @@
         )
 
 
 OperandConvertibleBound = OperandConvertible[Coordinates]
 
 
 class _BaseOperation(ABC):
-    """
-    An operation is made out of one or more operands and possibly some other primitive attributes such as strings or numbers.
+    """An operation is made out of one or more operands and possibly some other primitive attributes such as strings or numbers.
 
     To ensure that operations are immutable and serializable, operands must never be of type `ConstantValue` or `HasCoordinates`.
     These must be converted to `Constant` and `Coordinates` instead.
 
     This base class' sole purpose is to provide a shared fundation for `Condition` and `Operation`.
     All classes inheriting from `_BaseOperation` must inherit from one of these two classes.
     As such, this class must remain private and not referenced outside this file.
     """
 
     @property
     @abstractmethod
-    def _coordinates_classes(self) -> FrozenSet[Type[Coordinates]]:
+    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
         """The set of classes of the coordinates used in this operation.
 
         This is used, for instance, to detect whether an operation is purely column-based and could thus be the input of a UDAF.
         """
 
     @classmethod
     def _get_coordinates_classes(
         cls, operand: Optional[Operand[Coordinates]], /
-    ) -> FrozenSet[Type[Coordinates]]:
+    ) -> frozenset[type[Coordinates]]:
         if operand is None or isinstance(operand, Constant):
             return frozenset()
         if isinstance(operand, Coordinates):
             return frozenset([type(operand)])
         return operand._coordinates_classes
 
 
@@ -647,15 +638,15 @@
     Condition[
         ConditionSubjectT,
         ConditionComparisonOperatorT,
         ConditionTargetT,
         ConditionCombinationOperatorT,
     ]
 ):
-    sub_conditions: Tuple[
+    sub_conditions: tuple[
         Condition[
             ConditionSubjectT,
             ConditionComparisonOperatorT,
             ConditionTargetT,
             ConditionCombinationOperatorT,
         ],
         Condition[
@@ -665,15 +656,15 @@
             ConditionCombinationOperatorT,
         ],
     ]
     operator: ConditionCombinationOperatorT
 
     def __post_init__(self) -> None:
         # Access the `boolean_operator` property to trigger the validation process.
-        self.boolean_operator  # pylint: disable=pointless-statement
+        assert self.boolean_operator
 
     @cached_property
     def boolean_operator(self) -> BooleanOperator:
         operator: Optional[BooleanOperator] = self.operator
 
         assert operator is not None, "Missing combination operator."
 
@@ -689,26 +680,26 @@
     ]:
         return CombinedCondition(
             sub_conditions=(~self.sub_conditions[0], ~self.sub_conditions[1]),
             operator="or" if self.operator == "and" else "and",
         )
 
     @property
-    def _coordinates_classes(self) -> FrozenSet[Type[Coordinates]]:
+    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
         return frozenset(
             chain(
                 *(
                     sub_condition._coordinates_classes
                     for sub_condition in self.sub_conditions
                 )
             )
         )
 
     def __repr__(self) -> str:
-        return f"({repr(self.sub_conditions[0])}) {'&' if self.operator == 'and' else '|'} ({repr(self.sub_conditions[1])})"
+        return f"({self.sub_conditions[0]!r}) {'&' if self.operator == 'and' else '|'} ({self.sub_conditions[1]!r})"
 
 
 _ComparisonOperatorT = TypeVar(
     "_ComparisonOperatorT",
     bound=ComparisonOperator,
     covariant=True,
 )
@@ -739,15 +730,15 @@
 
         if self.target is None and self.operator not in {"eq", "ne"}:
             raise ValueError(
                 f"Expected `{self.target}` to be compared with an equality operator but got operator `{self.operator}`."
             )
 
     @property
-    def _coordinates_classes(self) -> FrozenSet[Type[Coordinates]]:
+    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
         return frozenset(
             chain(
                 *(
                     self._get_coordinates_classes(operand)
                     for operand in [self.subject, self.target]
                 )
             )
@@ -759,15 +750,15 @@
         return ComparisonCondition(
             subject=self.subject,
             operator=OPERATOR_TO_INVERSE_OPERATOR[self.operator],
             target=self.target,
         )
 
     def __repr__(self) -> str:
-        return f"{repr(self.subject)} {_COMPARISON_OPERATOR_TO_SYMBOL[self.operator]} {repr(self.target.value if isinstance(self.target, Constant) else self.target)}"
+        return f"{self.subject!r} {_COMPARISON_OPERATOR_TO_SYMBOL[self.operator]} {self.target.value if isinstance(self.target, Constant) else self.target!r}"
 
 
 _ARITHMETIC_OPERATOR_TO_SYMBOL: Mapping[ArithmeticOperator, str] = {
     "add": "+",
     "floordiv": "//",
     "mod": "%",
     "mul": "*",
@@ -776,19 +767,19 @@
     "truediv": "/",
 }
 
 
 @keyword_only_dataclass
 @dataclass(eq=False, frozen=True)
 class ArithmeticOperation(Operation[CoordinatesT]):
-    operands: Tuple[NonConditionOperand[CoordinatesT], ...]
+    operands: tuple[NonConditionOperand[CoordinatesT], ...]
     operator: ArithmeticOperator
 
     @property
-    def _coordinates_classes(self) -> FrozenSet[Type[Coordinates]]:
+    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
         return frozenset(
             chain(
                 *(self._get_coordinates_classes(operand) for operand in self.operands)
             )
         )
 
     def __repr__(self) -> str:
@@ -818,34 +809,34 @@
         Constant,
         slice,
         CoordinatesT,
         Operation[CoordinatesT],
     ]
 
     def __post_init__(self) -> None:
-        allowed_data_types: Tuple[DataType, ...] = ("int", "int[]", "long", "long[]")
+        allowed_data_types: tuple[DataType, ...] = ("int", "int[]", "long", "long[]")
 
         if (
             isinstance(self.index, Constant)
             and self.index.data_type not in allowed_data_types
         ):
             raise TypeError(
                 f"Expected constant index's type to be one of `{allowed_data_types}` but got `{self.index.data_type}`."
             )
 
     @property
-    def _coordinates_classes(self) -> FrozenSet[Type[Coordinates]]:
+    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
         return self._get_coordinates_classes(self.operand).union(
             frozenset([])
             if isinstance(self.index, (int, tuple, slice))
             else self._get_coordinates_classes(self.index)
         )
 
     def __repr__(self) -> str:
-        return f"{repr(self.operand)}[{repr(self.index)}]"
+        return f"{self.operand!r}[{self.index!r}]"
 
 
 NonConstantNonConditionOperand = Union[CoordinatesT, Operation[CoordinatesT]]
 NonConditionOperand = Union[Constant, NonConstantNonConditionOperand[CoordinatesT]]
 
 OperandCondition = Condition[
     NonConstantNonConditionOperand[CoordinatesT],
```

## atoti_core/plugin.py

```diff
@@ -1,32 +1,24 @@
-from abc import ABC
+from collections.abc import Mapping
 from pathlib import Path
-from typing import Mapping, Optional, Union
+from typing import Optional, Union
 
 from .base_session import BaseSessionBound
 from .empty_mapping import EMPTY_MAPPING
 
 
-class Plugin(ABC):
-    def activate(self) -> None:
-        """Activate the plugin.
-
-        It can be used to monkey patch the public API to plug the real functions.
-        """
-
-    def init_session(  # pylint: disable=unused-argument
-        self, session: BaseSessionBound, /
-    ) -> None:
-        """Handle newly initialized session."""
-
+class Plugin:
     @property
     def app_extensions(self) -> Mapping[str, Union[str, Path]]:
         """The app extensions contributed by the plugin to be added to the session configuration."""
         return EMPTY_MAPPING
 
+    def init_session(self, session: BaseSessionBound, /) -> None:
+        """Handle newly initialized session."""
+
     @property
     def jar_path(self) -> Optional[Path]:
         """The path to the plugin's JAR.
 
         When not ``None``, the JAR will be added to the classpath of the Java process.
         """
         return None
```

## atoti_core/plugins.py

```diff
@@ -1,132 +1,32 @@
-import os
-import sys
-from functools import lru_cache
-from importlib.metadata import version
-from typing import Dict, Union
+from collections.abc import Mapping
 
-from .get_package_version import get_package_version
-from .missing_plugin_error import MissingPluginError
+from .get_installed_plugins import get_installed_plugins
 from .plugin import Plugin
 
-# https://packaging.python.org/guides/creating-and-discovering-plugins/#using-package-metadata
-# The selectable entry points were introduced in importlib_metadata 3.6 and Python 3.10.
-# Prior to those changes, entry_points accepted no parameters and always returned a dictionary of entry points.
-if sys.version_info < (3, 10):
-    from importlib_metadata import (  # pylint: disable=nested-import
-        EntryPoint,
-        entry_points,
-    )
-else:
-    from importlib.metadata import (  # pylint: disable=nested-import
-        EntryPoint,
-        entry_points,
-    )
-
-
-def create_plugin(entry_point: EntryPoint, /) -> Plugin:
-    plugin_class = entry_point.load()  # type: ignore[no-untyped-call]
-    plugin = plugin_class()
-
-    if not isinstance(plugin, Plugin):
-        raise TypeError(f"Unexpected plugin type: {type(plugin)}.")
-
-    return plugin
-
-
-@lru_cache
-def get_installed_plugins_entry_points() -> Dict[str, EntryPoint]:
-    main_package_version = get_package_version(__name__)
-    plugin_entry_points: Dict[str, EntryPoint] = {}
-
-    for entry_point in entry_points(group="atoti.plugins"):
-        entry_point_name: str = entry_point.name
-        plugin_package_name = f"atoti-{entry_point_name}"
-        plugin_version = version(plugin_package_name)
-
-        if plugin_version != main_package_version:
-            raise RuntimeError(
-                f"Plugin {plugin_package_name} v{plugin_version} does not have the same version as the main package (v{main_package_version})."
-            )
-
-        plugin_entry_points[entry_point_name] = entry_point
-
-    return plugin_entry_points
-
-
-class _ActivePlugins:
-    _FILTER_ENV_VAR = "_ATOTI_PLUGIN_FILTER"
-    _NO_PLUGINS_FILTER = "no-plugins"
 
+class _Plugins:
     def __init__(self) -> None:
-        self._selected: bool = False
-
-    def selected(self) -> None:
-        self._selected = True
+        self._default: dict[str, Plugin] = {}
+        self._initialized: bool = False
 
     @property
-    def filter(self) -> Union[bool, str]:
-        value = os.environ.get(_ActivePlugins._FILTER_ENV_VAR)
-        if not value:
-            return True
-        if value == _ActivePlugins._NO_PLUGINS_FILTER:
-            return False
-        return value
-
-    @filter.setter
-    def filter(self, value: Union[bool, str], /) -> None:
-        assert (
-            not self._selected
-        ), "Too late to change the plugin filter, the active plugins have already been selected."
-
-        if isinstance(value, bool):
-            if value:
-                if _ActivePlugins._FILTER_ENV_VAR in os.environ:
-                    del os.environ[_ActivePlugins._FILTER_ENV_VAR]
-            else:
-                os.environ[
-                    _ActivePlugins._FILTER_ENV_VAR
-                ] = _ActivePlugins._NO_PLUGINS_FILTER
-        else:
-            plugin_key = next(
-                plugin_key
-                for plugin_key in get_installed_plugins_entry_points()
-                if plugin_key == value
-            )
-            os.environ[_ActivePlugins._FILTER_ENV_VAR] = plugin_key
-
-
-_ACTIVE_PLUGINS = _ActivePlugins()
-
+    def default(self) -> Mapping[str, Plugin]:
+        if not self._initialized:
+            self._default.clear()
+            self._default.update(get_installed_plugins())
+            self._initialized = True
 
-def set_plugin_filter(value: Union[bool, str], /) -> None:
-    """Indicate which plugins to activate:
-
-    * ``True`` (default): all installed plugins
-    * ``False``: no plugins
-    * The plugin key of the only plugin to activate (e.g. ``"aws"``).
-    """
-    _ACTIVE_PLUGINS.filter = value
-
-
-@lru_cache
-def get_active_plugins() -> Dict[str, Plugin]:
-    _ACTIVE_PLUGINS.selected()
-    return {
-        plugin_key: create_plugin(entry_point)
-        for plugin_key, entry_point in get_installed_plugins_entry_points().items()
-        if _ACTIVE_PLUGINS.filter is True or _ACTIVE_PLUGINS.filter == plugin_key
-    }
-
-
-def activate_plugins() -> None:
-    for plugin in get_active_plugins().values():
-        plugin.activate()
+        return self._default
 
+    @default.setter
+    def default(self, value: Mapping[str, Plugin], /) -> None:
+        assert (
+            not self._initialized
+        ), "The default plugins have already been initialized, they cannot be changed anymore."
 
-def is_plugin_active(plugin_key: str) -> bool:
-    return plugin_key in get_active_plugins()
+        self._default.clear()
+        self._default.update(value)
+        self._initialized = True
 
 
-def ensure_plugin_active(plugin_key: str) -> None:
-    if not is_plugin_active(plugin_key):
-        raise MissingPluginError(plugin_key)
+PLUGINS = _Plugins()
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## atoti_core/query_doc.py

```diff
@@ -1,25 +1,25 @@
 QUERY_DOC = """Query the cube to retrieve the value of the passed measures on the given levels.
 
-        In JupyterLab with the :mod:`atoti-jupyterlab <atoti_jupyterlab>` plugin installed, query results can be converted to interactive widgets with the :guilabel:`Convert to Widget Below` action available in the command palette or by right clicking on the representation of the returned Dataframe.
+        In JupyterLab with the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin installed, query results can be converted to interactive widgets with the :guilabel:`Convert to Widget Below` action available in the command palette or by right clicking on the representation of the returned Dataframe.
 
         {args}
 """
 
 QUERY_ARGS_DOC = {
     "mode": """mode: The query mode.""",
     "pretty": """* ``"pretty"`` is best for queries returning small results:
 
                 * A :class:`~atoti_query.QueryResult` will be returned and its rows will be sorted according to the level order.""",
     "raw": """* ``"raw"`` is best for benchmarks or large exports:
 
                 * A faster and more efficient endpoint reducing the data transfer from Java to Python will be used.
                 * A classic :class:`pandas.DataFrame` will be returned.
                 * ``include_totals="True"`` will not be allowed.
-                * The :guilabel:`Convert to Widget Below` action provided by the :mod:`atoti-jupyterlab <atoti_jupyterlab>` plugin will not be available.""",
+                * The :guilabel:`Convert to Widget Below` action provided by the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin will not be available.""",
     "timeout": """timeout: The amount of time the query execution can take before aborting it.""",
     "totals": """Totals can be useful but they make the DataFrame harder to work with since its index will have some empty values.""",
     "context": """context: Context values to use when executing the query.""",
 }
 
 
 def get_query_args_doc(*, is_query_session: bool) -> str:
@@ -69,27 +69,31 @@
                         ... ]
                         >>> cube.measures["American Price"] = tt.where(
                         ...     cube.levels["Continent"] == "America",
                         ...     cube.measures["Price.SUM"],
                         ... )
                         {example_lines}
 
+                    Single equality test:
+
                     .. doctest:: query
 
                         >>> cube.query(
                         ...     m["Price.SUM"],
                         ...     levels=[l["Country"]],
                         ...     filter=l["Continent"] == "Europe",
                         ... )
                                                  Price.SUM
                         Continent Country
                         Europe    France            200.00
                                   Germany           150.00
                                   United Kingdom    120.00
 
+                    Combined equality test:
+
                     .. doctest:: query
 
                         >>> cube.query(
                         ...     m["Price.SUM"],
                         ...     levels=[l["Country"], l["Currency"]],
                         ...     filter=(
                         ...         (l["Continent"] == "Europe")
@@ -97,14 +101,16 @@
                         ...     ),
                         ... )
                                                    Price.SUM
                         Continent Country Currency
                         Europe    France  EUR         200.00
                                   Germany EUR         150.00
 
+                    Hierarchy filter:
+
                     .. doctest:: query
 
                         >>> cube.query(
                         ...     m["Price.SUM"],
                         ...     levels=[l["Country"]],
                         ...     filter=h["Geography"].isin(
                         ...         ("America",), ("Europe", "Germany")
@@ -112,14 +118,30 @@
                         ... )
                                                 Price.SUM
                         Continent Country
                         America   Mexico           270.00
                                   United states    240.00
                         Europe    Germany          150.00
 
+                    Exclusion filter:
+
+                    .. doctest:: query
+
+                        >>> cube.query(
+                        ...     m["Price.SUM"],
+                        ...     levels=[l["Country"], l["Currency"]],
+                        ...     # Equivalent to `filter=(l["Currency"] != "GBP") & (l["Currency"] != "MXN")`
+                        ...     filter=~l["Currency"].isin("GBP", "MXN"),
+                        ... )
+                                                         Price.SUM
+                        Continent Country       Currency
+                        America   United states USD         240.00
+                        Europe    France        EUR         200.00
+                                  Germany       EUR         150.00
+
             include_empty_rows: Whether to keep the rows where all the requested measures have no value.
 
                 Example:
 
                     .. doctest:: query
 
                             >>> cube.query(
```

## atoti_core/query_filter.py

```diff
@@ -5,11 +5,11 @@
 from .constant import Constant
 from .hierarchy_coordinates import HierarchyCoordinates
 from .level_coordinates import LevelCoordinates
 from .operation import Condition
 
 QueryFilter = Condition[
     Union[HierarchyCoordinates, LevelCoordinates],
-    Literal["eq", "isin"],
+    Literal["eq", "isin", "ne"],
     Constant,
     Optional[Literal["and"]],
 ]
```

## atoti_core/raise_multiple_levels_with_same_name_error.py

```diff
@@ -1,8 +1,9 @@
-from typing import Iterable, NoReturn, Union
+from collections.abc import Iterable
+from typing import NoReturn, Union
 
 from .base_hierarchy import BaseHierarchyBound
 from .hierarchy_coordinates import HierarchyCoordinates
 
 
 def raise_multiple_levels_with_same_name_error(
     level_name: str,
```

## atoti_core/repr_json.py

```diff
@@ -1,17 +1,18 @@
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
-from typing import Any, Dict, Iterable, Mapping, Optional, Tuple, Union
+from collections.abc import Iterable, Mapping
+from typing import Any, Optional, Union
 
 from typing_extensions import TypeGuard
 
 _INDENTATION = "  "
 
-ReprJson = Tuple[Any, Dict[str, Union[bool, str]]]
+ReprJson = tuple[Any, dict[str, Union[bool, str]]]
 
 
 def _json_to_html(
     obj: Union[Iterable[Any], Mapping[str, Any]], *, indent: int = 0
 ) -> str:
     return (
         _mapping_to_html(obj, indent=indent)
```

## atoti_core/str_to_bool.py

```diff
@@ -1,10 +1,11 @@
 _TRUE_VALUES = tuple(str(value).lower() for value in [True, 1])
 _FALSE_VALUES = tuple(str(value).lower() for value in [False, 0])
 
+
 # Stricter version of the deprecated `distutils.strtobool()`.
 # See https://www.python.org/dev/peps/pep-0632/.
 def str_to_bool(value: str) -> bool:
     """Convert a string to a boolean."""
     value = value.lower()
 
     if value in _TRUE_VALUES:
```

## Comparing `atoti_core-0.7.4.dist-info/METADATA` & `atoti_core-0.8.0.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 Metadata-Version: 2.1
 Name: atoti-core
-Version: 0.7.4
-Summary: Package containing private symbols shared by the other atoti packages
+Version: 0.8.0
+Summary: Package containing private symbols shared by the other Atoti packages
 Home-page: https://www.atoti.io
-Author: atoti
+Author: ActiveViam
 Author-email: dev@atoti.io
 Keywords: atoti,core
 Classifier: Development Status :: 4 - Beta
 Classifier: License :: Free To Use But Restricted
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Typing :: Typed
-Requires-Python: >=3.8
-Requires-Dist: pandas
-Requires-Dist: importlib-metadata (~=4.10)
-Requires-Dist: typing-extensions (>=4.0.1)
+Requires-Python: >=3.9
+Requires-Dist: pandas (>=1.5.3)
+Requires-Dist: numpy (>=1.24.3)
+Requires-Dist: importlib-metadata (>=6.6.0)
+Requires-Dist: typing-extensions (>=4.5.0)
 Provides-Extra: dev
 Requires-Dist: atoti ; extra == 'dev'
-Requires-Dist: pandas-stubs ; extra == 'dev'
+Requires-Dist: pandas-stubs (>=1.5.3) ; extra == 'dev'
 Requires-Dist: pytest ; extra == 'dev'
 Requires-Dist: pytz ; extra == 'dev'
 Requires-Dist: test-utils ; extra == 'dev'
```

## Comparing `atoti_core-0.7.4.dist-info/RECORD` & `atoti_core-0.8.0.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,67 +1,77 @@
-atoti_core/LICENSE,sha256=zuv36yiRiDNTn2hbzi0QK5qpjlrbt1TNz-pykQF9lx0,23139
-atoti_core/__init__.py,sha256=67JY7L3T8vptUJNV9uC-uDsn4J47jOzMoyf7uQ-iPCA,1823
-atoti_core/_deprecated_comparison_with_none.py,sha256=SgPagw-FG3CnRZW0IGPNLhFiokwsBV4L7u8wHTt5ZF8,335
-atoti_core/_get_endpoint_path.py,sha256=IYgUnA7iffJkkseG3Z8x1eWvTlDUWQ9iBx2DAx9wuO8,1652
+atoti_core/LICENSE,sha256=Q9b5T6w6Fv8QYaSLbHupmnRXMjoVLdIch_mE9BzcUDM,23472
+atoti_core/__init__.py,sha256=Op-ZEg-xfSrbuNsuan7Gviznq_Xmogs4_TnQPVFyye4,2420
+atoti_core/_get_endpoint_path.py,sha256=zmrlyiXz6APpXtMEAFb2-o3C82bAKGuTC6ZTjaSskf0,1679
 atoti_core/_other_coordinates.py,sha256=OZRQXRu2NQovSUwQNE3ryTxprmRwE3hVoKPtZfL21cs,150
-atoti_core/_server_versions.py,sha256=LyvfpNr3UoHL8b1HeFN4vyUiTpALwjhecEXyyas9ZIk,346
-atoti_core/activeviam_client.py,sha256=4nz-Gv0m-8-GUutJ7e72mJj-Tv_TO5KMOMgVerHA5oU,8665
+atoti_core/_server_versions.py,sha256=uJO4uAxTvrdT7EO9pYqT_5sP1jnEr7VxIkXaI6wzc3U,398
+atoti_core/activeviam_client.py,sha256=d7ndwFDgp93l7oSBWO6WxP4BwsZOAjKM7iwoL1vcwGA,8811
 atoti_core/arithmetic_operator.py,sha256=KXpKn1Zw2z_bxkW2VebZU_g6kWrBTTqeQTkEg0JxI08,128
-atoti_core/base_cube.py,sha256=86luMgmtONe9wJDMA36rqDJMGwuRpleHcU-E7H1TXRY,2376
-atoti_core/base_cubes.py,sha256=2BSmYTxnspbdDvszkC55s5EF2Qu2-RO0GzW0AgPuymg,534
-atoti_core/base_hierarchies.py,sha256=Z6fy_jWjYC92VPT_AntwqRzu2ewjh2CNk7LyYm-303A,2269
-atoti_core/base_hierarchy.py,sha256=VzN4wP-3dtYv0qHxHEuuTKlC_zBwsbtfaK4iWA37f-Q,5670
-atoti_core/base_level.py,sha256=bDQRJ8LIe-WhYN7-DZ4sF4UMNscZIm0Oxti_HDdEsTY,4945
-atoti_core/base_levels.py,sha256=Ac27r-qu6tZ8GU8FelTAj2ptdLtKMyGSe92HT-LrY_E,3672
-atoti_core/base_measure.py,sha256=7yk9d4_qdAkVi3pXvsXDPaummglSJd8bHNnx8rJZuuU,2523
-atoti_core/base_measures.py,sha256=YcoBd1Os5FV-BtHDb8KIC2IoJLpmMGwVI3W2cqCdNBE,1344
-atoti_core/base_session.py,sha256=5Voh9PIfJB3NwTYUuuBuW437db5gobfq9X68sXs76yM,8711
-atoti_core/boolean_operator.py,sha256=CZ0Q4eF258zLnn9DsQ3lwcR4fqlmFvoc43cIxIh0g84,228
-atoti_core/combine_conditions.py,sha256=H8KuI4B9ysPWdPzqO_isUXOE_hPbzpN3RmuBc51SN3M,3517
-atoti_core/comparison_operator.py,sha256=489MTYYAbPWogSmujYCKA27ZOyuQWUOULab4eUm17so,712
-atoti_core/condition_to_dict.py,sha256=cKXgd2MsscICeW7wFLgye4VDVdcIuRLA_rIOS9do3oI,779
-atoti_core/condition_to_pairs.py,sha256=gb1K_1nbjs2QKKqz0glBIE8tDvzGHodgdcOOjmdq2rM,926
-atoti_core/constant.py,sha256=Hc2T8cx1LCd-_8S4Og8yhZTw1U2E9wm2zbPe6tzAToE,3671
-atoti_core/context.py,sha256=smczWlGasWrFELuR1V3w3uzxq_HfgBvppblWoWvaeK0,61
-atoti_core/convert_to_pandas.py,sha256=QHi-ZipaD41Awdzb8VvIHET0osDU4CM4q05ys0VhAag,1170
-atoti_core/coordinates.py,sha256=DixRDtEYX8v2ZG3_rXQrrOfcDCUE84pb7wTtN8rmiBA,374
-atoti_core/data_type.py,sha256=weHcS2tD-HWafIWKOUVaHrwq11z-Plzkd-_jL9Pc4zg,3763
-atoti_core/decombine_condition.py,sha256=ZaJdJfeyOkHr4fb094L_GN1HhW2XPxiJ0nyWXpwT8Wo,9608
-atoti_core/deprecated.py,sha256=K1KYloV2Cs1DgJoC7Jv7MUkWUjo4RSTG8rwq6N1hVIM,551
-atoti_core/doc.py,sha256=etMk52ix8piNMF4ifVyQcENll1mgirhdkTyvHhDov2o,1786
-atoti_core/empty_mapping.py,sha256=UAn-OAbf64F5X9UgZg2IHiyvHVZvcfCgdOIC7PHq0R8,138
-atoti_core/fetch_json.py,sha256=FUZ7TeY9rILBaUGHAGr5SvLZ0NAhiny-9VtYs1JCOHk,3465
-atoti_core/find_corresponding_top_level_variable_name.py,sha256=hfOIER2Oeo4JE3E7IbqW3LuTc1_3h1nyKYkwV7eUhiE,673
+atoti_core/base_cube.py,sha256=cXn8jGSL6zRfDMKWzEIuhz45zdAMFEBs6R3CrpkT3ns,2437
+atoti_core/base_cubes.py,sha256=v05VbN41yBTEjFdhS3b05I8VqBmV_2qsjYZhff2INwQ,561
+atoti_core/base_hierarchies.py,sha256=jwuUaqzu4r_KrLKdMy0g1IAVEc8fi41dFg3pJbdGy6A,2277
+atoti_core/base_hierarchy.py,sha256=D0lBr25Jk9eLnBsYbZl8axOkBk49iuWhNkAApQr0PRs,5690
+atoti_core/base_level.py,sha256=Yia9kO_ZCZGL7Lpj4kY9rp6q_6F1LChhJLA9S2M7j_Y,4900
+atoti_core/base_levels.py,sha256=RhYXjoqTdqswXu-odkcmtDl6R7q9EEyFlLRmXw2RkwY,3961
+atoti_core/base_measure.py,sha256=LW3YhnI8JPpwW5aBk_6Pt6Z956x3ZbA-9pbwI-jRetw,2522
+atoti_core/base_measures.py,sha256=9v1yjAflQ_F2bkdG-BWBDEqBM9UGFpf8WFfjb_RDX94,1365
+atoti_core/base_session.py,sha256=NDpwG8wiAf6FJgxsZudAye5lj11DCfuzwqUOGuE1n5Q,10896
+atoti_core/boolean_operator.py,sha256=ibSEuUAGWYkFj8vsE22j4adXLkXIUsKS4_p9Fpyny88,221
+atoti_core/column_coordinates.py,sha256=eF1jbMXoq_HMflJtCzfaUVr01THYx37YFyFwBif3Qs8,420
+atoti_core/combine_conditions.py,sha256=sZ_bmrorhcfPg8VT_dOxz7g4tl-wMgEyNqvFT0Q5WsM,3537
+atoti_core/comparison_operator.py,sha256=UrFgPkRECKxU9wqcB45dloVYBrUGrZyAMGdN_Q4aii8,732
+atoti_core/condition_to_dict.py,sha256=c4C4cB9MRIQXKn8Zclii5oCK71t8qQRP1PDiRTcLCDw,773
+atoti_core/condition_to_pairs.py,sha256=zQQWT70scCM8YGYXZxKC2tdZkKPNUB31nSx3CjYa09s,913
+atoti_core/constant.py,sha256=-G09zKPly0G6wClLBp6KKQ1J0DMFSCRWvWdf_itYNs8,5240
+atoti_core/context.py,sha256=_vh7nlMabh6221vp0fcpZ35WAOAqsssG_DCQb3SeXVM,88
+atoti_core/convert_series.py,sha256=NAYgA_WspxiQztdWk0ch41TB3VPThiIxHBpo8-F5OIQ,3313
+atoti_core/coordinates.py,sha256=9bG02aFagh97zrSf1K2ymkldZ-do0ZId2xALM3Pqv-M,349
+atoti_core/coordinates_like.py,sha256=rAR_Ec0CYyNbLCrVWceigz8vDwliH4glgmevfiXUZ4w,153
+atoti_core/create_dataframe.py,sha256=HJ5EaXfOPzgzQQXsui4KSubzkSIN60zSmYukOd-0R4c,1720
+atoti_core/data_type.py,sha256=UjVTL6mmwYFNUMkLJHQVE7DNy4VAngMLQfc9XIolV3c,3946
+atoti_core/decombine_condition.py,sha256=XLcuFZqpyfynHMChTTADy6JdWqW_0TTtKFpe0pQmfVs,9600
+atoti_core/default_query_timeout.py,sha256=W5qgzdk26T0eoXVM6W2VC3nv7bKUwplM6wE8wl3qRiQ,78
+atoti_core/delegate_mutable_mapping.py,sha256=Q_HDEv3mKSoGUsZMaKLCaWr77cIlZNcTXbi_nREGRss,3191
+atoti_core/delegate_mutable_set.py,sha256=Wh54XQj4d63yVaiGN7xUdPkLUwuul0avd8xvvMrPQ-g,1325
+atoti_core/deprecated.py,sha256=Z9PKwNBfem77PUTqEJYUHZYNgK_s56A1gYOF4aDQ9yU,553
+atoti_core/doc.py,sha256=kmMhZ3bfr3UH25ao3yC82QaCEQX1DItgsCIGX_b5LhM,1903
+atoti_core/empty_mapping.py,sha256=i2jBPz404-PcpHoHusfQNv9kmEYP10Hzn7XB02F-sGc,165
+atoti_core/fetch_json.py,sha256=fkm8PqxYWeSfVWun-P7_tfLQS2_Qz7VREZjhCqawUg8,3431
+atoti_core/find_corresponding_top_level_variable_name.py,sha256=SOsU4RpW8Ix29C4aTIBIu-xacAGGIXBr5468b7XsVtU,590
 atoti_core/get_env_flag.py,sha256=vVc3jfLZEuvIDwvlENInkhMOMQtZrIUHMaGtbjMHIsg,326
-atoti_core/get_literal_args.py,sha256=xw8kwY5ZKLJQr4tXGu2cdsBE5ckEfInApIAHaumFO10,2181
+atoti_core/get_installed_plugins.py,sha256=eeeu0Er_udDLVfqupKiQ-4IkqDynFylyCBnfRK92MhE,1613
+atoti_core/get_ipython.py,sha256=n9B-amc65pSIZFf5ZdOR8goqvpkozP_QV5PVuF-EZx4,1008
+atoti_core/get_literal_args.py,sha256=Z3nRNgn-cu6KsBXm6QZP9_P5RNvMlaq1Bwzgf2UwH6A,2145
 atoti_core/get_package_version.py,sha256=w0QRERDT9e2S15aTujfv7py3QNkAf-Z5LxG0B3tqOcA,358
 atoti_core/get_top_level_package_name.py,sha256=RTsEgQWDzXL5WokrXDVzyK2GSsTf4XUbCOXgi08cq-w,265
 atoti_core/has_coordinates.py,sha256=wpMC6_XTYrnDnQGGknKQWTaHtK6OgUTuyaRQpypUeW8,379
-atoti_core/hierarchy_coordinates.py,sha256=1K3WRffs1CEZQolKHulWeVv_Q-9HSRsJWJpD7NHGfws,427
-atoti_core/hierarchy_isin_condition.py,sha256=k4yZkiRAGPznQOcPQB0u-wyEEzer6HlBogGPl3BFVRE,2910
-atoti_core/hierarchy_key.py,sha256=FoIav5Eqjalhl83hziQjpqrK3jOB-ZayPYQsmaV-gEs,76
+atoti_core/hierarchy_coordinates.py,sha256=woAlAErOh7CIBMzuB9w4cwCs4bBvTJTMxJCG5PhbFTk,402
+atoti_core/hierarchy_isin_condition.py,sha256=lgx27I9WBva54NdmJxkmAI-ms8E-WY5_WL0EW6R7V3M,4282
+atoti_core/hierarchy_key.py,sha256=9phdmKk2sp8q1GGsTZKpyiLM7-ojibRebA8FcBgQFpo,69
 atoti_core/http_method.py,sha256=wd2TYDjpLryll8PLHOWKP8nYZEDaG-iW4aim7PjSXho,109
-atoti_core/immutable_mapping.py,sha256=uZT2Wj7CF_Hz9ZFPprzrzCn7mV3XYF37j2hvcvxGHR4,806
-atoti_core/ipython_key_completions.py,sha256=ME_a3wm3ZS0UKxY_6nBKIOF0ipMSl_NeG6XoHwuyxp8,390
-atoti_core/isin_condition.py,sha256=apt9g4Wm5yKEgxPGFBhYRtO0HUisi7sS5ccf46sUSYs,2319
-atoti_core/keyword_only_dataclass.py,sha256=1DdsAamws2n529LIs3BbK2MEEOlKpbS76PGihLKSPR0,900
-atoti_core/level_coordinates.py,sha256=SF3U-63Plaj-VJzCs3adt58UTL5oDGJ9tU_f_QAEzz4,720
-atoti_core/level_key.py,sha256=bNCeucmo2WPFvvuVHsTHNwCmULmDjcp4hun0zZEsqiI,109
-atoti_core/measure_coordinates.py,sha256=odKV4hP6RZ6hHUpT_7MvBMjo7kH7yC2K6fBhxD5qBVo,389
+atoti_core/immutable_mapping.py,sha256=l_6zp5OO8uheyS91xlZvasdOjTR-IcN6Nd7xq7YoNmY,886
+atoti_core/ipython_key_completions.py,sha256=ur_ahskeZIkJlhVtUnKWvw9ZD80pFw6T8342bSyDdYk,404
+atoti_core/isin_condition.py,sha256=EMp00i3wrgzRx1Sfce_AKBzwRmN6wAe0cmXZG9esbSE,3420
+atoti_core/java_max_int.py,sha256=EPR4gNoGUOyaWAi6OnT2L_KutDLHQBpzOFMwWVwvtbQ,109
+atoti_core/keyword_only_dataclass.py,sha256=5DfSEtbZlcSsS0uslcDXiMNtajinp2sxTNEVhpTS9DA,1011
+atoti_core/level_coordinates.py,sha256=Cy6TC4EBuFHQ-G6TcByCO7ChMaqnZ_oGbHb4rKIGJ88,695
+atoti_core/level_key.py,sha256=KJSltyI9tDw4I2Jyy7bnH74YcO0Qml-c5GtEuMFhrbo,102
+atoti_core/license_key.py,sha256=-CIVHH-Q0mCDHwdZPciTpSpeqDnt0958jTVLZOOe3dQ,637
+atoti_core/measure_coordinates.py,sha256=0cHmnrOadaLXn8jwenxkAnK33PdesKvJkw0Om7B7Z9s,364
 atoti_core/missing_plugin_error.py,sha256=TTjkQEhYRZLn1pdJ4MAfOGDqbgT1WzS2MmQOzC9Hgyc,280
-atoti_core/operand_convertible_with_coordinates.py,sha256=Ob4cd_LSKWs5hP2unySvZM3lwoVDrbDy5sKrpxa1SEI,9779
-atoti_core/operation.py,sha256=6uP_OYEYKv0HQmtgQFZbPlR1fPXnCWJi3JD3RBnM2nQ,25759
+atoti_core/operand_convertible_with_coordinates.py,sha256=Curj3ggcD9WsEcmM-yRB-XbkEYH_wSAzP3c0apl6lfY,9157
+atoti_core/operation.py,sha256=lNurcb1UHnnSL960WJlKdski_PNVPK5NrvS9l0w9dWU,25609
+atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py,sha256=GtlR0Ow9OZWcfYEctr0NI1SwNei20YORnaWW01IS42Y,315
 atoti_core/path.py,sha256=477HG_h_YrE320S-Q5hwnlbCh9xjcthKVkmI0Mn7wVQ,180
-atoti_core/plugin.py,sha256=Tr1zZMUC9xoBo5meme2_S_EfzeLecf8mQVqh_JR64a0,945
-atoti_core/plugins.py,sha256=XDAmbl_c03thBUPnDYiJB-E4KJLd2b39rU0ovcWV4iU,4198
+atoti_core/plugin.py,sha256=XwymA0gJ3UAM4iZ7QQ5ZyNd3suP7SWKZY3OV31JwoDI,738
+atoti_core/plugins.py,sha256=28ckZdVW3Rn_XmQ14MKMsa5Vj7zgQClv2Du7HSuMgq8,866
 atoti_core/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-atoti_core/query_doc.py,sha256=iRX58_oLGyifbIAfREXzZ2DoIwPMVnuqPBxW5bQRs9g,9042
-atoti_core/query_filter.py,sha256=8r2_PIP2q5uDRacTM5k7qjAfV64kBhimdCEo6p_11tk,399
-atoti_core/raise_multiple_levels_with_same_name_error.py,sha256=nQB9xxbNrs4oTYpoOlgSqNePLs5lbAom4wTbIjuYW5Y,762
-atoti_core/repr_json.py,sha256=_cIueuKp5wcpBaf7K1ato68uVsNyQsUq3mQvfSW-Pgg,2188
-atoti_core/running_in_ipython.py,sha256=ePwIe8CsDx3Z1GN37sqSiEwRRJYrj8OYKEp0QFIGxUY,180
+atoti_core/query_doc.py,sha256=SZ81X9K2srZBJnZrhK5-HhUIIvZ26BwqhvwRs3hceqI,9949
+atoti_core/query_filter.py,sha256=HIkG6l92qzfDVTgv-LFUtqcMEP_DO2BCxEUMrta3prw,405
+atoti_core/raise_multiple_levels_with_same_name_error.py,sha256=OW_obnSS-nNM415T3c4h8iyFd-axoaXMoMqpNWa9R8Y,789
+atoti_core/reactive_mutable_set.py,sha256=vGQlNAiDnto2GWLdVhL6sM4qKRxdA8uqXm4NYMbUi14,2270
+atoti_core/repr_json.py,sha256=0M2H3k3A0AW-De2xt71MzgyFTFfWc9eQin_S5ZbCYiQ,2202
 atoti_core/scenario.py,sha256=Kp7RU9veySavOAG6mufEAjZPcBdh-m2P8MDpHY2Q4HE,28
-atoti_core/str_to_bool.py,sha256=umH-0uiQV0xs1hiBPZoUZmczWTC1ZJ3URl_9kKXE0rc,562
-atoti_core-0.7.4.dist-info/METADATA,sha256=cgNibDhvnyiDJ6fJI1OCmUIioZwDe33P2hbcpeAcNSs,797
-atoti_core-0.7.4.dist-info/WHEEL,sha256=MSis4yI4Wnq-8tzjLA3bUSbAjW_zs0NWGYfzsbp1H7g,109
-atoti_core-0.7.4.dist-info/top_level.txt,sha256=X4wSoqoZ3mCpyKACr5RpBXn4RbvtPqwcYyaJXAiLuy4,11
-atoti_core-0.7.4.dist-info/RECORD,,
+atoti_core/str_to_bool.py,sha256=Nq27fx8yRn3bDBcDr2ktT9emk-wlnBbNfRBOVLJfgmM,563
+atoti_core-0.8.0.dist-info/METADATA,sha256=zmqKn2t7MT_rOYMM-lwRq_IZmKFQvc7RS1pjKuxFZH0,855
+atoti_core-0.8.0.dist-info/WHEEL,sha256=xXVWFHOwiVUrSyw5z4tOAdevnUSxbBzqewjZqxZS0zU,109
+atoti_core-0.8.0.dist-info/top_level.txt,sha256=X4wSoqoZ3mCpyKACr5RpBXn4RbvtPqwcYyaJXAiLuy4,11
+atoti_core-0.8.0.dist-info/RECORD,,
```

