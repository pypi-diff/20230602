# Comparing `tmp/atoti_query-0.7.4-0_cb607ee-py3-none-any.whl.zip` & `tmp/atoti_query-0.8.0-0_04c5fd8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,64 @@
-Zip file size: 39410 bytes, number of entries: 40
--rw-r--r--  2.0 unx    23139 b- defN 23-Mar-15 20:20 atoti_query/LICENSE
--rw-r--r--  2.0 unx      725 b- defN 23-Mar-15 20:11 atoti_query/__init__.py
--rw-r--r--  2.0 unx      813 b- defN 23-Mar-15 20:11 atoti_query/_arrow_to_pandas.py
--rw-r--r--  2.0 unx     1513 b- defN 23-Mar-15 20:11 atoti_query/_cellset.py
--rw-r--r--  2.0 unx    16633 b- defN 23-Mar-15 20:11 atoti_query/_cellset_to_query_result.py
--rw-r--r--  2.0 unx     2734 b- defN 23-Mar-15 20:11 atoti_query/_create_query_cubes_from_discovery.py
--rw-r--r--  2.0 unx     1723 b- defN 23-Mar-15 20:11 atoti_query/_discovery.py
--rw-r--r--  2.0 unx      619 b- defN 23-Mar-15 20:11 atoti_query/_execute_gaq.py
--rw-r--r--  2.0 unx    12195 b- defN 23-Mar-15 20:11 atoti_query/_generate_mdx.py
--rw-r--r--  2.0 unx      591 b- defN 23-Mar-15 20:11 atoti_query/_get_cube.py
--rw-r--r--  2.0 unx      720 b- defN 23-Mar-15 20:11 atoti_query/_get_dimensions_mapping.py
--rw-r--r--  2.0 unx      294 b- defN 23-Mar-15 20:11 atoti_query/_get_level_data_types.py
--rw-r--r--  2.0 unx     1218 b- defN 23-Mar-15 20:11 atoti_query/_index_cellset.py
--rw-r--r--  2.0 unx     2409 b- defN 23-Mar-15 20:11 atoti_query/_index_discovery.py
--rw-r--r--  2.0 unx      105 b- defN 23-Mar-15 20:11 atoti_query/_named.py
--rw-r--r--  2.0 unx      553 b- defN 23-Mar-15 20:11 atoti_query/_parse_level_coordinates.py
--rw-r--r--  2.0 unx      467 b- defN 23-Mar-15 20:11 atoti_query/_query_mdx.py
--rw-r--r--  2.0 unx      577 b- defN 23-Mar-15 20:11 atoti_query/_query_private_parameters.py
--rw-r--r--  2.0 unx      225 b- defN 23-Mar-15 20:11 atoti_query/_widget_conversion_details.py
--rw-r--r--  2.0 unx      497 b- defN 23-Mar-15 20:11 atoti_query/auth.py
--rw-r--r--  2.0 unx      990 b- defN 23-Mar-15 20:11 atoti_query/basic_authentication.py
--rw-r--r--  2.0 unx     2012 b- defN 23-Mar-15 20:11 atoti_query/client_certificate.py
--rw-r--r--  2.0 unx     1923 b- defN 23-Mar-15 20:11 atoti_query/oauth2_resource_owner_password_authentication.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-15 20:11 atoti_query/py.typed
--rw-r--r--  2.0 unx     4242 b- defN 23-Mar-15 20:11 atoti_query/query_cube.py
--rw-r--r--  2.0 unx      170 b- defN 23-Mar-15 20:11 atoti_query/query_cubes.py
--rw-r--r--  2.0 unx      754 b- defN 23-Mar-15 20:11 atoti_query/query_hierarchies.py
--rw-r--r--  2.0 unx     1019 b- defN 23-Mar-15 20:11 atoti_query/query_hierarchy.py
--rw-r--r--  2.0 unx      772 b- defN 23-Mar-15 20:11 atoti_query/query_level.py
--rw-r--r--  2.0 unx     1221 b- defN 23-Mar-15 20:11 atoti_query/query_levels.py
--rw-r--r--  2.0 unx      990 b- defN 23-Mar-15 20:11 atoti_query/query_measure.py
--rw-r--r--  2.0 unx      191 b- defN 23-Mar-15 20:11 atoti_query/query_measures.py
--rw-r--r--  2.0 unx     4692 b- defN 23-Mar-15 20:11 atoti_query/query_result.py
--rw-r--r--  2.0 unx    12166 b- defN 23-Mar-15 20:11 atoti_query/query_session.py
--rw-r--r--  2.0 unx      704 b- defN 23-Mar-15 20:11 atoti_query/token_authentication.py
--rw-r--r--  2.0 unx      125 b- defN 23-Mar-15 20:11 atoti_query/_internal/__init__.py
--rw-r--r--  2.0 unx      903 b- defN 23-Mar-15 20:20 atoti_query-0.7.4.dist-info/METADATA
--rw-r--r--  2.0 unx      109 b- defN 23-Mar-15 20:20 atoti_query-0.7.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 23-Mar-15 20:20 atoti_query-0.7.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3448 b- defN 23-Mar-15 20:20 atoti_query-0.7.4.dist-info/RECORD
-40 files, 104193 bytes uncompressed, 33858 bytes compressed:  67.5%
+Zip file size: 59488 bytes, number of entries: 62
+-rw-r--r--  2.0 unx    23472 b- defN 23-Jun-02 01:02 atoti_query/LICENSE
+-rw-r--r--  2.0 unx      701 b- defN 23-Jun-02 00:55 atoti_query/__init__.py
+-rw-r--r--  2.0 unx     1396 b- defN 23-Jun-02 00:55 atoti_query/_arrow_to_pandas.py
+-rw-r--r--  2.0 unx     1551 b- defN 23-Jun-02 00:55 atoti_query/_cellset.py
+-rw-r--r--  2.0 unx    16443 b- defN 23-Jun-02 00:55 atoti_query/_cellset_to_query_result.py
+-rw-r--r--  2.0 unx     2734 b- defN 23-Jun-02 00:55 atoti_query/_create_query_cubes_from_discovery.py
+-rw-r--r--  2.0 unx     1800 b- defN 23-Jun-02 00:55 atoti_query/_discovery.py
+-rw-r--r--  2.0 unx      644 b- defN 23-Jun-02 00:55 atoti_query/_execute_gaq.py
+-rw-r--r--  2.0 unx      312 b- defN 23-Jun-02 00:55 atoti_query/_gaq_filter.py
+-rw-r--r--  2.0 unx    13046 b- defN 23-Jun-02 00:55 atoti_query/_generate_mdx.py
+-rw-r--r--  2.0 unx      591 b- defN 23-Jun-02 00:55 atoti_query/_get_cube.py
+-rw-r--r--  2.0 unx      285 b- defN 23-Jun-02 00:55 atoti_query/_get_data_types.py
+-rw-r--r--  2.0 unx      729 b- defN 23-Jun-02 00:55 atoti_query/_get_dimensions_mapping.py
+-rw-r--r--  2.0 unx      675 b- defN 23-Jun-02 00:55 atoti_query/_hierarchy_filter.py
+-rw-r--r--  2.0 unx     1193 b- defN 23-Jun-02 00:55 atoti_query/_index_cellset.py
+-rw-r--r--  2.0 unx     2436 b- defN 23-Jun-02 00:55 atoti_query/_index_discovery.py
+-rw-r--r--  2.0 unx      509 b- defN 23-Jun-02 00:55 atoti_query/_is_gaq_filter.py
+-rw-r--r--  2.0 unx      105 b- defN 23-Jun-02 00:55 atoti_query/_named.py
+-rw-r--r--  2.0 unx      553 b- defN 23-Jun-02 00:55 atoti_query/_parse_level_coordinates.py
+-rw-r--r--  2.0 unx      490 b- defN 23-Jun-02 00:55 atoti_query/_query_mdx.py
+-rw-r--r--  2.0 unx      282 b- defN 23-Jun-02 00:55 atoti_query/_query_private_parameters.py
+-rw-r--r--  2.0 unx      452 b- defN 23-Jun-02 00:55 atoti_query/_widget_conversion_details.py
+-rw-r--r--  2.0 unx      524 b- defN 23-Jun-02 00:55 atoti_query/auth.py
+-rw-r--r--  2.0 unx     1034 b- defN 23-Jun-02 00:55 atoti_query/basic_authentication.py
+-rw-r--r--  2.0 unx     1944 b- defN 23-Jun-02 00:55 atoti_query/client_certificate.py
+-rw-r--r--  2.0 unx     1950 b- defN 23-Jun-02 00:55 atoti_query/oauth2_resource_owner_password_authentication.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-02 00:55 atoti_query/py.typed
+-rw-r--r--  2.0 unx     4455 b- defN 23-Jun-02 00:55 atoti_query/query_cube.py
+-rw-r--r--  2.0 unx      170 b- defN 23-Jun-02 00:55 atoti_query/query_cubes.py
+-rw-r--r--  2.0 unx      728 b- defN 23-Jun-02 00:55 atoti_query/query_hierarchies.py
+-rw-r--r--  2.0 unx     1028 b- defN 23-Jun-02 00:55 atoti_query/query_hierarchy.py
+-rw-r--r--  2.0 unx      772 b- defN 23-Jun-02 00:55 atoti_query/query_level.py
+-rw-r--r--  2.0 unx     1316 b- defN 23-Jun-02 00:55 atoti_query/query_levels.py
+-rw-r--r--  2.0 unx      990 b- defN 23-Jun-02 00:55 atoti_query/query_measure.py
+-rw-r--r--  2.0 unx      191 b- defN 23-Jun-02 00:55 atoti_query/query_measures.py
+-rw-r--r--  2.0 unx     5648 b- defN 23-Jun-02 00:55 atoti_query/query_result.py
+-rw-r--r--  2.0 unx    12454 b- defN 23-Jun-02 00:55 atoti_query/query_session.py
+-rw-r--r--  2.0 unx      752 b- defN 23-Jun-02 00:55 atoti_query/token_authentication.py
+-rw-r--r--  2.0 unx      150 b- defN 23-Jun-02 00:55 atoti_query/_internal/__init__.py
+-rw-r--r--  2.0 unx      134 b- defN 23-Jun-02 00:55 atoti_query/security/__init__.py
+-rw-r--r--  2.0 unx       94 b- defN 23-Jun-02 00:55 atoti_query/security/_authentication_type.py
+-rw-r--r--  2.0 unx       28 b- defN 23-Jun-02 00:55 atoti_query/security/_column_key.py
+-rw-r--r--  2.0 unx      371 b- defN 23-Jun-02 00:55 atoti_query/security/_constants.py
+-rw-r--r--  2.0 unx     2997 b- defN 23-Jun-02 00:55 atoti_query/security/_content_client.py
+-rw-r--r--  2.0 unx      258 b- defN 23-Jun-02 00:55 atoti_query/security/_restriction.py
+-rw-r--r--  2.0 unx      728 b- defN 23-Jun-02 00:55 atoti_query/security/_restriction_from_mapping.py
+-rw-r--r--  2.0 unx     1411 b- defN 23-Jun-02 00:55 atoti_query/security/_restriction_to_dict.py
+-rw-r--r--  2.0 unx     1162 b- defN 23-Jun-02 00:55 atoti_query/security/_restrictions.py
+-rw-r--r--  2.0 unx     5094 b- defN 23-Jun-02 00:55 atoti_query/security/_roles.py
+-rw-r--r--  2.0 unx     6003 b- defN 23-Jun-02 00:55 atoti_query/security/_service.py
+-rw-r--r--  2.0 unx     4375 b- defN 23-Jun-02 00:55 atoti_query/security/basic_security.py
+-rw-r--r--  2.0 unx     1041 b- defN 23-Jun-02 00:55 atoti_query/security/default_roles.py
+-rw-r--r--  2.0 unx     4174 b- defN 23-Jun-02 00:55 atoti_query/security/individual_roles.py
+-rw-r--r--  2.0 unx      730 b- defN 23-Jun-02 00:55 atoti_query/security/kerberos_security.py
+-rw-r--r--  2.0 unx     1934 b- defN 23-Jun-02 00:55 atoti_query/security/ldap_security.py
+-rw-r--r--  2.0 unx     2459 b- defN 23-Jun-02 00:55 atoti_query/security/oidc_security.py
+-rw-r--r--  2.0 unx     3839 b- defN 23-Jun-02 00:55 atoti_query/security/role_mapping.py
+-rw-r--r--  2.0 unx    12217 b- defN 23-Jun-02 00:55 atoti_query/security/security.py
+-rw-r--r--  2.0 unx      913 b- defN 23-Jun-02 01:02 atoti_query-0.8.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      109 b- defN 23-Jun-02 01:02 atoti_query-0.8.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 23-Jun-02 01:02 atoti_query-0.8.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     5484 b- defN 23-Jun-02 01:02 atoti_query-0.8.0.dist-info/RECORD
+62 files, 160072 bytes uncompressed, 50682 bytes compressed:  68.3%
```

## zipnote {}

```diff
@@ -18,32 +18,41 @@
 
 Filename: atoti_query/_discovery.py
 Comment: 
 
 Filename: atoti_query/_execute_gaq.py
 Comment: 
 
+Filename: atoti_query/_gaq_filter.py
+Comment: 
+
 Filename: atoti_query/_generate_mdx.py
 Comment: 
 
 Filename: atoti_query/_get_cube.py
 Comment: 
 
+Filename: atoti_query/_get_data_types.py
+Comment: 
+
 Filename: atoti_query/_get_dimensions_mapping.py
 Comment: 
 
-Filename: atoti_query/_get_level_data_types.py
+Filename: atoti_query/_hierarchy_filter.py
 Comment: 
 
 Filename: atoti_query/_index_cellset.py
 Comment: 
 
 Filename: atoti_query/_index_discovery.py
 Comment: 
 
+Filename: atoti_query/_is_gaq_filter.py
+Comment: 
+
 Filename: atoti_query/_named.py
 Comment: 
 
 Filename: atoti_query/_parse_level_coordinates.py
 Comment: 
 
 Filename: atoti_query/_query_mdx.py
@@ -102,20 +111,77 @@
 
 Filename: atoti_query/token_authentication.py
 Comment: 
 
 Filename: atoti_query/_internal/__init__.py
 Comment: 
 
-Filename: atoti_query-0.7.4.dist-info/METADATA
+Filename: atoti_query/security/__init__.py
+Comment: 
+
+Filename: atoti_query/security/_authentication_type.py
+Comment: 
+
+Filename: atoti_query/security/_column_key.py
+Comment: 
+
+Filename: atoti_query/security/_constants.py
+Comment: 
+
+Filename: atoti_query/security/_content_client.py
+Comment: 
+
+Filename: atoti_query/security/_restriction.py
+Comment: 
+
+Filename: atoti_query/security/_restriction_from_mapping.py
+Comment: 
+
+Filename: atoti_query/security/_restriction_to_dict.py
+Comment: 
+
+Filename: atoti_query/security/_restrictions.py
+Comment: 
+
+Filename: atoti_query/security/_roles.py
+Comment: 
+
+Filename: atoti_query/security/_service.py
+Comment: 
+
+Filename: atoti_query/security/basic_security.py
+Comment: 
+
+Filename: atoti_query/security/default_roles.py
+Comment: 
+
+Filename: atoti_query/security/individual_roles.py
+Comment: 
+
+Filename: atoti_query/security/kerberos_security.py
+Comment: 
+
+Filename: atoti_query/security/ldap_security.py
+Comment: 
+
+Filename: atoti_query/security/oidc_security.py
+Comment: 
+
+Filename: atoti_query/security/role_mapping.py
+Comment: 
+
+Filename: atoti_query/security/security.py
+Comment: 
+
+Filename: atoti_query-0.8.0.dist-info/METADATA
 Comment: 
 
-Filename: atoti_query-0.7.4.dist-info/WHEEL
+Filename: atoti_query-0.8.0.dist-info/WHEEL
 Comment: 
 
-Filename: atoti_query-0.7.4.dist-info/top_level.txt
+Filename: atoti_query-0.8.0.dist-info/top_level.txt
 Comment: 
 
-Filename: atoti_query-0.7.4.dist-info/RECORD
+Filename: atoti_query-0.8.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## atoti_query/LICENSE

```diff
@@ -1,30 +1,27 @@
-ATOTI
-Free community edition LICENSE AGREEMENT
-Version 0.7.4
-
-This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of ATOTI version 0.7.4, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
+This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.0, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
 
 By requesting to have access to the Software, downloading or using the Software, End User acknowledges that he/she and End Customer has understood and agreed with the terms of this EULA.
 If End Customer does not accept these terms, End User must not use the Software.
 
 End Customer and ActiveViam are hereinafter individually or collectively referred to as the "PARTY (IES)".
 
 1. Purpose & description of the Software
 
    1. The EULA sets out the terms and conditions under which End User may install the Software from a library package and/or use the Software on a royalty-free basis.
       In order to run the Software, End User must install a java virtual machine (JVM).
       For convenience purposes, the Software includes the JVM provided by OpenJDK in the downloadable package.
       OpenJDK is licensed under the GPLv2 with classpath exception license https://openjdk.java.net/legal/gplv2+ce.html.
 
-   2. The Software can be downloaded via third party platforms such as, but not limited to, https://pypi.org/ or via ActiveViam's servers. The features and functionalities of the Software are listed on the Software's website at https://atoti.io/ (the "Site").
+   2. The Software can be downloaded via third party platforms such as, but not limited to, https://pypi.org or via ActiveViam's servers.
+      The features and functionalities of the Software are listed on the Software's website at https://www.atoti.io (the "Site").
 
 2. Limited community edition
 
-   1. The Software is provided for the restricted usage authorized herein.
+   1. The Software is provided under this EULA for the restricted usage authorized herein.
       It may not include all features and functionalities found in any future version of the Software.
       It is also possible that some of the features and functionalities included in the current version of the Software may be removed from future versions of the Software or that some use cases authorized for this version may not apply to future versions.
 
    2. The Software is made available exclusively for the purpose of demonstrating the possibilities offered by the Software so End Customer can evaluate the possibilities and potential of the Software.
 
 3. License Grant
 
@@ -40,34 +37,41 @@
       ActiveViam will acknowledge and confirm that End User may use the Software in Production Environment by email and may add certain restrictions / conditions to this authorization.
       If ActiveViam does not respond within ten (10) business days from End User's request, ActiveViam is deemed to have denied use of the Software in the Production Environment.
 
    4. Regarding any other elements generated as part of the use of the Software such as the models or dashboards created (the "Results"), they cannot in any event be used for more than the number of Viewers indicated herein without subscribing to an Enterprise Edition License Agreement.
 
    5. This EULA includes the right to display and copy the Software and the Results solely for the purposes authorized herein above.
 
-   6. When End User downloads the Software, End User is provided with the executable code of the Software. End User understands that no source code is provided.
+   6. When End User downloads the Software, End User is provided with the executable code of the Software.
+      End User understands that no source code is provided.
 
    7. The Software does not include any authentication or user access control system.
       End User / End Customer is not authorized to use or add any external software, hardware or programming method to implement an authentication or user access control layer to the Software.
-      This feature is available in ATOTI+, the enterprise edition of the Software (see section 7 below).
+      This feature is available in Atoti, the enterprise edition of the Software (see section 7 below).
 
    8. End User may make one copy of the Software in machine readable form for backup / security purposes only, provided that the backup copy must include all proprietary notices contained in the original Software package.
 
 4. Ownership - Restrictions
 
-   1. The EULA does not convey any assignment of rights to End User or End Customer on the Software. ActiveViam owns or has all the title, copyright and other intellectual property rights in the Software.
+   1. The EULA does not convey any assignment of rights to End User or End Customer on the Software.
+      ActiveViam owns or has all the title, copyright and other intellectual property rights in the Software.
 
-   2. Regarding Results, End User is also granted a right to use such Results as provided under this EULA. However, such Results are not assigned to the End Customer.
+   2. Regarding Results, End User is also granted a right to use such Results as provided under this EULA.
+      However, such Results are not assigned to the End Customer.
 
    3. End User may not and will not allow a third party to:
 
       1. reverse engineer, decompile, disassemble, or otherwise attempt to discover / have access to the source code or algorithms of the Software,
+
       2. adapt, modify, translate, disable any features and functionality of, the Software / the Results, or create derivative works based on the Software/ the Results,
+
       3. distribute, share, timeshare, transfer, sell, rent, lease, lend, grant a security interest in, use for service bureau purposes, sublicense or send the Software / Results or make available the Software or its functionalities to any other End User aside from Viewers,
+
       4. remove, modify, or conceal any product identification, copyright, proprietary, intellectual property notices or other marks on or within the Software,
+
       5. use the Software in any manner not expressly authorized by this EULA, such as develop a product which is competitive with any ActiveViam product or services offerings.
 
 5. Software Support
 
    1. ActiveViam will not provide any support or maintenance services under this EULA or any other professional services except as offered on a discretionary basis.
       End Customer acknowledges that ActiveViam has no express or implied obligation to announce or make available any updates, enhancements, modifications, revisions, or additions to the Software and that this EULA does not give End Customer any rights in or to any of the foregoing.
       Support and maintenance are available under an enterprise edition license of the Software (see section 7 below).
@@ -80,120 +84,134 @@
       In addition, such release or new Community edition may require an access to the internet, an updated version of the browser or to upgrade other Software dependencies (such as Java, Python, anaconda, node, etc.) and additional storage space on the device used to download the Software.
       Failing to meet these criteria may result in the failing to download or install the release or new community edition version.
 
    4. If necessary and requested in writing by End User, ActiveViam will provide available interface information needed to achieve interoperability between the Software and another software or application.
 
 6. Software's improvements
 
-   1. For the purpose of improving the Software and for statistical and analytical purposes, ActiveViam has integrated a telemetry feature in the Software that automatically collects the following information:
+   1. For the purpose of improving the Software and for statistical and analytical purposes as Atoti CE is provided in a freemium community version, ActiveViam has integrated a telemetry feature in the Software that automatically collects the following information:
 
       1. when a session is created, from where (geo location based on the IP address)
+
       2. method call/API usage
+
       3. data size/data structure
+
       4. error types
+
       5. up time
-      6. Python, atoti, and OS version
 
-   2. ActiveViam also associates a random unique ID for each installation of the Software and session to track the number of installations and how many sessions are run by installation without direct or indirect identification of the End-User concerned.
+      6. Python, Atoti CE, O/S versions
+
+   2. ActiveViam also associates a random unique ID for each installation of the Software and session to track the number of installations and how many sessions are run by installation without direct or indirect identification of the End User concerned.
 
-   3. ActiveViam will not access at any time the data processed by the Software nor information to identify the End-User.
+   3. ActiveViam will not access at any time the data processed by the Software nor information to identify the End User and/or End Customer except to verify compliance with this Agreement and as provided under the privacy policy.
 
-   4. If End-User does not want this information to be uploaded to ActiveViam, or if End User's system does not allow information to be sent to ActiveViam, End-User must register and obtain an evaluation license as provided in section 7.2 below in which case the telemetry can be disabled.
+   4. If End User does not want this information to be uploaded to ActiveViam, or if End User's system does not allow information to be uploaded to ActiveViam, End User must register and obtain an evaluation license as provided in section 7.2 below in which case the telemetry can be disabled.
+      This evaluation license is available through https://www.atoti.io/evaluation-license-request.
 
-7. Upgrade to the ATOTI+ version of the Software
+7. Upgrade to the Atoti version of the Software
 
-   1. End User may upgrade the Software to an enterprise edition of the Software ("ATOTI+") allowing them to download the ATOTI+ extensions.
-      The telemetry is automatically disabled when the ATOTI+ plugin is installed and enabled.
+   1. End User may upgrade the Software to an enterprise edition of the Software ("Atoti") allowing them to use the full Atoti extensions and disable telemetry.
 
-   2. Except for evaluation licenses that can be granted through registration, use of ATOTI+ is subject to the execution by End Customer of a separate paid license agreement with ActiveViam instead of this EULA.
+   2. Except for evaluation licenses that can be granted through registration and accepting the evaluation license terms, use of Atoti is subject to the execution by End Customer of a separate paid license agreement with ActiveViam instead of this EULA.
 
 8. Term and Termination
 
    1. The Software can be used for a period of 100 (hundred) days from the date of the Software's release (the "Term").
-      At the end of the Term, End-User must upgrade to a more recent version of the Software.
+      At the end of the Term, End User must upgrade to a more recent version of the Software.
       In the absence of a Software's release before the end of the Term, the Term will be extended until a new version is released.
 
    2. ActiveViam may terminate this EULA at any time by informing End User (if End User has provided his/her contact information) or deciding so when making available a Software release or new community edition.
 
    3. The rights under this EULA will terminate automatically without notice and without compensation from ActiveViam if End User / End Customer fails to comply with any of the terms and conditions of this EULA, notwithstanding ActiveViam's right to claim damages.
 
    4. The EULA will also terminate if and when End User deletes / erases the Software and any copy made of it.
 
    5. At the end of the Term, End User must cease all use of the Software and erase all copies of the Software, the Results and releases.
 
 9. Data Protection
 
-   1. ActiveViam and the End Customer undertake to comply with the applicable regulation on data privacy depending on the location of End-Users (the "Data Privacy Regulation").
+   1. ActiveViam and the End Customer undertake to comply with the applicable regulation on data privacy depending on the location of End User (the "Data Privacy Regulation").
 
    2. The End User exercises total control over the uses he/she makes of the Software, therefore End Customer fully and exclusively bears the responsibility of all processing activities of any personal data that may be carried out using the Software.
 
    3. If contact information is provided by End User, ActiveViam shall process this data in compliance with its privacy policy.
-      Access and use of the Site is subject to a privacy policy and terms of use available at the following addresses https://atoti.io/privacy-policy and https://atoti.io/terms.
+      Access and use of the Site is subject to a privacy policy and terms of use available at the following addresses https://www.atoti.io/privacy-policy and https://www.atoti.io/terms.
 
 10. Warranty
 
-   1. THE SOFTWARE IS PROVIDED "AS IS" AND ON AN "AS AVAILABLE" BASIS.
-      ACTIVEVIAM HEREBY EXPRESSLY EXCLUDES, TO THE FULLEST EXTENT PERMISSIBLE BY LAW, ALL WARRANTIES, REPRESENTATIONS, GUARANTEES, CONDITIONS AND TERMS, OTHER THAN THOSE EXPRESSLY SET OUT IN THIS EULA, SUCH AS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR FREE, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, WHETHER EXPRESS OR IMPLIED BY STATUTE, COMMON LAW, COURSE OF DEALING, TRADE USAGE OR OTHERWISE AND WHETHER WRITTEN OR ORAL, INCLUDING BUT NOT LIMITED TO ANY WARRANTY AS TO THE ACCURACY AND ADEQUACY OF ANY RESULTS GENERATED THROUGH USE OF THE SOFTWARE.
-      END-CUSTOMER BEARS AND ASSUMES THE ENTIRE RISK AS TO THE RESULTS AND PERFORMANCE OF THE SOFTWARE AND/OR THE USE IT MAKES OR ANY RELIANCE ON THE RESULTS.
+    1. THE SOFTWARE IS PROVIDED "AS IS" AND ON AN "AS AVAILABLE" BASIS.
+       ACTIVEVIAM HEREBY EXPRESSLY EXCLUDES, TO THE FULLEST EXTENT PERMISSIBLE BY LAW, ALL WARRANTIES, REPRESENTATIONS, GUARANTEES, CONDITIONS AND TERMS, OTHER THAN THOSE EXPRESSLY SET OUT IN THIS EULA, SUCH AS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR FREE, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, WHETHER EXPRESS OR IMPLIED BY STATUTE, COMMON LAW, COURSE OF DEALING, TRADE USAGE OR OTHERWISE AND WHETHER WRITTEN OR ORAL, INCLUDING BUT NOT LIMITED TO ANY WARRANTY AS TO THE ACCURACY AND ADEQUACY OF ANY RESULTS GENERATED THROUGH USE OF THE SOFTWARE.
+       END CUSTOMER BEARS AND ASSUMES THE ENTIRE RISK AS TO THE RESULTS AND PERFORMANCE OF THE SOFTWARE AND/OR THE USE IT MAKES OR ANY RELIANCE ON THE RESULTS.
 
-   2. END-CUSTOMER HEREBY REPRESENTS THAT IT SHALL (I) COMPLY WITH ALL APPLICABLE LOCAL AND FOREIGN LAWS AND REGULATIONS WHICH MAY GOVERN THE USE OF THE SOFTWARE AND DOCUMENTATION, AND (II) USE THE SOFTWARE AND DOCUMENTATION ONLY FOR LAWFUL PURPOSES AND IN ACCORDANCE WITH THE TERMS OF THIS EULA.
-      END-CUSTOMER SHALL INDEMNIFY AND HOLD ACTIVEVIAM ITS AFFILIATES, MANAGERS AND ADVISORS, AND EACH OF THEIR OFFICERS, DIRECTORS, SHAREHOLDERS, PARTNERS, EMPLOYEES, REPRESENTATIVES, AGENTS AND ATTORNEYS (INDEMNIFIED PARTIES) HARMLESS AGAINST ANY TROUBLE, CLAIM, EVICTION, DAMAGES OR PROTEST IN CASE OF BREACH OF ANY OBLIGATION OF THE EULA HARMLESS FROM ANY AND ALL LOSSES, LIABILITIES, OBLIGATIONS, CLAIMS, CONTINGENCIES, DAMAGES, REASONABLE COSTS AND EXPENSES, INCLUDING ALL JUDGMENTS, AMOUNTS PAID IN SETTLEMENTS, COURT COSTS AND REASONABLE ATTORNEYS' FEES AND COSTS OF INVESTIGATION THAT ANY INDEMNIFIED PARTY MAY SUFFER OR INCUR AS A RESULT OF OR RELATING TO ANY BREACH BY END-CUSTOMER OF THE REPRESENTATIONS HEREIN.
+    2. END CUSTOMER HEREBY REPRESENTS THAT IT SHALL (I) COMPLY WITH ALL APPLICABLE LOCAL AND FOREIGN LAWS AND REGULATIONS WHICH MAY GOVERN THE USE OF THE SOFTWARE AND DOCUMENTATION, AND (II) USE THE SOFTWARE AND DOCUMENTATION ONLY FOR LAWFUL PURPOSES AND IN ACCORDANCE WITH THE TERMS OF THIS EULA.
+       END CUSTOMER SHALL INDEMNIFY AND HOLD ACTIVEVIAM ITS AFFILIATES, MANAGERS AND ADVISORS, AND EACH OF THEIR OFFICERS, DIRECTORS, SHAREHOLDERS, PARTNERS, EMPLOYEES, REPRESENTATIVES, AGENTS AND ATTORNEYS (INDEMNIFIED PARTIES) HARMLESS AGAINST ANY TROUBLE, CLAIM, EVICTION, DAMAGES OR PROTEST IN CASE OF BREACH OF ANY OBLIGATION OF THE EULA HARMLESS FROM ANY AND ALL LOSSES, LIABILITIES, OBLIGATIONS, CLAIMS, CONTINGENCIES, DAMAGES, REASONABLE COSTS AND EXPENSES, INCLUDING ALL JUDGMENTS, AMOUNTS PAID IN SETTLEMENTS, COURT COSTS AND REASONABLE ATTORNEYS' FEES AND COSTS OF INVESTIGATION THAT ANY INDEMNIFIED PARTY MAY SUFFER OR INCUR AS A RESULT OF OR RELATING TO ANY BREACH BY END CUSTOMER OF THE REPRESENTATIONS HEREIN.
 
 11. Limited Liability
 
-   1. NOTHING IN THIS EULA SHALL BE DEEMED TO EXCLUDE, RESTRICT OR LIMIT LIABILITY OF EITHER PARTY (OR THEIR RESPECTIVE AGENTS OR SUB-CONTRACTORS) FOR DEATH OR PERSONAL INJURY RESULTING FROM THEIR NEGLIGENCE OR ANY LIABILITY FOR FRAUDULENT MISREPRESENTATION.
+    1. NOTHING IN THIS EULA SHALL BE DEEMED TO EXCLUDE, RESTRICT OR LIMIT LIABILITY OF EITHER PARTY (OR THEIR RESPECTIVE AGENTS OR SUB-CONTRACTORS) FOR DEATH OR PERSONAL INJURY RESULTING FROM THEIR NEGLIGENCE OR ANY LIABILITY FOR FRAUDULENT MISREPRESENTATION.
+
+    2. SUBJECT TO SECTION 11.1, ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) SHALL NOT BE LIABLE FOR ANY DAMAGES OF ANY KIND ARISING OUT OF OR RELATING TO THE USE OR THE INABILITY TO USE THE SOFTWARE, RESULTS OR ANY THIRD PARTY APPLICATION, ITS CONTENT OR FUNCTIONALITY, INCLUDING BUT NOT LIMITED TO DAMAGED CAUSES BY OR RELATED TO ERRORS, OMISSIONS, INTERRUPTIONS, DEFECTS, DELAY IN OPERATION OR TRANSMISSION, COMPUTER VIRUS, FAILURE TO CONNECT, NETWORK CHARGES, IN-APP PURCHASES, AND ALL OTHER DIRECT, INDIRECT, MORAL, INCIDENTAL, SPECIAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES OR ANY OTHER DAMAGES WHATSOEVER, INCLUDING BUT NOT LIMITED TO LOSS ARISING OUT OF OR IN CONNECTION WITH THE SOFTWARE OR RESULTS WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF ACTIVEVIAM IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
+       ACTIVEVIAM WILL NOT BE RESPONSIBLE FOR ANY DAMAGE CAUSED BY END CUSTOMER, END USER, ITS EMPLOYEES, SUBCONTRACTORS OR ANY THIRD PARTIES.
+
+    3. SUBJECT TO SECTION 11.1, ACTIVEVIAM SHALL ONLY BE LIABLE FOR DIRECT DAMAGES AND IN NO EVENT SHALL ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) BE LIABLE FOR:
 
-   2. SUBJECT TO SECTION 11.1, ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) SHALL NOT BE LIABLE FOR ANY DAMAGES OF ANY KIND ARISING OUT OF OR RELATING TO THE USE OR THE INABILITY TO USE THE SOFTWARE, RESULTS OR ANY THIRD PARTY APPLICATION, ITS CONTENT OR FUNCTIONALITY, INCLUDING BUT NOT LIMITED TO DAMAGED CAUSES BY OR RELATED TO ERRORS, OMISSIONS, INTERRUPTIONS, DEFECTS, DELAY IN OPERATION OR TRANSMISSION, COMPUTER VIRUS, FAILURE TO CONNECT, NETWORK CHARGES, IN-APP PURCHASES, AND ALL OTHER DIRECT, INDIRECT, MORAL, INCIDENTAL, SPECIAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES OR ANY OTHER DAMAGES WHATSOEVER, INCLUDING BUT NOT LIMITED TO LOSS ARISING OUT OF OR IN CONNECTION WITH THE SOFTWARE OR RESULTS WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF ACTIVEVIAM IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
-      ACTIVEVIAM WILL NOT BE RESPONSIBLE FOR ANY DAMAGE CAUSED BY END-CUSTOMER, END-USER, ITS EMPLOYEES, SUBCONTRACTORS OR ANY THIRD PARTIES.
+       1. ANY LOSS OF REVENUES OR PROFITS, LOSS, CORRUPTION OR DAMAGED OF DATA, COST OF COVER, BUSINESS INTERRUPTION, LOSS OF USE, LOSS OF CONTRACTS, LOSS OF GOODWILL (WHETHER DIRECT OR INDIRECT); OR
 
-   3. SUBJECT TO SECTION 11.1, ACTIVEVIAM SHALL ONLY BE LIABLE FOR DIRECT DAMAGES AND IN NO EVENT SHALL ACTIVEVIAM (INCLUDING ITS RESPECTIVE AGENTS AND SUB-CONTRACTORS) BE LIABLE FOR:
+       2. ANY INDIRECT OR CONSEQUENTIAL LOSSES OF ANY NATURE WHATSOEVER; OR
 
-      1. ANY LOSS OF REVENUES OR PROFITS, LOSS, CORRUPTION OR DAMAGED OF DATA, COST OF COVER, BUSINESS INTERRUPTION, LOSS OF USE, LOSS OF CONTRACTS, LOSS OF GOODWILL (WHETHER DIRECT OR INDIRECT); OR
-      2. ANY INDIRECT OR CONSEQUENTIAL LOSSES OF ANY NATURE WHATSOEVER; OR
-      3. ANY FAILURE OF THE SOFTWARE DUE TO ANY INTEGRATION OR INTEROPERABILITY ISSUES ARISING WITH ANY THIRD PARTY OR END CUSTOMER SYSTEMS OR LEGACY SYSTEMS UNLESS EXPRESSLY SET OUT TO THE CONTRARY;
-      4. WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF IT IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
-      5. ANY DAMAGES OR LOSS MUST BE NOTIFIED IN WRITING TO ACTIVEVIAM WITHIN FIFTEEN (15) DAYS OF ITS OCCURRENCE, FAILURE TO DO SO EXTINGUISHES SUCH CLAIM.
+       3. ANY FAILURE OF THE SOFTWARE DUE TO ANY INTEGRATION OR INTEROPERABILITY ISSUES ARISING WITH ANY THIRD PARTY OR END CUSTOMER SYSTEMS OR LEGACY SYSTEMS UNLESS EXPRESSLY SET OUT TO THE CONTRARY;
 
-   4. SOME STATES/COUNTRIES MAY NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, IN WHOLE OR IN PART, SO THE ABOVE LIMITATION MAY NOT APPLY IN ITS ENTIRETY TO USERS IN THOSE JURISDICTIONS SHALL BE APPLICABLE TO THE MAXIMUM EXTENT PERMISSIBLE.
-      IF ANY COURT OF COMPETENT JURISDICTIONS DETERMINES THAT ACTIVEVIAM IS OBLIGATED TO WARRANT THE PERFORMANCE OF THE SOFTWARE NOTWITHSTANDING THAT IS HAS BEEN PROVIDED TO END-CUSTOMER HEREUNDER FREE OF CHARGE, END-CUSTOMER'S EXCLUSIVE REMEDY SHALL BE THAT ACTIVEVIAM WILL REPAIR OR REPLACE THE SOFTWARE WITH ALTERNATIVE SOFTWARE REASONABLY SIMILAR TO THE SOFTWARE.
+       4. WHETHER OR NOT CAUSED BY OR RESULTING FROM ITS NEGLIGENCE OR A BREACH OF ITS STATUTORY DUTIES OR A BREACH OF ITS OBLIGATIONS HOWSOEVER CAUSED EVEN IF IT IS ADVISED OF THE POSSIBILITY OF SUCH LOSS.
 
-   5. END-CUSTOMER ACKNOWLEDGES AND AGREES THAT ACTIVEVIAM WOULD NOT BE ABLE TO PROVIDE THE SOFTWARE ON A NO-FEE BASIS WITHOUT SUCH LIMITATIONS.
+       5. ANY DAMAGES OR LOSS MUST BE NOTIFIED IN WRITING TO ACTIVEVIAM WITHIN FIFTEEN (15) DAYS OF ITS OCCURRENCE, FAILURE TO DO SO EXTINGUISHES SUCH CLAIM.
+
+    4. SOME STATES/COUNTRIES MAY NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, IN WHOLE OR IN PART, SO THE ABOVE LIMITATION MAY NOT APPLY IN ITS ENTIRETY IN WHICH CASE SUCH EXCLUSION OR LIMITATION OF LIABILITY SHALL BE APPLICABLE TO THE MAXIMUM EXTENT PERMISSIBLE UNDER APPLICABLE LAW.
+       IF ANY COURT OF COMPETENT JURISDICTIONS DETERMINES THAT ACTIVEVIAM IS OBLIGATED TO WARRANT THE PERFORMANCE OF THE SOFTWARE NOTWITHSTANDING THAT IT HAS BEEN PROVIDED TO END CUSTOMER HEREUNDER FREE OF CHARGE, END CUSTOMER'S EXCLUSIVE REMEDY SHALL BE THAT ACTIVEVIAM WILL REPAIR OR REPLACE THE SOFTWARE WITH ALTERNATIVE SOFTWARE REASONABLY SIMILAR TO THE SOFTWARE.
+
+    5. END CUSTOMER ACKNOWLEDGES AND AGREES THAT ACTIVEVIAM WOULD NOT BE ABLE TO PROVIDE THE SOFTWARE ON A NO-FEE BASIS WITHOUT SUCH LIMITATIONS.
 
 12. Third Party Application including Open Source
 
-   1. End User agrees that third party applications, software or programs, including solutions offered on an open source mode (the "Third-Party Software") may be required, included with, or downloaded with this Software.
-      ActiveViam makes no representations whatsoever about any of these Third-Party Software, as such Third-Party Software may be subject to open source license provisions.
-      ActiveViam may provide the applicable open source licenses upon request.
-
-   2. Since ActiveViam has no control over such Third-Party Software, End Customer acknowledges and agrees that ActiveViam is not responsible for such Third-Party Software.
-      End Customer expressly acknowledges and agrees that the use of Third-Party Software is at its sole risk and that the entire risk of unsatisfactory quality, performance, accuracy and effort is borne by End Customer.
-      ActiveViam shall not be responsible or liable, directly or indirectly, for any damage or loss, including but not limited to any damage to or loss of data, caused or alleged to be caused by, or in connection with, use of or reliance on any such Third-Party Software available on or through any such Third-Party Software.
-
-   3. End Customer acknowledges and agrees that the use of any Third-Party Software is governed by such Third-Party Software's terms, EULA and privacy Policy, or other such agreement and that any information or personal data provided by the End User, whether knowingly or unknowingly, to such Third-Party Software, will be subject to such Third-Party Software' privacy policy.
-      ActiveViam expressly disclaims any responsibility for any disclosure of information or any other practices of any Third-Party Software.
-      ActiveViam expressly disclaims any warranty regarding whether personal information is captured by any Third-Party Software provider or the use to which such personal information may be put by such Third-Party Software provider.
+    1. End User agrees that third party applications, software or programs, including solutions offered on an open source mode (the "Third-Party Software") may be required, included with, or downloaded with this Software.
+       ActiveViam makes no representations whatsoever about any of these Third-Party Software, as such Third-Party Software may be subject to open source license provisions.
+       ActiveViam may provide the applicable open source licenses upon request.
+
+    2. Since ActiveViam has no control over such Third-Party Software, End Customer acknowledges and agrees that ActiveViam is not responsible for such Third-Party Software.
+       End Customer expressly acknowledges and agrees that the use of Third-Party Software is at its sole risk and that the entire risk of unsatisfactory quality, performance, accuracy and effort is borne by End Customer.
+       ActiveViam shall not be responsible or liable, directly or indirectly, for any damage or loss, including but not limited to any damage to or loss of data, caused or alleged to be caused by, or in connection with, use of or reliance on any such Third-Party Software available on or through any such Third-Party Software.
+
+    3. End Customer acknowledges and agrees that the use of any Third-Party Software is governed by such Third-Party Software's terms, EULA and privacy Policy, or other such agreement and that any information or personal data provided by the End User, whether knowingly or unknowingly, to such Third-Party Software, will be subject to such Third-Party Software' privacy policy.
+       ActiveViam expressly disclaims any responsibility for any disclosure of information or any other practices of any Third-Party Software.
+       ActiveViam expressly disclaims any warranty regarding whether personal information is captured by any Third-Party Software provider or the use to which such personal information may be put by such Third-Party Software provider.
 
 13. Assignment and Transfer
 
-   1. End Customer may not assign, delegate, hypothecate, encumbered or otherwise transfer this EULA in whole or in part, or any rights or obligations hereunder (by operation of law, agreement of otherwise), without the prior written consent of ActiveViam to any third party.
-      Any attempt to assign, delegate or otherwise transfer any of End-Customer's rights or obligations without ActiveViam's consent shall be void.
+    1. End Customer may not assign, delegate, hypothecate, encumbered or otherwise transfer this EULA in whole or in part, or any rights or obligations hereunder (by operation of law, agreement of otherwise), without the prior written consent of ActiveViam to any third party.
+       Any attempt to assign, delegate or otherwise transfer any of End Customer's rights or obligations without ActiveViam's consent shall be void.
 
-   2. In addition, End Customer expressly authorizes ActiveViam to assign the EULA to a subsidiary, or to any company or legal entity, in particular in the context of a merger, divestiture, transfer, partial asset contribution or direct or indirect change of control.
+    2. In addition, End Customer expressly authorizes ActiveViam to assign the EULA to a subsidiary, or to any company or legal entity, in particular in the context of a merger, divestiture, transfer, partial asset contribution or direct or indirect change of control.
 
 14. General provisions
 
-   1. Export rules.
-      End Customer acknowledges that the Software may be subject to the U.S. Export Administration Regulations and other export laws and regulations, and End Customer will comply with such regulations.
-   2. Non - waiver.
-      Unless otherwise agreed, failure by either Party to exercise any of its rights hereunder or to enforce at any time any provision, term or condition of this EULA will not be deemed or considered a waiver or forfeiture of that Party's right or ability to enforce such provision, term or condition.
-   3. Severance.
-      If any provision of this EULA (or part of any provision) is held to be void, illegal or otherwise unenforceable by any court of competent jurisdiction, such provision (or part) shall, to the extent necessary to ensure that the remaining provisions of this EULA are not void, illegal or unenforceable, be deemed to be deleted and the validity, legality and/or enforceability of the remaining provisions of this EULA shall not be affected.
-      In such a case, the Parties will do their best efforts to interpret or renegotiate the concerned provision to achieve as nearly as possible the same economic effect of the original provision and remain in line with the Parties' intentions.
-   4. Compliance.
-      Upon ActiveViam's written request, the End User will certify in writing that the use of the Software is fully compliant with the terms of this EULA.
-   5. Modifications.
-      The EULA may be modified at any time and without any prior notice.
-      The applicable version of the EULA that governs the use of the Software is the EULA in force when End User downloads the Software and that is enclosed with it.
-      Any modification of the EULA applies to all the elements previously installed and/or generated by End User and overrides any previous version as soon as End User downloads any release.
-   6. This EULA is exclusively governed and construed in accordance with the laws of the State of New-York, United-States of America, without regard to any conflict of law rules, and excluding the application of the United Nations Convention on Contracts for the International Sale of Goods.
-      In order to resolve amicably any dispute that may arise with respect to the interpretation, the performance and/or the termination of this EULA, the Parties agree to meet after the receipt of a notice sent by registered mail by one of the Parties, with the intent to solve any dispute in an amicable way.
-      Failing for the Parties to reach an amicable settlement by executing a settlement agreement within thirty (30) days following the notification by a Party of the existence of the dispute and making an express reference to this provision, the Parties shall submit their dispute to the state and federal courts sitting in New York, New York that will have exclusive jurisdiction to settle the dispute.
+    1. Export rules.
+       End Customer acknowledges that the Software may be subject to the U.S. Export Administration Regulations and other export laws and regulations, and End Customer will comply with such regulations.
+
+    2. Non - waiver.
+       Unless otherwise agreed, failure by either Party to exercise any of its rights hereunder or to enforce at any time any provision, term or condition of this EULA will not be deemed or considered a waiver or forfeiture of that Party's right or ability to enforce such provision, term or condition.
+
+    3. Severance.
+       If any provision of this EULA (or part of any provision) is held to be void, illegal or otherwise unenforceable by any court of competent jurisdiction, such provision (or part) shall, to the extent necessary to ensure that the remaining provisions of this EULA are not void, illegal or unenforceable, be deemed to be deleted and the validity, legality and/or enforceability of the remaining provisions of this EULA shall not be affected.
+       In such a case, the Parties will do their best efforts to interpret or renegotiate the concerned provision to achieve as nearly as possible the same economic effect of the original provision and remain in line with the Parties' intentions.
+
+    4. Compliance.
+       Upon ActiveViam's written request, the End User will certify in writing that the use of the Software is fully compliant with the terms of this EULA.
+
+    5. Modifications.
+       The EULA may be modified at any time and without any prior notice.
+       The applicable version of the EULA that governs the use of the Software is the EULA in force when End User downloads the Software and that is enclosed with it.
+       Any modification of the EULA applies to all the elements previously installed and/or generated by End User and overrides any previous version as soon as End User downloads any release.
+
+    6. This EULA is exclusively governed and construed in accordance with the laws of the State of New-York, United-States of America, without regard to any conflict of law rules, and excluding the application of the United Nations Convention on Contracts for the International Sale of Goods.
+       In order to resolve amicably any dispute that may arise with respect to the interpretation, the performance and/or the termination of this EULA, the Parties agree to meet after the receipt of a notice sent by registered mail by one of the Parties, with the intent to solve any dispute in an amicable way.
+       Failing for the Parties to reach an amicable settlement by executing a settlement agreement within thirty (30) days following the notification by a Party of the existence of the dispute and making an express reference to this provision, the Parties shall submit their dispute to the state and federal courts sitting in New York, New York that will have exclusive jurisdiction to settle the dispute.
```

## atoti_query/__init__.py

```diff
@@ -1,11 +1,11 @@
-"""There are two main ways to query remote atoti sessions (or classic ActivePivot >= 5.7 servers):
+"""There are two main ways to query Atoti sessions.
 
-* by passing measures and levels to :meth:`atoti_query.QueryCube.query`
-* by passing an MDX string to :meth:`atoti_query.QuerySession.query_mdx`
+* Passing measures and levels to :meth:`atoti_query.QueryCube.query`.
+* Passing an MDX string to :meth:`atoti_query.QuerySession.query_mdx`.
 """
 
 from .auth import *
 from .basic_authentication import *
 from .client_certificate import *
 from .oauth2_resource_owner_password_authentication import *
 from .query_cube import *
@@ -13,9 +13,9 @@
 from .query_hierarchies import *
 from .query_hierarchy import *
 from .query_level import *
 from .query_levels import *
 from .query_measure import *
 from .query_measures import *
 from .query_result import *
-from .query_session import *
+from .query_session import QuerySession as QuerySession
 from .token_authentication import *
```

## atoti_query/_arrow_to_pandas.py

```diff
@@ -1,20 +1,34 @@
-from typing import Iterable
+from collections.abc import Iterable
 
 import pandas as pd
 import pyarrow as pa
 
 from ._parse_level_coordinates import parse_level_coordinates
 
+# See https://arrow.apache.org/docs/python/pandas.html#nullable-types.
+# Only types that can be sent by Atoti Server are listed.
+_ARROW_TYPE_TO_PANDAS_NULLABLE_TYPE = {
+    pa.int32(): pd.Int32Dtype(),
+    pa.int64(): pd.Int64Dtype(),
+    pa.bool_(): pd.BooleanDtype(),
+    pa.float32(): pd.Float32Dtype(),
+    pa.float64(): pd.Float64Dtype(),
+    pa.string(): pd.StringDtype(),
+}
+
 
 def arrow_to_pandas(
     table: pa.Table,  # pyright: ignore[reportUnknownParameterType]
 ) -> pd.DataFrame:
     # Fast for small tables (less than 100k lines) but can take several seconds for larger datasets.
-    dataframe: pd.DataFrame = table.to_pandas()
+    dataframe: pd.DataFrame = table.to_pandas(
+        # The level columns could stay non nullable but there is no fast way to handle them differently than measure columns.
+        types_mapper=_ARROW_TYPE_TO_PANDAS_NULLABLE_TYPE.get
+    )
     column_names: Iterable[str] = table.column_names
     level_coordinates = {
         column_name: parse_level_coordinates(column_name)
         for column_name in column_names
     }
     return dataframe.rename(
         columns={
```

## atoti_query/_cellset.py

```diff
@@ -1,10 +1,11 @@
 from __future__ import annotations
 
-from typing import Mapping, Optional, Sequence, TypedDict, Union
+from collections.abc import Mapping, Sequence
+from typing import Optional, TypedDict, Union
 
 from ._discovery import DefaultMember
 
 MeasureValue = Optional[Union[float, int, str, Sequence[Union[float, int]]]]
 
 
 class CellSetHierarchy(TypedDict):
@@ -15,23 +16,23 @@
 class CellSetMember(TypedDict):
     captionPath: Sequence[str]
     namePath: Sequence[str]
 
 
 class CellSetAxis(TypedDict):
     hierarchies: Sequence[CellSetHierarchy]
-    id: int
+    id: int  # noqa: A003
     positions: Sequence[Sequence[CellSetMember]]
 
 
-class NormalizedCellSetAxis(CellSetAxis):
+class NormalizedCellSetAxis(CellSetAxis, TypedDict):
     maxLevelPerHierarchy: Sequence[int]
-    """This property exists in CellSets returned by the WebSocket API but not in those returned by the REST API used by atoti.
+    """This property exists in CellSets returned by the WebSocket API but not in those returned by the REST API.
 
-    It is added when indexing the CellSet so that the logic to convert it to a table can be similar to the one used in ActiveUI.
+    It is added when indexing the CellSet so that the logic to convert it to a table can be similar to the one used in Atoti UI.
     """
 
 
 class CellSetCellProperties(TypedDict):
     BACK_COLOR: Optional[Union[int, str]]
     FONT_FLAGS: Optional[int]
     FONT_NAME: Optional[str]
```

## atoti_query/_cellset_to_query_result.py

```diff
@@ -1,47 +1,36 @@
 from __future__ import annotations
 
 import math
-from typing import (
-    TYPE_CHECKING,
-    Any,
-    Collection,
-    Dict,
-    Iterable,
-    List,
-    Literal,
-    Mapping,
-    Optional,
-    Sequence,
-    Tuple,
-    Union,
-    cast,
-)
+from collections.abc import Collection, Iterable, Mapping
+from typing import TYPE_CHECKING, Any, Literal, Optional, Union, cast
 
 import pandas as pd
 from atoti_core import (
     Context,
+    DataFrameColumnDescription,
     DataType,
     HierarchyCoordinates,
     LevelCoordinates,
-    convert_to_pandas,
+    MeasureCoordinates,
+    convert_series,
+    create_dataframe,
 )
 
 from ._cellset import (
     CellSetAxis,
     CellSetCellProperties,
     CellSetHierarchy,
     CellSetMember,
     IndexedCellSet,
-    MeasureValue,
     NormalizedCellSetAxis,
 )
 from ._discovery import DefaultMember, IndexedDiscovery, IndexedDiscoveryCube
 from ._get_cube import get_cube
-from ._get_level_data_types import GetLevelDataTypes
+from ._get_data_types import GetDataTypes
 from .query_result import QueryResult
 
 if TYPE_CHECKING:
     # This requires pandas' optional dependency jinja2.
     from pandas.io.formats.style import Styler  # pylint: disable=nested-import
 
 
@@ -72,16 +61,16 @@
             and member["hierarchy"] == _MEASURES_HIERARCHY["hierarchy"]
         ),
         None,
     )
 
 
 def _get_measure_names_and_captions(
-    axes: Iterable[CellSetAxis], /, *, default_measure: Optional[CellSetMember] = None
-) -> Tuple[Sequence[str], Sequence[str]]:
+    axes: Iterable[CellSetAxis], /, *, default_measure: Optional[CellSetMember]
+) -> tuple[list[str], list[str]]:
     if not axes:
         # When there are no axes at all, there is only one cell:
         # the value of the default measure aggregated at the top.
         return (
             ([default_measure["namePath"][0]], [default_measure["captionPath"][0]])
             if default_measure
             else ([], [])
@@ -96,23 +85,23 @@
         for axis in axes
         if not _is_slicer(axis)
         for hierarchy_index, hierarchy in enumerate(axis["hierarchies"])
         if hierarchy == _MEASURES_HIERARCHY
         for position in axis["positions"]
     }
 
-    return tuple(name_to_caption), tuple(name_to_caption.values())
+    return list(name_to_caption.keys()), list(name_to_caption.values())
 
 
 def _get_levels_coordinates(
     axes: Iterable[NormalizedCellSetAxis],
     /,
     *,
     cube: IndexedDiscoveryCube,
-) -> List[LevelCoordinates]:
+) -> list[LevelCoordinates]:
     return [
         LevelCoordinates(hierarchy["dimension"], hierarchy["hierarchy"], level["name"])
         for axis in axes
         if not _is_slicer(axis)
         for hierarchy_index, hierarchy in enumerate(axis["hierarchies"])
         if hierarchy != _MEASURES_HIERARCHY
         for level_index, level in enumerate(
@@ -133,25 +122,25 @@
     rest, red = divmod(color, 256)
     rest, green = divmod(rest, 256)
     rest, blue = divmod(rest, 256)
     return f"rgb({red}, {green}, {blue})"
 
 
 # See https://docs.microsoft.com/en-us/analysis-services/multidimensional-models/mdx/mdx-cell-properties-using-cell-properties.
-def _cell_font_flags_to_styles(font_flags: int, /) -> List[str]:
+def _cell_font_flags_to_styles(font_flags: int, /) -> list[str]:
     styles = []
     text_decorations = []
 
     if font_flags & 1 == 1:
         styles.append("font-weight: bold")
-    if font_flags & 2 == 2:
+    if font_flags & 2 == 2:  # noqa: PLR2004
         styles.append("font-style: italic")
-    if font_flags & 4 == 4:
+    if font_flags & 4 == 4:  # noqa: PLR2004
         text_decorations.append("underline")
-    if font_flags & 8 == 8:
+    if font_flags & 8 == 8:  # noqa: PLR2004
         text_decorations.append("line-through")
 
     if text_decorations:
         styles.append(f"""text-decoration: {" ".join(text_decorations)}""")
 
     return styles
 
@@ -190,25 +179,25 @@
 
     if lower_formatted_value == "false":
         return "False"
 
     return formatted_value
 
 
-CellMembers = Dict[HierarchyCoordinates, CellSetMember]
+CellMembers = dict[HierarchyCoordinates, CellSetMember]
 
 
 def _get_cell_members_and_is_total(
     ordinal: int,
     /,
     *,
     axes: Iterable[NormalizedCellSetAxis],
     cube: IndexedDiscoveryCube,
     keep_totals: bool,
-) -> Tuple[CellMembers, bool]:
+) -> tuple[CellMembers, bool]:
     cell_members: CellMembers = {}
     is_total = False
 
     for axis in axes:
         if _is_slicer(axis):
             continue
 
@@ -242,54 +231,51 @@
 
 
 def _get_member_name_index(
     levels_coordinates: Collection[LevelCoordinates],
     /,
     *,
     cube_name: str,
-    get_level_data_types: Optional[GetLevelDataTypes] = None,
-    members: Iterable[Tuple[Optional[str], ...]],
+    get_data_types: Optional[GetDataTypes],
+    keep_totals: bool,
+    members: Iterable[tuple[Optional[str], ...]],
 ) -> Optional[pd.Index]:
     if not levels_coordinates:
         return None
 
-    level_names = tuple(
-        level_coordinates.level_name for level_coordinates in levels_coordinates
+    types: dict[LevelCoordinates, DataType] = (
+        get_data_types(levels_coordinates, cube_name=cube_name)
+        if get_data_types
+        else {level_coordinates: "Object" for level_coordinates in levels_coordinates}
     )
-    index_dataframe = pd.DataFrame(
+    index_dataframe = create_dataframe(
         members,
-        columns=level_names,
-    )
-    object_java_type: DataType = "Object"
-    level_data_types: Mapping[LevelCoordinates, DataType] = (
-        get_level_data_types(levels_coordinates, cube_name=cube_name)
-        if get_level_data_types
-        else {
-            level_coordinates: object_java_type
+        [
+            DataFrameColumnDescription(
+                level_coordinates.level_name,
+                types[level_coordinates],
+                nullable=keep_totals,  # A level cell can only be null if it is a total.
+            )
             for level_coordinates in levels_coordinates
-        }
+        ],
     )
-    for level_coordinates in levels_coordinates:
-        index_dataframe[level_coordinates.level_name] = convert_to_pandas(
-            index_dataframe[level_coordinates.level_name],
-            data_type=level_data_types[level_coordinates],
-        )
-
-    if len(levels_coordinates) == 1:
-        return pd.Index(index_dataframe.iloc[:, 0])
 
-    return pd.MultiIndex.from_frame(index_dataframe)  # type: ignore[no-any-return]
+    return (
+        pd.Index(index_dataframe.iloc[:, 0])
+        if len(levels_coordinates) == 1
+        else pd.MultiIndex.from_frame(index_dataframe)
+    )
 
 
 def _get_member_caption_index(
     levels_coordinates: Collection[LevelCoordinates],
     /,
     *,
     cube: IndexedDiscoveryCube,
-    members: Iterable[Tuple[Optional[str], ...]],
+    members: Iterable[tuple[Optional[str], ...]],
 ) -> Optional[pd.Index]:
     if not levels_coordinates:
         return None
 
     level_captions = tuple(
         next(
             level["caption"]
@@ -299,108 +285,106 @@
             if level_name == level_coordinates.level_name
         )
         for level_coordinates in levels_coordinates
     )
 
     members_with_grand_total_caption = (
         (_GRAND_TOTAL_CAPTION,)
-        if all(element == None for element in member)
+        if all(element is None for element in member)
         else member
         for member in members
     )
 
     index_dataframe = pd.DataFrame(
         members_with_grand_total_caption,
         columns=level_captions,
         dtype="string",
     ).fillna("")
 
     if len(levels_coordinates) == 1:
         return pd.Index(index_dataframe.iloc[:, 0])
 
-    return pd.MultiIndex.from_frame(index_dataframe)  # type: ignore[no-any-return]
+    return pd.MultiIndex.from_frame(index_dataframe)
 
 
-def _create_measure_collection(
+def _get_measure_values(
     measure_values: Iterable[Mapping[str, Any]],
     /,
     *,
+    cube_name: str,
+    get_data_types: Optional[GetDataTypes],
     index: Optional[pd.Index],
-    measure_name: str,
-) -> Union[List[MeasureValue], pd.Series]:
-    values: List[MeasureValue] = [values.get(measure_name) for values in measure_values]
-    return (
-        pd.Series(
-            values,
-            # Forcing `object` dtypes when some measure values are ``None`` to prevent pandas from inferring a numerical type and ending up with NaNs.
-            dtype="object",
-            index=index,
+    measure_names: Collection[str],
+) -> dict[str, Iterable[Any]]:
+    types: dict[MeasureCoordinates, DataType] = (
+        get_data_types(
+            [MeasureCoordinates(measure_name) for measure_name in measure_names],
+            cube_name=cube_name,
         )
-        if None in values
-        else values
+        if get_data_types
+        else {
+            MeasureCoordinates(measure_name): "Object" for measure_name in measure_names
+        }
     )
 
+    return {
+        measure_name: convert_series(
+            pd.Series(
+                [values.get(measure_name) for values in measure_values],
+                dtype="object",  # To prevent any preliminary conversion.
+                index=index,
+            ),
+            data_type=types[MeasureCoordinates(measure_name)],
+            nullable=True,  # Measures are always nullable.
+        )
+        for measure_name in measure_names
+    }
+
 
 def _get_members_path(
     members: Iterable[CellSetMember],
     /,
     *,
     property_name: Literal["captionPath", "namePath"],
-) -> Tuple[Optional[str], ...]:
+) -> tuple[Optional[str], ...]:
     return tuple(
         name
         for member in members
         for name in member[property_name]
         # Replacing empty collection with `None` so that the member is still taken into account.
         or cast(  # mypy raises a `list-item` issue without the widening to `Optional[str]`.
             Iterable[Optional[str]], [None]
         )
     )
 
 
-def _get_data_values(
-    measure_values: Iterable[Mapping[str, Any]],
-    /,
-    *,
-    index: Optional[pd.Index],
-    measure_names: Collection[str],
-) -> Dict[str, Union[List[MeasureValue], pd.Series]]:
-    """Return a mapping of measure name to collection with a dtype of ``object`` when some measure values are ``None``."""
-    return {
-        measure_name: _create_measure_collection(
-            measure_values, index=index, measure_name=measure_name
-        )
-        for measure_name in measure_names
-    }
-
-
 def cellset_to_query_result(
     cellset: IndexedCellSet,
     /,
     *,
     context: Optional[Context] = None,
     discovery: IndexedDiscovery,
-    get_level_data_types: Optional[GetLevelDataTypes] = None,
+    get_data_types: Optional[GetDataTypes] = None,
     keep_totals: bool,
 ) -> QueryResult:
     """Convert an MDX CellSet to a pandas DataFrame."""
     default_measure = _get_default_measure(cellset["defaultMembers"])
     cube = get_cube(cellset["cube"], discovery=discovery)
 
     has_some_style = any(
         cell for cell in cellset["cells"].values() if cell["properties"]
     )
 
-    member_captions_to_measure_formatted_values: Dict[
-        Tuple[Optional[str], ...], Dict[str, str]
+    member_captions_to_measure_formatted_values: dict[
+        tuple[Optional[str], ...], dict[str, str]
     ] = {}
-    member_captions_to_measure_styles: Dict[
-        Tuple[Optional[str], ...], Dict[str, str]
+    member_captions_to_measure_styles: dict[
+        tuple[Optional[str], ...], dict[str, str]
     ] = {}
-    member_names_to_measure_values: Dict[Tuple[Optional[str], ...], Dict[str, Any]] = {}
+    member_names_to_measure_values: dict[tuple[Optional[str], ...], dict[str, Any]] = {}
 
     has_some_cells_or_any_non_measures_hierarchy = cellset["cells"] or any(
         hierarchy != _MEASURES_HIERARCHY
         for axis in cellset["axes"]
         for hierarchy in axis["hierarchies"]
     )
     cell_count = (
@@ -468,15 +452,16 @@
         cellset["axes"],
         cube=cube,
     )
 
     member_name_index = _get_member_name_index(
         levels_coordinates,
         cube_name=cellset["cube"],
-        get_level_data_types=get_level_data_types,
+        get_data_types=get_data_types,
+        keep_totals=keep_totals,
         members=member_names_to_measure_values.keys(),
     )
 
     member_caption_index = _get_member_caption_index(
         levels_coordinates,
         cube=cube,
         members=member_captions_to_measure_formatted_values.keys(),
@@ -497,32 +482,32 @@
         styler = formatted_values_dataframe.style
 
         if has_some_style:
 
             def apply_style(_: pd.DataFrame) -> pd.DataFrame:
                 return pd.DataFrame(
                     member_captions_to_measure_styles.values(),
+                    dtype="string",
                     columns=measure_captions,
                     index=member_caption_index,
                 )
 
-            styler = styler.apply(
-                apply_style,
-                # `None` is documented as a valid argument value but pandas-stubs does not support it.
-                axis=None,  # type: ignore
-            )
+            styler = styler.apply(apply_style, axis=None)
 
         return styler
 
-    data_values = _get_data_values(
+    measure_values = _get_measure_values(
         member_names_to_measure_values.values(),
+        cube_name=cellset["cube"],
+        get_data_types=get_data_types,
         index=member_name_index,
         measure_names=measure_names,
     )
 
-    return QueryResult(
-        data_values,
+    # `pandas-stub` declares a `__new__` but `pandas` actually have an `__init__`.
+    return QueryResult(  # pyright: ignore[reportGeneralTypeIssues]
+        measure_values,
         context=context,
         formatted_values=formatted_values_dataframe,
         get_styler=_get_styler,
         index=member_name_index,
     )
```

## atoti_query/_discovery.py

```diff
@@ -1,17 +1,18 @@
 from __future__ import annotations
 
-from typing import Mapping, Optional, Sequence, TypedDict
+from collections.abc import Mapping, Sequence
+from typing import Optional, TypedDict
 
 from ._named import Named
 
 
 class DiscoveryLevel(Named):
     caption: str
-    type: str
+    type: str  # noqa: A003
 
 
 class _DiscoveryHierarchy(Named):
     caption: str
     slicing: bool
 
 
@@ -21,41 +22,41 @@
 
 class IndexedDiscoveryHierarchy(_DiscoveryHierarchy):
     levels: Mapping[str, DiscoveryLevel]
 
 
 class _DiscoveryDimension(Named):
     caption: str
-    type: str
+    type: str  # noqa: A003
 
 
 class DiscoveryDimension(_DiscoveryDimension):
     hierarchies: Sequence[DiscoveryHierarchy]
 
 
 class IndexedDiscoveryDimension(_DiscoveryDimension):
     hierarchies: Mapping[str, IndexedDiscoveryHierarchy]
 
 
-class DiscoveryMeasure(Named):
+class DiscoveryMeasure(Named, TypedDict):
     caption: str
     description: Optional[str]
     folder: Optional[str]
     formatString: Optional[str]
     visible: bool
 
 
 class DefaultMember(TypedDict):
     captionPath: Sequence[str]
     dimension: str
     hierarchy: str
     path: Sequence[str]
 
 
-class _DiscoveryCube(Named):
+class _DiscoveryCube(Named, TypedDict):
     defaultMembers: Sequence[DefaultMember]
 
 
 class DiscoveryCube(_DiscoveryCube):
     dimensions: Sequence[DiscoveryDimension]
     measures: Sequence[DiscoveryMeasure]
```

## atoti_query/_execute_gaq.py

```diff
@@ -1,20 +1,23 @@
+from collections.abc import Iterable
 from datetime import timedelta
-from typing import Iterable, Optional, Protocol
+from typing import Optional, Protocol
 
 import pandas as pd
-from atoti_core import LevelCoordinates, MeasureCoordinates, QueryFilter
+from atoti_core import LevelCoordinates, MeasureCoordinates
+
+from ._gaq_filter import GaqFilter
 
 
 class ExecuteGaq(Protocol):
     def __call__(
         self,
         *,
         cube_name: str,
-        filter: Optional[QueryFilter] = None,  # pylint: disable=redefined-builtin
+        filter: Optional[GaqFilter] = None,  # noqa: A002
         include_empty_rows: bool,
         include_totals: bool,
         levels_coordinates: Iterable[LevelCoordinates],
         measures_coordinates: Iterable[MeasureCoordinates],
         scenario: str,
         timeout: timedelta,
     ) -> pd.DataFrame:
```

## atoti_query/_generate_mdx.py

```diff
@@ -1,18 +1,9 @@
-from typing import (
-    Collection,
-    Dict,
-    Iterable,
-    List,
-    Literal,
-    Mapping,
-    Optional,
-    Sequence,
-    Tuple,
-)
+from collections.abc import Collection, Iterable, Mapping, Sequence
+from typing import Literal, Optional
 
 from atoti_core import (
     BASE_SCENARIO_NAME,
     ComparisonCondition,
     Constant,
     HierarchyCoordinates,
     HierarchyIsinCondition,
@@ -20,14 +11,15 @@
     LevelCoordinates,
     MeasureCoordinates,
     QueryFilter,
     decombine_condition,
 )
 
 from ._discovery import IndexedDiscoveryCube, IndexedDiscoveryHierarchy
+from ._hierarchy_filter import HierarchyFilter
 
 
 def _escape(name: str, /) -> str:
     return name.replace("]", "]]")
 
 
 def _generate_set(
@@ -41,27 +33,27 @@
 
 def _generate_columns_set(measures_coordinates: Iterable[MeasureCoordinates], /) -> str:
     return _generate_set(
         [
             f"[Measures].[{_escape(measure_coordinates.measure_name)}]"
             for measure_coordinates in measures_coordinates
         ],
-        # ActiveUI 5 does not support it.
+        # Atoti UI 5 does not support it.
         # See https://support.activeviam.com/jira/browse/UI-5036.
         single_element_short_syntax=False,
     )
 
 
 def _keep_only_deepest_levels(
     levels_coordinates: Iterable[LevelCoordinates],
     /,
     *,
     cube: IndexedDiscoveryCube,
-) -> Dict[LevelCoordinates, int]:
-    hierarchy_to_max_level_depth: Dict[HierarchyCoordinates, int] = {}
+) -> dict[LevelCoordinates, int]:
+    hierarchy_to_max_level_depth: dict[HierarchyCoordinates, int] = {}
 
     for level_coordinates in levels_coordinates:
         hierarchy_coordinates = level_coordinates.hierarchy_coordinates
         current_max_level_depth = hierarchy_to_max_level_depth.get(
             hierarchy_coordinates, -1
         )
         regular_level_names = [
@@ -172,47 +164,67 @@
         raise (
             ValueError(
                 f"Only conditions based on the shallowest level of a hierarchy are supported but level {level_coordinates} was given."
             )
         )
 
 
-def _generate_hierarchy_coordinates_to_member_paths_from_conditions(
+def _generate_hierarchy_coordinates_to_filter(
     *,
     comparison_conditions: Iterable[
-        ComparisonCondition[LevelCoordinates, Literal["eq"], Constant]
+        ComparisonCondition[LevelCoordinates, Literal["eq", "ne"], Constant]
     ],
     cube: IndexedDiscoveryCube,
     hierarchy_isin_conditions: Iterable[HierarchyIsinCondition],
     isin_conditions: Iterable[IsinCondition[LevelCoordinates, Constant]],
-) -> Dict[HierarchyCoordinates, Sequence[Tuple[Constant, ...]]]:
-    hierarchy_coordinates_to_member_paths: Dict[
-        HierarchyCoordinates, Sequence[Tuple[Constant, ...]]
-    ] = {}
+) -> dict[HierarchyCoordinates, HierarchyFilter]:
+    hierarchy_coordinates_to_filter: dict[HierarchyCoordinates, HierarchyFilter] = {}
+
+    def add_hierarchy_filter(
+        hierarchy_filter: HierarchyFilter,
+        /,
+        *,
+        hierarchy_coordinates: HierarchyCoordinates,
+    ) -> None:
+        existing_filter = hierarchy_coordinates_to_filter.get(hierarchy_coordinates)
+
+        hierarchy_coordinates_to_filter[hierarchy_coordinates] = (
+            existing_filter & hierarchy_filter if existing_filter else hierarchy_filter
+        )
 
     for comparison_condition in comparison_conditions:
         _ensure_condition_on_shallowest_level(comparison_condition.subject, cube=cube)
 
-        hierarchy_coordinates_to_member_paths[
-            comparison_condition.subject.hierarchy_coordinates
-        ] = [(comparison_condition.target,)]
+        add_hierarchy_filter(
+            HierarchyFilter(
+                exclusion=comparison_condition.operator == "ne",
+                member_paths=[(comparison_condition.target,)],
+            ),
+            hierarchy_coordinates=comparison_condition.subject.hierarchy_coordinates,
+        )
 
     for isin_condition in isin_conditions:
         _ensure_condition_on_shallowest_level(isin_condition.subject, cube=cube)
 
-        hierarchy_coordinates_to_member_paths[
-            isin_condition.subject.hierarchy_coordinates
-        ] = [(member,) for member in isin_condition.elements]
+        add_hierarchy_filter(
+            HierarchyFilter(
+                member_paths=[(member,) for member in isin_condition.elements],
+            ),
+            hierarchy_coordinates=isin_condition.subject.hierarchy_coordinates,
+        )
 
     for hierarchy_isin_condition in hierarchy_isin_conditions:
-        hierarchy_coordinates_to_member_paths[
-            hierarchy_isin_condition.subject
-        ] = hierarchy_isin_condition.member_paths
+        add_hierarchy_filter(
+            HierarchyFilter(
+                member_paths=hierarchy_isin_condition.member_paths,
+            ),
+            hierarchy_coordinates=hierarchy_isin_condition.subject,
+        )
 
-    return hierarchy_coordinates_to_member_paths
+    return hierarchy_coordinates_to_filter
 
 
 def _generate_member_unique_name(
     member_path: Iterable[Constant],
     /,
     *,
     cube: IndexedDiscoveryCube,
@@ -241,44 +253,50 @@
 
         parts.append(f"[{_escape(value)}]")
 
     return ".".join(parts)
 
 
 def _generate_filter(
-    member_paths: Iterable[Tuple[Constant, ...]],
+    hierarchy_filter: HierarchyFilter,
     /,
     *,
     cube: IndexedDiscoveryCube,
     hierarchy_coordinates: HierarchyCoordinates,
 ) -> str:
-    return _generate_set(
+    filter_set = _generate_set(
         [
             _generate_member_unique_name(
                 member_path, cube=cube, hierarchy_coordinates=hierarchy_coordinates
             )
-            for member_path in member_paths
+            for member_path in hierarchy_filter.member_paths
         ]
     )
 
+    return (
+        f"Except({_generate_hierarchy_unique_name(hierarchy_coordinates, cube=cube)}.Members,{filter_set})"
+        if hierarchy_filter.exclusion
+        else filter_set
+    )
+
 
 def _generate_filters(
-    hierarchy_coordinates_to_member_paths: Mapping[
-        HierarchyCoordinates, Iterable[Tuple[Constant, ...]]
-    ],
+    hierarchy_coordinates_to_filter: Mapping[HierarchyCoordinates, HierarchyFilter],
     /,
     *,
     cube: IndexedDiscoveryCube,
     scenario_name: str,
-) -> List[str]:
+) -> list[str]:
     filters = [
         _generate_filter(
-            member_paths, cube=cube, hierarchy_coordinates=hierarchy_coordinates
+            hierarchy_filter,
+            cube=cube,
+            hierarchy_coordinates=hierarchy_coordinates,
         )
-        for hierarchy_coordinates, member_paths in hierarchy_coordinates_to_member_paths.items()
+        for hierarchy_coordinates, hierarchy_filter in hierarchy_coordinates_to_filter.items()
     ]
 
     if scenario_name != BASE_SCENARIO_NAME:
         filters.append(
             _generate_member_unique_name(
                 [Constant(scenario_name)],
                 cube=cube,
@@ -302,15 +320,15 @@
 
     return f"FROM (SELECT {filters[-1]} ON COLUMNS {_generate_from_clause(filters[0:-1], cube=cube)})"
 
 
 def _generate_mdx_with_decombined_conditions(
     *,
     comparison_conditions: Iterable[
-        ComparisonCondition[LevelCoordinates, Literal["eq"], Constant]
+        ComparisonCondition[LevelCoordinates, Literal["eq", "ne"], Constant]
     ] = (),
     cube: IndexedDiscoveryCube,
     hierarchy_isin_conditions: Iterable[HierarchyIsinCondition] = (),
     include_empty_rows: bool = False,
     include_totals: bool = False,
     isin_conditions: Iterable[IsinCondition[LevelCoordinates, Constant]] = (),
     levels_coordinates: Iterable[LevelCoordinates],
@@ -320,56 +338,54 @@
     mdx = f"SELECT {_generate_columns_set(measures_coordinates)} ON COLUMNS"
 
     deepest_levels = _keep_only_deepest_levels(levels_coordinates, cube=cube)
 
     if deepest_levels:
         mdx = f"{mdx}, {'' if include_empty_rows else 'NON EMPTY '}{_generate_rows_set(deepest_levels, cube=cube, include_totals=include_totals)} ON ROWS"
 
-    hierarchy_coordinates_to_member_paths = (
-        _generate_hierarchy_coordinates_to_member_paths_from_conditions(
-            comparison_conditions=comparison_conditions,
-            cube=cube,
-            hierarchy_isin_conditions=hierarchy_isin_conditions,
-            isin_conditions=isin_conditions,
-        )
+    hierarchy_coordinates_to_filter = _generate_hierarchy_coordinates_to_filter(
+        comparison_conditions=comparison_conditions,
+        cube=cube,
+        hierarchy_isin_conditions=hierarchy_isin_conditions,
+        isin_conditions=isin_conditions,
     )
 
     filters = _generate_filters(
-        hierarchy_coordinates_to_member_paths,
+        hierarchy_coordinates_to_filter,
         cube=cube,
         scenario_name=scenario_name,
     )
 
-    mdx = f"{mdx} {_generate_from_clause(filters, cube=cube)}"
-
-    return mdx
+    return f"{mdx} {_generate_from_clause(filters, cube=cube)}"
 
 
 def generate_mdx(
     *,
     cube: IndexedDiscoveryCube,
-    filter: Optional[QueryFilter] = None,  # pylint: disable=redefined-builtin
+    filter: Optional[QueryFilter] = None,  # noqa: A002
     include_empty_rows: bool = False,
     include_totals: bool = False,
     levels_coordinates: Iterable[LevelCoordinates] = (),
     measures_coordinates: Iterable[MeasureCoordinates] = (),
     scenario: str = BASE_SCENARIO_NAME,
 ) -> str:
     """Return the corresponding MDX query.
 
     The value of the measures is given on all the members of the given levels.
     If no level is specified then the value at the top level is returned.
     """
+    allowed_comparison_operators: tuple[Literal["eq", "ne"], ...] = ("eq", "ne")
+
     comparison_conditions, isin_conditions, hierarchy_isin_conditions = (
         ((), (), ())
         if filter is None
         else decombine_condition(
             filter,
             allowed_subject_types=(LevelCoordinates,),
-            allowed_comparison_operators=("eq",),
+            allowed_comparison_operators=allowed_comparison_operators,
             allowed_target_types=(Constant,),
             allowed_combination_operators=("and",),
             allowed_isin_element_types=(Constant,),
         )[0]
     )
 
     return _generate_mdx_with_decombined_conditions(
```

## atoti_query/_get_dimensions_mapping.py

```diff
@@ -1,10 +1,10 @@
 from __future__ import annotations
 
-from typing import Mapping
+from collections.abc import Mapping
 
 from ._discovery import DiscoveryCube, DiscoveryDimension, DiscoveryHierarchy
 
 DiscoveryHierarchyMapping = Mapping[str, DiscoveryHierarchy]
 DiscoveryDimensionMapping = Mapping[str, DiscoveryHierarchyMapping]
```

## atoti_query/_index_cellset.py

```diff
@@ -1,15 +1,13 @@
 from __future__ import annotations
 
-from typing import List
-
 from ._cellset import CellSet, CellSetAxis, IndexedCellSet, NormalizedCellSetAxis
 
 
-def _get_max_level_per_hierarchy(axis: CellSetAxis, /) -> List[int]:
+def _get_max_level_per_hierarchy(axis: CellSetAxis, /) -> list[int]:
     return [
         max(
             (
                 len(position[hierarchy_index]["namePath"])
                 for position in axis["positions"]
             ),
             default=0,
```

## atoti_query/_index_discovery.py

```diff
@@ -1,10 +1,11 @@
 from __future__ import annotations
 
-from typing import Callable, Iterable, Mapping, Optional, TypeVar, Union, overload
+from collections.abc import Callable, Iterable, Mapping
+from typing import Optional, TypeVar, Union, overload
 
 from ._discovery import (
     Discovery,
     DiscoveryCatalog,
     DiscoveryCube,
     DiscoveryDimension,
     DiscoveryHierarchy,
```

## atoti_query/_query_mdx.py

```diff
@@ -1,19 +1,19 @@
 from datetime import timedelta
 from typing import Any, Literal, Protocol
 
 import pandas as pd
-from atoti_core import EMPTY_MAPPING, Context
+from atoti_core import DEFAULT_QUERY_TIMEOUT, EMPTY_MAPPING, Context
 
 
 class QueryMdx(Protocol):
     def __call__(
         self,
         mdx: str,
         *,
         context: Context = EMPTY_MAPPING,
         keep_totals: bool = False,
         mode: Literal["pretty", "raw"] = "pretty",
-        timeout: timedelta = timedelta(seconds=30),
+        timeout: timedelta = DEFAULT_QUERY_TIMEOUT,
         **kwargs: Any,
     ) -> pd.DataFrame:
         ...
```

## atoti_query/_query_private_parameters.py

```diff
@@ -1,19 +1,12 @@
 from dataclasses import dataclass
 from typing import Optional
 
-from atoti_core import QueryFilter, deprecated, keyword_only_dataclass
+from atoti_core import keyword_only_dataclass
 
-from ._get_level_data_types import GetLevelDataTypes
+from ._get_data_types import GetDataTypes
 
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class QueryPrivateParameters:
-    condition: Optional[QueryFilter] = None
-    get_level_data_types: Optional[GetLevelDataTypes] = None
-
-    def __post_init__(self) -> None:
-        if self.condition is not None:
-            deprecated(
-                "The `condition` parameter is deprecated: it has been renamed `filter`."
-            )
+    get_data_types: Optional[GetDataTypes] = None
```

## atoti_query/_widget_conversion_details.py

```diff
@@ -1,11 +1,18 @@
 from dataclasses import dataclass
 
-from atoti_core import keyword_only_dataclass
+from atoti_core import get_package_version, keyword_only_dataclass
 
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class WidgetConversionDetails:
     mdx: str
     session_id: str
     widget_creation_code: str
+
+
+_MAJOR_VERSION = get_package_version(__name__).split(".", maxsplit=1)[0]
+
+CONVERT_QUERY_RESULT_TO_WIDGET_MIME_TYPE = (
+    f"application/vnd.atoti.convert-query-result-to-widget.v{_MAJOR_VERSION}+json"
+)
```

## atoti_query/auth.py

```diff
@@ -1,8 +1,9 @@
-from typing import Mapping, Protocol
+from collections.abc import Mapping
+from typing import Protocol
 
 
 class Auth(Protocol):
     """Called with the URL of the request against a :class:`atoti_query.QuerySession` and returning the HTTP headers necessary to authenticate it.
 
     There are some built-in implementations:
```

## atoti_query/basic_authentication.py

```diff
@@ -1,31 +1,34 @@
 from base64 import b64encode
+from collections.abc import Mapping
 from dataclasses import dataclass
 from functools import cached_property
-from typing import Mapping
 
 from atoti_core import keyword_only_dataclass
 
 from .auth import Auth
 from .token_authentication import TokenAuthentication
 
 
 @keyword_only_dataclass
 @dataclass(eq=False, frozen=True)
 class BasicAuthentication(Auth):
     """:class:`atoti_query.Auth` relying on `basic authentication <https://en.wikipedia.org/wiki/Basic_access_authentication>`__.
 
-    See also:
+    See Also:
         :class:`atoti.BasicAuthenticationConfig`.
     """
 
     username: str
     password: str
 
     def __call__(self, url: str) -> Mapping[str, str]:
         return self._token_authentication(url)
 
     @cached_property
     def _token_authentication(self) -> TokenAuthentication:
         plain_credentials = f"{self.username}:{self.password}"
         token = str(b64encode(plain_credentials.encode("ascii")), "utf8")
-        return TokenAuthentication(token=token, token_type="Basic")  # nosec B106
+        return TokenAuthentication(
+            token=token,
+            token_type="Basic",  # noqa: S106
+        )
```

## atoti_query/client_certificate.py

```diff
@@ -6,23 +6,21 @@
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class ClientCertificate:
     """A client certificate to open a :class:`atoti_query.QuerySession` against a session configured with :class:`atoti.ClientCertificateConfig`.
 
     Example:
-
         .. doctest:: client_certificate
             :hide:
 
-            >>> from atoti_plus import UserServiceClient
             >>> CERTIFICATES_DIRECTORY = (
             ...     _PYTHON_PACKAGES_PATH
-            ...     / "atoti-plus"
-            ...     / "tests_atoti_plus"
+            ...     / "atoti"
+            ...     / "tests_atoti"
             ...     / "resources"
             ...     / "config"
             ...     / "certificates"
             ... )
             >>> session = tt.Session(
             ...     client_certificate=tt.ClientCertificateConfig(
             ...         trust_store=CERTIFICATES_DIRECTORY / "truststore.jks",
```

## atoti_query/oauth2_resource_owner_password_authentication.py

```diff
@@ -1,10 +1,11 @@
+from collections.abc import Mapping
 from dataclasses import dataclass
 from functools import cached_property, lru_cache
-from typing import Mapping, TypedDict, cast
+from typing import TypedDict, cast
 from urllib.parse import urljoin
 
 from atoti_core import fetch_json, keyword_only_dataclass
 
 from .auth import Auth
 from .token_authentication import TokenAuthentication
 
@@ -26,15 +27,15 @@
 
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class OAuth2ResourceOwnerPasswordAuthentication(Auth):
     """This :class:`atoti_query.Auth` relies on OAuth 2's `Resource Owner Password Credentials Grant <https://datatracker.ietf.org/doc/html/rfc6749#section-4.3>`__.
 
-    See also:
+    See Also:
         :attr:`atoti.OidcConfig.access_token_format`.
     """
 
     username: str
     password: str
     issuer_url: str
     client_id: str
```

## atoti_query/query_cube.py

```diff
@@ -1,35 +1,39 @@
 from __future__ import annotations
 
+from collections.abc import Iterable
 from datetime import timedelta
-from typing import Any, Iterable, Literal, Optional
+from typing import Any, Literal, Optional
 
 import pandas as pd
 from atoti_core import (
     BASE_SCENARIO_NAME,
+    DEFAULT_QUERY_TIMEOUT,
     EMPTY_MAPPING,
     QUERY_DOC,
     BaseCube,
     BaseLevel,
     BaseMeasure,
     Context,
     QueryFilter,
     doc,
     get_query_args_doc,
 )
 
 from ._discovery import IndexedDiscoveryCube
 from ._execute_gaq import ExecuteGaq
 from ._generate_mdx import generate_mdx
+from ._is_gaq_filter import is_gaq_filter
 from ._query_mdx import QueryMdx
 from ._query_private_parameters import QueryPrivateParameters
 from ._widget_conversion_details import WidgetConversionDetails
 from .query_hierarchies import QueryHierarchies
 from .query_levels import QueryLevels
 from .query_measures import QueryMeasures
+from .query_result import QueryResult
 
 
 class QueryCube(BaseCube[QueryHierarchies, QueryLevels, QueryMeasures]):
     def __init__(
         self,
         name: str,
         /,
@@ -52,30 +56,34 @@
         return QueryLevels(hierarchies=self.hierarchies)
 
     @doc(QUERY_DOC, args=get_query_args_doc(is_query_session=True))
     def query(
         self,
         *measures: BaseMeasure,
         context: Context = EMPTY_MAPPING,
-        filter: Optional[QueryFilter] = None,  # pylint: disable=redefined-builtin
+        filter: Optional[QueryFilter] = None,  # noqa: A002
         include_empty_rows: bool = False,
         include_totals: bool = False,
         levels: Iterable[BaseLevel] = (),
         mode: Literal["pretty", "raw"] = "pretty",
         scenario: str = BASE_SCENARIO_NAME,
-        timeout: timedelta = timedelta(seconds=30),
+        timeout: timedelta = DEFAULT_QUERY_TIMEOUT,
         **kwargs: Any,
     ) -> pd.DataFrame:
         query_private_parameters = QueryPrivateParameters(**kwargs)
-        filter = query_private_parameters.condition if filter is None else filter
 
         levels_coordinates = [level._coordinates for level in levels]
         measures_coordinates = [measure._coordinates for measure in measures]
 
-        if mode == "raw" and self._execute_gaq and not context:
+        if (
+            mode == "raw"
+            and self._execute_gaq
+            and not context
+            and (filter is None or is_gaq_filter(filter))
+        ):
             return self._execute_gaq(
                 cube_name=self.name,
                 filter=filter,
                 include_empty_rows=include_empty_rows,
                 include_totals=include_totals,
                 levels_coordinates=levels_coordinates,
                 measures_coordinates=measures_coordinates,
@@ -92,22 +100,26 @@
             measures_coordinates=measures_coordinates,
             scenario=scenario,
         )
 
         query_result = self._query_mdx(
             mdx,
             context=context,
-            get_level_data_types=query_private_parameters.get_level_data_types,
+            get_data_types=query_private_parameters.get_data_types,
             keep_totals=include_totals,
             mode=mode,
             timeout=timeout,
         )
 
-        # Always use an MDX including totals because ActiveUI 5 then relies on context values to show/hide totals.
-        if not include_totals and query_result._atoti_widget_conversion_details:
+        # Always use an MDX including totals because Atoti UI 5 relies only on context values to show/hide totals.
+        if (
+            not include_totals
+            and isinstance(query_result, QueryResult)
+            and query_result._atoti_widget_conversion_details
+        ):
             query_result._atoti_widget_conversion_details = WidgetConversionDetails(
                 mdx=generate_mdx(
                     cube=self._cube,
                     filter=filter,
                     include_empty_rows=include_empty_rows,
                     include_totals=True,
                     levels_coordinates=levels_coordinates,
```

## atoti_query/query_hierarchies.py

```diff
@@ -1,16 +1,14 @@
-from typing import Tuple
-
 from atoti_core import BaseHierarchies, HierarchyKey, ImmutableMapping
 
 from .query_hierarchy import QueryHierarchy
 
 
 class QueryHierarchies(
-    ImmutableMapping[Tuple[str, str], QueryHierarchy], BaseHierarchies[QueryHierarchy]
+    ImmutableMapping[tuple[str, str], QueryHierarchy], BaseHierarchies[QueryHierarchy]
 ):
     def __getitem__(self, key: HierarchyKey, /) -> QueryHierarchy:
         if isinstance(key, tuple):
             return super().__getitem__(key)
         matching_hierarchies = [
             hierarchy for hierarchy in self.values() if hierarchy.name == key
         ]
```

## atoti_query/query_hierarchy.py

```diff
@@ -1,8 +1,8 @@
-from typing import Mapping
+from collections.abc import Mapping
 
 from atoti_core import BaseHierarchy
 
 from .query_level import QueryLevel
 
 
 class QueryHierarchy(BaseHierarchy[QueryLevel]):
```

## atoti_query/query_levels.py

```diff
@@ -29,8 +29,12 @@
                 raise_multiple_levels_with_same_name_error(
                     level_name,
                     hierarchies=hierarchies,
                 )
 
             return self._hierarchies[hierarchy_name][level_name]
 
-        return self._hierarchies[(dimension_name, hierarchy_name)][level_name]  # type: ignore
+        return self._hierarchies[
+            (dimension_name, hierarchy_name)  # type: ignore[index]
+        ][  # pyright: ignore[reportGeneralTypeIssues]
+            level_name
+        ]
```

## atoti_query/query_result.py

```diff
@@ -1,37 +1,42 @@
 from __future__ import annotations
 
 import logging
-from typing import TYPE_CHECKING, Any, Callable, Dict, Optional, cast
+from collections.abc import Callable
+from typing import TYPE_CHECKING, Any, Optional
 
 import pandas as pd
 from atoti_core import Context
 from typeguard import typeguard_ignore
 
-from ._widget_conversion_details import WidgetConversionDetails
+from ._widget_conversion_details import (
+    CONVERT_QUERY_RESULT_TO_WIDGET_MIME_TYPE,
+    WidgetConversionDetails,
+)
 
 if TYPE_CHECKING:
     # This requires pandas' optional dependency jinja2.
     from pandas.io.formats.style import Styler  # pylint: disable=nested-import
 
 
-class QueryResult(pd.DataFrame):  # pylint: disable=abstract-method
-    """pandas DataFrame corresponding to the result of a query.
+class QueryResult(pd.DataFrame):
+    """pandas DataFrame corresponding to the result of a query ran in ``"pretty"`` *mode*.
 
     It is indexed by the queried levels (date levels become :class:`pandas.DatetimeIndex`).
 
     .. note::
         Unless mutated in place, the ``__repr__()``, ``_repr_html_()``, ``_repr_latex_()``, and ``_repr_mimebundle_()`` methods will use:
 
         * The caption of levels and members instead of their name.
         * The formatted value of measures instead of their value.
     """
 
     # See https://pandas.pydata.org/pandas-docs/stable/development/extending.html#define-original-properties
-    _internal_names = pd.DataFrame._internal_names + [  # type: ignore
+    _internal_names = [
+        *pd.DataFrame._internal_names,  # type: ignore[attr-defined] # pyright: ignore[reportGeneralTypeIssues]
         "_atoti_context",
         "_atoti_formatted_values",
         "_atoti_get_styler",
         "_atoti_has_been_mutated",
         "_atoti_initial_dataframe",
         "_atoti_widget_conversion_details",
     ]
@@ -44,33 +49,35 @@
         data: Any = None,
         index: Any = None,
         *,
         context: Optional[Context] = None,
         formatted_values: pd.DataFrame,
         get_styler: Callable[[], Styler],
     ):
-        super().__init__(data, index)
+        # `pandas-stub` declares a `__new__` but `pandas` actually have an `__init__`.
+        super().__init__(data, index)  # type: ignore[call-arg] # pyright: ignore[reportGeneralTypeIssues]
 
         self._atoti_context = context
         self._atoti_formatted_values = formatted_values
         self._atoti_get_styler = get_styler
         self._atoti_has_been_mutated = False
         self._atoti_initial_dataframe: pd.DataFrame = self.copy(deep=True)
         self._atoti_widget_conversion_details: Optional[WidgetConversionDetails] = None
 
-    # The conversion to an atoti widget and the styling are based on the fact that this dataframe represents the original result of the MDX query.
+    # The conversion to an Atoti widget and the styling are based on the fact that this dataframe represents the original result of the MDX query.
     # If the dataframe was mutated, these features should be disabled to prevent them from being incorrect.
     def _has_been_mutated(self) -> bool:
-        if not self._atoti_has_been_mutated:
-            if not self.equals(self._atoti_initial_dataframe):
-                self._atoti_has_been_mutated = True
-
-                logging.getLogger("atoti.query").warning(
-                    "The query result has been mutated: captions, formatted values, and styling will not be shown."
-                )
+        if not self._atoti_has_been_mutated and not self.equals(
+            self._atoti_initial_dataframe
+        ):
+            self._atoti_has_been_mutated = True
+
+            logging.getLogger("atoti.query").warning(
+                "The query result has been mutated: captions, formatted values, and styling will not be shown."
+            )
 
         return self._atoti_has_been_mutated
 
     @property
     def style(self) -> Styler:
         """Return a Styler object.
 
@@ -88,37 +95,48 @@
     def _atoti_repr(self, *, has_been_mutated: bool) -> str:
         return repr(self._get_dataframe_to_repr(has_been_mutated=has_been_mutated))
 
     def __repr__(self) -> str:
         return self._atoti_repr(has_been_mutated=self._has_been_mutated())
 
     def _atoti_repr_html(self, *, has_been_mutated: bool) -> str:
-        return cast(
-            str,
-            self._get_dataframe_to_repr(
-                has_been_mutated=has_been_mutated
-            )._repr_html_(),
+        dataframe_to_repr = self._get_dataframe_to_repr(
+            has_been_mutated=has_been_mutated
         )
+        # `pandas-stubs` lacks the `_repr_html_` method.
+        html: str = dataframe_to_repr._repr_html_()  # type: ignore[operator]
+        return html
 
     def _repr_html_(self) -> str:
         return self._atoti_repr_html(has_been_mutated=self._has_been_mutated())
 
     def _atoti_repr_latex(self, *, has_been_mutated: bool) -> str:
-        return cast(
-            str,
-            self._get_dataframe_to_repr(
-                has_been_mutated=has_been_mutated
-            )._repr_latex_(),
+        dataframe_to_repr = self._get_dataframe_to_repr(
+            has_been_mutated=has_been_mutated
         )
+        # `pandas-stubs` lacks the `_repr_latex_` method.
+        latex: str = dataframe_to_repr._repr_latex_()  # type: ignore[operator]
+        return latex
 
     def _repr_latex_(self) -> str:
         return self._atoti_repr_latex(has_been_mutated=self._has_been_mutated())
 
     def _repr_mimebundle_(
-        self, include: object, exclude: object  # pylint: disable=unused-argument
-    ) -> Dict[str, object]:
+        self,
+        include: object,  # noqa: ARG002
+        exclude: object,  # noqa: ARG002
+    ) -> dict[str, object]:
         has_been_mutated = self._has_been_mutated()
 
-        return {
+        mimebundle: dict[str, object] = {
             "text/html": self._atoti_repr_html(has_been_mutated=has_been_mutated),
             "text/plain": self._atoti_repr(has_been_mutated=has_been_mutated),
         }
+
+        if self._atoti_widget_conversion_details and not self._has_been_mutated():
+            mimebundle[CONVERT_QUERY_RESULT_TO_WIDGET_MIME_TYPE] = {
+                "mdx": self._atoti_widget_conversion_details.mdx,
+                "sessionId": self._atoti_widget_conversion_details.session_id,
+                "widgetCreationCode": self._atoti_widget_conversion_details.widget_creation_code,
+            }
+
+        return mimebundle
```

## atoti_query/query_session.py

```diff
@@ -1,50 +1,54 @@
+from collections.abc import Iterable, Mapping
 from dataclasses import dataclass
 from datetime import timedelta
 from functools import cached_property
 from math import ceil
 from pathlib import Path
-from typing import Any, Dict, Iterable, Literal, Mapping, Optional, Union, cast
+from typing import Any, Literal, Optional, Union, cast
 
 import pandas as pd
 import pyarrow as pa
 from atoti_core import (
+    DEFAULT_QUERY_TIMEOUT,
     EMPTY_MAPPING,
+    PLUGINS,
     ActiveViamClient,
     BaseSession,
     BaseSessionBound,
     Constant,
     Context,
     HierarchyIsinCondition,
     LevelCoordinates,
     MeasureCoordinates,
+    Plugin,
     QueryFilter,
     decombine_condition,
     doc,
-    get_active_plugins,
     keyword_only_dataclass,
 )
 
 from ._arrow_to_pandas import arrow_to_pandas
 from ._cellset import CellSet
 from ._cellset_to_query_result import cellset_to_query_result
 from ._create_query_cubes_from_discovery import create_query_cubes_from_discovery
 from ._discovery import Discovery, IndexedDiscovery
-from ._get_level_data_types import GetLevelDataTypes
+from ._get_data_types import GetDataTypes
 from ._index_cellset import index_cellset
 from ._index_discovery import index_discovery
 from ._widget_conversion_details import WidgetConversionDetails
 from .auth import Auth
 from .client_certificate import ClientCertificate
 from .query_cubes import QueryCubes
+from .security import Security
 
 _VERSIONS_WITHOUT_RAW_MODE = ("4", "5")
 
 
-def _serialize_condition(condition: QueryFilter) -> Dict[str, Any]:
+def _serialize_condition(condition: QueryFilter) -> dict[str, Any]:
     (
         level_conditions,
         level_isin_conditions,
         hierarchy_isin_conditions,
     ) = decombine_condition(
         condition,
         allowed_subject_types=(LevelCoordinates,),
@@ -71,15 +75,15 @@
         not_string = [
             value.value
             for value in level_isin_condition.elements
             if not isinstance(value.value, str)
         ]
         if not_string:
             raise TypeError(
-                f"Only strings are supported in query condition but the following values are not strings: {str(not_string)}."
+                f"Only strings are supported in query condition but the following values are not strings: {not_string}."
             )
 
     # Serialize the conditions
     equal_conditions = {
         level_condition.subject.java_description: level_condition.target.value
         for level_condition in level_conditions
     }
@@ -106,28 +110,29 @@
     }
 
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class _QuerySessionPrivateParameters:
     client: Optional[ActiveViamClient] = None
+    plugins: Optional[Mapping[str, Plugin]] = None
 
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class _QueryMdxPrivateParameters:
+    get_data_types: Optional[GetDataTypes] = None
     session: Optional[BaseSessionBound] = None
-    get_level_data_types: Optional[GetLevelDataTypes] = None
 
 
-class QuerySession(BaseSession[QueryCubes]):
-    """Used to query a remote atoti session (or a classic ActivePivot >= 5.7 server).
+class QuerySession(BaseSession[QueryCubes, Security]):
+    """Used to query a remote Atoti session.
 
     Note:
-        Query sessions are immutable: the structure of their underlying cubes is not expected to change.
+        The cube and table structure of a query session is expected to be immutable.
     """
 
     @doc(url="{url}")
     def __init__(
         self,
         url: str,
         *,
@@ -166,16 +171,21 @@
             if client_certificate and client_certificate.keyfile
             else None,
             client_certificate_password=client_certificate.password
             if client_certificate
             else None,
         )
 
-        plugins = get_active_plugins().values()
-        for plugin in plugins:
+        plugins = (
+            PLUGINS.default
+            if private_parameters.plugins is None
+            else private_parameters.plugins
+        )
+
+        for plugin in plugins.values():
             plugin.init_session(self)
 
     @property
     def cubes(self) -> QueryCubes:
         """Cubes of the session."""
         return self._cubes
 
@@ -184,14 +194,22 @@
         return create_query_cubes_from_discovery(
             self._discovery,
             execute_gaq=self._execute_gaq if self._gaq_supported else None,
             query_mdx=self.query_mdx,
         )
 
     @property
+    def _security(self) -> Security:
+        return self.__security
+
+    @cached_property
+    def __security(self) -> Security:
+        return Security(client=self._client)
+
+    @property
     def url(self) -> str:
         """URL of the session."""
         return self._client.url
 
     @property
     def _client(self) -> ActiveViamClient:
         return self.__client
@@ -217,15 +235,15 @@
             namespace=namespace,
             raw=True,
             route=route,
         ) as response:
             record_batch_stream = pa.ipc.open_stream(response)
             schema = record_batch_stream.schema
             for name in schema.names:
-                schema.field(name).with_nullable(True)
+                schema.field(name).with_nullable(True)  # noqa: FBT003
             table = pa.Table.from_batches(record_batch_stream, schema=schema)
 
         return arrow_to_pandas(table)
 
     @property
     def _raw_query_mode_supported(self) -> bool:
         return any(
@@ -233,21 +251,21 @@
             for version in self._client.server_versions["apis"][self._pivot_namespace][
                 "versions"
             ]
         )
 
     @property
     def _gaq_supported(self) -> bool:
-        return "atoti" in self._client.server_versions["apis"]
+        return self._client.has_atoti_python_api_endpoints
 
     def _execute_gaq(
         self,
         *,
         cube_name: str,
-        filter: Optional[QueryFilter] = None,  # pylint: disable=redefined-builtin
+        filter: Optional[QueryFilter] = None,  # noqa: A002
         include_empty_rows: bool,
         include_totals: bool,
         levels_coordinates: Iterable[LevelCoordinates],
         measures_coordinates: Iterable[MeasureCoordinates],
         scenario: str,
         timeout: timedelta,
     ) -> pd.DataFrame:
@@ -275,24 +293,24 @@
                 if filter is None
                 else _serialize_condition(filter)
             ),
             "timeout": ceil(timeout.total_seconds()),
         }
         return self._execute_arrow_query(body, namespace="atoti", route="arrow/query")
 
-    def _generate_auth_headers(self) -> Dict[str, str]:
+    def _generate_auth_headers(self) -> dict[str, str]:
         return dict(self._auth(self.url)) if self._auth else {}
 
     @property
     def _pivot_namespace(self) -> str:
         return next(
             namespace
             for namespace in [
                 "activeviam/pivot",
-                "pivot",  # ActivePivot < 6.0.0-M1.
+                "pivot",  # Atoti Server < 6.0.0-M1.
             ]
             if namespace in self._client.server_versions["apis"]
         )
 
     def _fetch_discovery(self) -> Discovery:
         """Return the discovery for this session.
 
@@ -302,16 +320,15 @@
         response = self._client.fetch_json(
             namespace=self._pivot_namespace, route="cube/discovery"
         )
         return cast(Discovery, response.body)
 
     @cached_property
     def _discovery(self) -> IndexedDiscovery:
-        indexed_discovery = index_discovery(self._fetch_discovery())
-        return indexed_discovery
+        return index_discovery(self._fetch_discovery())
 
     def _query_mdx_to_cellset(
         self, mdx: str, *, context: Context = EMPTY_MAPPING
     ) -> CellSet:
         response = self._client.fetch_json(
             body={
                 "context": {**context},
@@ -323,27 +340,27 @@
         return cast(CellSet, response.body)
 
     def query_mdx(
         self,
         mdx: str,
         *,
         keep_totals: bool = False,
-        timeout: timedelta = timedelta(seconds=30),
+        timeout: timedelta = DEFAULT_QUERY_TIMEOUT,
         mode: Literal["pretty", "raw"] = "pretty",
         context: Context = EMPTY_MAPPING,
         **kwargs: Any,
     ) -> pd.DataFrame:
         private_parameters = _QueryMdxPrivateParameters(**kwargs)
 
         context = _enrich_context(context, timeout=timeout)
 
         if mode == "raw":
             if not self._raw_query_mode_supported:
                 raise ValueError(
-                    "`raw` mode not supported by this ActivePivot version."
+                    "`raw` mode not supported by this Atoti Server version."
                 )
 
             return self._execute_arrow_query(
                 {
                     "jsonMdxQuery": {"mdx": mdx, "context": context},
                     "outputConfiguration": {"format": "arrow"},
                 },
@@ -353,15 +370,15 @@
 
         cellset = self._query_mdx_to_cellset(mdx, context=context)
         indexed_cellset = index_cellset(cellset)
         query_result = cellset_to_query_result(
             indexed_cellset,
             context=context,
             discovery=self._discovery,
-            get_level_data_types=private_parameters.get_level_data_types,
+            get_data_types=private_parameters.get_data_types,
             keep_totals=keep_totals,
         )
         # Let local sessions pass their reference to have the correct name and widget creation code.
         session = private_parameters.session or self
 
         widget_creation_code = session._get_widget_creation_code()
         if widget_creation_code is not None:
```

## atoti_query/token_authentication.py

```diff
@@ -1,23 +1,26 @@
+from collections.abc import Mapping
 from dataclasses import dataclass
 from functools import cached_property
-from typing import Mapping
 
 from atoti_core import keyword_only_dataclass
 
 from .auth import Auth
 
 
 @keyword_only_dataclass
 @dataclass(eq=False, frozen=True)
 class TokenAuthentication(Auth):
     """Also called "Bearer authentication", this :class:`atoti_query.Auth`, passes the given token to the HTTP :guilabel:`Authorization` header of the request being made."""
 
     token: str
     token_type: str = "Bearer"
 
-    def __call__(self, url: str) -> Mapping[str, str]:
+    def __call__(
+        self,
+        url: str,  # noqa: ARG002
+    ) -> Mapping[str, str]:
         return self._headers
 
     @cached_property
     def _headers(self) -> Mapping[str, str]:
         return {"Authorization": f"{self.token_type} {self.token}"}
```

## atoti_query/_internal/__init__.py

```diff
@@ -1,4 +1,5 @@
 from .._discovery import *
 from .._generate_mdx import *
 from .._get_cube import *
 from .._query_private_parameters import *
+from ..security import *
```

## Comparing `atoti_query-0.7.4.dist-info/METADATA` & `atoti_query-0.8.0.dist-info/METADATA`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 Metadata-Version: 2.1
 Name: atoti-query
-Version: 0.7.4
-Summary: Package to query remote atoti sessions.
+Version: 0.8.0
+Summary: Package to query Atoti sessions.
 Home-page: https://www.atoti.io
-Author: atoti
+Author: ActiveViam
 Author-email: dev@atoti.io
-Project-URL: Documentation, https://docs.atoti.io/0.7.4/lib/atoti-query/atoti_query.html
+Project-URL: Documentation, https://docs.atoti.io/0.8.0/lib/atoti-query/atoti_query.html
 Project-URL: Bug Tracker, https://github.com/atoti/atoti/issues
 Keywords: atoti,query
 Classifier: Development Status :: 4 - Beta
 Classifier: License :: Free To Use But Restricted
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Typing :: Typed
-Requires-Python: >=3.8
-Requires-Dist: atoti-core (==0.7.4)
+Requires-Dist: atoti-core (==0.8.0)
 Requires-Dist: pandas
-Requires-Dist: pyarrow (<11.0,>=8.0)
-Requires-Dist: typeguard (~=2.12)
+Requires-Dist: pyarrow (>=11.0.0)
+Requires-Dist: typeguard (<3,>=2.13.3)
+Requires-Dist: typing-extensions
 Provides-Extra: dev
 Requires-Dist: atoti ; extra == 'dev'
 Requires-Dist: premailer ; extra == 'dev'
 Requires-Dist: pytest ; extra == 'dev'
 Requires-Dist: test-utils ; extra == 'dev'
```

